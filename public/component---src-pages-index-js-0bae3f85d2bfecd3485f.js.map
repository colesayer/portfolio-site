{"version":3,"sources":["webpack:///component---src-pages-index-js-0bae3f85d2bfecd3485f.js","webpack:///./~/hoist-non-react-statics/index.js","webpack:///./~/process/browser.js","webpack:///./~/randomcolor/randomColor.js","webpack:///./~/three-obj-loader/dist/index.js","webpack:///./~/three-orbit-controls/index.js","webpack:///./~/three/build/three.js","webpack:///./~/tween.js/src/Tween.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/components/three/initPosition.js","webpack:///./src/components/three/initRotateTween.js","webpack:///./src/components/three/initTitle.js","webpack:///./src/components/three/initTranslateTween.js","webpack:///./src/components/three/threeTitle.js","webpack:///./src/pages/index.js"],"names":["webpackJsonp","144","module","exports","REACT_STATICS","childContextTypes","contextTypes","defaultProps","displayName","getDefaultProps","mixins","propTypes","type","KNOWN_STATICS","name","length","prototype","caller","callee","arguments","arity","defineProperty","Object","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","getPrototypeOf","objectPrototype","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","keys","concat","i","key","descriptor","e","41","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","call","this","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","Array","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","89","__webpack_require__","root","factory","randomColor","pickHue","options","hueRange","getHueRange","hue","randomWithin","pickSaturation","luminosity","saturationRange","getSaturationRange","sMin","sMax","pickBrightness","H","S","bMin","getMinimumBrightness","bMax","setFormat","hsv","format","HSVtoHSL","hsl","hslColor","alpha","Math","random","HSVtoRGB","rgb","join","rgbColor","HSVtoHex","lowerBounds","getColorInfo","s1","v1","s2","v2","m","b","colorInput","parseInt","number","colorDictionary","color","match","HexToHSB","colorName","range","seed","floor","max","min","rnd","componentToHex","c","hex","toString","defineColor","brightnessRange","loadColorBounds","h","s","v","h_i","f","p","q","t","r","g","result","replace","red","substr","green","blue","cMax","delta","saturation","k","round","stringToInteger","string","total","Number","MAX_SAFE_INTEGER","charCodeAt","undefined","TypeError","B","count","totalColors","colors","413","defaultOnError","err","THREE","OBJLoader","manager","DefaultLoadingManager","materials","regexp","vertex_pattern","normal_pattern","uv_pattern","face_vertex","face_vertex_uv","face_vertex_uv_normal","face_vertex_normal","object_pattern","smoothing_pattern","material_library_pattern","material_use_pattern","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","text","parse","value","setMaterials","_createParserState","state","objects","object","vertices","normals","uvs","materialLibraries","startObject","fromDeclaration","previousMaterial","currentMaterial","_finalize","geometry","smooth","startMaterial","libraries","previous","inherited","groupCount","splice","index","material","mtllib","isArray","groupStart","groupEnd","clone","cloned","bind","end","lastMultiMaterial","mi","declared","finalize","parseVertexIndex","parseNormalIndex","parseUVIndex","addVertex","a","src","dst","addVertexLine","addNormal","addUV","addUVLine","addFace","d","ua","ub","uc","ud","na","nb","nc","nd","id","vLen","ia","ib","ic","uvLen","nLen","addLineGeometry","vi","l","uvi","debug","console","time","indexOf","lines","split","line","lineFirstChar","lineSecondChar","lineLength","trimLeft","trim","charAt","exec","parseFloat","lineParts","substring","lineVertices","lineUVs","li","llen","parts","test","toLowerCase","container","Group","isLine","buffergeometry","BufferGeometry","addAttribute","BufferAttribute","Float32Array","computeVertexNormals","createdMaterials","miLen","sourceMaterial","create","LineBasicMaterial","materialLine","copy","MeshPhongMaterial","shading","SmoothShading","FlatShading","mesh","addGroup","multiMaterial","MultiMaterial","LineSegments","Mesh","add","timeEnd","414","OrbitControls","domElement","getAutoRotationAngle","PI","autoRotateSpeed","getZoomScale","pow","zoomSpeed","rotateLeft","angle","sphericalDelta","theta","rotateUp","phi","dollyIn","dollyScale","PerspectiveCamera","scale","OrthographicCamera","zoom","minZoom","maxZoom","updateProjectionMatrix","zoomChanged","warn","enableZoom","dollyOut","handleMouseDownRotate","event","rotateStart","set","clientX","clientY","handleMouseDownDolly","dollyStart","handleMouseDownPan","panStart","handleMouseMoveRotate","rotateEnd","rotateDelta","subVectors","element","document","body","x","clientWidth","rotateSpeed","y","clientHeight","update","handleMouseMoveDolly","dollyEnd","dollyDelta","handleMouseMovePan","panEnd","panDelta","pan","handleMouseUp","handleMouseWheel","deltaY","handleKeyDown","keyCode","UP","keyPanSpeed","BOTTOM","LEFT","RIGHT","handleTouchStartRotate","touches","pageX","pageY","handleTouchStartDolly","dx","dy","distance","sqrt","handleTouchStartPan","handleTouchMoveRotate","handleTouchMoveDolly","handleTouchMovePan","handleTouchEnd","onMouseDown","enabled","preventDefault","button","mouseButtons","ORBIT","enableRotate","STATE","ROTATE","ZOOM","DOLLY","PAN","enablePan","NONE","addEventListener","onMouseMove","onMouseUp","dispatchEvent","startEvent","removeEventListener","endEvent","onMouseWheel","stopPropagation","onKeyDown","enableKeys","onTouchStart","TOUCH_ROTATE","TOUCH_DOLLY","TOUCH_PAN","onTouchMove","onTouchEnd","onContextMenu","target","Vector3","minDistance","maxDistance","Infinity","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","autoRotate","MOUSE","MIDDLE","target0","position0","position","zoom0","getPolarAngle","spherical","getAzimuthalAngle","reset","changeEvent","offset","quat","Quaternion","setFromUnitVectors","up","quatInverse","inverse","lastPosition","lastQuaternion","sub","applyQuaternion","setFromVector3","makeSafe","radius","panOffset","setFromSpherical","lookAt","distanceToSquared","EPS","dot","quaternion","dispose","window","Spherical","Vector2","panLeft","objectMatrix","setFromMatrixColumn","multiplyScalar","panUp","deltaX","targetDistance","tan","fov","matrix","right","left","top","bottom","EventDispatcher","defineProperties","center","get","noZoom","noRotate","noPan","noKeys","staticMoving","dynamicDampingFactor","178","global","Matrix4","elements","error","z","w","_x","_y","_z","_w","Matrix3","Texture","image","mapping","wrapS","wrapT","magFilter","minFilter","anisotropy","encoding","textureId","uuid","_Math","generateUUID","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","repeat","rotation","matrixAutoUpdate","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","LinearEncoding","onUpdate","Vector4","WebGLRenderTarget","width","height","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","WebGLRenderTargetCube","activeCubeFace","activeMipMapLevel","DataTexture","data","NearestFilter","CubeTexture","images","CubeReflectionMapping","UniformContainer","seq","map","flatten","nBlocks","blockSize","firstElem","n","arrayCacheF32","toArray","allocTexUnits","renderer","arrayCacheI32","Int32Array","allocTextureUnit","setValue1f","gl","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","mat3array","setValue4fm","uniformMatrix4fv","mat4array","setValueT1","unit","setTexture2D","emptyTexture","setValueT6","setTextureCube","emptyCubeTexture","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","size","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","units","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","setValue","PureArrayUniform","StructuredUniform","addUniform","uniformObject","parseUniform","pathLength","RePathPart","lastIndex","matchEnd","idIsIndex","subscript","next","WebGLUniforms","program","getProgramParameter","ACTIVE_UNIFORMS","info","getActiveUniform","getUniformLocation","Color","setRGB","CanvasTexture","canvas","needsUpdate","WebGLSpriteRenderer","textures","capabilities","init","faces","Uint16Array","vertexBuffer","createBuffer","elementBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","createProgram","attributes","getAttribLocation","uv","uniforms","uvOffset","uvScale","opacity","modelViewMatrix","projectionMatrix","fogType","fogDensity","fogNear","fogFar","fogColor","fogDepth","alphaTest","createElementNS","context","getContext","fillStyle","fillRect","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderSource","precision","compileShader","attachShader","linkProgram","painterSortStable","renderOrder","spritePosition","spriteRotation","spriteScale","render","sprites","scene","camera","useProgram","initAttributes","enableAttribute","disableUnusedAttributes","disable","CULL_FACE","enable","BLEND","vertexAttribPointer","FLOAT","activeTexture","TEXTURE0","oldFogType","sceneFogType","fog","isFog","near","far","isFogExp2","density","sprite","multiplyMatrices","matrixWorldInverse","matrixWorld","sort","visible","onBeforeRender","decompose","setBlending","blending","blendEquation","blendSrc","blendDst","blendEquationAlpha","blendSrcAlpha","blendDstAlpha","premultipliedAlpha","buffers","depth","setTest","depthTest","setMask","depthWrite","colorWrite","drawElements","TRIANGLES","UNSIGNED_SHORT","onAfterRender","Material","materialId","lights","NormalBlending","side","FrontSide","flatShading","vertexColors","NoColors","transparent","SrcAlphaFactor","OneMinusSrcAlphaFactor","AddEquation","depthFunc","LessEqualDepth","clippingPlanes","clipIntersection","clipShadows","shadowSide","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","dithering","overdraw","userData","MeshDepthMaterial","parameters","depthPacking","BasicDepthPacking","skinning","morphTargets","alphaMap","displacementMap","displacementScale","displacementBias","wireframe","wireframeLinewidth","setValues","MeshDistanceMaterial","referencePosition","nearDistance","farDistance","Box3","Sphere","Plane","normal","constant","Frustum","p0","p1","p2","p3","p4","p5","planes","WebGLShadowMap","_renderer","_objects","maxTextureSize","getDepthMaterial","isPointLight","lightPositionWorld","shadowCameraNear","shadowCameraFar","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","isBufferGeometry","morphAttributes","isGeometry","isSkinnedMesh","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","localClippingEnabled","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","linewidth","isMeshDistanceMaterial","renderObject","shadowCamera","layers","isMesh","isPoints","castShadow","frustumCulled","_frustum","intersectsObject","groups","kl","group","groupMaterial","materialIndex","depthMaterial","_lightPositionWorld","renderBufferDirect","children","_projScreenMatrix","_shadowMapSize","_maxShadowMapSize","_lookTarget","_NumberOfMaterialVariants","0","BackSide","1","2","DoubleSide","cubeDirections","cubeUps","cube2DViewPorts","RGBADepthPacking","distanceMaterial","autoUpdate","PCFShadowMap","_gl","_state","setClear","setScissorTest","faceCount","il","light","shadow","mapSize","vpWidth","vpHeight","pars","isSpotLightShadow","shadowMap","shadowMatrix","setFromMatrixPosition","makeTranslation","updateMatrixWorld","multiply","setRenderTarget","clear","face","vpDimensions","setFromMatrix","WebGLAttributes","attribute","bufferType","usage","dynamic","DYNAMIC_DRAW","buffer","onUploadCallback","Float64Array","Int16Array","SHORT","Uint32Array","UNSIGNED_INT","INT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","bytesPerElement","BYTES_PER_ELEMENT","updateBuffer","updateRange","bufferSubData","subarray","isInterleavedBufferAttribute","remove","deleteBuffer","Euler","order","_order","DefaultOrder","Layers","mask","Object3D","onRotationChange","setFromEuler","onQuaternionChange","setFromQuaternion","object3DId","parent","DefaultUp","onChange","enumerable","normalMatrix","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","receiveShadow","Camera","view","Face3","isVector3","vertexNormals","isColor","Geometry","geometryId","faceVertexUvs","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","itemSize","normalized","Int8BufferAttribute","Uint8BufferAttribute","Uint8ClampedBufferAttribute","Uint8ClampedArray","Int16BufferAttribute","Uint16BufferAttribute","Int32BufferAttribute","Uint32BufferAttribute","Float32BufferAttribute","Float64BufferAttribute","DirectGeometry","indices","uvs2","arrayMax","bufferGeometryId","drawRange","start","BoxGeometry","widthSegments","heightSegments","depthSegments","fromBufferGeometry","BoxBufferGeometry","mergeVertices","buildPlane","u","udir","vdir","gridX","gridY","ix","iy","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vector","numberOfVertices","setIndex","PlaneGeometry","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","MeshBasicMaterial","lightMap","lightMapIntensity","aoMap","aoMapIntensity","specularMap","envMap","combine","MultiplyOperation","reflectivity","refractionRatio","wireframeLinecap","wireframeLinejoin","ShaderMaterial","defines","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","uv2","index0AttributeName","uniformsNeedUpdate","Ray","origin","direction","Line3","Triangle","drawMode","TrianglesDrawMode","updateMorphTargets","WebGLBackground","geometries","renderList","forceClear","background","clearColor","clearAlpha","autoClear","autoClearColor","autoClearDepth","autoClearStencil","isCubeTexture","boxMesh","ShaderLib","cube","removeAttribute","copyPosition","tCube","isTexture","planeCamera","planeMesh","getClearColor","setClearColor","getClearAlpha","setClearAlpha","reversePainterSortStable","WebGLRenderList","renderItemsIndex","opaque","renderItem","renderItems","WebGLRenderLists","hash","list","lists","absNumericalSort","abs","WebGLMorphtargets","objectInfluences","morphTargetInfluences","influences","influencesList","influence","morphInfluences","getUniforms","WebGLIndexedBufferRenderer","infoRender","setMode","mode","calls","POINTS","points","renderInstances","extension","drawElementsInstancedANGLE","maxInstancedCount","WebGLBufferRenderer","drawArrays","drawArraysInstancedANGLE","WebGLGeometries","infoMemory","onGeometryDispose","wireframeAttributes","_bufferGeometry","setFromObject","geometryAttributes","getWireframeAttribute","geometryIndex","WebGLObjects","frame","updateList","updateFromObject","addLineNumbers","WebGLShader","shader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getEncodingComponents","sRGBEncoding","RGBEEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","GammaEncoding","getTexelDecodingFunction","functionName","components","getTexelEncodingFunction","getToneMappingFunction","toneMapping","toneMappingName","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","generateExtensions","rendererExtensions","chunks","envMapCubeUV","bumpMap","normalMap","logarithmicDepthBuffer","filter","filterEmptyLine","generateDefines","fetchAttributeLocations","ACTIVE_ATTRIBUTES","getActiveAttrib","replaceLightNums","numDirLights","numSpotLights","numRectAreaLights","numPointLights","numHemiLights","replaceClippingPlaneNums","numClippingPlanes","numClipIntersection","parseIncludes","include","ShaderChunk","pattern","unrollLoops","snippet","unroll","WebGLProgram","code","shadowMapTypeDefine","shadowMapType","PCFSoftShadowMap","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","CubeRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","MixOperation","AddOperation","prefixVertex","prefixFragment","gammaFactorDefine","gammaFactor","customExtensions","customDefines","isRawShaderMaterial","supportsVertexTextures","maxBones","useFog","fogExp","emissiveMap","roughnessMap","metalnessMap","useVertexTexture","doubleSided","flipSided","shadowMapEnabled","sizeAttenuation","gradientMap","physicallyCorrectLights","NoToneMapping","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","glFragmentShader","bindAttribLocation","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","log","prefix","deleteShader","cachedUniforms","cachedAttributes","getAttributes","destroy","deleteProgram","programIdCount","usedTimes","WebGLPrograms","allocateBones","skeleton","bones","floatVertexTextures","nVertexUniforms","maxVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","isWebGLRenderTarget","programs","shaderIDs","MeshNormalMaterial","MeshLambertMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","parameterNames","getParameters","shadows","nClipPlanes","nClipIntersection","shaderID","getMaxPrecision","currentRenderTarget","getRenderTarget","vertexTextures","gammaOutput","gammaInput","envMapMode","maxMorphTargets","maxMorphNormals","directional","point","spot","rectArea","hemi","getProgramCode","onBeforeCompile","acquireProgram","pl","programInfo","releaseProgram","pop","WebGLTextures","properties","utils","clampToMaxSize","maxSize","drawImage","isPowerOfTwo","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","ImageBitmap","_canvas","floorPowerOfTwo","textureNeedsPowerOfTwo","textureNeedsGenerateMipmaps","filterFallback","NearestMipMapNearestFilter","NearestMipMapLinearFilter","NEAREST","LINEAR","onTextureDispose","deallocateTexture","isVideoTexture","_videoTextures","onRenderTargetDispose","renderTarget","deallocateRenderTarget","textureProperties","__image__webglTextureCube","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","isWebGLRenderTargetCube","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","slot","updateVideoTexture","__version","complete","uploadTexture","bindTexture","TEXTURE_2D","createTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isCompressedTexture","isDataTexture","cubeImage","maxCubemapSize","isPowerOfTwoImage","glFormat","convert","glType","setTextureParameters","mipmap","j","jl","RGBFormat","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","setTextureCubeDynamic","textureType","texParameteri","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","FloatType","HalfFloatType","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isDepthTexture","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","DepthFormat","UnsignedShortType","UnsignedIntType","DepthStencilFormat","DEPTH_STENCIL","UnsignedInt248Type","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","isCube","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","webglTexture","WebGL2RenderingContext","WebGLProperties","WebGLState","ColorBuffer","locked","currentColorMask","currentColorClear","colorMask","setLocked","lock","equals","DepthBuffer","currentDepthMask","currentDepthFunc","currentDepthClear","DEPTH_TEST","depthMask","setFunc","NeverDepth","NEVER","AlwaysDepth","ALWAYS","LessDepth","LESS","LEQUAL","EqualDepth","EQUAL","GreaterEqualDepth","GEQUAL","GreaterDepth","GREATER","NotEqualDepth","NOTEQUAL","clearDepth","StencilBuffer","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","stencilFunc","stencilRef","setOp","stencilFail","stencilZFail","stencilZPass","stencilOp","stencil","clearStencil","RGBA","newAttributes","enabledAttributes","enableVertexAttribArray","attributeDivisors","vertexAttribDivisorANGLE","enableAttributeAndDivisor","meshPerAttribute","disableVertexAttribArray","compressedTextureFormats","formats","getParameter","COMPRESSED_TEXTURE_FORMATS","currentProgram","NoBlending","CustomBlending","currentBlending","currentPremultipledAlpha","AdditiveBlending","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","blendFunc","SRC_ALPHA","SubtractiveBlending","ZERO","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","MultiplyBlending","SRC_COLOR","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","setMaterial","frontFaceCW","setFlipSided","colorBuffer","setPolygonOffset","currentFlipSided","frontFace","CW","CCW","setCullFace","cullFace","CullFaceNone","currentCullFace","CullFaceBack","BACK","CullFaceFront","FRONT","FRONT_AND_BACK","setLineWidth","currentLineWidth","lineWidthAvailable","lineWidth","factor","POLYGON_OFFSET_FILL","currentPolygonOffsetFactor","currentPolygonOffsetUnits","SCISSOR_TEST","webglSlot","maxTextures","currentTextureSlot","webglType","boundTexture","currentBoundTextures","emptyTextures","currentScissor","currentViewport","maxVertexAttributes","MAX_VERTEX_ATTRIBS","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glVersion","VERSION","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","HIGH_FLOAT","MEDIUM_FLOAT","maxPrecision","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","floatFragmentTextures","aspect","focus","filmGauge","filmOffset","ArrayCamera","cameras","WebVRManager","onVRDisplayPresentChange","device","isPresenting","eyeParameters","getEyeParameters","renderWidth","renderHeight","currentPixelRatio","getPixelRatio","currentSize","getSize","setDrawingBufferSize","frameData","poseTarget","standingMatrix","standingMatrixInverse","VRFrameData","cameraL","bounds","cameraR","cameraVR","userHeight","getDevice","setDevice","setPoseTarget","getCamera","depthNear","depthFar","getFrameData","pose","poseObject","fromArray","orientation","stageParameters","sittingToStandingTransform","applyMatrix4","leftViewMatrix","rightViewMatrix","getInverse","leftProjectionMatrix","rightProjectionMatrix","getLayers","layer","leftBounds","rightBounds","getStandingMatrix","submitFrame","WebGLExtensions","getExtension","WebGLClipping","resetGlobalState","uniform","globalState","numGlobalPlanes","numPlanes","numIntersection","projectPlanes","dstOffset","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","viewNormalMatrix","getNormalMatrix","i4","plane","renderingShadows","enableLocalClipping","beginShadows","endShadows","setState","cache","fromCache","nGlobal","lGlobal","clippingState","WebGLUtils","RepeatWrapping","REPEAT","MirroredRepeatWrapping","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LinearMipMapNearestFilter","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UnsignedShort4444Type","UNSIGNED_SHORT_4_4_4_4","UnsignedShort5551Type","UNSIGNED_SHORT_5_5_5_1","UnsignedShort565Type","UNSIGNED_SHORT_5_6_5","ByteType","ShortType","IntType","HALF_FLOAT_OES","AlphaFormat","ALPHA","RGB","LuminanceFormat","LUMINANCE","LuminanceAlphaFormat","LUMINANCE_ALPHA","SubtractEquation","FUNC_SUBTRACT","ReverseSubtractEquation","FUNC_REVERSE_SUBTRACT","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","DstAlphaFactor","DST_ALPHA","OneMinusDstAlphaFactor","ONE_MINUS_DST_ALPHA","DstColorFactor","DST_COLOR","OneMinusDstColorFactor","ONE_MINUS_DST_COLOR","SrcAlphaSaturateFactor","SRC_ALPHA_SATURATE","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","RGB_ETC1_Format","COMPRESSED_RGB_ETC1_WEBGL","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","MinEquation","MaxEquation","MIN_EXT","MAX_EXT","UNSIGNED_INT_24_8_WEBGL","UniformsCache","shadowBias","shadowRadius","shadowMapSize","coneCos","penumbraCos","decay","skyColor","groundColor","halfWidth","halfHeight","WebGLLights","setup","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","intensity","isAmbientLight","isDirectionalLight","vector3","transformDirection","bias","directionalShadowMap","directionalShadowMatrix","isSpotLight","cos","penumbra","spotShadowMap","spotShadowMatrix","isRectAreaLight","matrix42","identity","matrix4","premultiply","extractRotation","pointShadowMap","pointShadowMatrix","isHemisphereLight","normalize","ambient","WebGLRenderState","lightsArray","shadowsArray","spritesArray","pushLight","pushShadow","shadowLight","pushSprite","setupLights","WebGLRenderStates","renderState","renderStates","WebGLRenderer","resetInfo","_infoRender","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","initGLContext","_currentScissor","_scissor","_currentViewport","_viewport","_infoMemory","morphtargets","programCache","_this","renderLists","_premultipliedAlpha","bufferRenderer","indexedBufferRenderer","spriteRenderer","onContextLost","_isContextLost","onContextRestore","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","renderObjectImmediate","renderBufferImmediate","setupVertexAttributes","startIndex","isInstancedBufferGeometry","programAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","stride","isInstancedInterleavedBuffer","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","startAnimation","isAnimating","requestAnimationLoopFrame","stopAnimation","vr","requestAnimationFrame","animationLoop","onAnimationFrame","projectObject","sortObjects","isLight","currentRenderState","isSprite","intersectsSprite","isImmediateRenderObject","_vector3","currentRenderList","renderObjects","overrideMaterial","isArrayCamera","_currentArrayCamera","camera2","_width","_height","determinant","setProgram","_currentGeometryProgram","initMaterial","materialProperties","_clipping","programChange","lightsHash","UniformsUtils","numSupportedMorphTargets","numSupportedMorphNormals","isShaderMaterial","ambientLightColor","directionalLights","spotLights","rectAreaLights","pointLights","hemisphereLights","progUniforms","uniformsList","seqWithValue","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","_currentCamera","useCache","_currentMaterialId","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","LN2","isMeshPhongMaterial","isMeshStandardMaterial","uCamPos","cameraPosition","isMeshLambertMaterial","isMeshBasicMaterial","setOptional","boneTexture","ceilPowerOfTwo","boneMatrices","boneTextureSize","toneMappingExposure","toneMappingWhitePoint","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLambert","isMeshToonMaterial","refreshUniformsToon","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshDepthMaterial","refreshUniformsDepth","refreshUniformsDistance","isMeshNormalMaterial","refreshUniformsNormal","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","isShadowMaterial","ltc_1","UniformsLib","LTC_1","ltc_2","LTC_2","upload","diffuse","emissive","emissiveIntensity","flipEnvMap","uvScaleMap","setUvTransform","uvTransform","dashSize","totalSize","gapSize","specular","shininess","bumpScale","normalScale","roughness","metalness","envMapIntensity","clearCoat","clearCoatRoughness","textureUnit","REVISION","_context","_alpha","_depth","_stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_currentFramebuffer","_currentScissorTest","_scissorTest","memory","autoReset","contextAttributes","rangeMin","rangeMax","message","getContextAttributes","forceContextLoss","loseContext","forceContextRestore","restoreContext","setPixelRatio","setSize","updateStyle","style","setViewport","getDrawingBufferSize","pixelRatio","getCurrentViewport","setScissor","boolean","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","hasPositions","hasNormals","hasUvs","hasColors","positionArray","normalArray","nx","ny","nz","uvArray","colorArray","geometryProgram","updateBuffers","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","LINES","TriangleStripDrawMode","TRIANGLE_STRIP","TriangleFanDrawMode","TRIANGLE_FAN","isLineSegments","isLineLoop","LINE_LOOP","LINE_STRIP","compile","traverse","animate","callback","isCamera","opaqueObjects","transparentObjects","warned","setTexture","readRenderTargetPixels","restore","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","copyFramebufferToTexture","level","copyTexImage2D","FogExp2","Fog","Scene","SpriteMaterial","Sprite","LOD","levels","Skeleton","boneInverses","slice","calculateInverses","Bone","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","initBones","normalizeSkinWeights","linecap","linejoin","Line","LineLoop","Points","VideoTexture","video","CompressedTexture","DepthTexture","WireframeGeometry","o","ol","edge1","edge2","vertex","edge","edges","index1","index2","getX","fromBufferAttribute","ParametricGeometry","func","slices","stacks","ParametricBufferGeometry","pu","pv","sliceCount","crossVectors","PolyhedronGeometry","detail","PolyhedronBufferGeometry","subdivide","getVertexByIndex","subdivideFace","cols","aj","lerp","bj","rows","pushVertex","appplyRadius","generateUVs","azimuth","inclination","uvBuffer","correctUVs","correctSeam","x0","x1","x2","centroid","uvA","uvB","uvC","divideScalar","azi","correctUV","atan2","normalizeNormals","TetrahedronGeometry","TetrahedronBufferGeometry","OctahedronGeometry","OctahedronBufferGeometry","IcosahedronGeometry","IcosahedronBufferGeometry","DodecahedronGeometry","DodecahedronBufferGeometry","TubeGeometry","tubularSegments","radialSegments","closed","taper","bufferGeometry","TubeBufferGeometry","tangents","binormals","generateBufferData","generateSegment","generateIndices","P","getPointAt","N","frames","sin","computeFrenetFrames","TorusKnotGeometry","tube","heightScale","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","T","addVectors","cx","cy","TorusGeometry","arc","TorusBufferGeometry","linkedList","dim","clockwise","last","signedArea","insertNode","removeNode","filterPoints","again","steiner","area","prev","earcutLinked","ear","triangles","minX","minY","invSize","pass","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","zOrder","maxZ","nextZ","prevZ","intersects","locallyInside","isValidDiagonal","splitPolygon","eliminateHoles","holeIndices","outerNode","getLeftmost","compareX","eliminateHole","hole","findHoleBridge","hx","hy","qx","mx","my","tanMin","sortLinked","tail","numMerges","pSize","qSize","inSize","leftmost","ax","ay","bx","by","px","py","intersectsPolygon","middleInside","q1","q2","inside","a2","Node","b2","an","bp","sum","removeDupEndPts","addContour","contour","ExtrudeGeometry","shapes","ExtrudeBufferGeometry","addShapeList","TextGeometry","TextBufferGeometry","font","isFont","generateShapes","curveSegments","amount","bevelThickness","bevelSize","bevelEnabled","SphereGeometry","phiStart","phiLength","thetaStart","thetaLength","SphereBufferGeometry","thetaEnd","grid","verticesRow","RingGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","RingBufferGeometry","segment","radiusStep","thetaSegmentLevel","LatheGeometry","segments","LatheBufferGeometry","clamp","base","inverseSegments","n1","n2","ShapeGeometry","ShapeBufferGeometry","addShape","shape","shapeHole","indexOffset","extractPoints","shapeVertices","shapeHoles","holes","ShapeUtils","isClockWise","reverse","triangulateShape","toJSON","EdgesGeometry","thresholdAngle","geometry2","thresholdDot","DEG2RAD","computeFaceNormals","sourceVertices","face1","face2","CylinderGeometry","radiusTop","radiusBottom","openEnded","CylinderBufferGeometry","generateTorso","slope","indexRow","sinTheta","cosTheta","indexArray","generateCap","centerIndexStart","centerIndexEnd","sign","ConeGeometry","ConeBufferGeometry","CircleGeometry","CircleBufferGeometry","RawShaderMaterial","STANDARD","PHYSICAL","TOON","LoadingManager","isLoading","itemsLoaded","itemsTotal","urlModifier","onStart","itemStart","itemEnd","itemError","resolveURL","setURLModifier","transform","CompressedTextureLoader","_parser","DataTextureLoader","ImageLoader","CubeTextureLoader","TextureLoader","Curve","arcLengthDivisions","EllipseCurve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","ArcCurve","aRadius","CubicPoly","t0","t1","c0","c1","c2","c3","initCatmullRom","x3","tension","initNonuniformCatmullRom","dt0","dt1","dt2","t2","calc","t3","CatmullRomCurve3","curveType","CatmullRom","v0","QuadraticBezierP0","QuadraticBezierP1","QuadraticBezierP2","QuadraticBezier","CubicBezierP0","CubicBezierP1","CubicBezierP2","CubicBezierP3","CubicBezier","CubicBezierCurve","v3","CubicBezierCurve3","LineCurve","LineCurve3","QuadraticBezierCurve","QuadraticBezierCurve3","SplineCurve","CurvePath","curves","autoClose","Path","currentPoint","setFromPoints","Shape","Light","HemisphereLight","updateMatrix","LightShadow","SpotLightShadow","SpotLight","power","PointLight","DirectionalLightShadow","DirectionalLight","AmbientLight","RectAreaLight","StringKeyframeTrack","times","values","interpolation","KeyframeTrack","BooleanKeyframeTrack","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","QuaternionLinearInterpolant","QuaternionKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","LinearInterpolant","DiscreteInterpolant","AnimationUtils","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","optimize","VectorKeyframeTrack","AnimationClip","duration","tracks","resetDuration","MaterialLoader","BufferGeometryLoader","Loader","onLoadStart","onLoadProgress","onLoadComplete","JSONLoader","withCredentials","ObjectLoader","texturePath","ImageBitmapLoader","createImageBitmap","fetch","ShapePath","subPaths","currentPath","Font","createPaths","divisions","chars","String","resolution","line_height","yMax","yMin","underlineThickness","paths","offsetX","offsetY","char","ret","createPath","glyph","glyphs","cpx","cpy","cpx1","cpy1","cpx2","cpy2","outline","_cachedOutline","action","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","FontLoader","AudioLoader","StereoCamera","eyeSep","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","AudioListener","AudioContext","gain","createGain","connect","destination","Audio","listener","getInput","autoplay","loop","startTime","playbackRate","isPlaying","hasPlaybackControl","sourceType","filters","PositionalAudio","panner","createPanner","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getOutput","PropertyMixer","typeName","mixFunction","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","useCount","referenceCount","Composite","targetGroup","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","rootNode","node","findNode","nodeName","AnimationObjectGroup","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","stats","inUse","bindingsPerObject","AnimationAction","mixer","clip","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","interpolant","createInterpolant","settings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","LoopRepeat","_loopCount","_startTime","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","AnimationMixer","_root","_initMemoryManager","_accuIndex","Uniform","InstancedBufferGeometry","InterleavedBufferAttribute","interleavedBuffer","InterleavedBuffer","InstancedInterleavedBuffer","InstancedBufferAttribute","Raycaster","ray","params","threshold","PointCloud","ascSort","intersectObject","raycaster","recursive","raycast","Clock","autoStart","oldTime","elapsedTime","running","Cylindrical","Box2","ImmediateRenderObject","VertexNormalsHelper","nNormals","objGeometry","positions","SpotLightHelper","cone","getBoneList","boneList","isBone","SkeletonHelper","color1","color2","bone","VertexColors","PointLightHelper","sphereSize","RectAreaLightHelper","HemisphereLightHelper","rotateY","getAttribute","GridHelper","step","halfSize","PolarGridHelper","radials","circles","FaceNormalsHelper","DirectionalLightHelper","lightPlane","targetLine","CameraHelper","addLine","addPoint","pointMap","FaceColors","colorFrustum","colorCone","colorUp","colorTarget","colorCross","BoxHelper","Box3Helper","box","computeBoundingSphere","PlaneHelper","positions2","ArrowHelper","headLength","headWidth","lineGeometry","coneGeometry","translate","setDirection","setLength","AxesHelper","Face4","MeshFaceMaterial","isMultiMaterial","Particle","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","DynamicBufferAttribute","setDynamic","Int8Attribute","Uint8Attribute","Uint8ClampedAttribute","Int16Attribute","Uint16Attribute","Int32Attribute","Uint32Attribute","Float32Attribute","Float64Attribute","ClosedSplineCurve3","SplineCurve3","Spline","AxisHelper","BoundingBoxHelper","EdgesHelper","WireframeHelper","XHRLoader","BinaryTextureLoader","Projector","projectVector","project","unprojectVector","unproject","pickingRay","CanvasRenderer","LensFlare","EPSILON","isInteger","isFinite","Function","assign","output","source","nextKey","hasOwnProperty","_listeners","hasEventListener","listenerArray","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","UVMapping","RGBEFormat","LoopOnce","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroSlopeEnding","WrapAroundEnding","LogLuvEncoding","RAD2DEG","lut","toUpperCase","d0","d1","d2","d3","euclideanModulo","mapLinear","a1","b1","smoothstep","smootherstep","randInt","low","high","randFloat","randFloatSpread","degToRad","degrees","radToDeg","radians","ceil","isVector2","setScalar","scalar","setX","setY","setComponent","getComponent","addScalar","addScaledVector","subScalar","divide","applyMatrix3","clampScalar","minVal","maxVal","clampLength","roundToZero","negate","lengthSq","manhattanLength","distanceTo","manhattanDistanceTo","lerpVectors","getY","rotateAround","isMatrix4","n11","n12","n13","n14","n21","n22","n23","n24","n31","n32","n33","n34","n41","n42","n43","n44","te","me","extractBasis","xAxis","yAxis","zAxis","makeBasis","scaleX","scaleY","scaleZ","makeRotationFromEuler","euler","isEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","applyToBufferAttribute","getZ","setXYZ","transpose","tmp","setPosition","throwOnDegenerate","t11","t12","t13","t14","det","msg","detInv","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","axis","tx","ty","makeScale","makeShear","compose","sx","sy","sz","invSX","invSY","invSZ","setFromRotationMatrix","makePerspective","makeOrthographic","slerp","qa","qb","qm","slerpFlat","src0","srcOffset0","src1","srcOffset1","y0","z0","w0","y1","z1","w1","sqrSin","tDir","onChangeCallback","s3","setFromAxisAngle","halfAngle","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","vFrom","vTo","conjugate","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","setZ","multiplyVectors","applyEuler","applyAxisAngle","qy","qz","qw","iz","iw","cross","az","bz","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","acos","dz","sinPhiRadius","setFromCylindrical","setFromMatrixScale","isMatrix3","setFromMatrix4","transposeIntoArray","rotate","meta","getDataURL","ImageData","putImageData","toDataURL","isRootObject","metadata","generator","wrap","transformUv","isVector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","getW","ColorKeywords","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","setHex","setStyle","setHSL","hue2rgb","handleAlpha","copyGammaToLinear","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","getHSL","optionalTarget","lightness","getStyle","offsetHSL","addColors","common","specularmap","envmap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","gradientmap","merge","merged","uniforms_src","uniforms_dst","parameter_src","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_vertex","fog_pars_vertex","fog_fragment","fog_pars_fragment","gradientmap_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_template","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_fragment","normalmap_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","dithering_fragment","dithering_pars_fragment","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","basic","lambert","phong","standard","dashed","tFlip","equirect","tEquirect","distanceRGBA","physical","isMaterial","newValue","currentValue","extractFromCache","isRoot","JSON","stringify","srcPlanes","dstPlanes","isBox3","setFromArray","maxX","maxY","setFromBufferAttribute","makeEmpty","expandByPoint","setFromCenterAndSize","expandByObject","isEmpty","getCenter","expandByVector","expandByScalar","containsPoint","containsBox","intersectsBox","intersectsSphere","closestPoint","sphere","clampPoint","intersectsPlane","intersectsTriangle","satForAxes","axes","testAxis","extents","f0","f1","f2","triangleNormal","triangle","distanceToPoint","clampedPoint","getBoundingSphere","intersect","union","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","intersectLine","denominator","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","frustum","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","negRadius","RotationOrders","asin","reorder","newOrder","toVector3","optionalResult","channel","toggle","isObject3D","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateX","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","force","serialize","library","uuids","isOrthographicCamera","setViewOffset","fullWidth","fullHeight","clearViewOffset","zoomW","zoomH","scaleW","scaleH","computeBoundingBox","obj","tempNormals","tempUVs","tempUVs2","cb","ab","fl","vA","vB","vC","areaWeighted","vl","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","verticesMap","unique","changes","precisionPoints","faceIndicesToRemove","idx","diff","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","isBufferAttribute","setArray","copyAt","copyArray","copyColorsArray","copyIndicesArray","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","setXY","setXYZW","onUpload","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","getIndex","clearGroups","setDrawRange","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","isNaN","pA","pB","pC","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","array2","morphAttribute","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","invDet","intersectSphere","tca","radius2","thc","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","distanceSq","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","i1","i2","midpoint","edgeList","projectedPoint","setDrawMode","morphTargetDictionary","ml","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","faceIndex","inverseMatrix","tempA","tempB","tempC","fvA","fvB","fvC","faceMaterial","tl","targets","uvs_f","isPerspectiveCamera","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","skew","isSpriteMaterial","intersectPoint","worldPosition","worldScale","guessSizeSq","addLevel","getObjectForDistance","matrixPosition","offsetMatrix","identityMatrix","getBoneByName","gbone","pos","rotq","scl","sw","vec","skinWeight","computeLineDistances","positionAttribute","linePrecision","precisionSq","vStart","vEnd","interSegment","interRay","distSq","nbVertices","testPoint","rayPointDistanceSq","localThresholdSq","distanceToRay","localThreshold","isGroup","readyState","HAVE_CURRENT_DATA","Earcut","triangulate","hasHoles","outerLen","pts","holeIndex","forEach","getArrays","verticesArray","uvAttribute","IndexAttribute","indicesArray","sl","arrays","scalePt2","pt","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","hl","ahole","extrudeMaterial","slen1","slen2","f4","placeholder","nextIndex","uvgen","generateTopUV","generateSideWallUV","vector2","extrudePts","splineTube","binormal","position2","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","getSpacedPoints","shapePoints","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","Geometries","freeze","Materials","Cache","files","file","loading","cached","dataUriRegex","dataUriRegexResult","mimeType","isBase64","decodeURIComponent","atob","response","responseType","Blob","parser","DOMParser","parseFromString","request","XMLHttpRequest","open","callbacks","status","overrideMimeType","header","requestHeader","setRequestHeader","send","setResponseType","setWithCredentials","setMimeType","loadTexture","texDatas","loaded","mipmapCount","isCubemap","texData","crossOrigin","setCrossOrigin","urls","isJPEG","search","getPoint","getUtoTmapping","getPoints","getLength","lengths","getLengths","cacheArcLengths","current","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","fromJSON","json","isEllipseCurve","twoPi","deltaAngle","samePoints","isArcCurve","pz","isCatmullRomCurve3","intPoint","isCubicBezierCurve","isCubicBezierCurve3","isLineCurve","tangent","isLineCurve3","isQuadraticBezierCurve","isQuadraticBezierCurve3","isSplineCurve","Curves","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","lens","cacheLengths","sums","aCPx","aCPy","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","getPointsHoles","holesPts","ValueTypeName","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","DefaultSettings_","getSettings_","copySampleValue_","getValueSize","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","arraySlice","from","to","isTypedArray","forceClone","ArrayBuffer","isView","DataView","getKeyframeOrder","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","trackType","_getTrackTypeForValueTypeName","track","getInterpolation","InterpolantFactoryMethodDiscrete","factoryMethod","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","jsonTracks","frameTime","fps","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","animationMorphTargets","clips","parseAnimation","animation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","setTextures","getTexture","typedArray","TYPED_ARRAYS","drawcalls","offsets","Handlers","handlers","regex","initMaterials","createMaterial","BlendingMode","textureLoader","materialLoader","fullPath","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","LoaderUtils","decodeText","TextDecoder","decode","fromCharCode","escape","extractUrlBase","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","morphAnimationClips","lastIndexOf","parseShape","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","details","geometryShapes","loadImage","parseConstant","TEXTURE_MAPPING","TEXTURE_WRAPPING","TEXTURE_FILTER","getGeometry","getMaterial","setOptions","then","res","blob","imageBitmap","catch","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","isPointInsidePolygon","inPolygon","polyLen","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","webkitAudioContext","setContext","decodeAudioData","audioBuffer","instance","eyeRight","eyeLeft","xmin","xmax","eyeSepOnProjection","ymax","removeFilter","disconnect","getFilter","setFilter","getMasterVolume","setMasterVolume","positionX","setValueAtTime","currentTime","positionY","positionZ","forwardX","forwardY","forwardZ","upX","upY","upZ","setOrientation","setNodeSource","audioNode","setBuffer","play","createBufferSource","onended","onEnded","pause","getFilters","setFilters","setPlaybackRate","getPlaybackRate","getLoop","setLoop","getVolume","setVolume","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","setMaxDistance","getFrequencyData","getByteFrequencyData","getAverageFrequency","accumulate","accuIndex","currentWeight","mix","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","RESERVED_CHARS_RE","firstValidIndex","bindings","unbind","isAnimationObjectGroup","sanitizeNodeName","reservedRe","RegExp","wordChar","wordCharOrDot","directoryRe","nodeRe","objectRe","propertyRe","trackRe","supportedObjectNames","matches","results","objectName","objectIndex","propertyIndex","lastDot","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","BindingType","Direct","EntireArray","ArrayElement","HasFromToArray","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","GetterByBindingType","resolvedProperty","SetterByBindingTypeAndVersioning","targetObject","dest","targetArray","sourceArray","nodeProperty","versioning","bindingType","_getValue_unbound","_setValue_unbound","nObjects","nCachedObjects","indicesByUUID","parsedPaths","nBindings","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","now","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_update","deltaTime","timeDirection","_updateWeight","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","_bindAction","prototypeAction","rootUuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","_addInactiveBinding","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","actions","controlInterpolants","actionsByClip","actionByRoot","_removeInactiveAction","lastInactiveAction","cacheIndex","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","clipAction","optionalRoot","clipObject","existingAction","newAction","stopAllAction","nActions","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction","isInterleavedBuffer","setFromCamera","coords","intersectObjects","performance","Date","getElapsedTime","getDelta","newTime","other","vec3","objPos","objNorm","coneLength","coneWidth","boneMatrix","matrixWorldInv","setPoint","setColor","LineStrip","LinePieces","construct","createPointsGeometry","createGeometry","createSpacedPointsGeometry","fromPoints","initFromArray","getControlPointsArray","reparametrizeByArcLength","setColors","isIntersectionBox","isIntersectionSphere","random16","nearestPowerOfTwo","nextPowerOfTwo","flattenToArrayOffset","multiplyVector3","multiplyVector3Array","applyToBuffer","applyToVector3Array","extractPosition","getPosition","multiplyToArray","multiplyVector4","rotateAxis","crossVector","rotateByAxis","makeFrustum","isIntersectionLine","isIntersectionPlane","extractAllPoints","extrude","makeGeometry","fromAttribute","distanceToManhattan","lengthManhattan","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","applyProjection","computeTangents","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","getCurrentRenderTarget","getPrecision","resetGLState","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","setFaceCulling","shadowMapCullFace","renderReverseSided","renderSingleSided","standing","audioLoader","getData","updateCubeMap","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","SceneUtils","createMultiMaterialObject","detach","attach","CubeGeometry","110","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","TWEEN","_tweens","getAll","removeAll","tween","preserve","hrtime","getTime","Tween","_repeatDelayTime","_object","_valuesStart","_valuesEnd","_valuesStartRepeat","_duration","_repeat","_yoyo","_isPlaying","_reversed","_delayTime","_easingFunction","Easing","Linear","_interpolationFunction","Interpolation","_chainedTweens","_onStartCallback","_onStartCallbackFired","_onUpdateCallback","_onCompleteCallback","_onStopCallback","property","stopChainedTweens","numChainedTweens","delay","repeatDelay","yoyo","easing","chain","onComplete","onStop","elapsed","Quadratic","In","Out","InOut","Cubic","Quartic","Quintic","Sinusoidal","Exponential","Circular","Elastic","Back","Bounce","fn","Utils","Bezier","pw","bn","Bernstein","fc","Factorial","111","webpackPolyfill","deprecate","187","initPosition","isMobile","__esModule","188","_interopRequireDefault","default","initRotateTween","randomNumber1","randomNumber2","randomNumber3","randomNumber4","randomNumber5","randomNumber6","direction1","generateDirection","direction2","generateOppositeDirection","direction3","direction4","direction5","direction6","_tween2","tween2","tween3","tween4","tween5","tween6","tween7","tween8","tween9","tween10","tween11","tween12","_tween","189","_interopRequireWildcard","newObj","initTitle","threeLoader","objFile","titleColor","titleGroup","titleMaterial","titleLoader","objBbox","bboxCenter","letterPosition","_initPosition","_initTranslateTween","initTranslateTween","_initRotateTween","_three","_threeObjLoader","190","generateRandomNumber","originalPosition","returnTween","returnTween2","returnTween3","returnTween4","returnTween5","returnTween6","randomNumber","191","_classCallCheck","Constructor","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","configurable","setPrototypeOf","__proto__","_react","_react2","_gatsbyLink","_randomcolor","_randomcolor2","_initTitle","ThreeTitle","_Component","props","onWindowResize","mount","addTitle","componentDidMount","appendChild","controls","keyLight","pointLight","objFiles","titleColors","floorColor","floorGroup","floorGeometry","floorMaterial","floor2Geometry","floor2Material","floor2","componentWillUnmount","removeChild","frameId","cancelAnimationFrame","renderScene","_this2","createElement","ref","Component","194","_threeTitle","_threeTitle2","IndexPage"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCCxB,YAEA,IAAAC,IACAC,mBAAA,EACAC,cAAA,EACAC,cAAA,EACAC,aAAA,EACAC,iBAAA,EACAC,QAAA,EACAC,WAAA,EACAC,MAAA,GAGAC,GACAC,MAAA,EACAC,QAAA,EACAC,WAAA,EACAC,QAAA,EACAC,QAAA,EACAC,WAAA,EACAC,OAAA,GAGAC,EAAAC,OAAAD,eACAE,EAAAD,OAAAC,oBACAC,EAAAF,OAAAE,sBACAC,EAAAH,OAAAG,yBACAC,EAAAJ,OAAAI,eACAC,EAAAD,KAAAJ,OAEApB,GAAAC,QAAA,QAAAyB,GAAAC,EAAAC,EAAAC,GACA,mBAAAD,GAAA,CAEA,GAAAH,EAAA,CACA,GAAAK,GAAAN,EAAAI,EACAE,QAAAL,GACAC,EAAAC,EAAAG,EAAAD,GAIA,GAAAE,GAAAV,EAAAO,EAEAN,KACAS,IAAAC,OAAAV,EAAAM,IAGA,QAAAK,GAAA,EAAuBA,EAAAF,EAAAlB,SAAiBoB,EAAA,CACxC,GAAAC,GAAAH,EAAAE,EACA,MAAA/B,EAAAgC,IAAAvB,EAAAuB,IAAAL,KAAAK,IAAA,CACA,GAAAC,GAAAZ,EAAAK,EAAAM,EACA,KACAf,EAAAQ,EAAAO,EAAAC,GACiB,MAAAC,MAIjB,MAAAT,GAGA,MAAAA,KDWMU,GACA,SAAUrC,EAAQC,GEhExB,QAAAqC,KACA,SAAAC,OAAA,mCAEA,QAAAC,KACA,SAAAD,OAAA,qCAsBA,QAAAE,GAAAC,GACA,GAAAC,IAAAC,WAEA,MAAAA,YAAAF,EAAA,EAGA,KAAAC,IAAAL,IAAAK,IAAAC,WAEA,MADAD,GAAAC,WACAA,WAAAF,EAAA,EAEA,KAEA,MAAAC,GAAAD,EAAA,GACK,MAAAN,GACL,IAEA,MAAAO,GAAAE,KAAA,KAAAH,EAAA,GACS,MAAAN,GAET,MAAAO,GAAAE,KAAAC,KAAAJ,EAAA,KAMA,QAAAK,GAAAC,GACA,GAAAC,IAAAC,aAEA,MAAAA,cAAAF,EAGA,KAAAC,IAAAT,IAAAS,IAAAC,aAEA,MADAD,GAAAC,aACAA,aAAAF,EAEA,KAEA,MAAAC,GAAAD,GACK,MAAAZ,GACL,IAEA,MAAAa,GAAAJ,KAAA,KAAAG,GACS,MAAAZ,GAGT,MAAAa,GAAAJ,KAAAC,KAAAE,KAYA,QAAAG,KACAC,GAAAC,IAGAD,GAAA,EACAC,EAAAxC,OACAyC,EAAAD,EAAArB,OAAAsB,GAEAC,GAAA,EAEAD,EAAAzC,QACA2C,KAIA,QAAAA,KACA,IAAAJ,EAAA,CAGA,GAAAK,GAAAhB,EAAAU,EACAC,IAAA,CAGA,KADA,GAAAM,GAAAJ,EAAAzC,OACA6C,GAAA,CAGA,IAFAL,EAAAC,EACAA,OACAC,EAAAG,GACAL,GACAA,EAAAE,GAAAI,KAGAJ,IAAA,EACAG,EAAAJ,EAAAzC,OAEAwC,EAAA,KACAD,GAAA,EACAL,EAAAU,IAiBA,QAAAG,GAAAlB,EAAAmB,GACAf,KAAAJ,MACAI,KAAAe,QAYA,QAAAC,MAhKA,GAOAnB,GACAM,EARAc,EAAA/D,EAAAC,YAgBA,WACA,IAEA0C,EADA,kBAAAC,YACAA,WAEAN,EAEK,MAAAF,GACLO,EAAAL,EAEA,IAEAW,EADA,kBAAAC,cACAA,aAEAV,EAEK,MAAAJ,GACLa,EAAAT,KAuDA,IAEAa,GAFAC,KACAF,GAAA,EAEAG,GAAA,CAyCAQ,GAAAC,SAAA,SAAAtB,GACA,GAAAuB,GAAA,GAAAC,OAAAjD,UAAAJ,OAAA,EACA,IAAAI,UAAAJ,OAAA,EACA,OAAAoB,GAAA,EAAuBA,EAAAhB,UAAAJ,OAAsBoB,IAC7CgC,EAAAhC,EAAA,GAAAhB,UAAAgB,EAGAqB,GAAAa,KAAA,GAAAP,GAAAlB,EAAAuB,IACA,IAAAX,EAAAzC,QAAAuC,GACAX,EAAAe,IASAI,EAAA9C,UAAA6C,IAAA,WACAb,KAAAJ,IAAA0B,MAAA,KAAAtB,KAAAe,QAEAE,EAAAM,MAAA,UACAN,EAAAO,SAAA,EACAP,EAAAQ,OACAR,EAAAS,QACAT,EAAAU,QAAA,GACAV,EAAAW,YAIAX,EAAAY,GAAAb,EACAC,EAAAa,YAAAd,EACAC,EAAAc,KAAAf,EACAC,EAAAe,IAAAhB,EACAC,EAAAgB,eAAAjB,EACAC,EAAAiB,mBAAAlB,EACAC,EAAAkB,KAAAnB,EACAC,EAAAmB,gBAAApB,EACAC,EAAAoB,oBAAArB,EAEAC,EAAAqB,UAAA,SAAAxE,GAAqC,UAErCmD,EAAAsB,QAAA,SAAAzE,GACA,SAAA2B,OAAA,qCAGAwB,EAAAuB,IAAA,WAA2B,WAC3BvB,EAAAwB,MAAA,SAAAC,GACA,SAAAjD,OAAA,mCAEAwB,EAAA0B,MAAA,WAA4B,WFkFtBC,GACA,SAAU1F,EAAQC,EAAS0F,IG1QjC,SAAA3F,IAGC,SAAA4F,EAAAC,GAID,GAAAC,GAAAD,GAGA,iBAAA7F,SAAAC,UACAA,EAAAD,EAAAC,QAAA6F,GAIA7F,EAAA6F,eAWChD,KAAA,WAuED,QAAAiD,GAAAC,GAEA,GAAAC,GAAAC,EAAAF,EAAAG,KACAA,EAAAC,EAAAH,EAMA,OAFAE,GAAA,IAAkBA,EAAA,IAAAA,GAElBA,EAIA,QAAAE,GAAAF,EAAAH,GAEA,kBAAAA,EAAAG,IACA,QAGA,eAAAH,EAAAM,WACA,MAAAF,IAAA,OAGA,IAAAG,GAAAC,EAAAL,GAEAM,EAAAF,EAAA,GACAG,EAAAH,EAAA,EAEA,QAAAP,EAAAM,YAEA,aACAG,EAAA,EACA,MAEA,YACAA,EAAAC,EAAA,EACA,MAEA,aACAA,EAAA,GAIA,MAAAN,IAAAK,EAAAC,IAIA,QAAAC,GAAAC,EAAAC,EAAAb,GAEA,GAAAc,GAAAC,EAAAH,EAAAC,GACAG,EAAA,GAEA,QAAAhB,EAAAM,YAEA,WACAU,EAAAF,EAAA,EACA,MAEA,aACAA,GAAAE,EAAAF,GAAA,CACA,MAEA,cACAA,EAAA,EACAE,EAAA,IAIA,MAAAZ,IAAAU,EAAAE,IAGA,QAAAC,GAAAC,EAAAlB,GAEA,OAAAA,EAAAmB,QAEA,eACA,MAAAD,EAEA,gBACA,MAAAE,GAAAF,EAEA,WACA,GAAAG,GAAAD,EAAAF,EACA,cAAAG,EAAA,QAAAA,EAAA,SAAAA,EAAA,OAEA,YACA,GAAAC,GAAAF,EAAAF,GACAK,EAAAvB,EAAAuB,OAAAC,KAAAC,QACA,eAAAH,EAAA,QAAAA,EAAA,SAAAA,EAAA,SAAAC,EAAA,GAEA,gBACA,MAAAG,GAAAR,EAEA,WACA,GAAAS,GAAAD,EAAAR,EACA,cAAAS,EAAAC,KAAA,SAEA,YACA,GAAAC,GAAAH,EAAAR,GACAK,EAAAvB,EAAAuB,OAAAC,KAAAC,QACA,eAAAI,EAAAD,KAAA,WAAAL,EAAA,GAEA,SACA,MAAAO,GAAAZ,IAKA,QAAAH,GAAAH,EAAAC,GAIA,OAFAkB,GAAAC,EAAApB,GAAAmB,YAEA9F,EAAA,EAAmBA,EAAA8F,EAAAlH,OAAA,EAA4BoB,IAAA,CAE/C,GAAAgG,GAAAF,EAAA9F,GAAA,GACAiG,EAAAH,EAAA9F,GAAA,GAEAkG,EAAAJ,EAAA9F,EAAA,MACAmG,EAAAL,EAAA9F,EAAA,KAEA,IAAA4E,GAAAoB,GAAApB,GAAAsB,EAAA,CAEA,GAAAE,IAAAD,EAAAF,IAAAC,EAAAF,GACAK,EAAAJ,EAAAG,EAAAJ,CAEA,OAAAI,GAAAxB,EAAAyB,GAKA,SAGA,QAAApC,GAAAqC,GAEA,mBAAAC,UAAAD,GAAA,CAEA,GAAAE,GAAAD,SAAAD,EAEA,IAAAE,EAAA,KAAAA,EAAA,EACA,OAAAA,KAKA,mBAAAF,GAEA,GAAAG,EAAAH,GAAA,CACA,GAAAI,GAAAD,EAAAH,EACA,IAAAI,EAAA1C,SAA6B,MAAA0C,GAAA1C,aACtB,IAAAsC,EAAAK,MAAA,kCAAuD,CAC9D,GAAAzC,GAAA0C,EAAAN,GAAA,EACA,QAAApC,KAIA,cAIA,QAAAK,GAAAL,GACA,MAAA6B,GAAA7B,GAAAI,gBAGA,QAAAyB,GAAA7B,GAGAA,GAAA,KAAAA,GAAA,MACAA,GAAA,IAGA,QAAA2C,KAAAJ,GAAA,CACA,GAAAC,GAAAD,EAAAI,EACA,IAAAH,EAAA1C,UACAE,GAAAwC,EAAA1C,SAAA,IACAE,GAAAwC,EAAA1C,SAAA,GACA,MAAAyC,GAAAI,GAEK,wBAGL,QAAA1C,GAAA2C,GACA,UAAAC,EACA,MAAAxB,MAAAyB,MAAAF,EAAA,GAAAvB,KAAAC,UAAAsB,EAAA,KAAAA,EAAA,IAGA,IAAAG,GAAAH,EAAA,MACAI,EAAAJ,EAAA,KACAC,IAAA,KAAAA,EAAA,aACA,IAAAI,GAAAJ,EAAA,MACA,OAAAxB,MAAAyB,MAAAE,EAAAC,GAAAF,EAAAC,IAIA,QAAArB,GAAAZ,GAIA,QAAAmC,GAAAC,GACA,GAAAC,GAAAD,EAAAE,SAAA,GACA,WAAAD,EAAA1I,OAAA,IAAA0I,IAJA,GAAA5B,GAAAD,EAAAR,GAOAqC,EAAA,IAAAF,EAAA1B,EAAA,IAAA0B,EAAA1B,EAAA,IAAA0B,EAAA1B,EAAA,GAEA,OAAA4B,GAIA,QAAAE,GAAA7I,EAAAqF,EAAA8B,GAEA,GAAAtB,GAAAsB,EAAA,MACArB,EAAAqB,IAAAlH,OAAA,MAEAiG,EAAAiB,IAAAlH,OAAA,MACAmG,EAAAe,EAAA,KAEAW,GAAA9H,IACAqF,WACA8B,cACAxB,iBAAAE,EAAAC,GACAgD,iBAAA5C,EAAAE,IAKA,QAAA2C,KAEAF,EACA,aACA,OACA,eAGAA,EACA,QACA,SACA,2EAGAA,EACA,UACA,SACA,2DAGAA,EACA,UACA,SACA,mEAGAA,EACA,SACA,UACA,mEAGAA,EACA,QACA,WACA,2EAGAA,EACA,UACA,WACA,2EAGAA,EACA,QACA,WACA,2DAKA,QAAA/B,GAAAR,GAIA,GAAA0C,GAAA1C,EAAA,EACA,KAAA0C,IAAkBA,EAAA,GAClB,MAAAA,IAAoBA,EAAA,KAGpBA,GAAA,GACA,IAAAC,GAAA3C,EAAA,OACA4C,EAAA5C,EAAA,OAEA6C,EAAAvC,KAAAyB,MAAA,EAAAW,GACAI,EAAA,EAAAJ,EAAAG,EACAE,EAAAH,GAAA,EAAAD,GACAK,EAAAJ,GAAA,EAAAE,EAAAH,GACAM,EAAAL,GAAA,KAAAE,GAAAH,GACAO,EAAA,IACAC,EAAA,IACA/B,EAAA,GAEA,QAAAyB,GACA,OAAAK,EAAAN,EAAoBO,EAAAF,EAAO7B,EAAA2B,CAAO,MAClC,QAAAG,EAAAF,EAAoBG,EAAAP,EAAOxB,EAAA2B,CAAO,MAClC,QAAAG,EAAAH,EAAoBI,EAAAP,EAAOxB,EAAA6B,CAAO,MAClC,QAAAC,EAAAH,EAAoBI,EAAAH,EAAO5B,EAAAwB,CAAO,MAClC,QAAAM,EAAAD,EAAoBE,EAAAJ,EAAO3B,EAAAwB,CAAO,MAClC,QAAAM,EAAAN,EAAoBO,EAAAJ,EAAO3B,EAAA4B,EAG3B,GAAAI,IAAA9C,KAAAyB,MAAA,IAAAmB,GAAA5C,KAAAyB,MAAA,IAAAoB,GAAA7C,KAAAyB,MAAA,IAAAX,GACA,OAAAgC,GAGA,QAAAzB,GAAAU,GACAA,IAAAgB,QAAA,SACAhB,EAAA,IAAAA,EAAA1I,OAAA0I,EAAAgB,QAAA,eAAAhB,CAEA,IAAAiB,GAAAhC,SAAAe,EAAAkB,OAAA,aACAC,EAAAlC,SAAAe,EAAAkB,OAAA,aACAE,EAAAnC,SAAAe,EAAAkB,OAAA,aAEAG,EAAApD,KAAA0B,IAAAsB,EAAAE,EAAAC,GACAE,EAAAD,EAAApD,KAAA2B,IAAAqB,EAAAE,EAAAC,GACAG,EAAAF,EAAAC,EAAAD,EAAA,CAEA,QAAAA,GACA,IAAAJ,GAAA,YAAAE,EAAAC,GAAAE,EAAA,MAAAC,EAAAF,EACA,KAAAF,GAAA,YAAAC,EAAAH,GAAAK,EAAA,MAAAC,EAAAF,EACA,KAAAD,GAAA,YAAAH,EAAAE,GAAAG,EAAA,MAAAC,EAAAF,IAIA,QAAAxD,GAAAF,GACA,GAAA0C,GAAA1C,EAAA,GACA2C,EAAA3C,EAAA,OACA4C,EAAA5C,EAAA,OACA6D,GAAA,EAAAlB,GAAAC,CAEA,QACAF,EACApC,KAAAwD,MAAAnB,EAAAC,GAAAiB,EAAA,EAAAA,EAAA,EAAAA,GAAA,SACAA,EAAA,OAIA,QAAAE,GAAAC,GAEA,OADAC,GAAA,EACAlJ,EAAA,EAAmBA,IAAAiJ,EAAArK,UACnBsK,GAAAC,OAAAC,kBADwCpJ,IAExCkJ,GAAAD,EAAAI,WAAArJ,EAEA,OAAAkJ,GAnaA,GAAAnC,GAAA,KAGAN,IAGAiB,IAEA,IAAA7D,GAAA,SAAAE,GAMA,GAJAA,QAIAuF,SAAAvF,EAAAgD,MAAA,OAAAhD,EAAAgD,MAAAhD,EAAAgD,OAAAR,SAAAxC,EAAAgD,KAAA,IACAA,EAAAhD,EAAAgD,SAGK,oBAAAhD,GAAAgD,KACLA,EAAAiC,EAAAjF,EAAAgD,UAGK,IAAAuC,SAAAvF,EAAAgD,MAAA,OAAAhD,EAAAgD,KACL,SAAAwC,WAAA,8CAIAxC,GAAA,KAGA,GAAApC,GAAAC,EAAA4E,CAGA,WAAAzF,EAAA0F,OAAAH,SAAAvF,EAAA0F,MAAA,CAEA,GAAAC,GAAA3F,EAAA0F,MACAE,IAIA,KAFA5F,EAAA0F,MAAA,KAEAC,EAAAC,EAAA/K,QAKAmI,GAAAhD,EAAAgD,OAAAhD,EAAAgD,MAAA,GAEA4C,EAAAzH,KAAA2B,EAAAE,GAKA,OAFAA,GAAA0F,MAAAC,EAEAC,EAaA,MATAhF,GAAAb,EAAAC,GAGAa,EAAAR,EAAAO,EAAAZ,GAGAyF,EAAA9E,EAAAC,EAAAC,EAAAb,GAGAiB,GAAAL,EAAAC,EAAA4E,GAAAzF,GAqWA,OAAAF,OH+Q8BjD,KAAK5C,EAAS0F,EAAoB,KAAK3F,KAI/D6L,IACA,SAAU7L,EAAQC,GIvtBxB,YAEA,SAAA6L,GAAAC,GACA,SAAAxJ,OAAAwJ,GAGA/L,EAAAC,QAAA,SAAA+L,GAMAA,EAAAC,UAAA,SAAAC,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAF,EAAAG,sBAEArJ,KAAAsJ,UAAA,KAEAtJ,KAAAuJ,QAEAC,eAAA,0EAEAC,eAAA,2EAEAC,WAAA,oDAEAC,YAAA,kDAEAC,eAAA,sFAEAC,sBAAA,0HAEAC,mBAAA,8FAEAC,eAAA,gBAEAC,kBAAA,oBAEAC,yBAAA,WAEAC,qBAAA,aAIAhB,EAAAC,UAAAnL,WAEAmM,YAAAjB,EAAAC,UAEAiB,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAAAC,GAAAzK,IACAA,MAAAwK,WAAAxB,CAEA,IAAA0B,GAAA,GAAAxB,GAAAyB,WAAAF,EAAArB,QACAsB,GAAAE,QAAA5K,KAAA6K,MACAH,EAAAN,KAAAC,EAAA,SAAAS,GAEAR,EAAAG,EAAAM,MAAAD,KACOP,EAAAC,IAGPI,QAAA,SAAAI,GAEAhL,KAAA6K,KAAAG,GAGAC,aAAA,SAAA3B,GAEAtJ,KAAAsJ,aAGA4B,mBAAA,WAEA,GAAAC,IACAC,WACAC,UAEAC,YACAC,WACAC,OAEAC,qBAEAC,YAAA,SAAA5N,EAAA6N,GAIA,GAAA3L,KAAAqL,QAAArL,KAAAqL,OAAAM,mBAAA,EAIA,MAFA3L,MAAAqL,OAAAvN,YACAkC,KAAAqL,OAAAM,qBAAA,EAIA,IAAAC,GAAA5L,KAAAqL,QAAA,kBAAArL,MAAAqL,OAAAQ,gBAAA7L,KAAAqL,OAAAQ,kBAAApD,MA6GA,IA3GAzI,KAAAqL,QAAA,kBAAArL,MAAAqL,OAAAS,WAEA9L,KAAAqL,OAAAS,WAAA,GAGA9L,KAAAqL,QACAvN,QAAA,GACA6N,qBAAA,EAEAI,UACAT,YACAC,WACAC,QAEAlC,aACA0C,QAAA,EAEAC,cAAA,SAAAnO,EAAAoO,GAEA,GAAAC,GAAAnM,KAAA8L,WAAA,EAIAK,OAAAC,WAAAD,EAAAE,YAAA,IAEArM,KAAAsJ,UAAAgD,OAAAH,EAAAI,MAAA,EAGA,IAAAC,IACAD,MAAAvM,KAAAsJ,UAAAvL,OACAD,QAAA,GACA2O,OAAArL,MAAAsL,QAAAR,MAAAnO,OAAA,EAAAmO,IAAAnO,OAAA,MACAiO,OAAAvD,SAAA0D,IAAAH,OAAAhM,KAAAgM,OACAW,WAAAlE,SAAA0D,IAAAS,SAAA,EACAA,UAAA,EACAP,YAAA,EACAD,WAAA,EAEAS,MAAA,SAAAN,GACA,GAAAO,IACAP,MAAA,gBAAAA,KAAAvM,KAAAuM,MACAzO,KAAAkC,KAAAlC,KACA2O,OAAAzM,KAAAyM,OACAT,OAAAhM,KAAAgM,OACAW,WAAA,EACAC,UAAA,EACAP,YAAA,EACAD,WAAA,EAGA,OADAU,GAAAD,MAAA7M,KAAA6M,MAAAE,KAAAD,GACAA,GAMA,OAFA9M,MAAAsJ,UAAAjI,KAAAmL,GAEAA,GAGAX,gBAAA,WAEA,GAAA7L,KAAAsJ,UAAAvL,OAAA,EACA,MAAAiC,MAAAsJ,UAAAtJ,KAAAsJ,UAAAvL,OAAA,IAMA+N,UAAA,SAAAkB,GAEA,GAAAC,GAAAjN,KAAA6L,iBASA,IARAoB,KAAAL,YAAA,IAEAK,EAAAL,SAAA5M,KAAA+L,SAAAT,SAAAvN,OAAA,EACAkP,EAAAZ,WAAAY,EAAAL,SAAAK,EAAAN,WACAM,EAAAb,WAAA,GAIAY,GAAAhN,KAAAsJ,UAAAvL,OAAA,EAEA,OAAAmP,GAAAlN,KAAAsJ,UAAAvL,OAAA,EAAwDmP,GAAA,EAASA,IACjElN,KAAAsJ,UAAA4D,GAAAb,YAAA,GACArM,KAAAsJ,UAAAgD,OAAAY,EAAA,EAcA,OARAF,IAAA,IAAAhN,KAAAsJ,UAAAvL,QAEAiC,KAAAsJ,UAAAjI,MACAvD,KAAA,GACAkO,OAAAhM,KAAAgM,SAIAiB,IAUArB,KAAA9N,MAAA,kBAAA8N,GAAAiB,MAAA,CAEA,GAAAM,GAAAvB,EAAAiB,MAAA,EACAM,GAAAf,WAAA,EACApM,KAAAqL,OAAA/B,UAAAjI,KAAA8L,GAGAnN,KAAAoL,QAAA/J,KAAArB,KAAAqL,SAGA+B,SAAA,WAEApN,KAAAqL,QAAA,kBAAArL,MAAAqL,OAAAS,WAEA9L,KAAAqL,OAAAS,WAAA,IAIAuB,iBAAA,SAAArC,EAAApK,GAEA,GAAA2L,GAAA7G,SAAAsF,EAAA,GACA,WAAAuB,GAAA,EAAAA,EAAA,EAAAA,EAAA3L,EAAA,IAGA0M,iBAAA,SAAAtC,EAAApK,GAEA,GAAA2L,GAAA7G,SAAAsF,EAAA,GACA,WAAAuB,GAAA,EAAAA,EAAA,EAAAA,EAAA3L,EAAA,IAGA2M,aAAA,SAAAvC,EAAApK,GAEA,GAAA2L,GAAA7G,SAAAsF,EAAA,GACA,WAAAuB,GAAA,EAAAA,EAAA,EAAAA,EAAA3L,EAAA,IAGA4M,UAAA,SAAAC,EAAAjI,EAAAgB,GAEA,GAAAkH,GAAA1N,KAAAsL,SACAqC,EAAA3N,KAAAqL,OAAAU,SAAAT,QAEAqC,GAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlH,EAAA,IACAmH,EAAAtM,KAAAqM,EAAAlH,EAAA,IACAmH,EAAAtM,KAAAqM,EAAAlH,EAAA,KAGAoH,cAAA,SAAAH,GAEA,GAAAC,GAAA1N,KAAAsL,SACAqC,EAAA3N,KAAAqL,OAAAU,SAAAT,QAEAqC,GAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,KAGAI,UAAA,SAAAJ,EAAAjI,EAAAgB,GAEA,GAAAkH,GAAA1N,KAAAuL,QACAoC,EAAA3N,KAAAqL,OAAAU,SAAAR,OAEAoC,GAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlH,EAAA,IACAmH,EAAAtM,KAAAqM,EAAAlH,EAAA,IACAmH,EAAAtM,KAAAqM,EAAAlH,EAAA,KAGAsH,MAAA,SAAAL,EAAAjI,EAAAgB,GAEA,GAAAkH,GAAA1N,KAAAwL,IACAmC,EAAA3N,KAAAqL,OAAAU,SAAAP,GAEAmC,GAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlI,EAAA,IACAmI,EAAAtM,KAAAqM,EAAAlH,EAAA,IACAmH,EAAAtM,KAAAqM,EAAAlH,EAAA,KAGAuH,UAAA,SAAAN,GAEA,GAAAC,GAAA1N,KAAAwL,IACAmC,EAAA3N,KAAAqL,OAAAU,SAAAP,GAEAmC,GAAAtM,KAAAqM,EAAAD,EAAA,IACAE,EAAAtM,KAAAqM,EAAAD,EAAA,KAGAO,QAAA,SAAAP,EAAAjI,EAAAgB,EAAAyH,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAKAC,GALAC,EAAA3O,KAAAsL,SAAAvN,OAEA6Q,EAAA5O,KAAAqN,iBAAAI,EAAAkB,GACAE,EAAA7O,KAAAqN,iBAAA7H,EAAAmJ,GACAG,EAAA9O,KAAAqN,iBAAA7G,EAAAmI,EAcA,IAXAlG,SAAAwF,EAEAjO,KAAAwN,UAAAoB,EAAAC,EAAAC,IAGAJ,EAAA1O,KAAAqN,iBAAAY,EAAAU,GAEA3O,KAAAwN,UAAAoB,EAAAC,EAAAH,GACA1O,KAAAwN,UAAAqB,EAAAC,EAAAJ,IAGAjG,SAAAyF,EAAA,CAEA,GAAAa,GAAA/O,KAAAwL,IAAAzN,MAEA6Q,GAAA5O,KAAAuN,aAAAW,EAAAa,GACAF,EAAA7O,KAAAuN,aAAAY,EAAAY,GACAD,EAAA9O,KAAAuN,aAAAa,EAAAW,GAEAtG,SAAAwF,EAEAjO,KAAA8N,MAAAc,EAAAC,EAAAC,IAGAJ,EAAA1O,KAAAuN,aAAAc,EAAAU,GAEA/O,KAAA8N,MAAAc,EAAAC,EAAAH,GACA1O,KAAA8N,MAAAe,EAAAC,EAAAJ,IAIA,GAAAjG,SAAA6F,EAAA,CAGA,GAAAU,GAAAhP,KAAAuL,QAAAxN,MACA6Q,GAAA5O,KAAAsN,iBAAAgB,EAAAU,GAEAH,EAAAP,IAAAC,EAAAK,EAAA5O,KAAAsN,iBAAAiB,EAAAS,GACAF,EAAAR,IAAAE,EAAAI,EAAA5O,KAAAsN,iBAAAkB,EAAAQ,GAEAvG,SAAAwF,EAEAjO,KAAA6N,UAAAe,EAAAC,EAAAC,IAGAJ,EAAA1O,KAAAsN,iBAAAmB,EAAAO,GAEAhP,KAAA6N,UAAAe,EAAAC,EAAAH,GACA1O,KAAA6N,UAAAgB,EAAAC,EAAAJ,MAKAO,gBAAA,SAAA3D,EAAAE,GAEAxL,KAAAqL,OAAAU,SAAAnO,KAAA,MAKA,QAHA+Q,GAAA3O,KAAAsL,SAAAvN,OACAgR,EAAA/O,KAAAwL,IAAAzN,OAEAmR,EAAA,EAAAC,EAAA7D,EAAAvN,OAA+CmR,EAAAC,EAAQD,IAEvDlP,KAAA4N,cAAA5N,KAAAqN,iBAAA/B,EAAA4D,GAAAP,GAGA,QAAAS,GAAA,EAAAD,EAAA3D,EAAAzN,OAA2CqR,EAAAD,EAASC,IAEpDpP,KAAA+N,UAAA/N,KAAAuN,aAAA/B,EAAA4D,GAAAL,KAQA,OAFA5D,GAAAO,YAAA,OAEAP,GAGAJ,MAAA,SAAAD,EAAAuE,GACA,mBAAAA,KACAA,GAAA,GAGAA,GACAC,QAAAC,KAAA,YAGA,IAAApE,GAAAnL,KAAAkL,oBAEAJ,GAAA0E,QAAA,eAGA1E,IAAArD,QAAA,eAGAqD,EAAA0E,QAAA,eAGA1E,IAAArD,QAAA,YAaA,QAVAgI,GAAA3E,EAAA4E,MAAA,MACAC,EAAA,GACAC,EAAA,GACAC,EAAA,GACAC,EAAA,EACAtI,KAGAuI,EAAA,qBAAAA,SAEA5Q,EAAA,EAAAgQ,EAAAM,EAAA1R,OAAuCoB,EAAAgQ,EAAOhQ,IAQ9C,GANAwQ,EAAAF,EAAAtQ,GAEAwQ,EAAAI,EAAAJ,EAAAI,WAAAJ,EAAAK,OAEAF,EAAAH,EAAA5R,OAEA,IAAA+R,IAEAF,EAAAD,EAAAM,OAAA,GAGA,MAAAL,GAEA,SAAAA,EAEAC,EAAAF,EAAAM,OAAA,GAEA,MAAAJ,GAAA,QAAArI,EAAAxH,KAAAuJ,OAAAC,eAAA0G,KAAAP,IAKAxE,EAAAG,SAAAjK,KAAA8O,WAAA3I,EAAA,IAAA2I,WAAA3I,EAAA,IAAA2I,WAAA3I,EAAA,KACW,MAAAqI,GAAA,QAAArI,EAAAxH,KAAAuJ,OAAAE,eAAAyG,KAAAP,IAKXxE,EAAAI,QAAAlK,KAAA8O,WAAA3I,EAAA,IAAA2I,WAAA3I,EAAA,IAAA2I,WAAA3I,EAAA,KACW,MAAAqI,GAAA,QAAArI,EAAAxH,KAAAuJ,OAAAG,WAAAwG,KAAAP,IAKXxE,EAAAK,IAAAnK,KAAA8O,WAAA3I,EAAA,IAAA2I,WAAA3I,EAAA,KAGAxH,KAAAwK,QAAA,sCAAAmF,EAAA,SAES,UAAAC,EAET,QAAApI,EAAAxH,KAAAuJ,OAAAM,sBAAAqG,KAAAP,IAMAxE,EAAA6C,QAAAxG,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KACW,QAAAA,EAAAxH,KAAAuJ,OAAAK,eAAAsG,KAAAP,IAMXxE,EAAA6C,QAAAxG,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACW,QAAAA,EAAAxH,KAAAuJ,OAAAO,mBAAAoG,KAAAP,IAMXxE,EAAA6C,QAAAxG,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAiB,4BAAAjB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACW,QAAAA,EAAAxH,KAAAuJ,OAAAI,YAAAuG,KAAAP,IAMXxE,EAAA6C,QAAAxG,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAGAxH,KAAAwK,QAAA,0BAAAmF,EAAA,SAES,UAAAC,EAAA,CAET,GAAAQ,GAAAT,EAAAU,UAAA,GAAAL,OAAAN,MAAA,KACAY,KACAC,IAEA,IAAAZ,EAAAH,QAAA,UAEAc,EAAAF,MAGA,QAAAI,GAAA,EAAAC,EAAAL,EAAArS,OAAqDyS,EAAAC,EAAWD,IAAA,CAEhE,GAAAE,GAAAN,EAAAI,GAAAd,MAAA,IAEA,MAAAgB,EAAA,IAAAJ,EAAAjP,KAAAqP,EAAA,IACA,KAAAA,EAAA,IAAAH,EAAAlP,KAAAqP,EAAA,IAGAvF,EAAA8D,gBAAAqB,EAAAC,OACS,YAAA/I,EAAAxH,KAAAuJ,OAAAQ,eAAAmG,KAAAP,IAAA,CAQT,GAAA7R,IAAA,IAAA0J,EAAA,GAAAG,OAAA,GAAAqI,QAAArI,OAAA,EAEAwD,GAAAO,YAAA5N,OACS,IAAAkC,KAAAuJ,OAAAW,qBAAAyG,KAAAhB,GAITxE,EAAAE,OAAAY,cAAA0D,EAAAU,UAAA,GAAAL,OAAA7E,EAAAM,uBACS,IAAAzL,KAAAuJ,OAAAU,yBAAA0G,KAAAhB,GAITxE,EAAAM,kBAAApK,KAAAsO,EAAAU,UAAA,GAAAL,YACS,YAAAxI,EAAAxH,KAAAuJ,OAAAS,kBAAAkG,KAAAP,IAAA,CAWT,GAAA3E,GAAAxD,EAAA,GAAAwI,OAAAY,aACAzF,GAAAE,OAAAW,OAAA,MAAAhB,GAAA,OAAAA,CAEA,IAAAwB,GAAArB,EAAAE,OAAAQ,iBACAW,KAEAA,EAAAR,OAAAb,EAAAE,OAAAW,YAES,CAGT,UAAA2D,EAAA,QAEA3P,MAAAwK,QAAA,qBAAAmF,EAAA,KAIAxE,EAAAiC,UAEA,IAAAyD,GAAA,GAAA3H,GAAA4H,KACAD,GAAApF,qBAAAvM,OAAAiM,EAAAM,kBAEA,QAAAtM,GAAA,EAAAgQ,EAAAhE,EAAAC,QAAArN,OAA+CoB,EAAAgQ,EAAOhQ,IAAA,CAEtD,GAAAkM,GAAAF,EAAAC,QAAAjM,GACA4M,EAAAV,EAAAU,SACAzC,EAAA+B,EAAA/B,UACAyH,EAAA,SAAAhF,EAAAnO,IAGA,QAAAmO,EAAAT,SAAAvN,OAAA,CAEA,GAAAiT,GAAA,GAAA9H,GAAA+H,cAEAD,GAAAE,aAAA,cAAAhI,GAAAiI,gBAAA,GAAAC,cAAArF,EAAAT,UAAA,IAEAS,EAAAR,QAAAxN,OAAA,EAEAiT,EAAAE,aAAA,YAAAhI,GAAAiI,gBAAA,GAAAC,cAAArF,EAAAR,SAAA,IAGAyF,EAAAK,uBAGAtF,EAAAP,IAAAzN,OAAA,GAEAiT,EAAAE,aAAA,QAAAhI,GAAAiI,gBAAA,GAAAC,cAAArF,EAAAP,KAAA,GAOA,QAFA8F,MAEApE,EAAA,EAAAqE,EAAAjI,EAAAvL,OAAkDmP,EAAAqE,EAAYrE,IAAA,CAE9D,GAAAsE,GAAAlI,EAAA4D,GACAV,EAAA/D,MAEA,WAAAzI,KAAAsJ,YAEAkD,EAAAxM,KAAAsJ,UAAAmI,OAAAD,EAAA1T,MAGAiT,GAAAvE,iBAAAtD,GAAAwI,oBAAA,CAEA,GAAAC,GAAA,GAAAzI,GAAAwI,iBACAC,GAAAC,KAAApF,GACAA,EAAAmF,EAIAnF,IAEAA,EAAAuE,EAAA,GAAA7H,GAAAwI,kBAAA,GAAAxI,GAAA2I,kBACArF,EAAA1O,KAAA0T,EAAA1T,MAGA0O,EAAAsF,QAAAN,EAAAxF,OAAA9C,EAAA6I,cAAA7I,EAAA8I,YAEAV,EAAAjQ,KAAAmL,GAKA,GAAAyF,EAEA,IAAAX,EAAAvT,OAAA,GAEA,OAAAmP,GAAA,EAAAqE,EAAAjI,EAAAvL,OAAoDmP,EAAAqE,EAAYrE,IAAA,CAEhE,GAAAsE,GAAAlI,EAAA4D,EACA8D,GAAAkB,SAAAV,EAAA7E,WAAA6E,EAAAnF,WAAAa,GAGA,GAAAiF,GAAA,GAAAjJ,GAAAkJ,cAAAd,EACAW,GAAAlB,EAAA,GAAA7H,GAAAmJ,aAAArB,EAAAmB,GAAA,GAAAjJ,GAAAoJ,KAAAtB,EAAAmB,OAGAF,GAAAlB,EAAA,GAAA7H,GAAAmJ,aAAArB,EAAAM,EAAA,OAAApI,GAAAoJ,KAAAtB,EAAAM,EAAA,GAGAW,GAAAnU,KAAAuN,EAAAvN,KAEA+S,EAAA0B,IAAAN,IAOA,MAJA5C,IACAC,QAAAkD,QAAA,aAGA3B,MJiuBM4B,IACA,SAAUvV,EAAQC,GKt3CxBD,EAAAC,QAAA,SAAA+L,GAgBA,QAAAwJ,GAAArH,EAAAsH,GA0PA,QAAAC,KAEA,SAAAlO,KAAAmO,GAAA,MAAApI,EAAAqI,gBAIA,QAAAC,KAEA,MAAArO,MAAAsO,IAAA,IAAAvI,EAAAwI,WAIA,QAAAC,GAAAC,GAEAC,EAAAC,OAAAF,EAIA,QAAAG,GAAAH,GAEAC,EAAAG,KAAAJ,EA2EA,QAAAK,GAAAC,GAEAhJ,EAAAY,iBAAAnC,GAAAwK,kBAEAC,GAAAF,EAEIhJ,EAAAY,iBAAAnC,GAAA0K,oBAEJnJ,EAAAY,OAAAwI,KAAAnP,KAAA0B,IAAAqE,EAAAqJ,QAAApP,KAAA2B,IAAAoE,EAAAsJ,QAAAtJ,EAAAY,OAAAwI,KAAAJ,IACAhJ,EAAAY,OAAA2I,yBACAC,GAAA,IAIA3E,QAAA4E,KAAA,uFACAzJ,EAAA0J,YAAA,GAMA,QAAAC,GAAAX,GAEAhJ,EAAAY,iBAAAnC,GAAAwK,kBAEAC,GAAAF,EAEIhJ,EAAAY,iBAAAnC,GAAA0K,oBAEJnJ,EAAAY,OAAAwI,KAAAnP,KAAA0B,IAAAqE,EAAAqJ,QAAApP,KAAA2B,IAAAoE,EAAAsJ,QAAAtJ,EAAAY,OAAAwI,KAAAJ,IACAhJ,EAAAY,OAAA2I,yBACAC,GAAA,IAIA3E,QAAA4E,KAAA,uFACAzJ,EAAA0J,YAAA,GAUA,QAAAE,GAAAC,GAIAC,EAAAC,IAAAF,EAAAG,QAAAH,EAAAI,SAIA,QAAAC,GAAAL,GAIAM,EAAAJ,IAAAF,EAAAG,QAAAH,EAAAI,SAIA,QAAAG,GAAAP,GAIAQ,EAAAN,IAAAF,EAAAG,QAAAH,EAAAI,SAIA,QAAAK,GAAAT,GAIAU,EAAAR,IAAAF,EAAAG,QAAAH,EAAAI,SACAO,EAAAC,WAAAF,EAAAT,EAEA,IAAAY,GAAA1K,EAAAkI,aAAAyC,SAAA3K,EAAAkI,WAAA0C,KAAA5K,EAAAkI,UAGAO,GAAA,EAAAxO,KAAAmO,GAAAoC,EAAAK,EAAAH,EAAAI,YAAA9K,EAAA+K,aAGAlC,EAAA,EAAA5O,KAAAmO,GAAAoC,EAAAQ,EAAAN,EAAAO,aAAAjL,EAAA+K,aAEAjB,EAAA3C,KAAAoD,GAEAvK,EAAAkL,SAIA,QAAAC,GAAAtB,GAIAuB,EAAArB,IAAAF,EAAAG,QAAAH,EAAAI,SAEAoB,GAAAZ,WAAAW,EAAAjB,GAEAkB,GAAAL,EAAA,EAEAjC,EAAAT,KAEI+C,GAAAL,EAAA,GAEJrB,EAAArB,KAIA6B,EAAAhD,KAAAiE,GAEApL,EAAAkL,SAIA,QAAAI,GAAAzB,GAIA0B,EAAAxB,IAAAF,EAAAG,QAAAH,EAAAI,SAEAuB,EAAAf,WAAAc,EAAAlB,GAEAoB,GAAAD,EAAAX,EAAAW,EAAAR,GAEAX,EAAAlD,KAAAoE,GAEAvL,EAAAkL,SAIA,QAAAQ,GAAA7B,IAMA,QAAA8B,GAAA9B,GAIAA,EAAA+B,OAAA,EAEAjC,EAAArB,KAEIuB,EAAA+B,OAAA,GAEJ7C,EAAAT,KAIAtI,EAAAkL,SAIA,QAAAW,GAAAhC,GAIA,OAAAA,EAAAiC,SAEA,IAAA9L,GAAAxL,KAAAuX,GACAN,GAAA,EAAAzL,EAAAgM,aACAhM,EAAAkL,QACA,MAEA,KAAAlL,GAAAxL,KAAAyX,OACAR,GAAA,GAAAzL,EAAAgM,aACAhM,EAAAkL,QACA,MAEA,KAAAlL,GAAAxL,KAAA0X,KACAT,GAAAzL,EAAAgM,YAAA,GACAhM,EAAAkL,QACA,MAEA,KAAAlL,GAAAxL,KAAA2X,MACAV,IAAAzL,EAAAgM,YAAA,GACAhM,EAAAkL,UAOA,QAAAkB,GAAAvC,GAIAC,EAAAC,IAAAF,EAAAwC,QAAA,GAAAC,MAAAzC,EAAAwC,QAAA,GAAAE,OAIA,QAAAC,GAAA3C,GAIA,GAAA4C,GAAA5C,EAAAwC,QAAA,GAAAC,MAAAzC,EAAAwC,QAAA,GAAAC,MACAI,EAAA7C,EAAAwC,QAAA,GAAAE,MAAA1C,EAAAwC,QAAA,GAAAE,MAEAI,EAAA1S,KAAA2S,KAAAH,IAAAC,IAEAvC,GAAAJ,IAAA,EAAA4C,GAIA,QAAAE,GAAAhD,GAIAQ,EAAAN,IAAAF,EAAAwC,QAAA,GAAAC,MAAAzC,EAAAwC,QAAA,GAAAE,OAIA,QAAAO,GAAAjD,GAIAU,EAAAR,IAAAF,EAAAwC,QAAA,GAAAC,MAAAzC,EAAAwC,QAAA,GAAAE,OACA/B,EAAAC,WAAAF,EAAAT,EAEA,IAAAY,GAAA1K,EAAAkI,aAAAyC,SAAA3K,EAAAkI,WAAA0C,KAAA5K,EAAAkI,UAGAO,GAAA,EAAAxO,KAAAmO,GAAAoC,EAAAK,EAAAH,EAAAI,YAAA9K,EAAA+K,aAGAlC,EAAA,EAAA5O,KAAAmO,GAAAoC,EAAAQ,EAAAN,EAAAO,aAAAjL,EAAA+K,aAEAjB,EAAA3C,KAAAoD,GAEAvK,EAAAkL,SAIA,QAAA6B,GAAAlD,GAIA,GAAA4C,GAAA5C,EAAAwC,QAAA,GAAAC,MAAAzC,EAAAwC,QAAA,GAAAC,MACAI,EAAA7C,EAAAwC,QAAA,GAAAE,MAAA1C,EAAAwC,QAAA,GAAAE,MAEAI,EAAA1S,KAAA2S,KAAAH,IAAAC,IAEAtB,GAAArB,IAAA,EAAA4C,GAEAtB,GAAAZ,WAAAW,EAAAjB,GAEAkB,GAAAL,EAAA,EAEArB,EAAArB,KAEI+C,GAAAL,EAAA,GAEJjC,EAAAT,KAIA6B,EAAAhD,KAAAiE,GAEApL,EAAAkL,SAIA,QAAA8B,GAAAnD,GAIA0B,EAAAxB,IAAAF,EAAAwC,QAAA,GAAAC,MAAAzC,EAAAwC,QAAA,GAAAE,OAEAf,EAAAf,WAAAc,EAAAlB,GAEAoB,GAAAD,EAAAX,EAAAW,EAAAR,GAEAX,EAAAlD,KAAAoE,GAEAvL,EAAAkL,SAIA,QAAA+B,GAAApD,IAUA,QAAAqD,GAAArD,GAEA,GAAA7J,EAAAmN,WAAA,GAIA,GAFAtD,EAAAuD,iBAEAvD,EAAAwD,SAAArN,EAAAsN,aAAAC,MAAA,CAEA,GAAAvN,EAAAwN,gBAAA,QAEA5D,GAAAC,GAEAnJ,EAAA+M,EAAAC,WAEI,IAAA7D,EAAAwD,SAAArN,EAAAsN,aAAAK,KAAA,CAEJ,GAAA3N,EAAA0J,cAAA,QAEAQ,GAAAL,GAEAnJ,EAAA+M,EAAAG,UAEI,IAAA/D,EAAAwD,SAAArN,EAAAsN,aAAAO,IAAA,CAEJ,GAAA7N,EAAA8N,aAAA,QAEA1D,GAAAP,GAEAnJ,EAAA+M,EAAAI,IAIAnN,IAAA+M,EAAAM,OAEApD,SAAAqD,iBAAA,YAAAC,GAAA,GACAtD,SAAAqD,iBAAA,UAAAE,GAAA,GAEAlO,EAAAmO,cAAAC,KAMA,QAAAH,GAAApE,GAEA,GAAA7J,EAAAmN,WAAA,EAIA,GAFAtD,EAAAuD,iBAEA1M,IAAA+M,EAAAC,OAAA,CAEA,GAAA1N,EAAAwN,gBAAA,QAEAlD,GAAAT,OAEI,IAAAnJ,IAAA+M,EAAAG,MAAA,CAEJ,GAAA5N,EAAA0J,cAAA,QAEAyB,GAAAtB,OAEI,IAAAnJ,IAAA+M,EAAAI,IAAA,CAEJ,GAAA7N,EAAA8N,aAAA,QAEAxC,GAAAzB,IAMA,QAAAqE,GAAArE,GAEA7J,EAAAmN,WAAA,IAEAzB,EAAA7B,GAEAc,SAAA0D,oBAAA,YAAAJ,GAAA,GACAtD,SAAA0D,oBAAA,UAAAH,GAAA,GAEAlO,EAAAmO,cAAAG,GAEA5N,EAAA+M,EAAAM,MAIA,QAAAQ,GAAA1E,GAEA7J,EAAAmN,WAAA,GAAAnN,EAAA0J,cAAA,GAAAhJ,IAAA+M,EAAAM,MAAArN,IAAA+M,EAAAC,SAEA7D,EAAAuD,iBACAvD,EAAA2E,kBAEA7C,EAAA9B,GAEA7J,EAAAmO,cAAAC,GACApO,EAAAmO,cAAAG,IAIA,QAAAG,GAAA5E,GAEA7J,EAAAmN,WAAA,GAAAnN,EAAA0O,cAAA,GAAA1O,EAAA8N,aAAA,GAEAjC,EAAAhC,GAIA,QAAA8E,GAAA9E,GAEA,GAAA7J,EAAAmN,WAAA,GAEA,OAAAtD,EAAAwC,QAAA/Y,QAEA,OAEA,GAAA0M,EAAAwN,gBAAA,QAEApB,GAAAvC,GAEAnJ,EAAA+M,EAAAmB,YAEA,MAEA,QAEA,GAAA5O,EAAA0J,cAAA,QAEA8C,GAAA3C,GAEAnJ,EAAA+M,EAAAoB,WAEA,MAEA,QAEA,GAAA7O,EAAA8N,aAAA,QAEAjB,GAAAhD,GAEAnJ,EAAA+M,EAAAqB,SAEA,MAEA,SAEApO,EAAA+M,EAAAM,KAIArN,IAAA+M,EAAAM,MAEA/N,EAAAmO,cAAAC,IAMA,QAAAW,GAAAlF,GAEA,GAAA7J,EAAAmN,WAAA,EAKA,OAHAtD,EAAAuD,iBACAvD,EAAA2E,kBAEA3E,EAAAwC,QAAA/Y,QAEA,OAEA,GAAA0M,EAAAwN,gBAAA,QACA,IAAA9M,IAAA+M,EAAAmB,aAAA,MAEA9B,GAAAjD,EAEA,MAEA,QAEA,GAAA7J,EAAA0J,cAAA,QACA,IAAAhJ,IAAA+M,EAAAoB,YAAA,MAEA9B,GAAAlD,EAEA,MAEA,QAEA,GAAA7J,EAAA8N,aAAA,QACA,IAAApN,IAAA+M,EAAAqB,UAAA,MAEA9B,GAAAnD,EAEA,MAEA,SAEAnJ,EAAA+M,EAAAM,MAMA,QAAAiB,GAAAnF,GAEA7J,EAAAmN,WAAA,IAEAF,EAAApD,GAEA7J,EAAAmO,cAAAG,GAEA5N,EAAA+M,EAAAM,MAIA,QAAAkB,GAAApF,GAEAA,EAAAuD,iBAj1BA7X,KAAAqL,SAEArL,KAAA2S,WAAAlK,SAAAkK,IAAAyC,SAGApV,KAAA4X,SAAA,EAGA5X,KAAA2Z,OAAA,GAAAzQ,GAAA0Q,QAGA5Z,KAAA6Z,YAAA,EACA7Z,KAAA8Z,YAAAC,IAGA/Z,KAAA8T,QAAA,EACA9T,KAAA+T,QAAAgG,IAIA/Z,KAAAga,cAAA,EACAha,KAAAia,cAAAvV,KAAAmO,GAIA7S,KAAAka,kBAAAH,KACA/Z,KAAAma,gBAAAJ,IAIA/Z,KAAAoa,eAAA,EACApa,KAAAqa,cAAA,IAIAra,KAAAmU,YAAA,EACAnU,KAAAiT,UAAA,EAGAjT,KAAAiY,cAAA,EACAjY,KAAAwV,YAAA,EAGAxV,KAAAuY,WAAA,EACAvY,KAAAyW,YAAA,EAIAzW,KAAAsa,YAAA,EACAta,KAAA8S,gBAAA,EAGA9S,KAAAmZ,YAAA,EAGAnZ,KAAAf,MAAe0X,KAAA,GAAAH,GAAA,GAAAI,MAAA,GAAAF,OAAA,IAGf1W,KAAA+X,cAAuBC,MAAA9O,EAAAqR,MAAA5D,KAAAyB,KAAAlP,EAAAqR,MAAAC,OAAAlC,IAAApP,EAAAqR,MAAA3D,OAGvB5W,KAAAya,QAAAza,KAAA2Z,OAAA9M,QACA7M,KAAA0a,UAAA1a,KAAAqL,OAAAsP,SAAA9N,QACA7M,KAAA4a,MAAA5a,KAAAqL,OAAAwI,KAMA7T,KAAA6a,cAAA,WAEA,MAAAC,GAAAvH,KAIAvT,KAAA+a,kBAAA,WAEA,MAAAD,GAAAzH,OAIArT,KAAAgb,MAAA,WAEAvQ,EAAAkP,OAAA/H,KAAAnH,EAAAgQ,SACAhQ,EAAAY,OAAAsP,SAAA/I,KAAAnH,EAAAiQ,WACAjQ,EAAAY,OAAAwI,KAAApJ,EAAAmQ,MAEAnQ,EAAAY,OAAA2I,yBACAvJ,EAAAmO,cAAAqC,GAEAxQ,EAAAkL,SAEAxK,EAAA+M,EAAAM,MAKAxY,KAAA2V,OAAA,WAEA,GAAAuF,GAAA,GAAAhS,GAAA0Q,QAGAuB,GAAA,GAAAjS,GAAAkS,YAAAC,mBAAAhQ,EAAAiQ,GAAA,GAAApS,GAAA0Q,QAAA,QACA2B,EAAAJ,EAAAtO,QAAA2O,UAEAC,EAAA,GAAAvS,GAAA0Q,QACA8B,EAAA,GAAAxS,GAAAkS,UAEA,mBAEA,GAAAT,GAAAlQ,EAAAY,OAAAsP,QA+DA,OA7DAO,GAAAtJ,KAAA+I,GAAAgB,IAAAlR,EAAAkP,QAGAuB,EAAAU,gBAAAT,GAGAL,EAAAe,eAAAX,GAEAzQ,EAAA6P,YAAAnP,IAAA+M,EAAAM,MAEAtF,EAAAN,KAIAkI,EAAAzH,OAAAD,EAAAC,MACAyH,EAAAvH,KAAAH,EAAAG,IAGAuH,EAAAzH,MAAA3O,KAAA0B,IAAAqE,EAAAyP,gBAAAxV,KAAA2B,IAAAoE,EAAA0P,gBAAAW,EAAAzH,QAGAyH,EAAAvH,IAAA7O,KAAA0B,IAAAqE,EAAAuP,cAAAtV,KAAA2B,IAAAoE,EAAAwP,cAAAa,EAAAvH,MAEAuH,EAAAgB,WAGAhB,EAAAiB,QAAApI,EAGAmH,EAAAiB,OAAArX,KAAA0B,IAAAqE,EAAAoP,YAAAnV,KAAA2B,IAAAoE,EAAAqP,YAAAgB,EAAAiB,SAGAtR,EAAAkP,OAAApH,IAAAyJ,GAEAd,EAAAe,iBAAAnB,GAGAI,EAAAU,gBAAAL,GAEAZ,EAAA/I,KAAAnH,EAAAkP,QAAApH,IAAA2I,GAEAzQ,EAAAY,OAAA6Q,OAAAzR,EAAAkP,QAEAlP,EAAA2P,iBAAA,GAEAhH,EAAAC,OAAA,EAAA5I,EAAA4P,cACAjH,EAAAG,KAAA,EAAA9I,EAAA4P,eAIAjH,EAAAoB,IAAA,OAIAb,EAAA,EACAqI,EAAAxH,IAAA,UAMAP,GACAwH,EAAAU,kBAAA1R,EAAAY,OAAAsP,UAAAyB,GACA,KAAAV,EAAAW,IAAA5R,EAAAY,OAAAiR,aAAAF,KAEA3R,EAAAmO,cAAAqC,GAEAQ,EAAA7J,KAAAnH,EAAAY,OAAAsP,UACAe,EAAA9J,KAAAnH,EAAAY,OAAAiR,YACArI,GAAA,GAEA,OAUAjU,KAAAuc,QAAA,WAEA9R,EAAAkI,WAAAmG,oBAAA,cAAAY,GAAA,GACAjP,EAAAkI,WAAAmG,oBAAA,YAAAnB,GAAA,GACAlN,EAAAkI,WAAAmG,oBAAA,QAAAE,GAAA,GAEAvO,EAAAkI,WAAAmG,oBAAA,aAAAM,GAAA,GACA3O,EAAAkI,WAAAmG,oBAAA,WAAAW,GAAA,GACAhP,EAAAkI,WAAAmG,oBAAA,YAAAU,GAAA,GAEApE,SAAA0D,oBAAA,YAAAJ,GAAA,GACAtD,SAAA0D,oBAAA,UAAAH,GAAA,GAEA6D,OAAA1D,oBAAA,UAAAI,GAAA,GAUA,IAAAzO,GAAAzK,KAEAib,GAAqBrd,KAAA,UACrBib,GAAoBjb,KAAA,SACpBmb,GAAkBnb,KAAA,OAElBsa,GAAeM,MAAA,EAAAL,OAAA,EAAAE,MAAA,EAAAC,IAAA,EAAAe,aAAA,EAAAC,YAAA,EAAAC,UAAA,GAEfpO,EAAA+M,EAAAM,KAEA4D,EAAA,KAGAtB,EAAA,GAAA5R,GAAAuT,UACArJ,EAAA,GAAAlK,GAAAuT,UAEA9I,EAAA,EACAqI,EAAA,GAAA9S,GAAA0Q,QACA3F,GAAA,EAEAM,EAAA,GAAArL,GAAAwT,QACA1H,EAAA,GAAA9L,GAAAwT,QACAzH,EAAA,GAAA/L,GAAAwT,QAEA5H,EAAA,GAAA5L,GAAAwT,QACA1G,EAAA,GAAA9M,GAAAwT,QACAzG,EAAA,GAAA/M,GAAAwT,QAEA9H,EAAA,GAAA1L,GAAAwT,QACA7G,EAAA,GAAA3M,GAAAwT,QACA5G,GAAA,GAAA5M,GAAAwT,QA0BAC,GAAA,WAEA,GAAA3V,GAAA,GAAAkC,GAAA0Q,OAEA,iBAAAxC,EAAAwF,GAEA5V,EAAA6V,oBAAAD,EAAA,GACA5V,EAAA8V,gBAAA1F,GAEA4E,EAAAzJ,IAAAvL,OAMA+V,GAAA,WAEA,GAAA/V,GAAA,GAAAkC,GAAA0Q,OAEA,iBAAAxC,EAAAwF,GAEA5V,EAAA6V,oBAAAD,EAAA,GACA5V,EAAA8V,eAAA1F,GAEA4E,EAAAzJ,IAAAvL,OAOAkP,GAAA,WAEA,GAAAgF,GAAA,GAAAhS,GAAA0Q,OAEA,iBAAAoD,EAAA3G,GAEA,GAAAlB,GAAA1K,EAAAkI,aAAAyC,SAAA3K,EAAAkI,WAAA0C,KAAA5K,EAAAkI,UAEA,IAAAlI,EAAAY,iBAAAnC,GAAAwK,kBAAA,CAGA,GAAAiH,GAAAlQ,EAAAY,OAAAsP,QACAO,GAAAtJ,KAAA+I,GAAAgB,IAAAlR,EAAAkP,OACA,IAAAsD,GAAA/B,EAAAnd,QAGAkf,IAAAvY,KAAAwY,IAAAzS,EAAAY,OAAA8R,IAAA,EAAAzY,KAAAmO,GAAA,KAGA8J,GAAA,EAAAK,EAAAC,EAAA9H,EAAAO,aAAAjL,EAAAY,OAAA+R,QACAL,GAAA,EAAA1G,EAAA4G,EAAA9H,EAAAO,aAAAjL,EAAAY,OAAA+R,YAEK3S,GAAAY,iBAAAnC,GAAA0K,oBAGL+I,GAAAK,GAAAvS,EAAAY,OAAAgS,MAAA5S,EAAAY,OAAAiS,MAAA7S,EAAAY,OAAAwI,KAAAsB,EAAAI,YAAA9K,EAAAY,OAAA+R,QACAL,GAAA1G,GAAA5L,EAAAY,OAAAkS,IAAA9S,EAAAY,OAAAmS,QAAA/S,EAAAY,OAAAwI,KAAAsB,EAAAO,aAAAjL,EAAAY,OAAA+R,UAKA9N,QAAA4E,KAAA,gFACAzJ,EAAA8N,WAAA,MAwgBA9N,GAAAkI,WAAA8F,iBAAA,cAAAiB,GAAA,GAEAjP,EAAAkI,WAAA8F,iBAAA,YAAAd,GAAA,GACAlN,EAAAkI,WAAA8F,iBAAA,QAAAO,GAAA,GAEAvO,EAAAkI,WAAA8F,iBAAA,aAAAW,GAAA,GACA3O,EAAAkI,WAAA8F,iBAAA,WAAAgB,GAAA,GACAhP,EAAAkI,WAAA8F,iBAAA,YAAAe,GAAA,GAEAgD,OAAA/D,iBAAA,UAAAS,GAAA,GAIAlZ,KAAA2V,SAoIA,MAhIAjD,GAAA1U,UAAAM,OAAAmT,OAAAvI,EAAAuU,gBAAAzf,WACA0U,EAAA1U,UAAAmM,YAAAuI,EAEApU,OAAAof,iBAAAhL,EAAA1U,WAEA2f,QAEAC,IAAA,WAGA,MADAtO,SAAA4E,KAAA,4DACAlU,KAAA2Z,SAQAkE,QAEAD,IAAA,WAGA,MADAtO,SAAA4E,KAAA,+EACAlU,KAAAmU,YAIAK,IAAA,SAAAxJ,GAEAsE,QAAA4E,KAAA,8EACAlU,KAAAmU,YAAAnJ,IAMA8S,UAEAF,IAAA,WAGA,MADAtO,SAAA4E,KAAA,mFACAlU,KAAAiY,cAIAzD,IAAA,SAAAxJ,GAEAsE,QAAA4E,KAAA,kFACAlU,KAAAiY,cAAAjN,IAMA+S,OAEAH,IAAA,WAGA,MADAtO,SAAA4E,KAAA,6EACAlU,KAAAuY,WAIA/D,IAAA,SAAAxJ,GAEAsE,QAAA4E,KAAA,4EACAlU,KAAAuY,WAAAvN,IAMAgT,QAEAJ,IAAA,WAGA,MADAtO,SAAA4E,KAAA,+EACAlU,KAAAmZ,YAIA3E,IAAA,SAAAxJ,GAEAsE,QAAA4E,KAAA,8EACAlU,KAAAmZ,YAAAnO,IAMAiT,cAEAL,IAAA,WAGA,MADAtO,SAAA4E,KAAA,wFACAlU,KAAAoa,eAIA5F,IAAA,SAAAxJ,GAEAsE,QAAA4E,KAAA,uFACAlU,KAAAoa,eAAApP,IAMAkT,sBAEAN,IAAA,WAGA,MADAtO,SAAA4E,KAAA,4FACAlU,KAAAqa,eAIA7F,IAAA,SAAAxJ,GAEAsE,QAAA4E,KAAA,4FACAlU,KAAAqa,cAAArP,MAQA0H,IL83CMyL,IACA,SAAUjhB,EAAQC,EAAS0F,IMz3EjC,SAAAub,EAAArb,GACAA,EAAA5F,IAGC6C,KAAA,SAAA7C,GAA4B,YAuG7B,SAAAsgB,MAuXA,QAAAf,GAAApH,EAAAG,GAEAzV,KAAAsV,KAAA,EACAtV,KAAAyV,KAAA,EA8eA,QAAA4I,KAEAre,KAAAse,UAEA,QACA,QACA,QACA,SAIAngB,UAAAJ,OAAA,GAEAuR,QAAAiP,MAAA,iFAu4BA,QAAAnD,GAAA9F,EAAAG,EAAA+I,EAAAC,GAEAze,KAAA0e,GAAApJ,GAAA,EACAtV,KAAA2e,GAAAlJ,GAAA,EACAzV,KAAA4e,GAAAJ,GAAA,EACAxe,KAAA6e,GAAApW,SAAAgW,IAAA,EA6lBA,QAAA7E,GAAAtE,EAAAG,EAAA+I,GAEAxe,KAAAsV,KAAA,EACAtV,KAAAyV,KAAA,EACAzV,KAAAwe,KAAA,EA8sBA,QAAAM,KAEA9e,KAAAse,UAEA,MACA,MACA,OAIAngB,UAAAJ,OAAA,GAEAuR,QAAAiP,MAAA,iFAqXA,QAAAQ,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,EAAAC,GAEAjhB,OAAAD,eAAA2B,KAAA,MAAsCgL,MAAAwU,OAEtCxf,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAAlC,KAAA,GAEAkC,KAAAgf,MAAAvW,SAAAuW,IAAAD,EAAAa,cACA5f,KAAA6f,WAEA7f,KAAAif,QAAAxW,SAAAwW,IAAAF,EAAAe,gBAEA9f,KAAAkf,MAAAzW,SAAAyW,IAAAa,GACA/f,KAAAmf,MAAA1W,SAAA0W,IAAAY,GAEA/f,KAAAof,UAAA3W,SAAA2W,IAAAY,GACAhgB,KAAAqf,UAAA5W,SAAA4W,IAAAY,GAEAjgB,KAAAsf,WAAA7W,SAAA6W,IAAA,EAEAtf,KAAAqE,OAAAoE,SAAApE,IAAA6b,GACAlgB,KAAApC,KAAA6K,SAAA7K,IAAAuiB,GAEAngB,KAAAkb,OAAA,GAAAwB,GAAA,KACA1c,KAAAogB,OAAA,GAAA1D,GAAA,KACA1c,KAAA2d,OAAA,GAAAjB,GAAA,KACA1c,KAAAqgB,SAAA,EAEArgB,KAAAsgB,kBAAA,EACAtgB,KAAAod,OAAA,GAAA0B,GAEA9e,KAAAugB,iBAAA,EACAvgB,KAAAwgB,kBAAA,EACAxgB,KAAAygB,OAAA,EACAzgB,KAAA0gB,gBAAA,EAMA1gB,KAAAuf,SAAA9W,SAAA8W,IAAAoB,GAEA3gB,KAAA2B,QAAA,EACA3B,KAAA4gB,SAAA,KA8QA,QAAAC,GAAAvL,EAAAG,EAAA+I,EAAAC,GAEAze,KAAAsV,KAAA,EACAtV,KAAAyV,KAAA,EACAzV,KAAAwe,KAAA,EACAxe,KAAAye,EAAAhW,SAAAgW,IAAA,EAinBA,QAAAqC,GAAAC,EAAAC,EAAA9d,GAEAlD,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAA+gB,QACA/gB,KAAAghB,SAEAhhB,KAAAihB,QAAA,GAAAJ,GAAA,IAAAE,EAAAC,GACAhhB,KAAAkhB,aAAA,EAEAlhB,KAAAmhB,SAAA,GAAAN,GAAA,IAAAE,EAAAC,GAEA9d,QAEAuF,SAAAvF,EAAAmc,YAAAnc,EAAAmc,UAAAW,IAEAhgB,KAAAohB,QAAA,GAAArC,GAAAtW,cAAAvF,EAAAgc,MAAAhc,EAAAic,MAAAjc,EAAAkc,UAAAlc,EAAAmc,UAAAnc,EAAAmB,OAAAnB,EAAAtF,KAAAsF,EAAAoc,WAAApc,EAAAqc,UAEAvf,KAAAqhB,YAAA5Y,SAAAvF,EAAAme,aAAAne,EAAAme,YACArhB,KAAAshB,cAAA7Y,SAAAvF,EAAAoe,eAAApe,EAAAoe,cACAthB,KAAAuhB,aAAA9Y,SAAAvF,EAAAqe,aAAAre,EAAAqe,aAAA,KA6DA,QAAAC,GAAAT,EAAAC,EAAA9d,GAEA4d,EAAA/gB,KAAAC,KAAA+gB,EAAAC,EAAA9d,GAEAlD,KAAAyhB,eAAA,EACAzhB,KAAA0hB,kBAAA,EAaA,QAAAC,GAAAC,EAAAb,EAAAC,EAAA3c,EAAAzG,EAAAqhB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEAR,EAAAhf,KAAAC,KAAA,KAAAif,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,EAAAC,GAEAvf,KAAAgf,OAAgB4C,OAAAb,QAAAC,UAEhBhhB,KAAAof,UAAA3W,SAAA2W,IAAAyC,GACA7hB,KAAAqf,UAAA5W,SAAA4W,IAAAwC,GAEA7hB,KAAAugB,iBAAA,EACAvgB,KAAAygB,OAAA,EACAzgB,KAAA0gB,gBAAA,EAaA,QAAAoB,GAAAC,EAAA9C,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,EAAAC,GAEAwC,EAAAtZ,SAAAsZ,OACA9C,EAAAxW,SAAAwW,IAAA+C,GAEAjD,EAAAhf,KAAAC,KAAA+hB,EAAA9C,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,EAAAC,GAEAvf,KAAAygB,OAAA,EA+EA,QAAAwB,KAEAjiB,KAAAkiB,OACAliB,KAAAmiB,OAkBA,QAAAC,GAAArhB,EAAAshB,EAAAC,GAEA,GAAAC,GAAAxhB,EAAA,EAEA,IAAAwhB,GAAA,GAAAA,EAAA,QAAAxhB,EAIA,IAAAyhB,GAAAH,EAAAC,EACAhb,EAAAmb,GAAAD,EASA,IAPA/Z,SAAAnB,IAEAA,EAAA,GAAA8J,cAAAoR,GACAC,GAAAD,GAAAlb,GAIA,IAAA+a,EAAA,CAEAE,EAAAG,QAAApb,EAAA,EAEA,QAAAnI,GAAA,EAAA+b,EAAA,EAA+B/b,IAAAkjB,IAAeljB,EAE9C+b,GAAAoH,EACAvhB,EAAA5B,GAAAujB,QAAApb,EAAA4T,GAMA,MAAA5T,GAMA,QAAAqb,GAAAC,EAAAJ,GAEA,GAAAlb,GAAAub,GAAAL,EAEA/Z,UAAAnB,IAEAA,EAAA,GAAAwb,YAAAN,GACAK,GAAAL,GAAAlb,EAIA,QAAAnI,GAAA,EAAkBA,IAAAqjB,IAASrjB,EAC3BmI,EAAAnI,GAAAyjB,EAAAG,kBAEA,OAAAzb,GAWA,QAAA0b,GAAAC,EAAAjc,GAEAic,EAAAC,UAAAljB,KAAAmjB,KAAAnc,GAIA,QAAAoc,GAAAH,EAAAjc,GAEAic,EAAAI,UAAArjB,KAAAmjB,KAAAnc,GAMA,QAAAsc,GAAAL,EAAAjc,GAEAyB,SAAAzB,EAAAsO,EAEA2N,EAAAM,WAAAvjB,KAAAmjB,KAAAnc,GAIAic,EAAAO,UAAAxjB,KAAAmjB,KAAAnc,EAAAsO,EAAAtO,EAAAyO,GAMA,QAAAgO,GAAAR,EAAAjc,GAEAyB,SAAAzB,EAAAsO,EAEA2N,EAAAS,UAAA1jB,KAAAmjB,KAAAnc,EAAAsO,EAAAtO,EAAAyO,EAAAzO,EAAAwX,GAEG/V,SAAAzB,EAAAM,EAEH2b,EAAAS,UAAA1jB,KAAAmjB,KAAAnc,EAAAM,EAAAN,EAAAO,EAAAP,EAAAxB,GAIAyd,EAAAU,WAAA3jB,KAAAmjB,KAAAnc,GAMA,QAAA4c,GAAAX,EAAAjc,GAEAyB,SAAAzB,EAAAsO,EAEA2N,EAAAY,WAAA7jB,KAAAmjB,KAAAnc,GAIAic,EAAAa,UAAA9jB,KAAAmjB,KAAAnc,EAAAsO,EAAAtO,EAAAyO,EAAAzO,EAAAwX,EAAAxX,EAAAyX,GAQA,QAAAsF,GAAAd,EAAAjc,GAEAic,EAAAe,iBAAAhkB,KAAAmjB,MAAA,EAAAnc,EAAAsX,UAAAtX,GAIA,QAAAid,GAAAhB,EAAAjc,GAEAyB,SAAAzB,EAAAsX,SAEA2E,EAAAiB,iBAAAlkB,KAAAmjB,MAAA,EAAAnc,IAIAmd,GAAA3P,IAAAxN,EAAAsX,UACA2E,EAAAiB,iBAAAlkB,KAAAmjB,MAAA,EAAAgB,KAMA,QAAAC,GAAAnB,EAAAjc,GAEAyB,SAAAzB,EAAAsX,SAEA2E,EAAAoB,iBAAArkB,KAAAmjB,MAAA,EAAAnc,IAIAsd,GAAA9P,IAAAxN,EAAAsX,UACA2E,EAAAoB,iBAAArkB,KAAAmjB,MAAA,EAAAmB,KAQA,QAAAC,GAAAtB,EAAAjc,EAAA4b,GAEA,GAAA4B,GAAA5B,EAAAG,kBACAE,GAAAI,UAAArjB,KAAAmjB,KAAAqB,GACA5B,EAAA6B,aAAAzd,GAAA0d,GAAAF,GAIA,QAAAG,GAAA1B,EAAAjc,EAAA4b,GAEA,GAAA4B,GAAA5B,EAAAG,kBACAE,GAAAI,UAAArjB,KAAAmjB,KAAAqB,GACA5B,EAAAgC,eAAA5d,GAAA6d,GAAAL,GAMA,QAAAM,GAAA7B,EAAAjc,GAEAic,EAAA8B,WAAA/kB,KAAAmjB,KAAAnc,GAIA,QAAAge,GAAA/B,EAAAjc,GAEAic,EAAAgC,WAAAjlB,KAAAmjB,KAAAnc,GAIA,QAAAke,GAAAjC,EAAAjc,GAEAic,EAAAkC,WAAAnlB,KAAAmjB,KAAAnc,GAMA,QAAAoe,GAAAxnB,GAEA,OAAAA,GAEA,gBAAAolB,EACA,kBAAAM,EACA,kBAAAG,EACA,kBAAAG,EAEA,kBAAAG,EACA,kBAAAE,EACA,kBAAAG,EAEA,6BAAAG,EACA,kBAAAI,EAEA,4BAAAvB,EACA,6BAAA0B,EACA,6BAAAE,EACA,6BAAAE,IAQA,QAAAG,GAAApC,EAAAjc,GAEAic,EAAAqC,WAAAtlB,KAAAmjB,KAAAnc,GAGA,QAAAue,GAAAtC,EAAAjc,GAEAic,EAAAuC,WAAAxlB,KAAAmjB,KAAAnc,GAMA,QAAAye,GAAAxC,EAAAjc,GAEAic,EAAAM,WAAAvjB,KAAAmjB,KAAAf,EAAApb,EAAAhH,KAAA0lB,KAAA,IAIA,QAAAC,GAAA1C,EAAAjc,GAEAic,EAAAU,WAAA3jB,KAAAmjB,KAAAf,EAAApb,EAAAhH,KAAA0lB,KAAA,IAIA,QAAAE,GAAA3C,EAAAjc,GAEAic,EAAAY,WAAA7jB,KAAAmjB,KAAAf,EAAApb,EAAAhH,KAAA0lB,KAAA,IAMA,QAAAG,GAAA5C,EAAAjc,GAEAic,EAAAe,iBAAAhkB,KAAAmjB,MAAA,EAAAf,EAAApb,EAAAhH,KAAA0lB,KAAA,IAIA,QAAAI,GAAA7C,EAAAjc,GAEAic,EAAAiB,iBAAAlkB,KAAAmjB,MAAA,EAAAf,EAAApb,EAAAhH,KAAA0lB,KAAA,IAIA,QAAAK,GAAA9C,EAAAjc,GAEAic,EAAAoB,iBAAArkB,KAAAmjB,MAAA,EAAAf,EAAApb,EAAAhH,KAAA0lB,KAAA,KAMA,QAAAM,GAAA/C,EAAAjc,EAAA4b,GAEA,GAAAJ,GAAAxb,EAAAjJ,OACAkoB,EAAAtD,EAAAC,EAAAJ,EAEAS,GAAAuC,WAAAxlB,KAAAmjB,KAAA8C,EAEA,QAAA9mB,GAAA,EAAkBA,IAAAqjB,IAASrjB,EAE3ByjB,EAAA6B,aAAAzd,EAAA7H,IAAAulB,GAAAuB,EAAA9mB,IAMA,QAAA+mB,GAAAjD,EAAAjc,EAAA4b,GAEA,GAAAJ,GAAAxb,EAAAjJ,OACAkoB,EAAAtD,EAAAC,EAAAJ,EAEAS,GAAAuC,WAAAxlB,KAAAmjB,KAAA8C,EAEA,QAAA9mB,GAAA,EAAkBA,IAAAqjB,IAASrjB,EAE3ByjB,EAAAgC,eAAA5d,EAAA7H,IAAA0lB,GAAAoB,EAAA9mB,IAQA,QAAAgnB,GAAAvoB,GAEA,OAAAA,GAEA,gBAAAynB,EACA,kBAAAI,EACA,kBAAAE,EACA,kBAAAC,EAEA,kBAAAC,EACA,kBAAAC,EACA,kBAAAC,EAEA,kBAAAC,EACA,kBAAAE,EAEA,4BAAAX,EACA,6BAAAT,EACA,6BAAAE,EACA,6BAAAE,IAQA,QAAAkB,GAAA1X,EAAA2X,EAAAlD,GAEAnjB,KAAA0O,KACA1O,KAAAmjB,OACAnjB,KAAAsmB,SAAAlB,EAAAiB,EAAAzoB,MAMA,QAAA2oB,GAAA7X,EAAA2X,EAAAlD,GAEAnjB,KAAA0O,KACA1O,KAAAmjB,OACAnjB,KAAA0lB,KAAAW,EAAAX,KACA1lB,KAAAsmB,SAAAH,EAAAE,EAAAzoB,MAMA,QAAA4oB,GAAA9X,GAEA1O,KAAA0O,KAEAuT,EAAAliB,KAAAC,MAmCA,QAAAymB,GAAA5V,EAAA6V,GAEA7V,EAAAqR,IAAA7gB,KAAAqlB,GACA7V,EAAAsR,IAAAuE,EAAAhY,IAAAgY,EAIA,QAAAC,GAAAN,EAAAlD,EAAAtS,GAEA,GAAAhG,GAAAwb,EAAAvoB,KACA8oB,EAAA/b,EAAA9M,MAKA,KAFA8oB,GAAAC,UAAA,IAEW,CAEX,GAAAhhB,GAAA+gB,GAAA3W,KAAArF,GACAkc,EAAAF,GAAAC,UAEApY,EAAA5I,EAAA,GACAkhB,EAAA,MAAAlhB,EAAA,GACAmhB,EAAAnhB,EAAA,EAIA,IAFAkhB,IAAAtY,GAAA,GAEAjG,SAAAwe,GAAA,MAAAA,GAAAF,EAAA,IAAAH,EAAA,CAIAH,EAAA5V,EAAApI,SAAAwe,EACA,GAAAb,GAAA1X,EAAA2X,EAAAlD,GACA,GAAAoD,GAAA7X,EAAA2X,EAAAlD,GAEA,OAMA,GAAAhB,GAAAtR,EAAAsR,IAAA+E,EAAA/E,EAAAzT,EAEAjG,UAAAye,IAEAA,EAAA,GAAAV,GAAA9X,GACA+X,EAAA5V,EAAAqW,IAIArW,EAAAqW,GAUA,QAAAC,GAAAlE,EAAAmE,EAAAxE,GAEAX,EAAAliB,KAAAC,MAEAA,KAAA4iB,UAIA,QAFAJ,GAAAS,EAAAoE,oBAAAD,EAAAnE,EAAAqE,iBAEAnoB,EAAA,EAAkBA,EAAAqjB,IAAOrjB,EAAA,CAEzB,GAAAooB,GAAAtE,EAAAuE,iBAAAJ,EAAAjoB,GACA0L,EAAA0c,EAAAzpB,KACAqlB,EAAAF,EAAAwE,mBAAAL,EAAAvc,EAEA8b,GAAAY,EAAApE,EAAAnjB,OAuFA,QAAA0nB,GAAApgB,EAAAC,EAAA/B,GAEA,MAAAiD,UAAAlB,GAAAkB,SAAAjD,EAGAxF,KAAAwU,IAAAlN,GAIAtH,KAAA2nB,OAAArgB,EAAAC,EAAA/B,GAoxCA,QAAAoiB,GAAAC,EAAA5I,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,GAEAP,EAAAhf,KAAAC,KAAA6nB,EAAA5I,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,GAEAtf,KAAA8nB,aAAA,EAYA,QAAAC,GAAAnF,EAAAK,EAAA9X,EAAA6c,EAAAC,GAaA,QAAAC,KAEA,GAAA5c,GAAA,GAAA8F,gBACA,WACA,WACA,WACA,YAGA+W,EAAA,GAAAC,cACA,MACA,OAGAC,GAAApF,EAAAqF,eACAC,EAAAtF,EAAAqF,eAEArF,EAAAuF,WAAAvF,EAAAwF,aAAAJ,GACApF,EAAAyF,WAAAzF,EAAAwF,aAAAnd,EAAA2X,EAAA0F,aAEA1F,EAAAuF,WAAAvF,EAAA2F,qBAAAL,GACAtF,EAAAyF,WAAAzF,EAAA2F,qBAAAT,EAAAlF,EAAA0F,aAEAvB,EAAAyB,IAEAC,GACAnO,SAAAsI,EAAA8F,kBAAA3B,EAAA,YACA4B,GAAA/F,EAAA8F,kBAAA3B,EAAA,OAGA6B,GACAC,SAAAjG,EAAAwE,mBAAAL,EAAA,YACA+B,QAAAlG,EAAAwE,mBAAAL,EAAA,WAEA/G,SAAA4C,EAAAwE,mBAAAL,EAAA,YACAzJ,OAAAsF,EAAAwE,mBAAAL,EAAA,UACAzT,MAAAsP,EAAAwE,mBAAAL,EAAA,SAEAvhB,MAAAod,EAAAwE,mBAAAL,EAAA,SACAjF,IAAAc,EAAAwE,mBAAAL,EAAA,OACAgC,QAAAnG,EAAAwE,mBAAAL,EAAA,WAEAiC,gBAAApG,EAAAwE,mBAAAL,EAAA,mBACAkC,iBAAArG,EAAAwE,mBAAAL,EAAA;AAEAmC,QAAAtG,EAAAwE,mBAAAL,EAAA,WACAoC,WAAAvG,EAAAwE,mBAAAL,EAAA,cACAqC,QAAAxG,EAAAwE,mBAAAL,EAAA,WACAsC,OAAAzG,EAAAwE,mBAAAL,EAAA,UACAuC,SAAA1G,EAAAwE,mBAAAL,EAAA,YACAwC,SAAA3G,EAAAwE,mBAAAL,EAAA,YAEAyC,UAAA5G,EAAAwE,mBAAAL,EAAA,aAGA,IAAAS,GAAAzS,SAAA0U,gBAAA,wCACAjC,GAAA9G,MAAA,EACA8G,EAAA7G,OAAA,CAEA,IAAA+I,GAAAlC,EAAAmC,WAAA,KACAD,GAAAE,UAAA,QACAF,EAAAG,SAAA,SAEA9I,EAAA,GAAAwG,GAAAC,GAsKA,QAAAgB,KAEA,GAAAzB,GAAAnE,EAAA4F,gBAEAsB,EAAAlH,EAAAmH,aAAAnH,EAAAoH,eACAC,EAAArH,EAAAmH,aAAAnH,EAAAsH,gBAyGA,OAvGAtH,GAAAuH,aAAAL,GAEA,aAAAlC,EAAAwC,UAAA,UAEA,qCAEA,gCACA,iCACA,0BACA,uBACA,sBACA,yBACA,wBAEA,2BACA,qBAEA,oBACA,0BAEA,gBAEA,mCAEA,0DAEA,0BACA,mGACA,mGAEA,qBAEA,+DACA,sCAEA,iDAEA,+BAEA,KAEA3lB,KAAA,OAEAme,EAAAuH,aAAAF,GAEA,aAAArC,EAAAwC,UAAA,UAEA,qCAEA,sBACA,yBACA,yBAEA,uBACA,yBACA,4BACA,yBACA,wBACA,2BAEA,oBACA,0BAEA,gBAEA,0CAEA,qEAEA,+CAEA,yBAEA,6BAEA,4BAEA,6DAEA,eAEA,qCACA,oFACA,wDAEA,QAEA,uEAEA,MAEA,KAEA3lB,KAAA,OAEAme,EAAAyH,cAAAP,GACAlH,EAAAyH,cAAAJ,GAEArH,EAAA0H,aAAAvD,EAAA+C,GACAlH,EAAA0H,aAAAvD,EAAAkD,GAEArH,EAAA2H,YAAAxD,GAEAA,EAIA,QAAAyD,GAAApd,EAAAjI,GAEA,MAAAiI,GAAAqd,cAAAtlB,EAAAslB,YAEArd,EAAAqd,YAAAtlB,EAAAslB,YAEIrd,EAAA+Q,IAAAhZ,EAAAgZ,EAEJhZ,EAAAgZ,EAAA/Q,EAAA+Q,EAIAhZ,EAAAkJ,GAAAjB,EAAAiB,GA9WA,GAAA2Z,GAAAE,EACAnB,EAAA0B,EAAAG,EAEA7H,EAIA2J,EAAA,GAAAnR,GACAoR,EAAA,GAAA5P,GACA6P,EAAA,GAAArR,EAqEA5Z,MAAAkrB,OAAA,SAAAC,EAAAC,EAAAC,GAEA,OAAAF,EAAAptB,OAAA,CAIA0K,SAAA2e,GAEAc,IAIA/c,EAAAmgB,WAAAlE,GAEAjc,EAAAogB,iBACApgB,EAAAqgB,gBAAA1C,EAAAnO,UACAxP,EAAAqgB,gBAAA1C,EAAAE,IACA7d,EAAAsgB,0BAEAtgB,EAAAugB,QAAAzI,EAAA0I,WACAxgB,EAAAygB,OAAA3I,EAAA4I,OAEA5I,EAAAuF,WAAAvF,EAAAwF,aAAAJ,GACApF,EAAA6I,oBAAAhD,EAAAnO,SAAA,EAAAsI,EAAA8I,OAAA,QACA9I,EAAA6I,oBAAAhD,EAAAE,GAAA,EAAA/F,EAAA8I,OAAA,QAEA9I,EAAAuF,WAAAvF,EAAA2F,qBAAAL,GAEAtF,EAAAoB,iBAAA4E,EAAAK,kBAAA,EAAA+B,EAAA/B,iBAAAhL,UAEAnT,EAAA6gB,cAAA/I,EAAAgJ,UACAhJ,EAAAI,UAAA4F,EAAA9G,IAAA,EAEA,IAAA+J,GAAA,EACAC,EAAA,EACAC,EAAAhB,EAAAgB,GAEAA,IAEAnJ,EAAAS,UAAAuF,EAAAU,SAAAyC,EAAAvmB,MAAAyB,EAAA8kB,EAAAvmB,MAAA0B,EAAA6kB,EAAAvmB,MAAAL,GAEA4mB,EAAAC,OAEApJ,EAAAC,UAAA+F,EAAAQ,QAAA2C,EAAAE,MACArJ,EAAAC,UAAA+F,EAAAS,OAAA0C,EAAAG,KAEAtJ,EAAAI,UAAA4F,EAAAM,QAAA,GACA2C,EAAA,EACAC,EAAA,GAEKC,EAAAI,YAELvJ,EAAAC,UAAA+F,EAAAO,WAAA4C,EAAAK,SAEAxJ,EAAAI,UAAA4F,EAAAM,QAAA,GACA2C,EAAA,EACAC,EAAA,KAMAlJ,EAAAI,UAAA4F,EAAAM,QAAA,GACA2C,EAAA,EACAC,EAAA,EAOA,QAAAhtB,GAAA,EAAAgQ,EAAAgc,EAAAptB,OAAuCoB,EAAAgQ,EAAOhQ,IAAA,CAE9C,GAAAutB,GAAAvB,EAAAhsB,EAEAutB,GAAArD,gBAAAsD,iBAAAtB,EAAAuB,mBAAAF,EAAAG,aACAH,EAAAlO,GAAAkO,EAAArD,gBAAA/K,SAAA,IAIA6M,EAAA2B,KAAAjC,EAOA,QAHAlX,MACAgK,KAEAxe,EAAA,EAAAgQ,EAAAgc,EAAAptB,OAAuCoB,EAAAgQ,EAAOhQ,IAAA,CAE9C,GAAAutB,GAAAvB,EAAAhsB,GACAqN,EAAAkgB,EAAAlgB,QAEA,IAAAA,EAAAugB,WAAA,GAEAL,EAAAM,eAAApK,EAAAwI,EAAAC,EAAA5iB,OAAA+D,EAAA/D,QAEAwa,EAAAC,UAAA+F,EAAAY,UAAArd,EAAAqd,WACA5G,EAAAoB,iBAAA4E,EAAAI,iBAAA,EAAAqD,EAAArD,gBAAA/K,UAEAoO,EAAAG,YAAAI,UAAAlC,EAAAC,EAAAC,GAEAtX,EAAA,GAAAsX,EAAA3V,EACA3B,EAAA,GAAAsX,EAAAxV,EAEAkI,EAAA,GAAA+O,EAAA/O,OAAArI,EAAA,GACAqI,EAAA,GAAA+O,EAAA/O,OAAAlI,EAAA,EAEA,IAAA8T,GAAA,CAEA6B,GAAAgB,KAAA5f,EAAA4f,MAEA7C,EAAA4C,GAIAD,IAAA3C,IAEAtG,EAAAI,UAAA4F,EAAAM,WACA2C,EAAA3C,GAIA,OAAA/c,EAAA2V,KAEAc,EAAAO,UAAAyF,EAAAC,SAAA1c,EAAA2V,IAAAjH,OAAA5F,EAAA9I,EAAA2V,IAAAjH,OAAAzF,GACAwN,EAAAO,UAAAyF,EAAAE,QAAA3c,EAAA2V,IAAA/B,OAAA9K,EAAA9I,EAAA2V,IAAA/B,OAAA3K,KAIAwN,EAAAO,UAAAyF,EAAAC,SAAA,KACAjG,EAAAO,UAAAyF,EAAAE,QAAA,MAIAlG,EAAAC,UAAA+F,EAAAG,QAAA5c,EAAA4c,SACAnG,EAAAS,UAAAuF,EAAApjB,MAAA2G,EAAA3G,MAAAyB,EAAAkF,EAAA3G,MAAA0B,EAAAiF,EAAA3G,MAAAL,GAEAyd,EAAAC,UAAA+F,EAAA5I,SAAA7T,EAAA6T,UACA4C,EAAAM,WAAA0F,EAAAtL,UACAsF,EAAAM,WAAA0F,EAAAtV,SAEAxI,EAAA+hB,YAAA1gB,EAAA2gB,SAAA3gB,EAAA4gB,cAAA5gB,EAAA6gB,SAAA7gB,EAAA8gB,SAAA9gB,EAAA+gB,mBAAA/gB,EAAAghB,cAAAhhB,EAAAihB,cAAAjhB,EAAAkhB,oBACAviB,EAAAwiB,QAAAC,MAAAC,QAAArhB,EAAAshB,WACA3iB,EAAAwiB,QAAAC,MAAAG,QAAAvhB,EAAAwhB,YACA7iB,EAAAwiB,QAAA9nB,MAAAkoB,QAAAvhB,EAAAyhB,YAEAjG,EAAAvD,aAAAjY,EAAA2V,KAAAf,EAAA,GAEA6B,EAAAiL,aAAAjL,EAAAkL,UAAA,EAAAlL,EAAAmL,eAAA,GAEA1B,EAAA2B,cAAAzL,EAAAwI,EAAAC,EAAA5iB,OAAA+D,EAAA/D,SAMA0C,EAAAygB,OAAA3I,EAAA0I,WAEAxgB,EAAA6P,UAiJA,QAAAsT,KAEAhwB,OAAAD,eAAA2B,KAAA,MAAsCgL,MAAAujB,OAEtCvuB,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAAlC,KAAA,GACAkC,KAAApC,KAAA,WAEAoC,KAAAosB,KAAA,EACApsB,KAAAwuB,QAAA,EAEAxuB,KAAAmtB,SAAAsB,GACAzuB,KAAA0uB,KAAAC,GACA3uB,KAAA4uB,aAAA,EACA5uB,KAAA6uB,aAAAC,GAEA9uB,KAAAopB,QAAA,EACAppB,KAAA+uB,aAAA,EAEA/uB,KAAAqtB,SAAA2B,GACAhvB,KAAAstB,SAAA2B,GACAjvB,KAAAotB,cAAA8B,GACAlvB,KAAAwtB,cAAA,KACAxtB,KAAAytB,cAAA,KACAztB,KAAAutB,mBAAA,KAEAvtB,KAAAmvB,UAAAC,GACApvB,KAAA8tB,WAAA,EACA9tB,KAAAguB,YAAA,EAEAhuB,KAAAqvB,eAAA,KACArvB,KAAAsvB,kBAAA,EACAtvB,KAAAuvB,aAAA,EAEAvvB,KAAAwvB,WAAA,KAEAxvB,KAAAiuB,YAAA,EAEAjuB,KAAAyqB,UAAA,KAEAzqB,KAAAyvB,eAAA,EACAzvB,KAAA0vB,oBAAA,EACA1vB,KAAA2vB,mBAAA,EAEA3vB,KAAA4vB,WAAA,EAEA5vB,KAAA6pB,UAAA,EACA7pB,KAAA0tB,oBAAA,EAEA1tB,KAAA6vB,SAAA,EAEA7vB,KAAA+sB,SAAA,EAEA/sB,KAAA8vB,YAEA9vB,KAAA8nB,aAAA,EAqUA,QAAAiI,GAAAC,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAAiwB,aAAAC,GAEAlwB,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EAEApwB,KAAAmiB,IAAA,KAEAniB,KAAAqwB,SAAA,KAEArwB,KAAAswB,gBAAA,KACAtwB,KAAAuwB,kBAAA,EACAvwB,KAAAwwB,iBAAA,EAEAxwB,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EAEA1wB,KAAAosB,KAAA,EACApsB,KAAAwuB,QAAA,EAEAxuB,KAAA2wB,UAAAX,GAwDA,QAAAY,GAAAZ,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,uBAEAoC,KAAA6wB,kBAAA,GAAAjX,GACA5Z,KAAA8wB,aAAA,EACA9wB,KAAA+wB,YAAA,IAEA/wB,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EAEApwB,KAAAmiB,IAAA,KAEAniB,KAAAqwB,SAAA,KAEArwB,KAAAswB,gBAAA,KACAtwB,KAAAuwB,kBAAA,EACAvwB,KAAAwwB,iBAAA,EAEAxwB,KAAAosB,KAAA,EACApsB,KAAAwuB,QAAA,EAEAxuB,KAAA2wB,UAAAX,GAqCA,QAAAgB,GAAA3qB,EAAAD,GAEApG,KAAAqG,IAAAoC,SAAApC,IAAA,GAAAuT,KAAAG,oBACA/Z,KAAAoG,IAAAqC,SAAArC,IAAA,GAAAwT,KAAAG,oBAokBA,QAAAkX,IAAAtT,EAAA5B,GAEA/b,KAAA2d,OAAAlV,SAAAkV,IAAA,GAAA/D,GACA5Z,KAAA+b,OAAAtT,SAAAsT,IAAA,EAiKA,QAAAmV,IAAAC,EAAAC,GAIApxB,KAAAmxB,OAAA1oB,SAAA0oB,IAAA,GAAAvX,GAAA,OACA5Z,KAAAoxB,SAAA3oB,SAAA2oB,IAAA,EA8NA,QAAAC,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA3xB,KAAA4xB,QAEAnpB,SAAA6oB,IAAA,GAAAJ,IACAzoB,SAAA8oB,IAAA,GAAAL,IACAzoB,SAAA+oB,IAAA,GAAAN,IACAzoB,SAAAgpB,IAAA,GAAAP,IACAzoB,SAAAipB,IAAA,GAAAR,IACAzoB,SAAAkpB,IAAA,GAAAT,KAyLA,QAAAW,IAAAC,EAAAC,EAAAC,GAuPA,QAAAC,GAAA5mB,EAAAmB,EAAA0lB,EAAAC,EAAAC,EAAAC,GAEA,GAAAtmB,GAAAV,EAAAU,SAEAvE,EAAA,KAEA8qB,EAAAC,EACAC,EAAAnnB,EAAAonB,mBASA,IAPAP,IAEAI,EAAAI,EACAF,EAAAnnB,EAAAsnB,wBAIAH,EAmCAhrB,EAAAgrB,MAnCA,CAEA,GAAAI,IAAA,CAEApmB,GAAA4jB,eAEArkB,KAAA8mB,iBAEAD,EAAA7mB,EAAA+mB,iBAAA/mB,EAAA+mB,gBAAAnY,UAAA5O,EAAA+mB,gBAAAnY,SAAA5c,OAAA,EAEMgO,KAAAgnB,aAENH,EAAA7mB,EAAAqkB,cAAArkB,EAAAqkB,aAAAryB,OAAA,IAMAsN,EAAA2nB,eAAAxmB,EAAA2jB,YAAA,GAEA7gB,QAAA4E,KAAA,+EAAA7I,EAIA,IAAA4nB,GAAA5nB,EAAA2nB,eAAAxmB,EAAA2jB,SAEA+C,EAAA,CAEAN,KAAAM,GAAAC,GACAF,IAAAC,GAAAE,GAEA5rB,EAAA8qB,EAAAY,GAQA,GAAApB,EAAAuB,sBACA7mB,EAAA+iB,eAAA,GACA,IAAA/iB,EAAA6iB,eAAAtxB,OAAA,CAKA,GAAAu1B,GAAA9rB,EAAAiY,KAAA8T,EAAA/mB,EAAAiT,KAEA+T,EAAAC,EAAAH,EAEA7qB,UAAA+qB,IAEAA,KACAC,EAAAH,GAAAE,EAIA,IAAAE,GAAAF,EAAAD,EAEA9qB,UAAAirB,IAEAA,EAAAlsB,EAAAqF,QACA2mB,EAAAD,GAAAG,GAIAlsB,EAAAksB,EAwBA,MApBAlsB,GAAAulB,QAAAvgB,EAAAugB,QACAvlB,EAAAipB,UAAAjkB,EAAAikB,UAEAjpB,EAAAknB,KAAA,MAAAliB,EAAAgjB,WAAAhjB,EAAAgjB,aAAAhjB,EAAAkiB,MAEAlnB,EAAA+nB,YAAA/iB,EAAA+iB,YACA/nB,EAAA6nB,eAAA7iB,EAAA6iB,eACA7nB,EAAA8nB,iBAAA9iB,EAAA8iB,iBAEA9nB,EAAAkpB,mBAAAlkB,EAAAkkB,mBACAlpB,EAAAmsB,UAAAnnB,EAAAmnB,UAEAzB,GAAA1qB,EAAAosB,yBAEApsB,EAAAqpB,kBAAAjf,KAAAugB,GACA3qB,EAAAspB,aAAAsB,EACA5qB,EAAAupB,YAAAsB,GAIA7qB,EAIA,QAAAqsB,GAAAxoB,EAAAggB,EAAAyI,EAAA5B,GAEA,GAAA7mB,EAAA0hB,WAAA,GAEA,GAAAA,GAAA1hB,EAAA0oB,OAAApjB,KAAA0a,EAAA0I,OAEA,IAAAhH,IAAA1hB,EAAA2oB,QAAA3oB,EAAA0F,QAAA1F,EAAA4oB,WAEA5oB,EAAA6oB,cAAA7oB,EAAA8oB,eAAAC,EAAAC,iBAAAhpB,IAAA,CAEAA,EAAAge,gBAAAsD,iBAAAmH,EAAAlH,mBAAAvhB,EAAAwhB,YAEA,IAAA9gB,GAAAgmB,EAAApc,OAAAtK,GACAmB,EAAAnB,EAAAmB,QAEA,IAAApL,MAAAsL,QAAAF,GAIA,OAFA8nB,GAAAvoB,EAAAuoB,OAEArsB,EAAA,EAAAssB,EAAAD,EAAAv2B,OAA0CkK,EAAAssB,EAAQtsB,IAAA,CAElD,GAAAusB,GAAAF,EAAArsB,GACAwsB,EAAAjoB,EAAAgoB,EAAAE,cAEA,IAAAD,KAAA1H,QAAA,CAEA,GAAA4H,GAAA1C,EAAA5mB,EAAAopB,EAAAvC,EAAA0C,EAAAd,EAAAxH,KAAAwH,EAAAvH,IACAuF,GAAA+C,mBAAAf,EAAA,KAAA/nB,EAAA4oB,EAAAtpB,EAAAmpB,QAMM,IAAAhoB,EAAAugB,QAAA,CAEN,GAAA4H,GAAA1C,EAAA5mB,EAAAmB,EAAA0lB,EAAA0C,EAAAd,EAAAxH,KAAAwH,EAAAvH,IACAuF,GAAA+C,mBAAAf,EAAA,KAAA/nB,EAAA4oB,EAAAtpB,EAAA,OAUA,OAFAypB,GAAAzpB,EAAAypB,SAEA31B,EAAA,EAAAgQ,EAAA2lB,EAAA/2B,OAAwCoB,EAAAgQ,EAAOhQ,IAE/C00B,EAAAiB,EAAA31B,GAAAksB,EAAAyI,EAAA5B,IA7WA,OAtCAkC,GAAA,GAAA/C,IACA0D,EAAA,GAAA1W,GAEA2W,EAAA,GAAAtY,GACAuY,EAAA,GAAAvY,GAAAsV,KAEAkD,EAAA,GAAAtb,GACAgb,EAAA,GAAAhb,GAEAuZ,EAAA,EACAC,EAAA,EAEA+B,GAAAhC,EAAAC,GAAA,EAEAb,EAAA,GAAAnxB,OAAA+zB,GACAzC,EAAA,GAAAtxB,OAAA+zB,GAEA1B,KAEAjE,GAAoB4F,EAAAC,GAAAC,EAAA3G,GAAA4G,EAAAC,IAEpBC,GACA,GAAA7b,GAAA,UAAAA,IAAA,UAAAA,GAAA,OACA,GAAAA,GAAA,WAAAA,GAAA,UAAAA,GAAA,SAGA8b,GACA,GAAA9b,GAAA,UAAAA,GAAA,UAAAA,GAAA,OACA,GAAAA,GAAA,UAAAA,GAAA,UAAAA,GAAA,SAGA+b,GACA,GAAA9U,GAAA,GAAAA,GAAA,GAAAA,GACA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,IAKA1hB,EAAA,EAAkBA,IAAAg2B,IAAiCh2B,EAAA,CAEnD,GAAAyzB,GAAA,KAAAzzB,EAAAg0B,GACAF,EAAA,KAAA9zB,EAAAi0B,GAEAuB,EAAA,GAAA5E,IAEAE,aAAA2F,GAEAxF,aAAAwC,EACAzC,SAAA8C,GAIAV,GAAApzB,GAAAw1B,CAIA,IAAAkB,GAAA,GAAAjF,IAEAR,aAAAwC,EACAzC,SAAA8C,GAIAP,GAAAvzB,GAAA02B,EAMA,GAAAprB,GAAAzK,IAEAA,MAAA4X,SAAA,EAEA5X,KAAA81B,YAAA,EACA91B,KAAA8nB,aAAA,EAEA9nB,KAAApC,KAAAm4B,GAEA/1B,KAAAkrB,OAAA,SAAAsD,EAAApD,EAAAC,GAEA,GAAA5gB,EAAAmN,WAAA,IACAnN,EAAAqrB,cAAA,GAAArrB,EAAAqd,eAAA,IAEA,IAAA0G,EAAAzwB,OAAA,CAGA,GAAAi4B,GAAAlE,EAAA/H,QACAkM,EAAAnE,EAAA3mB,KAGA8qB,GAAAvK,QAAAsK,EAAAnK,OACAoK,EAAAtI,QAAA9nB,MAAAqwB,SAAA,SACAD,EAAAtI,QAAAC,MAAAC,SAAA,GACAoI,EAAAE,gBAAA,EAMA,QAFAC,GAEAj3B,EAAA,EAAAk3B,EAAA7H,EAAAzwB,OAAuCoB,EAAAk3B,EAAQl3B,IAAA,CAE/C,GAAAm3B,GAAA9H,EAAArvB,GACAo3B,EAAAD,EAAAC,OACArE,EAAAoE,KAAApE,YAEA,IAAAzpB,SAAA8tB,EAAA,CAOA,GAAAzC,GAAAyC,EAAAlL,MAKA,IAHA2J,EAAApjB,KAAA2kB,EAAAC,SACAxB,EAAA3uB,IAAA4uB,GAEA/C,EAAA,CAEA,GAAAuE,GAAAzB,EAAA1f,EACAohB,EAAA1B,EAAAvf,CAgBAkgB,GAAA,GAAAnhB,IAAA,EAAAiiB,EAAAC,EAAAD,EAAAC,GAEAf,EAAA,GAAAnhB,IAAA,EAAAkiB,EAAAD,EAAAC,GAEAf,EAAA,GAAAnhB,IAAA,EAAAiiB,EAAAC,EAAAD,EAAAC,GAEAf,EAAA,GAAAnhB,IAAAiiB,EAAAC,EAAAD,EAAAC,GAEAf,EAAA,GAAAnhB,IAAA,EAAAiiB,EAAA,EAAAA,EAAAC,GAEAf,EAAA,GAAAnhB,IAAAiiB,EAAA,EAAAA,EAAAC,GAEA1B,EAAA1f,GAAA,EACA0f,EAAAvf,GAAA,EAIA,UAAA8gB,EAAApU,IAAA,CAEA,GAAAwU,IAAiBtX,UAAAwC,GAAAzC,UAAAyC,GAAAxd,OAAA6b,GAEjBqW,GAAApU,IAAA,GAAArB,GAAAkU,EAAA1f,EAAA0f,EAAAvf,EAAAkhB,GACAJ,EAAApU,IAAAf,QAAAtjB,KAAAw4B,EAAAx4B,KAAA,aAEAg2B,EAAA9f,yBAIAuiB,EAAAK,mBAEAL,EAAA5gB,OAAA2gB,EAIA,IAAAO,GAAAN,EAAApU,IACA2U,EAAAP,EAAAnZ,MAEAwX,GAAAmC,sBAAAT,EAAAzJ,aACAiH,EAAAnZ,SAAA/I,KAAAgjB,GAEA1C,GAEAkE,EAAA,EAKAU,EAAAE,iBAAApC,EAAAtf,GAAAsf,EAAAnf,GAAAmf,EAAApW,KAIA4X,EAAA,EAEAlB,EAAA6B,sBAAAT,EAAA3c,OAAAkT,aACAiH,EAAA5X,OAAAgZ,GACApB,EAAAmD,oBAIAH,EAAAtiB,IACA,UACA,UACA,UACA,SAGAsiB,EAAAI,SAAApD,EAAAxK,kBACAwN,EAAAI,SAAApD,EAAAlH,qBAIAkF,EAAAqF,gBAAAN,GACA/E,EAAAsF,OAKA,QAAAC,GAAA,EAAuBA,EAAAjB,EAAkBiB,IAAA,CAEzC,GAAAnF,EAAA,CAEAgD,EAAAtjB,KAAAkiB,EAAAnZ,UACAua,EAAA3iB,IAAAkjB,EAAA4B,IACAvD,EAAAxY,GAAA1J,KAAA8jB,EAAA2B,IACAvD,EAAA5X,OAAAgZ,GACApB,EAAAmD,mBAEA,IAAAK,GAAA3B,EAAA0B,EACApB,GAAA9U,SAAAmW,GAMAvC,EAAApI,iBAAAmH,EAAAxK,iBAAAwK,EAAAlH,oBACAwH,EAAAmD,cAAAxC,GAIAlB,EAAAzI,EAAAC,EAAAyI,EAAA5B,QAhIA5iB,SAAA4E,KAAA,wBAAAoiB,EAAA,kBAsIA7rB,EAAAqd,aAAA,IA8KA,QAAA0P,IAAAvU,GAIA,QAAAqF,GAAAmP,EAAAC,GAEA,GAAA32B,GAAA02B,EAAA12B,MACA42B,EAAAF,EAAAG,QAAA3U,EAAA4U,aAAA5U,EAAA0F,YAEAmP,EAAA7U,EAAAqF,cAEArF,GAAAuF,WAAAkP,EAAAI,GACA7U,EAAAyF,WAAAgP,EAAA32B,EAAA42B,GAEAF,EAAAM,kBAEA,IAAAn6B,GAAAqlB,EAAA8I,KAoCA,OAlCAhrB,aAAAqQ,cAEAxT,EAAAqlB,EAAA8I,MAEIhrB,YAAAi3B,cAEJ1oB,QAAA4E,KAAA,wEAEInT,YAAAqnB,aAEJxqB,EAAAqlB,EAAAmL,eAEIrtB,YAAAk3B,YAEJr6B,EAAAqlB,EAAAiV,MAEIn3B,YAAAo3B,aAEJv6B,EAAAqlB,EAAAmV,aAEIr3B,YAAA+hB,YAEJllB,EAAAqlB,EAAAoV,IAEIt3B,YAAAu3B,WAEJ16B,EAAAqlB,EAAAsV,KAEIx3B,YAAAy3B,cAEJ56B,EAAAqlB,EAAAwV,gBAKAX,SACAl6B,OACA86B,gBAAA33B,EAAA43B,kBACAh3B,QAAA81B,EAAA91B,SAKA,QAAAi3B,GAAAd,EAAAL,EAAAC,GAEA,GAAA32B,GAAA02B,EAAA12B,MACA83B,EAAApB,EAAAoB,WAEA5V,GAAAuF,WAAAkP,EAAAI,GAEAL,EAAAG,WAAA,EAEA3U,EAAAyF,WAAAgP,EAAA32B,EAAAkiB,EAAA0F,aAEIkQ,EAAAjwB,SAAA,EAIJqa,EAAA6V,cAAApB,EAAA,EAAA32B,GAEI,IAAA83B,EAAAjwB,MAEJ0G,QAAAiP,MAAA,4KAIA0E,EAAA6V,cAAApB,EAAAmB,EAAA3d,OAAAna,EAAA43B,kBACA53B,EAAAg4B,SAAAF,EAAA3d,OAAA2d,EAAA3d,OAAA2d,EAAAjwB,QAEAiwB,EAAAjwB,OAAA,GAQA,QAAAgV,GAAA6Z,GAIA,MAFAA,GAAAuB,+BAAAvB,IAAA7V,MAEA+L,EAAA8J,EAAAhY,MAIA,QAAAwZ,GAAAxB,GAEAA,EAAAuB,+BAAAvB,IAAA7V,KAEA,IAAAA,GAAA+L,EAAA8J,EAAAhY,KAEAmC,KAEAqB,EAAAiW,aAAAtX,EAAAkW,cAEAnK,GAAA8J,EAAAhY,OAMA,QAAA9J,GAAA8hB,EAAAC,GAEAD,EAAAuB,+BAAAvB,IAAA7V,KAEA,IAAAA,GAAA+L,EAAA8J,EAAAhY,KAEAhX,UAAAmZ,EAEA+L,EAAA8J,EAAAhY,MAAA6I,EAAAmP,EAAAC,GAEI9V,EAAAjgB,QAAA81B,EAAA91B,UAEJi3B,EAAAhX,EAAAkW,OAAAL,EAAAC,GAEA9V,EAAAjgB,QAAA81B,EAAA91B,SAnIA,GAAAgsB,KAyIA,QAEA/P,MACAqb,SACAtjB,UAYA,QAAAwjB,IAAA7jB,EAAAG,EAAA+I,EAAA4a,GAEAp5B,KAAA0e,GAAApJ,GAAA,EACAtV,KAAA2e,GAAAlJ,GAAA,EACAzV,KAAA4e,GAAAJ,GAAA,EACAxe,KAAAq5B,OAAAD,GAAAD,GAAAG,aAkVA,QAAAC,MAEAv5B,KAAAw5B,KAAA,EAgDA,QAAAC,MAmBA,QAAAC,KAEApd,EAAAqd,aAAAtZ,GAAA,GAIA,QAAAuZ,KAEAvZ,EAAAwZ,kBAAAvd,EAAA7T,QAAA,GAzBAnK,OAAAD,eAAA2B,KAAA,MAAsCgL,MAAA8uB,OAEtC95B,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAAlC,KAAA,GACAkC,KAAApC,KAAA,WAEAoC,KAAA+5B,OAAA,KACA/5B,KAAA80B,YAEA90B,KAAAsb,GAAAme,GAAAO,UAAAntB,OAEA,IAAA8N,GAAA,GAAAf,GACAyG,EAAA,GAAA8Y,IACA7c,EAAA,GAAAlB,GACAzH,EAAA,GAAAiG,GAAA,MAcAyG,GAAA4Z,SAAAP,GACApd,EAAA2d,SAAAL,GAEAt7B,OAAAof,iBAAA1d,MACA2a,UACAuf,YAAA,EACAlvB,MAAA2P,GAEA0F,UACA6Z,YAAA,EACAlvB,MAAAqV,GAEA/D,YACA4d,YAAA,EACAlvB,MAAAsR,GAEA3I,OACAumB,YAAA,EACAlvB,MAAA2I,GAEA0V,iBACAre,MAAA,GAAAqT,IAEA8b,cACAnvB,MAAA,GAAA8T,MAIA9e,KAAAod,OAAA,GAAAiB,GACAre,KAAA6sB,YAAA,GAAAxO,GAEAre,KAAAsgB,iBAAAmZ,GAAAW,wBACAp6B,KAAAq6B,wBAAA,EAEAr6B,KAAA+zB,OAAA,GAAAwF,IACAv5B,KAAA+sB,SAAA,EAEA/sB,KAAAk0B,YAAA,EACAl0B,KAAAs6B,eAAA,EAEAt6B,KAAAm0B,eAAA,EACAn0B,KAAA8qB,YAAA,EAEA9qB,KAAA8vB,YAquBA,QAAAyK,MAEAd,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,SAEAoC,KAAA4sB,mBAAA,GAAAvO,GACAre,KAAAspB,iBAAA,GAAAjL,GA0DA,QAAAzK,IAAA0J,EAAAD,EAAAE,EAAAC,EAAA8O,EAAAC,GAEAgO,GAAAx6B,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAA6T,KAAA,EACA7T,KAAAw6B,KAAA,KAEAx6B,KAAAsd,OACAtd,KAAAqd,QACArd,KAAAud,MACAvd,KAAAwd,SAEAxd,KAAAssB,KAAA7jB,SAAA6jB,IAAA,GACAtsB,KAAAusB,IAAA9jB,SAAA8jB,IAAA,IAEAvsB,KAAAgU,yBA2HA,QAAAymB,IAAAhtB,EAAAjI,EAAAgB,EAAA2qB,EAAAtrB,EAAA6uB,GAEA10B,KAAAyN,IACAzN,KAAAwF,IACAxF,KAAAwG,IAEAxG,KAAAmxB,YAAAuJ,UAAAvJ,EAAA,GAAAvX,GACA5Z,KAAA26B,cAAAv5B,MAAAsL,QAAAykB,QAEAnxB,KAAA6F,WAAA+0B,QAAA/0B,EAAA,GAAA6hB,GACA1nB,KAAA6uB,aAAAztB,MAAAsL,QAAA7G,QAEA7F,KAAA00B,cAAAjsB,SAAAisB,IAAA,EAoDA,QAAAmG,MAEAv8B,OAAAD,eAAA2B,KAAA,MAAsCgL,MAAA8vB,IAAA,IAEtC96B,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAAlC,KAAA,GACAkC,KAAApC,KAAA,WAEAoC,KAAAsL,YACAtL,KAAA8I,UACA9I,KAAAmoB,SACAnoB,KAAA+6B,mBAEA/6B,KAAAowB,gBACApwB,KAAAg7B,gBAEAh7B,KAAAi7B,eACAj7B,KAAAk7B,eAEAl7B,KAAAm7B,iBAEAn7B,KAAAo7B,YAAA,KACAp7B,KAAAq7B,eAAA,KAIAr7B,KAAAs7B,oBAAA,EACAt7B,KAAAu7B,oBAAA,EACAv7B,KAAAw7B,eAAA,EACAx7B,KAAAy7B,mBAAA,EACAz7B,KAAA07B,kBAAA,EACA17B,KAAA27B,yBAAA,EACA37B,KAAA47B,kBAAA,EAq2CA,QAAAzqB,IAAApQ,EAAA86B,EAAAC,GAEA,GAAA16B,MAAAsL,QAAA3L,GAEA,SAAA2H,WAAA,wDAIA1I,MAAAyf,KAAAC,GAAAC,eACA3f,KAAAlC,KAAA,GAEAkC,KAAAe,QACAf,KAAA67B,WACA77B,KAAA4I,MAAAH,SAAA1H,IAAAhD,OAAA89B,EAAA,EACA77B,KAAA87B,gBAAA,EAEA97B,KAAA43B,SAAA,EACA53B,KAAA64B,aAAsB3d,OAAA,EAAAtS,OAAA,GAEtB5I,KAAA+3B,iBAAA,aAEA/3B,KAAA2B,QAAA,EAyTA,QAAAo6B,IAAAh7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAs4B,WAAAv3B,GAAA86B,EAAAC,GAQA,QAAAE,IAAAj7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAw4B,YAAAz3B,GAAA86B,EAAAC,GAQA,QAAAG,IAAAl7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAk8B,mBAAAn7B,GAAA86B,EAAAC,GAQA,QAAAK,IAAAp7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAi4B,YAAAl3B,GAAA86B,EAAAC,GAQA,QAAAM,IAAAr7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAooB,aAAArnB,GAAA86B,EAAAC,GAQA,QAAAO,IAAAt7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAA8iB,YAAA/hB,GAAA86B,EAAAC,GAQA,QAAAQ,IAAAv7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAm4B,aAAAp3B,GAAA86B,EAAAC,GAQA,QAAAS,IAAAx7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAoR,cAAArQ,GAAA86B,EAAAC,GAQA,QAAAU,IAAAz7B,EAAA86B,EAAAC,GAEA3qB,GAAApR,KAAAC,KAAA,GAAAg4B,cAAAj3B,GAAA86B,EAAAC,GAWA,QAAAW,MAEAz8B,KAAA08B,WACA18B,KAAAsL,YACAtL,KAAAuL,WACAvL,KAAA8I,UACA9I,KAAAwL,OACAxL,KAAA28B,QAEA38B,KAAAs0B,UAEAt0B,KAAAowB,gBAEApwB,KAAAi7B,eACAj7B,KAAAk7B,eAIAl7B,KAAAo7B,YAAA,KACAp7B,KAAAq7B,eAAA,KAIAr7B,KAAAu7B,oBAAA,EACAv7B,KAAAy7B,mBAAA,EACAz7B,KAAA07B,kBAAA,EACA17B,KAAAw7B,eAAA,EACAx7B,KAAA47B,kBAAA,EAwOA,QAAAgB,IAAA77B,GAEA,OAAAA,EAAAhD,OAAA,QAAAgc,IAIA,QAFA3T,GAAArF,EAAA,GAEA5B,EAAA,EAAAgQ,EAAApO,EAAAhD,OAAoCoB,EAAAgQ,IAAOhQ,EAE3C4B,EAAA5B,GAAAiH,MAAArF,EAAA5B,GAIA,OAAAiH,GAWA,QAAA6K,MAEA3S,OAAAD,eAAA2B,KAAA,MAAsCgL,MAAA6xB,IAAA,IAEtC78B,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAAlC,KAAA,GACAkC,KAAApC,KAAA,iBAEAoC,KAAAuM,MAAA,KACAvM,KAAA8oB,cAEA9oB,KAAA8yB,mBAEA9yB,KAAAs0B,UAEAt0B,KAAAo7B,YAAA,KACAp7B,KAAAq7B,eAAA,KAEAr7B,KAAA88B,WAAoBC,MAAA,EAAAn0B,MAAAmR,KAkkCpB,QAAAijB,IAAAjc,EAAAC,EAAA4M,EAAAqP,EAAAC,EAAAC,GAEAtC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,cAEAoC,KAAAgwB,YACAjP,QACAC,SACA4M,QACAqP,gBACAC,iBACAC,iBAGAn9B,KAAAo9B,mBAAA,GAAAC,IAAAtc,EAAAC,EAAA4M,EAAAqP,EAAAC,EAAAC,IACAn9B,KAAAs9B,gBASA,QAAAD,IAAAtc,EAAAC,EAAA4M,EAAAqP,EAAAC,EAAAC,GAuDA,QAAAI,GAAAC,EAAAx2B,EAAAyX,EAAAgf,EAAAC,EAAA3c,EAAAC,EAAA4M,EAAA+P,EAAAC,EAAAlJ,GAEA,GAaAmJ,GAAAC,EAbAC,EAAAhd,EAAA4c,EACAK,EAAAhd,EAAA4c,EAEAK,EAAAld,EAAA,EACAmd,EAAAld,EAAA,EACAmd,EAAAvQ,EAAA,EAEAwQ,EAAAT,EAAA,EACAU,EAAAT,EAAA,EAEAU,EAAA,EACAjyB,EAAA,EAIAkyB,EAAA,GAAA3kB,EAIA,KAAAkkB,EAAA,EAAgBA,EAAAO,EAAaP,IAAA,CAE7B,GAAAroB,GAAAqoB,EAAAE,EAAAE,CAEA,KAAAL,EAAA,EAAiBA,EAAAO,EAAaP,IAAA,CAE9B,GAAAvoB,GAAAuoB,EAAAE,EAAAE,CAIAM,GAAAf,GAAAloB,EAAAmoB,EACAc,EAAAv3B,GAAAyO,EAAAioB,EACAa,EAAA9f,GAAA0f,EAIA7yB,EAAAjK,KAAAk9B,EAAAjpB,EAAAipB,EAAA9oB,EAAA8oB,EAAA/f,GAIA+f,EAAAf,GAAA,EACAe,EAAAv3B,GAAA,EACAu3B,EAAA9f,GAAAmP,EAAA,OAIAriB,EAAAlK,KAAAk9B,EAAAjpB,EAAAipB,EAAA9oB,EAAA8oB,EAAA/f,GAIAhT,EAAAnK,KAAAw8B,EAAAF,GACAnyB,EAAAnK,KAAA,EAAAy8B,EAAAF,GAIAU,GAAA,GAYA,IAAAR,EAAA,EAAgBA,EAAAF,EAAYE,IAE5B,IAAAD,EAAA,EAAiBA,EAAAF,EAAYE,IAAA,CAE7B,GAAApwB,GAAA+wB,EAAAX,EAAAO,EAAAN,EACAt4B,EAAAg5B,EAAAX,EAAAO,GAAAN,EAAA,GACAt3B,EAAAg4B,GAAAX,EAAA,GAAAO,GAAAN,EAAA,GACA7vB,EAAAuwB,GAAAX,EAAA,GAAAO,EAAAN,CAIApB,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAIA5B,GAAA,EAQA5B,EAAAyH,SAAAvF,EAAAN,EAAAqoB,GAIA/nB,GAAAN,EAIAmyB,GAAAF,EAzJArtB,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAAgwB,YACAjP,QACAC,SACA4M,QACAqP,gBACAC,iBACAC,gBAGA,IAAA1yB,GAAAzK,IAEA+gB,MAAA,EACAC,KAAA,EACA4M,KAAA,EAIAqP,EAAAv4B,KAAAyB,MAAA82B,IAAA,EACAC,EAAAx4B,KAAAyB,MAAA+2B,IAAA,EACAC,EAAAz4B,KAAAyB,MAAAg3B,IAAA,CAIA,IAAAT,MACApxB,KACAC,KACAC,KAIAgzB,EAAA,EACA7xB,EAAA,CAIA4wB,GAAA,kBAAA3P,EAAA5M,EAAAD,EAAAoc,EAAAD,EAAA,GACAK,EAAA,iBAAA3P,EAAA5M,GAAAD,EAAAoc,EAAAD,EAAA,GACAK,EAAA,gBAAAxc,EAAA6M,EAAA5M,EAAAic,EAAAE,EAAA,GACAI,EAAA,iBAAAxc,EAAA6M,GAAA5M,EAAAic,EAAAE,EAAA,GACAI,EAAA,iBAAAxc,EAAAC,EAAA4M,EAAAqP,EAAAC,EAAA,GACAK,EAAA,kBAAAxc,EAAAC,GAAA4M,EAAAqP,EAAAC,EAAA,GAIAl9B,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IAsHA,QAAAkzB,IAAA3d,EAAAC,EAAAic,EAAAC,GAEArC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,gBAEAoC,KAAAgwB,YACAjP,QACAC,SACAic,gBACAC,kBAGAl9B,KAAAo9B,mBAAA,GAAAuB,IAAA5d,EAAAC,EAAAic,EAAAC,IACAl9B,KAAAs9B,gBASA,QAAAqB,IAAA5d,EAAAC,EAAAic,EAAAC,GAEAjsB,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAAgwB,YACAjP,QACAC,SACAic,gBACAC,kBAGAnc,KAAA,EACAC,KAAA,CAEA,IAYA6c,GAAAC,EAZAc,EAAA7d,EAAA,EACA8d,EAAA7d,EAAA,EAEA2c,EAAAj5B,KAAAyB,MAAA82B,IAAA,EACAW,EAAAl5B,KAAAyB,MAAA+2B,IAAA,EAEAkB,EAAAT,EAAA,EACAU,EAAAT,EAAA,EAEAkB,EAAA/d,EAAA4c,EACAoB,EAAA/d,EAAA4c,EAMAlB,KACApxB,KACAC,KACAC,IAIA,KAAAsyB,EAAA,EAAeA,EAAAO,EAAaP,IAAA,CAE5B,GAAAroB,GAAAqoB,EAAAiB,EAAAF,CAEA,KAAAhB,EAAA,EAAgBA,EAAAO,EAAaP,IAAA,CAE7B,GAAAvoB,GAAAuoB,EAAAiB,EAAAF,CAEAtzB,GAAAjK,KAAAiU,GAAAG,EAAA,GAEAlK,EAAAlK,KAAA,OAEAmK,EAAAnK,KAAAw8B,EAAAF,GACAnyB,EAAAnK,KAAA,EAAAy8B,EAAAF,IAQA,IAAAE,EAAA,EAAeA,EAAAF,EAAYE,IAE3B,IAAAD,EAAA,EAAgBA,EAAAF,EAAYE,IAAA,CAE5B,GAAApwB,GAAAowB,EAAAO,EAAAN,EACAt4B,EAAAq4B,EAAAO,GAAAN,EAAA,GACAt3B,EAAAq3B,EAAA,EAAAO,GAAAN,EAAA,GACA7vB,EAAA4vB,EAAA,EAAAO,EAAAN,CAIApB,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAQAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IA0CA,QAAAwzB,IAAAhP,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UAEA1nB,KAAAmiB,IAAA,KAEAniB,KAAAi/B,SAAA,KACAj/B,KAAAk/B,kBAAA,EAEAl/B,KAAAm/B,MAAA,KACAn/B,KAAAo/B,eAAA,EAEAp/B,KAAAq/B,YAAA,KAEAr/B,KAAAqwB,SAAA,KAEArwB,KAAAs/B,OAAA,KACAt/B,KAAAu/B,QAAAC,GACAx/B,KAAAy/B,aAAA,EACAz/B,KAAA0/B,gBAAA,IAEA1/B,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EACA1wB,KAAA2/B,iBAAA,QACA3/B,KAAA4/B,kBAAA,QAEA5/B,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EAEApwB,KAAAwuB,QAAA,EAEAxuB,KAAA2wB,UAAAX,GAiEA,QAAA6P,IAAA7P,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,iBAEAoC,KAAA8/B,WACA9/B,KAAAipB,YAEAjpB,KAAAmqB,aAAA,gGACAnqB,KAAAsqB,eAAA,iEAEAtqB,KAAA2zB,UAAA,EAEA3zB,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EAEA1wB,KAAAosB,KAAA,EACApsB,KAAAwuB,QAAA,EACAxuB,KAAA+/B,UAAA,EAEA//B,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EACApwB,KAAAg7B,cAAA,EAEAh7B,KAAAggC,YACAC,aAAA,EACAC,WAAA,EACAC,aAAA,EACAC,kBAAA,GAKApgC,KAAAqgC,wBACAx6B,OAAA,OACAmjB,IAAA,KACAsX,KAAA,MAGAtgC,KAAAugC,oBAAA93B,OACAzI,KAAAwgC,oBAAA,EAEA/3B,SAAAunB,IAEAvnB,SAAAunB,EAAAlH,YAEAxZ,QAAAiP,MAAA,2FAIAve,KAAA2wB,UAAAX,IAuDA,QAAAyQ,IAAAC,EAAAC,GAEA3gC,KAAA0gC,OAAAj4B,SAAAi4B,IAAA,GAAA9mB,GACA5Z,KAAA2gC,UAAAl4B,SAAAk4B,IAAA,GAAA/mB,GA+gBA,QAAAgnB,IAAA7D,EAAA/vB,GAEAhN,KAAA+8B,MAAAt0B,SAAAs0B,IAAA,GAAAnjB,GACA5Z,KAAAgN,IAAAvE,SAAAuE,IAAA,GAAA4M,GA2HA,QAAAinB,IAAApzB,EAAAjI,EAAAgB,GAEAxG,KAAAyN,EAAAhF,SAAAgF,IAAA,GAAAmM,GACA5Z,KAAAwF,EAAAiD,SAAAjD,IAAA,GAAAoU,GACA5Z,KAAAwG,EAAAiC,SAAAjC,IAAA,GAAAoT,GAgQA,QAAAtH,IAAAvG,EAAAS,GAEAitB,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,OAEAoC,KAAA+L,SAAAtD,SAAAsD,IAAA,GAAAkF,IACAjR,KAAAwM,SAAA/D,SAAA+D,IAAA,GAAAwyB,KAA8En5B,MAAA,SAAAnB,KAAAC,WAE9E3E,KAAA8gC,SAAAC,GAEA/gC,KAAAghC,qBAoXA,QAAAC,IAAAre,EAAAzX,EAAA+1B,EAAAxT,GAQA,QAAAxC,GAAAiW,EAAA/V,EAAAC,EAAA+V,GAEA,GAAAC,GAAAjW,EAAAiW,UAEA,QAAAA,EAEAnL,EAAAoL,EAAAC,GAEIF,KAAAzG,UAEJ1E,EAAAmL,EAAA,GACAD,GAAA,IAIAxe,EAAA4e,WAAAJ,IAEAxe,EAAAwU,MAAAxU,EAAA6e,eAAA7e,EAAA8e,eAAA9e,EAAA+e,kBAIAN,KAAAO,eAEAn5B,SAAAo5B,IAEAA,EAAA,GAAAvvB,IACA,GAAA+qB,IAAA,OACA,GAAAwC,KACA5W,SAAA6Y,GAAAC,KAAA9Y,SACAkB,aAAA2X,GAAAC,KAAA5X,aACAG,eAAAwX,GAAAC,KAAAzX,eACAoE,KAAA2G,GACAvH,WAAA,EACAE,YAAA,EACA5B,KAAA,KAIAyV,EAAA91B,SAAAi2B,gBAAA,UACAH,EAAA91B,SAAAi2B,gBAAA,MAEAH,EAAA7U,eAAA,SAAApK,EAAAwI,EAAAC,GAEArrB,KAAA6sB,YAAAoV,aAAA5W,EAAAwB,cAIAqU,EAAAvrB,OAAAksB,EAAA91B,WAIA81B,EAAAr1B,SAAAyc,SAAAiZ,MAAAl3B,MAAAq2B,EAEAF,EAAA9/B,KAAAwgC,IAAA91B,SAAA81B,EAAAr1B,SAAA,SAEI60B,KAAAc,YAEJ15B,SAAA25B,IAEAA,EAAA,GAAAxuB,KAAA,cAEAyuB,EAAA,GAAA/vB,IACA,GAAAqsB,IAAA,KACA,GAAAK,KAA8BlR,WAAA,EAAAE,YAAA,EAAA5B,KAAA,KAG9B8U,EAAAvrB,OAAA0sB,EAAAt2B,WAIAs2B,EAAA71B,SAAA2V,IAAAkf,EAIAze,EAAAiS,mBAAAuN,EAAA,KAAAC,EAAAt2B,SAAAs2B,EAAA71B,SAAA61B,EAAA,OAMA,QAAAnM,GAAArwB,EAAApB,GAEA0G,EAAAwiB,QAAA9nB,MAAAqwB,SAAArwB,EAAAyB,EAAAzB,EAAA0B,EAAA1B,EAAAL,EAAAf,EAAAipB,GAxFA,GAGA0U,GAAAC,EACAR,EAJAP,EAAA,GAAA5Z,GAAA,GACA6Z,EAAA,CA2FA,QAEAe,cAAA,WAEA,MAAAhB,IAGAiB,cAAA,SAAA18B,EAAApB,GAEA68B,EAAA9sB,IAAA3O,GACA07B,EAAA94B,SAAAhE,IAAA,EACAyxB,EAAAoL,EAAAC,IAGAiB,cAAA,WAEA,MAAAjB,IAGAkB,cAAA,SAAAh+B,GAEA88B,EAAA98B,EACAyxB,EAAAoL,EAAAC,IAGArW,UAUA,QAAAL,IAAApd,EAAAjI,GAEA,MAAAiI,GAAAqd,cAAAtlB,EAAAslB,YAEArd,EAAAqd,YAAAtlB,EAAAslB,YAEGrd,EAAA2Z,SAAA5hB,EAAA4hB,SAAA3Z,EAAA2Z,UAAA5hB,EAAA4hB,QAEH3Z,EAAA2Z,QAAA1Y,GAAAlJ,EAAA4hB,QAAA1Y,GAEGjB,EAAAjB,SAAAkC,KAAAlJ,EAAAgH,SAAAkC,GAEHjB,EAAAjB,SAAAkC,GAAAlJ,EAAAgH,SAAAkC,GAEGjB,EAAA+Q,IAAAhZ,EAAAgZ,EAEH/Q,EAAA+Q,EAAAhZ,EAAAgZ,EAIA/Q,EAAAiB,GAAAlJ,EAAAkJ,GAMA,QAAAg0B,IAAAj1B,EAAAjI,GAEA,MAAAiI,GAAAqd,cAAAtlB,EAAAslB,YAEArd,EAAAqd,YAAAtlB,EAAAslB,YAEGrd,EAAA+Q,IAAAhZ,EAAAgZ,EAEHhZ,EAAAgZ,EAAA/Q,EAAA+Q,EAIA/Q,EAAAiB,GAAAlJ,EAAAkJ,GAMA,QAAAi0B,MAQA,QAAAza,KAEA0a,EAAA,EAEAC,EAAA9kC,OAAA,EACAgxB,EAAAhxB,OAAA,EAIA,QAAAsD,GAAAgK,EAAAU,EAAAS,EAAAgS,EAAAgW,GAEA,GAAAsO,GAAAC,EAAAH,EAEAn6B,UAAAq6B,GAEAA,GACAp0B,GAAArD,EAAAqD,GACArD,SACAU,WACAS,WACA4a,QAAA5a,EAAA4a,QACA0D,YAAAzf,EAAAyf,YACAtM,IACAgW,SAGAuO,EAAAH,GAAAE,IAIAA,EAAAp0B,GAAArD,EAAAqD,GACAo0B,EAAAz3B,SACAy3B,EAAA/2B,WACA+2B,EAAAt2B,WACAs2B,EAAA1b,QAAA5a,EAAA4a,QACA0b,EAAAhY,YAAAzf,EAAAyf,YACAgY,EAAAtkB,IACAskB,EAAAtO,UAIAhoB,EAAAuiB,eAAA,EAAAA,EAAA8T,GAAAxhC,KAAAyhC,GAEAF,IAIA,QAAA9V,KAEA+V,EAAA9kC,OAAA,GAAA8kC,EAAA/V,KAAAjC,IACAkE,EAAAhxB,OAAA,GAAAgxB,EAAAjC,KAAA4V,IAxDA,GAAAK,MACAH,EAAA,EAEAC,KACA9T,IAwDA,QACA8T,SACA9T,cAEA7G,OACA7mB,OAEAyrB,QAKA,QAAAkW,MAIA,QAAAplB,GAAAwN,EAAAC,GAEA,GAAA4X,GAAA7X,EAAA1c,GAAA,IAAA2c,EAAA3c,GACAw0B,EAAAC,EAAAF,EAWA,OATAx6B,UAAAy6B,IAIAA,EAAA,GAAAP,IACAQ,EAAAF,GAAAC,GAIAA,EAIA,QAAA3mB,KAEA4mB,KAtBA,GAAAA,KA0BA,QACAvlB,MACArB,WASA,QAAA6mB,IAAA31B,EAAAjI,GAEA,MAAAd,MAAA2+B,IAAA79B,EAAA,IAAAd,KAAA2+B,IAAA51B,EAAA,IAIA,QAAA61B,IAAArgB,GAKA,QAAAtN,GAAAtK,EAAAU,EAAAS,EAAA4a,GAEA,GAAAmc,GAAAl4B,EAAAm4B,sBAEAzlC,EAAAwlC,EAAAxlC,OAEA0lC,EAAAC,EAAA33B,EAAA2C,GAEA,IAAAjG,SAAAg7B,EAAA,CAIAA,IAEA,QAAAtkC,GAAA,EAAoBA,EAAApB,EAAYoB,IAEhCskC,EAAAtkC,MAAA,EAIAukC,GAAA33B,EAAA2C,IAAA+0B,EASA,OALArT,GAAA5jB,EAAA4jB,cAAArkB,EAAA+mB,gBAAAnY,SACAqgB,EAAAxuB,EAAAwuB,cAAAjvB,EAAA+mB,gBAAA3B,OAIAhyB,EAAA,EAAmBA,EAAApB,EAAYoB,IAAA,CAE/B,GAAAwkC,GAAAF,EAAAtkC,EAEA,KAAAwkC,EAAA,KAEAvT,GAAArkB,EAAAi2B,gBAAA,cAAA7iC,GACA67B,GAAAjvB,EAAAi2B,gBAAA,cAAA7iC,IAQA,OAAAA,GAAA,EAAmBA,EAAApB,EAAYoB,IAAA,CAE/B,GAAAwkC,GAAAF,EAAAtkC,EAEAwkC,GAAA,GAAAxkC,EACAwkC,EAAA,GAAAJ,EAAApkC,GAIAskC,EAAA3W,KAAAsW,GAIA,QAAAjkC,GAAA,EAAmBA,EAAA,EAAOA,IAAA,CAE1B,GAAAwkC,GAAAF,EAAAtkC,EAEA,IAAAwkC,EAAA,CAEA,GAAAp3B,GAAAo3B,EAAA,GACA34B,EAAA24B,EAAA,EAEA,IAAA34B,EAAA,CAEAolB,GAAArkB,EAAAmF,aAAA,cAAA/R,EAAAixB,EAAA7jB,IACAyuB,GAAAjvB,EAAAmF,aAAA,cAAA/R,EAAA67B,EAAAzuB,IAEAq3B,EAAAzkC,GAAA6L,CACA,WAMA44B,EAAAzkC,GAAA,EAIAioB,EAAAyc,cAAAvd,SAAArD,EAAA,wBAAA2gB,GArFA,GAAAF,MACAE,EAAA,GAAAxyB,cAAA,EAwFA,QAEAuE,UAUA,QAAAmuB,IAAA7gB,EAAA+c,EAAA+D,GAIA,QAAAC,GAAAh5B,GAEAi5B,EAAAj5B,EAMA,QAAAyzB,GAAAzzB,GAEApN,EAAAoN,EAAApN,KACA86B,EAAA1tB,EAAA0tB,gBAIA,QAAAxN,GAAA6R,EAAAn0B,GAEAqa,EAAAiL,aAAA+V,EAAAr7B,EAAAhL,EAAAm/B,EAAArE,GAEAqL,EAAAG,QACAH,EAAAz4B,UAAA1C,EAEAq7B,IAAAhhB,EAAAkL,UAAA4V,EAAA5b,OAAAvf,EAAA,EACAq7B,IAAAhhB,EAAAkhB,SAAAJ,EAAAK,QAAAx7B,GAIA,QAAAy7B,GAAAt4B,EAAAgxB,EAAAn0B,GAEA,GAAA07B,GAAAtE,EAAApiB,IAAA,yBAEA,eAAA0mB,MAEAh1B,SAAAiP,MAAA,0IAKA+lB,EAAAC,2BAAAN,EAAAr7B,EAAAhL,EAAAm/B,EAAArE,EAAA3sB,EAAAy4B,mBAEAT,EAAAG,QACAH,EAAAz4B,UAAA1C,EAAAmD,EAAAy4B,uBAEAP,IAAAhhB,EAAAkL,UAAA4V,EAAA5b,OAAApc,EAAAy4B,kBAAA57B,EAAA,EACAq7B,IAAAhhB,EAAAkhB,SAAAJ,EAAAK,QAAAr4B,EAAAy4B,kBAAA57B,KA9CA,GAAAq7B,GAQArmC,EAAA86B,CA4CA14B,MAAAgkC,UACAhkC,KAAAy+B,WACAz+B,KAAAkrB,SACAlrB,KAAAqkC,kBAQA,QAAAI,IAAAxhB,EAAA+c,EAAA+D,GAIA,QAAAC,GAAAh5B,GAEAi5B,EAAAj5B,EAIA,QAAAkgB,GAAA6R,EAAAn0B,GAEAqa,EAAAyhB,WAAAT,EAAAlH,EAAAn0B,GAEAm7B,EAAAG,QACAH,EAAAz4B,UAAA1C,EAEAq7B,IAAAhhB,EAAAkL,UAAA4V,EAAA5b,OAAAvf,EAAA,EACAq7B,IAAAhhB,EAAAkhB,SAAAJ,EAAAK,QAAAx7B,GAIA,QAAAy7B,GAAAt4B,EAAAgxB,EAAAn0B,GAEA,GAAA07B,GAAAtE,EAAApiB,IAAA,yBAEA,WAAA0mB,EAGA,WADAh1B,SAAAiP,MAAA,iIAKA,IAAA5D,GAAA5O,EAAA+c,WAAAnO,QAEAA,GAAAqe,8BAEApwB,EAAA+R,EAAAiH,KAAAhZ,MAEA07B,EAAAK,yBAAAV,EAAA,EAAAr7B,EAAAmD,EAAAy4B,oBAIAF,EAAAK,yBAAAV,EAAAlH,EAAAn0B,EAAAmD,EAAAy4B,mBAIAT,EAAAG,QACAH,EAAAz4B,UAAA1C,EAAAmD,EAAAy4B,kBAEAP,IAAAhhB,EAAAkL,UAAA4V,EAAA5b,OAAApc,EAAAy4B,kBAAA57B,EAAA,EACAq7B,IAAAhhB,EAAAkhB,SAAAJ,EAAAK,QAAAr4B,EAAAy4B,kBAAA57B,GAjDA,GAAAq7B,EAuDAjkC,MAAAgkC,UACAhkC,KAAAkrB,SACAlrB,KAAAqkC,kBAQA,QAAAO,IAAA3hB,EAAA6F,EAAA+b,GAKA,QAAAC,GAAAxwB,GAEA,GAAAvI,GAAAuI,EAAAqF,OACA3I,EAAAkwB,EAAAn1B,EAAA2C,GAEA,QAAAsC,EAAAzE,OAEAuc,EAAAmQ,OAAAjoB,EAAAzE,MAIA,QAAAzO,KAAAkT,GAAA8X,WAEAA,EAAAmQ,OAAAjoB,EAAA8X,WAAAhrB,GAIAiO,GAAA+M,oBAAA,UAAAgsB,SAEA5D,GAAAn1B,EAAA2C,GAIA,IAAA+oB,GAAAsN,EAAAh5B,EAAA2C,GAEA+oB,KAEA3O,EAAAmQ,OAAAxB,SACAsN,GAAAh5B,EAAA2C,KAIA+oB,EAAAsN,EAAA/zB,EAAAtC,IAEA+oB,IAEA3O,EAAAmQ,OAAAxB,SACAsN,GAAA/zB,EAAAtC,KAMAm2B,EAAA3D,aAIA,QAAAtjB,GAAAvS,EAAAU,GAEA,GAAAiF,GAAAkwB,EAAAn1B,EAAA2C,GAEA,OAAAsC,MAEAjF,EAAA0M,iBAAA,UAAAqsB,GAEA/4B,EAAA8mB,iBAEA7hB,EAAAjF,EAEIA,EAAAgnB,aAEJtqB,SAAAsD,EAAAi5B,kBAEAj5B,EAAAi5B,iBAAA,GAAA/zB,KAAAg0B,cAAA55B,IAIA2F,EAAAjF,EAAAi5B,iBAIA9D,EAAAn1B,EAAA2C,IAAAsC,EAEA6zB,EAAA3D,aAEAlwB,GAIA,QAAA2E,GAAA5J,GAEA,GAAAQ,GAAAR,EAAAQ,MACA24B,EAAAn5B,EAAA+c,UAEA,QAAAvc,GAEAuc,EAAAnT,OAAApJ,EAAA0W,EAAA2F,qBAIA,QAAA9qB,KAAAonC,GAEApc,EAAAnT,OAAAuvB,EAAApnC,GAAAmlB,EAAAwF,aAMA,IAAAqK,GAAA/mB,EAAA+mB,eAEA,QAAAh1B,KAAAg1B,GAIA,OAFA/xB,GAAA+xB,EAAAh1B,GAEAqB,EAAA,EAAAgQ,EAAApO,EAAAhD,OAAsCoB,EAAAgQ,EAAOhQ,IAE7C2pB,EAAAnT,OAAA5U,EAAA5B,GAAA8jB,EAAAwF,cAQA,QAAA0c,GAAAp5B,GAEA,GAAA0rB,GAAAsN,EAAAh5B,EAAA2C,GAEA,IAAA+oB,EAAA,MAAAA,EAEA,IAAAiF,MAEA0I,EAAAr5B,EAAAQ,MACA24B,EAAAn5B,EAAA+c,UAIA,WAAAsc,EAIA,OAFArkC,GAAAqkC,EAAArkC,MAEA5B,EAAA,EAAAgQ,EAAApO,EAAAhD,OAAsCoB,EAAAgQ,EAAOhQ,GAAA,GAE7C,GAAAsO,GAAA1M,EAAA5B,EAAA,GACAqG,EAAAzE,EAAA5B,EAAA,GACAqH,EAAAzF,EAAA5B,EAAA,EAEAu9B,GAAAr7B,KAAAoM,EAAAjI,IAAAgB,IAAAiH,OAQA,QAFA1M,GAAAmkC,EAAAvqB,SAAA5Z,MAEA5B,EAAA,EAAAgQ,EAAApO,EAAAhD,OAAA,IAAkDoB,EAAAgQ,EAAOhQ,GAAA,GAEzD,GAAAsO,GAAAtO,EAAA,EACAqG,EAAArG,EAAA,EACAqH,EAAArH,EAAA,CAEAu9B,GAAAr7B,KAAAoM,EAAAjI,IAAAgB,IAAAiH,GAcA,MANAgqB,GAAA,IAAAmF,GAAAF,GAAA,MAAAJ,GAAAF,IAAAM,EAAA,GAEA5T,EAAAnT,OAAA8hB,EAAAxU,EAAA2F,sBAEAmc,EAAAh5B,EAAA2C,IAAA+oB,EAEAA,EAxKA,GAAAyJ,MACA6D,IA2KA,QAEAnnB,MACAjI,SAEAwvB,yBAUA,QAAAE,IAAAnE,EAAA6C,GAIA,QAAApuB,GAAAtK,GAEA,GAAAi6B,GAAAvB,EAAAuB,MAEAv5B,EAAAV,EAAAU,SACAiF,EAAAkwB,EAAAtjB,IAAAvS,EAAAU,EAkBA,OAdAw5B,GAAAv0B,EAAAtC,MAAA42B,IAEAv5B,EAAAgnB,YAEA/hB,EAAAw0B,iBAAAn6B,GAIA61B,EAAAvrB,OAAA3E,GAEAu0B,EAAAv0B,EAAAtC,IAAA42B,GAIAt0B,EAIA,QAAAuL,KAEAgpB,KA/BA,GAAAA,KAmCA,QAEA5vB,SACA4G,WAUA,QAAAkpB,IAAAr9B,GAIA,OAFAqH,GAAArH,EAAAsH,MAAA,MAEAvQ,EAAA,EAAkBA,EAAAsQ,EAAA1R,OAAkBoB,IAEpCsQ,EAAAtQ,KAAA,OAAAsQ,EAAAtQ,EAIA,OAAAsQ,GAAA3K,KAAA,MAIA,QAAA4gC,IAAAziB,EAAArlB,EAAAwK,GAEA,GAAAu9B,GAAA1iB,EAAAmH,aAAAxsB,EAoBA,OAlBAqlB,GAAAuH,aAAAmb,EAAAv9B,GACA6a,EAAAyH,cAAAib,GAEA1iB,EAAA2iB,mBAAAD,EAAA1iB,EAAA4iB,mBAAA,GAEAv2B,QAAAiP,MAAA,+CAIA,KAAA0E,EAAA6iB,iBAAAH,IAEAr2B,QAAA4E,KAAA,2CAAAtW,IAAAqlB,EAAAoH,cAAA,oBAAApH,EAAA6iB,iBAAAH,GAAAF,GAAAr9B,IAOAu9B,EAUA,QAAAI,IAAAxmB,GAEA,OAAAA,GAEA,IAAAoB,IACA,4BACA,KAAAqlB,IACA,0BACA,KAAAC,IACA,0BACA,KAAAC,IACA,+BACA,KAAAC,IACA,gCACA,KAAAC,IACA,iCACA,KAAAC,IACA,kDACA,SACA,SAAA5mC,OAAA,yBAAA8f,IAMA,QAAA+mB,IAAAC,EAAAhnB,GAEA,GAAAinB,GAAAT,GAAAxmB,EACA,eAAAgnB,EAAA,2BAAmDC,EAAA,cAAAA,EAAA,SAInD,QAAAC,IAAAF,EAAAhnB,GAEA,GAAAinB,GAAAT,GAAAxmB,EACA,eAAAgnB,EAAA,mCAAmDC,EAAA,GAAAA,EAAA,SAInD,QAAAE,IAAAH,EAAAI,GAEA,GAAAC,EAEA,QAAAD,GAEA,IAAAE,IACAD,EAAA,QACA,MAEA,KAAAE,IACAF,EAAA,UACA,MAEA,KAAAG,IACAH,EAAA,YACA,MAEA,KAAAI,IACAJ,EAAA,iBACA,MAEA,SACA,SAAAnnC,OAAA,4BAAAknC,GAIA,cAAAJ,EAAA,2BAAmDK,EAAA,0BAInD,QAAAK,IAAAjH,EAAAhQ,EAAAkX,GAEAlH,OAEA,IAAAmH,IACAnH,EAAAC,aAAAjQ,EAAAoX,cAAApX,EAAAqX,SAAArX,EAAAsX,WAAAtX,EAAApB,YAAA,sDACAoR,EAAAE,WAAAlQ,EAAAuX,yBAAAL,EAAAtpB,IAAA,6DACAoiB,EAAA,aAAAkH,EAAAtpB,IAAA,qEACAoiB,EAAAI,kBAAApQ,EAAAsP,SAAA4H,EAAAtpB,IAAA,6EAGA,OAAAupB,GAAAK,OAAAC,IAAA3iC,KAAA,MAIA,QAAA4iC,IAAA5H,GAEA,GAAAqH,KAEA,QAAArpC,KAAAgiC,GAAA,CAEA,GAAA90B,GAAA80B,EAAAhiC,EAEAkN,MAAA,GAEAm8B,EAAA9lC,KAAA,WAAAvD,EAAA,IAAAkN,GAIA,MAAAm8B,GAAAriC,KAAA,MAIA,QAAA6iC,IAAA1kB,EAAAmE,GAMA,OAJA0B,MAEAtG,EAAAS,EAAAoE,oBAAAD,EAAAnE,EAAA2kB,mBAEAzoC,EAAA,EAAkBA,EAAAqjB,EAAOrjB,IAAA,CAEzB,GAAAooB,GAAAtE,EAAA4kB,gBAAAzgB,EAAAjoB,GACArB,EAAAypB,EAAAzpB,IAIAgrB,GAAAhrB,GAAAmlB,EAAA8F,kBAAA3B,EAAAtpB,GAIA,MAAAgrB,GAIA,QAAA2e,IAAAr/B,GAEA,WAAAA,EAIA,QAAA0/B,IAAA1/B,EAAA4nB,GAEA,MAAA5nB,GACAX,QAAA,kBAAAuoB,EAAA+X,cACAtgC,QAAA,mBAAAuoB,EAAAgY,eACAvgC,QAAA,wBAAAuoB,EAAAiY,mBACAxgC,QAAA,oBAAAuoB,EAAAkY,gBACAzgC,QAAA,mBAAAuoB,EAAAmY,eAIA,QAAAC,IAAAhgC,EAAA4nB,GAEA,MAAA5nB,GACAX,QAAA,uBAAAuoB,EAAAqY,mBACA5gC,QAAA,yBAAAuoB,EAAAqY,kBAAArY,EAAAsY,qBAIA,QAAAC,IAAAngC,GAIA,QAAAX,GAAA3B,EAAA0iC,GAEA,GAAA/gC,GAAAghC,GAAAD,EAEA,IAAA//B,SAAAhB,EAEA,SAAAhI,OAAA,6BAAA+oC,EAAA,IAIA,OAAAD,IAAA9gC,GAZA,GAAAihC,GAAA,iCAgBA,OAAAtgC,GAAAX,QAAAihC,EAAAjhC,GAIA,QAAAkhC,IAAAvgC,GAIA,QAAAX,GAAA3B,EAAAi3B,EAAA/vB,EAAA47B,GAIA,OAFAC,GAAA,GAEA1pC,EAAAuG,SAAAq3B,GAAmC59B,EAAAuG,SAAAsH,GAAqB7N,IAExD0pC,GAAAD,EAAAnhC,QAAA,gBAAAtI,EAAA,KAIA,OAAA0pC,GAZA,GAAAH,GAAA,8FAgBA,OAAAtgC,GAAAX,QAAAihC,EAAAjhC,GAIA,QAAAqhC,IAAAlmB,EAAAod,EAAA+I,EAAAv8B,EAAAm5B,EAAA3V,GAEA,GAAA/M,GAAAL,EAAAmH,QAEA+V,EAAAtzB,EAAAszB,QAEA3V,EAAAwb,EAAAxb,aACAG,EAAAqb,EAAArb,eAEA0e,EAAA,sBAEAhZ,GAAAiZ,gBAAAlT,GAEAiT,EAAA,qBAEGhZ,EAAAiZ,gBAAAC,KAEHF,EAAA,0BAIA,IAAAG,GAAA,mBACAC,EAAA,yBACAC,EAAA,0BAEA,IAAArZ,EAAAsP,OAAA,CAEA,OAAA9yB,EAAA8yB,OAAArgB,SAEA,IAAA+C,IACA,IAAAsnB,IACAH,EAAA,kBACA,MAEA,KAAAI,IACA,IAAAC,IACAL,EAAA,qBACA,MAEA,KAAAM,IACA,IAAAC,IACAP,EAAA,qBACA,MAEA,KAAAQ,IACAR,EAAA,qBAKA,OAAA38B,EAAA8yB,OAAArgB,SAEA,IAAAqqB,IACA,IAAAI,IACAN,EAAA,yBAKA,OAAA58B,EAAA+yB,SAEA,IAAAC,IACA6J,EAAA,0BACA,MAEA,KAAAO,IACAP,EAAA,qBACA,MAEA,KAAAQ,IACAR,EAAA,uBAOA,GAcAS,GAAAC,EAdAC,EAAApnB,EAAAqnB,YAAA,EAAArnB,EAAAqnB,YAAA,EAMAC,EAAAjD,GAAAz6B,EAAAwzB,WAAAhQ,EAAAgQ,GAEAmK,EAAAzC,GAAA5H,GAIA1Y,EAAAnE,EAAA4F,eAIArc,GAAA49B,qBAEAN,GAEAK,GAEA3C,OAAAC,IAAA3iC,KAAA,MAEAglC,EAAA/rC,OAAA,IAEA+rC,GAAA,MAIAC,GAEAG,EACAC,GAEA3C,OAAAC,IAAA3iC,KAAA,MAEAilC,EAAAhsC,OAAA,IAEAgsC,GAAA,QAMAD,GAEA,aAAA9Z,EAAAvF,UAAA,UACA,aAAAuF,EAAAvF,UAAA,QAEA,uBAAAkb,EAAA7nC,KAEAqsC,EAEAna,EAAAqa,uBAAA,6BAEA,wBAAAL,EAEA,qBAAAha,EAAAsa,SACAta,EAAAua,QAAAva,EAAA5D,IAAA,qBACA4D,EAAAua,QAAAva,EAAAwa,OAAA,sBAEAxa,EAAA7N,IAAA,qBACA6N,EAAAsP,OAAA,wBACAtP,EAAAsP,OAAA,WAAA8J,EAAA,GACApZ,EAAAiP,SAAA,0BACAjP,EAAAmP,MAAA,uBACAnP,EAAAya,YAAA,6BACAza,EAAAqX,QAAA,yBACArX,EAAAsX,UAAA,2BACAtX,EAAAM,iBAAAN,EAAAqa,uBAAA,iCACAra,EAAAqP,YAAA,6BACArP,EAAA0a,aAAA,8BACA1a,EAAA2a,aAAA,8BACA3a,EAAAK,SAAA,0BACAL,EAAAnB,aAAA,uBAEAmB,EAAApB,YAAA,yBAEAoB,EAAAG,SAAA,0BACAH,EAAA4a,iBAAA,0BAEA5a,EAAAI,aAAA,8BACAJ,EAAAgL,cAAAhL,EAAApB,eAAA,gCACAoB,EAAA6a,YAAA,0BACA7a,EAAA8a,UAAA,wBAEA9a,EAAA+a,iBAAA,2BACA/a,EAAA+a,iBAAA,WAAA/B,EAAA,GAEAhZ,EAAAgb,gBAAA,iCAEAhb,EAAAuX,uBAAA,6BACAvX,EAAAuX,wBAAAvH,EAAApiB,IAAA,mDAEA,4BACA,gCACA,iCACA,2BACA,6BACA,+BAEA,2BACA,yBACA,qBAEA,mBAEA,0BAEA,SAEA,0BAEA,iCACA,iCACA,iCACA,iCAEA,4BAEA,mCACA,mCACA,mCACA,mCAEA,UAEA,mCACA,mCACA,mCACA,mCAEA,WAEA,SAEA,sBAEA,8BACA,+BAEA,SAEA,MAEA4pB,OAAAC,IAAA3iC,KAAA,MAEAilC,GAEAG,EAEA,aAAAla,EAAAvF,UAAA,UACA,aAAAuF,EAAAvF,UAAA,QAEA,uBAAAkb,EAAA7nC,KAEAqsC,EAEAna,EAAAnG,UAAA,qBAAAmG,EAAAnG,UAAA,GAEA,wBAAAmgB,EAEAha,EAAAua,QAAAva,EAAA5D,IAAA,qBACA4D,EAAAua,QAAAva,EAAAwa,OAAA,sBAEAxa,EAAA7N,IAAA,qBACA6N,EAAAsP,OAAA,wBACAtP,EAAAsP,OAAA,WAAA6J,EAAA,GACAnZ,EAAAsP,OAAA,WAAA8J,EAAA,GACApZ,EAAAsP,OAAA,WAAA+J,EAAA,GACArZ,EAAAiP,SAAA,0BACAjP,EAAAmP,MAAA,uBACAnP,EAAAya,YAAA,6BACAza,EAAAqX,QAAA,yBACArX,EAAAsX,UAAA,2BACAtX,EAAAqP,YAAA,6BACArP,EAAA0a,aAAA,8BACA1a,EAAA2a,aAAA,8BACA3a,EAAAK,SAAA,0BACAL,EAAAnB,aAAA,uBAEAmB,EAAAib,YAAA,6BAEAjb,EAAApB,YAAA,yBAEAoB,EAAA6a,YAAA,0BACA7a,EAAA8a,UAAA,wBAEA9a,EAAA+a,iBAAA,2BACA/a,EAAA+a,iBAAA,WAAA/B,EAAA,GAEAhZ,EAAAtC,mBAAA,iCAEAsC,EAAAkb,wBAAA,uCAEAlb,EAAAuX,uBAAA,6BACAvX,EAAAuX,wBAAAvH,EAAApiB,IAAA,mDAEAoS,EAAAsP,QAAAU,EAAApiB,IAAA,uDAEA,2BACA,+BAEAoS,EAAA2W,cAAAwE,GAAA,0BACAnb,EAAA2W,cAAAwE,GAAA1C,GAAA,6BACAzY,EAAA2W,cAAAwE,GAAAzE,GAAA,cAAA1W,EAAA2W,aAAA,GAEA3W,EAAAJ,UAAA,uBAEAI,EAAAob,gBAAApb,EAAAqb,aAAArb,EAAAsb,gBAAAtb,EAAAub,oBAAA9C,GAAA,2BACAzY,EAAAqb,YAAA/E,GAAA,mBAAAtW,EAAAqb,aAAA,GACArb,EAAAsb,eAAAhF,GAAA,sBAAAtW,EAAAsb,gBAAA,GACAtb,EAAAub,oBAAAjF,GAAA,2BAAAtW,EAAAub,qBAAA,GACAvb,EAAAob,eAAA3E,GAAA,sBAAAzW,EAAAob,gBAAA,GAEApb,EAAAC,aAAA,yBAAAzjB,EAAAyjB,aAAA,GAEA,MAEAuX,OAAAC,IAAA3iC,KAAA;AAIAqlB,EAAAoe,GAAApe,GACAA,EAAA2d,GAAA3d,EAAA6F,GACA7F,EAAAie,GAAAje,EAAA6F,GAEA1F,EAAAie,GAAAje,GACAA,EAAAwd,GAAAxd,EAAA0F,GACA1F,EAAA8d,GAAA9d,EAAA0F,GAEA7F,EAAAwe,GAAAxe,GACAG,EAAAqe,GAAAre,EAEA,IAAAkhB,GAAA1B,EAAA3f,EACAshB,EAAA1B,EAAAzf,EAKAohB,EAAAhG,GAAAziB,IAAAoH,cAAAmhB,GACAG,EAAAjG,GAAAziB,IAAAsH,gBAAAkhB,EAEAxoB,GAAA0H,aAAAvD,EAAAskB,GACAzoB,EAAA0H,aAAAvD,EAAAukB,GAIAljC,SAAA+D,EAAA+zB,oBAEAtd,EAAA2oB,mBAAAxkB,EAAA,EAAA5a,EAAA+zB,qBAEGvQ,EAAAI,gBAAA,GAGHnN,EAAA2oB,mBAAAxkB,EAAA,cAIAnE,EAAA2H,YAAAxD,EAEA,IAAAykB,GAAA5oB,EAAA6oB,kBAAA1kB,GAAApX,OACA+7B,EAAA9oB,EAAA6iB,iBAAA4F,GAAA17B,OACAg8B,EAAA/oB,EAAA6iB,iBAAA6F,GAAA37B,OAEAi8B,GAAA,EACAC,GAAA,CAKAjpB,GAAAoE,oBAAAD,EAAAnE,EAAAkpB,gBAAA,GAEAF,GAAA,EAEA38B,QAAAiP,MAAA,qCAAA0E,EAAAmpB,WAAA,qBAAAnpB,EAAAoE,oBAAAD,EAAAnE,EAAAopB,iBAAA,uBAAAR,EAAAE,EAAAC,IAEG,KAAAH,EAEHv8B,QAAA4E,KAAA,6CAAA23B,GAEG,KAAAE,GAAA,KAAAC,IAEHE,GAAA,GAIAA,IAEAlsC,KAAAssC,aAEAL,WACAz/B,WAEAq/B,aAEA1hB,cAEAoiB,IAAAR,EACAS,OAAA1C,GAIAxf,gBAEAiiB,IAAAP,EACAQ,OAAAzC,KAUA9mB,EAAAwpB,aAAAf,GACAzoB,EAAAwpB,aAAAd,EAIA,IAAAe,EAEA1sC,MAAA6jC,YAAA,WAQA,MANAp7B,UAAAikC,IAEAA,EAAA,GAAAvlB,GAAAlE,EAAAmE,EAAAxE,IAIA8pB,EAMA,IAAAC,EAyDA,OAvDA3sC,MAAA4sC,cAAA,WAQA,MANAnkC,UAAAkkC,IAEAA,EAAAhF,GAAA1kB,EAAAmE,IAIAulB,GAMA3sC,KAAA6sC,QAAA,WAEA5pB,EAAA6pB,cAAA1lB,GACApnB,KAAAonB,QAAA3e,QAMAnK,OAAAof,iBAAA1d,MAEAipB,UACArL,IAAA,WAGA,MADAtO,SAAA4E,KAAA,wDACAlU,KAAA6jC,gBAKA/a,YACAlL,IAAA,WAGA,MADAtO,SAAA4E,KAAA,4DACAlU,KAAA4sC,oBAUA5sC,KAAA0O,GAAAq+B,KACA/sC,KAAA+oC,OACA/oC,KAAAgtC,UAAA,EACAhtC,KAAAonB,UACApnB,KAAAmqB,aAAAuhB,EACA1rC,KAAAsqB,eAAAqhB,EAEA3rC,KAQA,QAAAitC,IAAArqB,EAAAod,EAAA/X,GAkCA,QAAAilB,GAAA7hC,GAEA,GAAA8hC,GAAA9hC,EAAA8hC,SACAC,EAAAD,EAAAC,KAEA,IAAAnlB,EAAAolB,oBAEA,WAWA,IAAAC,GAAArlB,EAAAslB,kBACAC,EAAA9oC,KAAAyB,OAAAmnC,EAAA,OAEAhD,EAAA5lC,KAAA2B,IAAAmnC,EAAAJ,EAAArvC,OAEA,OAAAusC,GAAA8C,EAAArvC,QAEAuR,QAAA4E,KAAA,qCAAAk5B,EAAArvC,OAAA,6BAAAusC,EAAA,KACA,GAIAA,EAMA,QAAAmD,GAAAtrB,EAAAurB,GAEA,GAAAnuB,EAwBA,OAtBA4C,GAIIA,EAAAggB,UAEJ5iB,EAAA4C,EAAA5C,SAEI4C,EAAAwrB,sBAEJr+B,QAAA4E,KAAA,6HACAqL,EAAA4C,EAAAf,QAAA7B,UATAA,EAAAoB,GAcApB,IAAAoB,IAAA+sB,IAEAnuB,EAAA8mB,IAIA9mB,EA9FA,GAAAquB,MAEAC,GACA9d,kBAAA,QACAa,qBAAA,eACAkd,mBAAA,SACA9O,kBAAA,QACA+O,oBAAA,UACAl8B,kBAAA,QACAm8B,iBAAA,QACAC,qBAAA,WACAC,qBAAA,WACAx8B,kBAAA,QACAy8B,mBAAA,SACAC,eAAA,SACAC,eAAA,UAGAC,GACA,gGACA,6GACA,4CACA,4DACA,oEACA,4DACA,yDACA,oFACA,2EACA,2GAsEAtuC,MAAAuuC,cAAA,SAAA/hC,EAAAgiB,EAAAggB,EAAApiB,EAAAqiB,EAAAC,EAAArjC,GAEA,GAAAsjC,GAAAd,EAAArhC,EAAA5O,MAKA0sC,EAAAj/B,EAAA2nB,cAAAka,EAAA7hC,GAAA,EACAof,EAAAxC,EAAAwC,SAEA,QAAAje,EAAAie,YAEAA,EAAAxC,EAAA2mB,gBAAApiC,EAAAie,WAEAA,IAAAje,EAAAie,WAEAnb,QAAA4E,KAAA,oCAAA1H,EAAAie,UAAA,uBAAAA,EAAA,YAMA,IAAAokB,GAAAjsB,EAAAksB,kBAEA9e,GAEA2e,WAEAlkB,YACA4f,uBAAApiB,EAAA8mB,eACA3D,eAAAqC,EAAAoB,IAAAztB,QAAA,KAAAwB,EAAAosB,aACA7sB,MAAA3V,EAAA2V,IACAkpB,YAAAoC,EAAAjhC,EAAA2V,IAAAS,EAAAqsB,YACA3P,SAAA9yB,EAAA8yB,OACA4P,WAAA1iC,EAAA8yB,QAAA9yB,EAAA8yB,OAAArgB,QACAqsB,eAAAmC,EAAAjhC,EAAA8yB,OAAA1c,EAAAqsB,YACA7H,eAAA56B,EAAA8yB,SAAA9yB,EAAA8yB,OAAArgB,UAAAsqB,IAAA/8B,EAAA8yB,OAAArgB,UAAAuqB,IACAvK,WAAAzyB,EAAAyyB,SACAE,QAAA3yB,EAAA2yB,MACAsL,cAAAj+B,EAAAi+B,YACAc,oBAAAkC,EAAAjhC,EAAAi+B,YAAA7nB,EAAAqsB,YACA5H,UAAA76B,EAAA66B,QACAC,YAAA96B,EAAA86B,UACAhX,kBAAA9jB,EAAA8jB,gBACAoa,eAAAl+B,EAAAk+B,aACAC,eAAAn+B,EAAAm+B,aACAtL,cAAA7yB,EAAA6yB,YACAhP,WAAA7jB,EAAA6jB,SAEA4a,cAAAz+B,EAAAy+B,YAEA1L,QAAA/yB,EAAA+yB,QAEA1Q,aAAAriB,EAAAqiB,aAEAzC,QACAme,OAAA/9B,EAAA4f,IACAoe,OAAApe,KAAAI,UAEAoC,YAAApiB,EAAAoiB,YAEAoc,gBAAAx+B,EAAAw+B,gBACAzD,uBAAAtf,EAAAsf,uBAEApX,SAAA3jB,EAAA2jB,UAAAma,EAAA,EACAA,WACAM,iBAAA3iB,EAAAolB,oBAEAjd,aAAA5jB,EAAA4jB,aACA4K,aAAAxuB,EAAAwuB,aACAmU,gBAAAvsB,EAAAusB,gBACAC,gBAAAxsB,EAAAwsB,gBAEArH,aAAAvZ,EAAA6gB,YAAAtxC,OACAmqC,eAAA1Z,EAAA8gB,MAAAvxC,OACAiqC,cAAAxZ,EAAA+gB,KAAAxxC,OACAkqC,kBAAAzZ,EAAAghB,SAAAzxC,OACAoqC,cAAA3Z,EAAAihB,KAAA1xC,OAEAsqC,kBAAAoG,EACAnG,oBAAAoG,EAEA9e,UAAApjB,EAAAojB,UAEAmb,iBAAAnoB,EAAAiU,UAAAjf,SAAAvM,EAAAivB,eAAAkU,EAAAzwC,OAAA,EACAkrC,cAAArmB,EAAAiU,UAAAj5B,KAEA+oC,YAAA/jB,EAAA+jB,YACAuE,wBAAAtoB,EAAAsoB,wBAEAxd,mBAAAlhB,EAAAkhB,mBAEA7D,UAAArd,EAAAqd,UACAghB,YAAAr+B,EAAAkiB,OAAA8G,GACAsV,UAAAt+B,EAAAkiB,OAAA2G,GAEApF,aAAAxnB,SAAA+D,EAAAyjB,cAAAzjB,EAAAyjB,aAIA,OAAAD,IAIAhwB,KAAA0vC,eAAA,SAAAljC,EAAAwjB,GAEA,GAAAjvB,KAaA,IAXAivB,EAAA2e,SAEA5tC,EAAAM,KAAA2uB,EAAA2e,WAIA5tC,EAAAM,KAAAmL,EAAA8d,gBACAvpB,EAAAM,KAAAmL,EAAA2d,eAIA1hB,SAAA+D,EAAAszB,QAEA,OAAAhiC,KAAA0O,GAAAszB,QAEA/+B,EAAAM,KAAAvD,GACAiD,EAAAM,KAAAmL,EAAAszB,QAAAhiC,GAMA,QAAAqB,GAAA,EAAmBA,EAAAmvC,EAAAvwC,OAA2BoB,IAE9C4B,EAAAM,KAAA2uB,EAAAse,EAAAnvC,IAQA,OAJA4B,GAAAM,KAAAmL,EAAAmjC,gBAAAjpC,YAEA3F,EAAAM,KAAAuhB,EAAAosB,aAEAjuC,EAAA+D,QAIA9E,KAAA4vC,eAAA,SAAApjC,EAAAm5B,EAAA3V,EAAA+Y,GAKA,OAHA3hB,GAGAjgB,EAAA,EAAA0oC,EAAAjC,EAAA7vC,OAAyCoJ,EAAA0oC,EAAQ1oC,IAAA,CAEjD,GAAA2oC,GAAAlC,EAAAzmC,EAEA,IAAA2oC,EAAA/G,SAAA,CAEA3hB,EAAA0oB,IACA1oB,EAAA4lB,SAEA,QAaA,MAPAvkC,UAAA2e,IAEAA,EAAA,GAAA0hB,IAAAlmB,EAAAod,EAAA+I,EAAAv8B,EAAAm5B,EAAA3V,GACA4d,EAAAvsC,KAAA+lB,IAIAA,GAIApnB,KAAA+vC,eAAA,SAAA3oB,GAEA,SAAAA,EAAA4lB,UAAA,CAGA,GAAA7tC,GAAAyuC,EAAAp+B,QAAA4X,EACAwmB,GAAAzuC,GAAAyuC,IAAA7vC,OAAA,GACA6vC,EAAAoC,MAGA5oB,EAAAylB,YAOA7sC,KAAA4tC,WAQA,QAAAqC,IAAAja,EAAAgK,EAAA70B,EAAA+kC,EAAAjoB,EAAAkoB,EAAAtL,EAAAd,GAQA,QAAAqM,GAAApxB,EAAAqxB,GAEA,GAAArxB,EAAA+B,MAAAsvB,GAAArxB,EAAAgC,OAAAqvB,EAAA,CAKA,GAAA18B,GAAA08B,EAAA3rC,KAAA0B,IAAA4Y,EAAA+B,MAAA/B,EAAAgC,QAEA6G,EAAAzS,SAAA0U,gBAAA,wCACAjC,GAAA9G,MAAArc,KAAAyB,MAAA6Y,EAAA+B,MAAApN,GACAkU,EAAA7G,OAAAtc,KAAAyB,MAAA6Y,EAAAgC,OAAArN,EAEA,IAAAoW,GAAAlC,EAAAmC,WAAA,KAKA,OAJAD,GAAAumB,UAAAtxB,EAAA,IAAAA,EAAA+B,MAAA/B,EAAAgC,OAAA,IAAA6G,EAAA9G,MAAA8G,EAAA7G,QAEA1R,QAAA4E,KAAA,0CAAA8K,EAAA+B,MAAA,IAAA/B,EAAAgC,OAAA,iBAAA6G,EAAA9G,MAAA,IAAA8G,EAAA7G,OAAAhC,GAEA6I,EAIA,MAAA7I,GAIA,QAAAuxB,GAAAvxB,GAEA,MAAAU,IAAA6wB,aAAAvxB,EAAA+B,QAAArB,GAAA6wB,aAAAvxB,EAAAgC,QAIA,QAAAwvB,GAAAxxB,GAEA,GAAAA,YAAAyxB,mBAAAzxB,YAAA0xB,oBAAA1xB,YAAA2xB,aAAA,CAEAloC,SAAAmoC,MAAAx7B,SAAA0U,gBAAA,0CAEA8mB,EAAA7vB,MAAArB,GAAAmxB,gBAAA7xB,EAAA+B,OACA6vB,EAAA5vB,OAAAtB,GAAAmxB,gBAAA7xB,EAAAgC,OAEA,IAAA+I,GAAA6mB,EAAA5mB,WAAA,KAKA,OAJAD,GAAAumB,UAAAtxB,EAAA,IAAA4xB,EAAA7vB,MAAA6vB,EAAA5vB,QAEA1R,QAAA4E,KAAA,mDAAA8K,EAAA+B,MAAA,IAAA/B,EAAAgC,OAAA,iBAAA4vB,EAAA7vB,MAAA,IAAA6vB,EAAA5vB,OAAAhC,GAEA4xB,EAIA,MAAA5xB,GAIA,QAAA8xB,GAAA1vB,GAEA,MAAAA,GAAAlC,QAAAa,IAAAqB,EAAAjC,QAAAY,IACAqB,EAAA/B,YAAAwC,IAAAT,EAAA/B,YAAAW,GAIA,QAAA+wB,GAAA3vB,EAAAmvB,GAEA,MAAAnvB,GAAAb,iBAAAgwB,GACAnvB,EAAA/B,YAAAwC,IAAAT,EAAA/B,YAAAW,GAMA,QAAAgxB,GAAA9pC,GAEA,MAAAA,KAAA2a,IAAA3a,IAAA+pC,IAAA/pC,IAAAgqC,GAEAlb,EAAAmb,QAIAnb,EAAAob,OAMA,QAAAC,GAAA/8B,GAEA,GAAA8M,GAAA9M,EAAAqF,MAEAyH,GAAAtI,oBAAA,UAAAu4B,GAEAC,EAAAlwB,GAEAA,EAAAmwB,sBAEAC,GAAApwB,EAAA1S,IAIAm2B,EAAA7c,WAIA,QAAAypB,GAAAn9B,GAEA,GAAAo9B,GAAAp9B,EAAAqF,MAEA+3B,GAAA54B,oBAAA,UAAA24B,GAEAE,EAAAD,GAEA7M,EAAA7c,WAMA,QAAAspB,GAAAlwB,GAEA,GAAAwwB,GAAA1B,EAAAtyB,IAAAwD,EAEA,IAAAA,EAAApC,OAAA4yB,EAAAC,0BAIA7b,EAAA8b,cAAAF,EAAAC,+BAEI,CAIJ,GAAAppC,SAAAmpC,EAAAG,YAAA,MAEA/b,GAAA8b,cAAAF,EAAAI,gBAKA9B,EAAAjX,OAAA7X,GAIA,QAAAuwB,GAAAD,GAEA,GAAAO,GAAA/B,EAAAtyB,IAAA8zB,GACAE,EAAA1B,EAAAtyB,IAAA8zB,EAAAtwB,QAEA,IAAAswB,EAAA,CAcA,GAZAjpC,SAAAmpC,EAAAI,gBAEAhc,EAAA8b,cAAAF,EAAAI,gBAIAN,EAAAnwB,cAEAmwB,EAAAnwB,aAAAhF,UAIAm1B,EAAAQ,wBAEA,OAAA/yC,GAAA,EAAoBA,EAAA,EAAOA,IAE3B62B,EAAAmc,kBAAAF,EAAAG,mBAAAjzC,IACA8yC,EAAAI,oBAAArc,EAAAsc,mBAAAL,EAAAI,mBAAAlzC,QAMA62B,GAAAmc,kBAAAF,EAAAG,oBACAH,EAAAI,oBAAArc,EAAAsc,mBAAAL,EAAAI,mBAIAnC,GAAAjX,OAAAyY,EAAAtwB,SACA8uB,EAAAjX,OAAAyY,IAQA,QAAAjtB,GAAArD,EAAAmxB,GAEA,GAAAX,GAAA1B,EAAAtyB,IAAAwD,EAIA,IAFAA,EAAAmwB,gBAAAiB,EAAApxB,GAEAA,EAAAzf,QAAA,GAAAiwC,EAAAa,YAAArxB,EAAAzf,QAAA,CAEA,GAAAqd,GAAAoC,EAAApC,KAEA,IAAAvW,SAAAuW,EAEA1P,QAAA4E,KAAA,wEAAAkN,OAEK,IAAApC,EAAA0zB,YAAA,EAOL,WADAC,GAAAf,EAAAxwB,EAAAmxB,EAJAjjC,SAAA4E,KAAA,yEAAAkN,IAWAjW,EAAA6gB,cAAAgK,EAAA/J,SAAAsmB,GACApnC,EAAAynC,YAAA5c,EAAA6c,WAAAjB,EAAAI,gBAIA,QAAAptB,GAAAxD,EAAAmxB,GAEA,GAAAX,GAAA1B,EAAAtyB,IAAAwD,EAEA,QAAAA,EAAApC,MAAAjhB,OAEA,GAAAqjB,EAAAzf,QAAA,GAAAiwC,EAAAa,YAAArxB,EAAAzf,QAAA,CAEAiwC,EAAAC,4BAEAzwB,EAAA3I,iBAAA,UAAA44B,GAEAO,EAAAC,0BAAA7b,EAAA8c,gBAEAjO,EAAA7c,YAIA7c,EAAA6gB,cAAAgK,EAAA/J,SAAAsmB,GACApnC,EAAAynC,YAAA5c,EAAA+c,iBAAAnB,EAAAC,2BAEA7b,EAAAgd,YAAAhd,EAAAid,oBAAA7xB,EAAAX,MAOA,QALAyyB,GAAA9xB,KAAA+xB,oBACAC,EAAAhyB,EAAApC,MAAA,IAAAoC,EAAApC,MAAA,GAAAo0B,cAEAC,KAEAl0C,EAAA,EAAqBA,EAAA,EAAOA,IAE5B+zC,GAAAE,EAMAC,EAAAl0C,GAAAi0C,EAAAhyB,EAAApC,MAAA7f,GAAA6f,MAAAoC,EAAApC,MAAA7f,GAJAk0C,EAAAl0C,GAAAixC,EAAAhvB,EAAApC,MAAA7f,GAAA8oB,EAAAqrB,eAUA,IAAAt0B,GAAAq0B,EAAA,GACAE,EAAAhD,EAAAvxB,GACAw0B,EAAArD,EAAAsD,QAAAryB,EAAA/c,QACAqvC,EAAAvD,EAAAsD,QAAAryB,EAAAxjB,KAEA+1C,GAAA3d,EAAA+c,iBAAA3xB,EAAAmyB,EAEA,QAAAp0C,GAAA,EAAqBA,EAAA,EAAOA,IAE5B,GAAA+zC,EAgBA,OAFAU,GAAA/zB,EAAAwzB,EAAAl0C,GAAA0gB,QAEAg0B,EAAA,EAAAC,EAAAj0B,EAAA9hB,OAA4C81C,EAAAC,EAAQD,IAEpDD,EAAA/zB,EAAAg0B,GAEAzyB,EAAA/c,SAAA6b,IAAAkB,EAAA/c,SAAA0vC,GAEA5oC,EAAA6oC,8BAAAxkC,QAAAgkC,IAAA,EAEAroC,EAAA8oC,qBAAAje,EAAAke,4BAAA/0C,EAAA00C,EAAAL,EAAAI,EAAA7yB,MAAA6yB,EAAA5yB,OAAA,EAAA4yB,EAAAhyB,MAIAtS,QAAA4E,KAAA,mGAMA/I,EAAAgpC,WAAAne,EAAAke,4BAAA/0C,EAAA00C,EAAAL,EAAAI,EAAA7yB,MAAA6yB,EAAA5yB,OAAA,EAAAwyB,EAAAE,EAAAE,EAAAhyB,UAhCAwxB,GAEAjoC,EAAAgpC,WAAAne,EAAAke,4BAAA/0C,EAAA,EAAAq0C,EAAAH,EAAAl0C,GAAA4hB,MAAAsyB,EAAAl0C,GAAA6hB,OAAA,EAAAwyB,EAAAE,EAAAL,EAAAl0C,GAAAyiB,MAIAzW,EAAAgpC,WAAAne,EAAAke,4BAAA/0C,EAAA,EAAAq0C,IAAAE,EAAAL,EAAAl0C,GAoCA4xC,GAAA3vB,EAAAmyB,IAEAvd,EAAAoe,eAAApe,EAAA+c,kBAIAnB,EAAAa,UAAArxB,EAAAzf,QAEAyf,EAAAR,UAAAQ,EAAAR,SAAAQ,OAIAjW,GAAA6gB,cAAAgK,EAAA/J,SAAAsmB,GACApnC,EAAAynC,YAAA5c,EAAA+c,iBAAAnB,EAAAC,2BAQA,QAAAwC,GAAAjzB,EAAAmxB,GAEApnC,EAAA6gB,cAAAgK,EAAA/J,SAAAsmB,GACApnC,EAAAynC,YAAA5c,EAAA+c,iBAAA7C,EAAAtyB,IAAAwD,GAAA4wB,gBAIA,QAAA2B,GAAAW,EAAAlzB,EAAAmyB,GAEA,GAAAjP,EAkCA,IAhCAiP,GAEAvd,EAAAue,cAAAD,EAAAte,EAAAwe,eAAArE,EAAAsD,QAAAryB,EAAAlC,QACA8W,EAAAue,cAAAD,EAAAte,EAAAye,eAAAtE,EAAAsD,QAAAryB,EAAAjC,QAEA6W,EAAAue,cAAAD,EAAAte,EAAA0e,mBAAAvE,EAAAsD,QAAAryB,EAAAhC,YACA4W,EAAAue,cAAAD,EAAAte,EAAA2e,mBAAAxE,EAAAsD,QAAAryB,EAAA/B,cAIA2W,EAAAue,cAAAD,EAAAte,EAAAwe,eAAAxe,EAAA4e,eACA5e,EAAAue,cAAAD,EAAAte,EAAAye,eAAAze,EAAA4e,eAEAxzB,EAAAlC,QAAAa,IAAAqB,EAAAjC,QAAAY,IAEAzQ,QAAA4E,KAAA,gIAAAkN,GAIA4U,EAAAue,cAAAD,EAAAte,EAAA0e,mBAAA1D,EAAA5vB,EAAAhC,YACA4W,EAAAue,cAAAD,EAAAte,EAAA2e,mBAAA3D,EAAA5vB,EAAA/B,YAEA+B,EAAA/B,YAAAwC,IAAAT,EAAA/B,YAAAW,IAEA1Q,QAAA4E,KAAA,kIAAAkN,IAMAkjB,EAAAtE,EAAApiB,IAAA,kCAEA,CAEA,GAAAwD,EAAAxjB,OAAAi3C,IAAA,OAAA7U,EAAApiB,IAAA,kCACA,IAAAwD,EAAAxjB,OAAAk3C,IAAA,OAAA9U,EAAApiB,IAAA,yCAEAwD,EAAA9B,WAAA,GAAA4wB,EAAAtyB,IAAAwD,GAAA2zB,uBAEA/e,EAAAgf,cAAAV,EAAAhQ,EAAA2Q,2BAAAvwC,KAAA2B,IAAA+a,EAAA9B,WAAA2I,EAAAitB,qBACAhF,EAAAtyB,IAAAwD,GAAA2zB,oBAAA3zB,EAAA9B,aAQA,QAAAqzB,GAAAf,EAAAxwB,EAAAmxB,GAEA9pC,SAAAmpC,EAAAG,cAEAH,EAAAG,aAAA,EAEA3wB,EAAA3I,iBAAA,UAAA44B,GAEAO,EAAAI,eAAAhc,EAAA8c,gBAEAjO,EAAA7c,YAIA7c,EAAA6gB,cAAAgK,EAAA/J,SAAAsmB,GACApnC,EAAAynC,YAAA5c,EAAA6c,WAAAjB,EAAAI,gBAEAhc,EAAAgd,YAAAhd,EAAAid,oBAAA7xB,EAAAX,OACAuV,EAAAgd,YAAAhd,EAAAmf,+BAAA/zB,EAAAZ,kBACAwV,EAAAgd,YAAAhd,EAAAof,iBAAAh0B,EAAAV,gBAEA,IAAA1B,GAAAoxB,EAAAhvB,EAAApC,MAAAiJ,EAAA+J,eAEA8e,GAAA1vB,IAAAmvB,EAAAvxB,MAAA,IAEAA,EAAAwxB,EAAAxxB,GAIA,IAAAu0B,GAAAhD,EAAAvxB,GACAw0B,EAAArD,EAAAsD,QAAAryB,EAAA/c,QACAqvC,EAAAvD,EAAAsD,QAAAryB,EAAAxjB,KAEA+1C,GAAA3d,EAAA6c,WAAAzxB,EAAAmyB,EAEA,IAAAK,GAAA/zB,EAAAuB,EAAAvB,OAEA,IAAAuB,EAAAi0B,eAAA,CAIA,GAAAC,GAAAtf,EAAAuf,eAEA,IAAAn0B,EAAAxjB,OAAAi3C,GAAA,CAEA,IAAAW,EAAA,SAAA/1C,OAAA,iDACA61C,GAAAtf,EAAAyf,uBAEKD,KAGLF,EAAAtf,EAAA0f,kBAIAt0B,GAAA/c,SAAAsxC,IAAAL,IAAAtf,EAAAuf,iBAKAn0B,EAAAxjB,OAAAg4C,IAAAx0B,EAAAxjB,OAAAi4C,KAEAvmC,QAAA4E,KAAA,+FAEAkN,EAAAxjB,KAAAg4C,GACAlC,EAAAvD,EAAAsD,QAAAryB,EAAAxjB,OAQAwjB,EAAA/c,SAAAyxC,KAEAR,EAAAtf,EAAA+f,cAKA30B,EAAAxjB,OAAAo4C,KAEA1mC,QAAA4E,KAAA,oFAEAkN,EAAAxjB,KAAAo4C,GACAtC,EAAAvD,EAAAsD,QAAAryB,EAAAxjB,QAMAuN,EAAAgpC,WAAAne,EAAA6c,WAAA,EAAAyC,EAAAt2B,EAAA+B,MAAA/B,EAAAgC,OAAA,EAAAwyB,EAAAE,EAAA,UAEI,IAAAtyB,EAAAgyB,cAMJ,GAAAvzB,EAAA9hB,OAAA,GAAAw1C,EAAA,CAEA,OAAAp0C,GAAA,EAAAk3B,EAAAxW,EAAA9hB,OAA0CoB,EAAAk3B,EAAQl3B,IAElDy0C,EAAA/zB,EAAA1gB,GACAgM,EAAAgpC,WAAAne,EAAA6c,WAAA1zC,EAAAq0C,EAAAI,EAAA7yB,MAAA6yB,EAAA5yB,OAAA,EAAAwyB,EAAAE,EAAAE,EAAAhyB,KAIAR,GAAAb,iBAAA,MAIApV,GAAAgpC,WAAAne,EAAA6c,WAAA,EAAAW,EAAAx0B,EAAA+B,MAAA/B,EAAAgC,OAAA,EAAAwyB,EAAAE,EAAA10B,EAAA4C,UAII,IAAAR,EAAA+xB,oBAEJ,OAAAh0C,GAAA,EAAAk3B,EAAAxW,EAAA9hB,OAAyCoB,EAAAk3B,EAAQl3B,IAEjDy0C,EAAA/zB,EAAA1gB,GAEAiiB,EAAA/c,SAAA6b,IAAAkB,EAAA/c,SAAA0vC,GAEA5oC,EAAA6oC,8BAAAxkC,QAAAgkC,IAAA,EAEAroC,EAAA8oC,qBAAAje,EAAA6c,WAAA1zC,EAAAq0C,EAAAI,EAAA7yB,MAAA6yB,EAAA5yB,OAAA,EAAA4yB,EAAAhyB,MAIAtS,QAAA4E,KAAA,kGAMA/I,EAAAgpC,WAAAne,EAAA6c,WAAA1zC,EAAAq0C,EAAAI,EAAA7yB,MAAA6yB,EAAA5yB,OAAA,EAAAwyB,EAAAE,EAAAE,EAAAhyB,UAcA,IAAA/B,EAAA9hB,OAAA,GAAAw1C,EAAA,CAEA,OAAAp0C,GAAA,EAAAk3B,EAAAxW,EAAA9hB,OAA0CoB,EAAAk3B,EAAQl3B,IAElDy0C,EAAA/zB,EAAA1gB,GACAgM,EAAAgpC,WAAAne,EAAA6c,WAAA1zC,EAAAq0C,IAAAE,EAAAE,EAIAxyB,GAAAb,iBAAA,MAIApV,GAAAgpC,WAAAne,EAAA6c,WAAA,EAAAW,IAAAE,EAAA10B,EAMA+xB,GAAA3vB,EAAAmyB,IAAAvd,EAAAoe,eAAApe,EAAA6c,YAEAjB,EAAAa,UAAArxB,EAAAzf,QAEAyf,EAAAR,UAAAQ,EAAAR,SAAAQ,GAOA,QAAA60B,GAAAC,EAAAxE,EAAAyE,EAAAC,GAEA,GAAA5C,GAAArD,EAAAsD,QAAA/B,EAAAtwB,QAAA/c,QACAqvC,EAAAvD,EAAAsD,QAAA/B,EAAAtwB,QAAAxjB,KACAuN,GAAAgpC,WAAAiC,EAAA,EAAA5C,EAAA9B,EAAA3wB,MAAA2wB,EAAA1wB,OAAA,EAAAwyB,EAAAE,EAAA,MACA1d,EAAAqgB,gBAAArgB,EAAAsgB,YAAAJ,GACAlgB,EAAAugB,qBAAAvgB,EAAAsgB,YAAAH,EAAAC,EAAAlG,EAAAtyB,IAAA8zB,EAAAtwB,SAAA4wB,eAAA,GACAhc,EAAAqgB,gBAAArgB,EAAAsgB,YAAA,MAKA,QAAAE,GAAAC,EAAA/E,GAEA1b,EAAA0gB,iBAAA1gB,EAAA2gB,aAAAF,GAEA/E,EAAArwB,cAAAqwB,EAAApwB,eAEA0U,EAAA4gB,oBAAA5gB,EAAA2gB,aAAA3gB,EAAA0f,kBAAAhE,EAAA3wB,MAAA2wB,EAAA1wB,QACAgV,EAAA6gB,wBAAA7gB,EAAAsgB,YAAAtgB,EAAA8gB,iBAAA9gB,EAAA2gB,aAAAF,IAEI/E,EAAArwB,aAAAqwB,EAAApwB,eAEJ0U,EAAA4gB,oBAAA5gB,EAAA2gB,aAAA3gB,EAAA+f,cAAArE,EAAA3wB,MAAA2wB,EAAA1wB,QACAgV,EAAA6gB,wBAAA7gB,EAAAsgB,YAAAtgB,EAAA+gB,yBAAA/gB,EAAA2gB,aAAAF,IAKAzgB,EAAA4gB,oBAAA5gB,EAAA2gB,aAAA3gB,EAAAghB,MAAAtF,EAAA3wB,MAAA2wB,EAAA1wB,QAIAgV,EAAA0gB,iBAAA1gB,EAAA2gB,aAAA,MAKA,QAAAM,GAAAf,EAAAxE,GAEA,GAAAwF,GAAAxF,KAAAQ,uBACA,IAAAgF,EAAA,SAAAz3C,OAAA,0DAIA,IAFAu2B,EAAAqgB,gBAAArgB,EAAAsgB,YAAAJ,IAEAxE,EAAAnwB,eAAAmwB,EAAAnwB,aAAA8zB,eAEA,SAAA51C,OAAA,sEAKAywC,GAAAtyB,IAAA8zB,EAAAnwB,cAAAywB,gBACAN,EAAAnwB,aAAAvC,MAAA+B,QAAA2wB,EAAA3wB,OACA2wB,EAAAnwB,aAAAvC,MAAAgC,SAAA0wB,EAAA1wB,SAEA0wB,EAAAnwB,aAAAvC,MAAA+B,MAAA2wB,EAAA3wB,MACA2wB,EAAAnwB,aAAAvC,MAAAgC,OAAA0wB,EAAA1wB,OACA0wB,EAAAnwB,aAAAuG,aAAA,GAIArD,EAAAitB,EAAAnwB,aAAA,EAEA,IAAA41B,GAAAjH,EAAAtyB,IAAA8zB,EAAAnwB,cAAAywB,cAEA,IAAAN,EAAAnwB,aAAAld,SAAAsxC,GAEA3f,EAAAugB,qBAAAvgB,EAAAsgB,YAAAtgB,EAAA8gB,iBAAA9gB,EAAA6c,WAAAsE,EAAA,OAEI,IAAAzF,EAAAnwB,aAAAld,SAAAyxC,GAMJ,SAAAr2C,OAAA,8BAJAu2B,GAAAugB,qBAAAvgB,EAAAsgB,YAAAtgB,EAAA+gB,yBAAA/gB,EAAA6c,WAAAsE,EAAA,IAWA,QAAAC,GAAA1F,GAEA,GAAAO,GAAA/B,EAAAtyB,IAAA8zB,GAEAwF,EAAAxF,EAAAQ,2BAAA,CAEA,IAAAR,EAAAnwB,aAAA,CAEA,GAAA21B,EAAA,SAAAz3C,OAAA,2DAEAw3C,GAAAhF,EAAAG,mBAAAV,OAIA,IAAAwF,EAAA,CAEAjF,EAAAI,qBAEA,QAAAlzC,GAAA,EAAqBA,EAAA,EAAOA,IAE5B62B,EAAAqgB,gBAAArgB,EAAAsgB,YAAArE,EAAAG,mBAAAjzC,IACA8yC,EAAAI,mBAAAlzC,GAAA62B,EAAAqhB,qBACAb,EAAAvE,EAAAI,mBAAAlzC,GAAAuyC,OAMA1b,GAAAqgB,gBAAArgB,EAAAsgB,YAAArE,EAAAG,oBACAH,EAAAI,mBAAArc,EAAAqhB,qBACAb,EAAAvE,EAAAI,mBAAAX,EAMA1b,GAAAqgB,gBAAArgB,EAAAsgB,YAAA,MAKA,QAAAgB,GAAA5F,GAEA,GAAAO,GAAA/B,EAAAtyB,IAAA8zB,GACAE,EAAA1B,EAAAtyB,IAAA8zB,EAAAtwB,QAEAswB,GAAAj5B,iBAAA,UAAAg5B,GAEAG,EAAAI,eAAAhc,EAAA8c,gBAEAjO,EAAA7c,UAEA,IAAAkvB,GAAAxF,EAAAQ,2BAAA,EACAqF,EAAAhH,EAAAmB,EAIA,IAAAwF,EAAA,CAEAjF,EAAAG,qBAEA,QAAAjzC,GAAA,EAAoBA,EAAA,EAAOA,IAE3B8yC,EAAAG,mBAAAjzC,GAAA62B,EAAAwhB,wBAMAvF,GAAAG,mBAAApc,EAAAwhB,mBAMA,IAAAN,EAAA,CAEA/rC,EAAAynC,YAAA5c,EAAA+c,iBAAAnB,EAAAI,gBACA2B,EAAA3d,EAAA+c,iBAAArB,EAAAtwB,QAAAm2B,EAEA,QAAAp4C,GAAA,EAAoBA,EAAA,EAAOA,IAE3B82C,EAAAhE,EAAAG,mBAAAjzC,GAAAuyC,EAAA1b,EAAAyhB,kBAAAzhB,EAAAke,4BAAA/0C,EAIA4xC,GAAAW,EAAAtwB,QAAAm2B,IAAAvhB,EAAAoe,eAAApe,EAAA+c,kBACA5nC,EAAAynC,YAAA5c,EAAA+c,iBAAA,UAIA5nC,GAAAynC,YAAA5c,EAAA6c,WAAAjB,EAAAI,gBACA2B,EAAA3d,EAAA6c,WAAAnB,EAAAtwB,QAAAm2B,GACAtB,EAAAhE,EAAAG,mBAAAV,EAAA1b,EAAAyhB,kBAAAzhB,EAAA6c,YAEA9B,EAAAW,EAAAtwB,QAAAm2B,IAAAvhB,EAAAoe,eAAApe,EAAA6c,YACA1nC,EAAAynC,YAAA5c,EAAA6c,WAAA,KAMAnB,GAAArwB,aAEA+1B,EAAA1F,GAMA,QAAAgG,GAAAhG,GAEA,GAAAtwB,GAAAswB,EAAAtwB,QACAm2B,EAAAhH,EAAAmB,EAEA,IAAAX,EAAA3vB,EAAAm2B,GAAA,CAEA,GAAA59B,GAAA+3B,EAAAQ,wBAAAlc,EAAA+c,iBAAA/c,EAAA6c,WACA8E,EAAAzH,EAAAtyB,IAAAwD,GAAA4wB,cAEA7mC,GAAAynC,YAAAj5B,EAAAg+B,GACA3hB,EAAAoe,eAAAz6B,GACAxO,EAAAynC,YAAAj5B,EAAA,OAMA,QAAA64B,GAAApxB,GAEA,GAAA1S,GAAA0S,EAAA1S,GACA42B,EAAAvB,EAAAuB,KAIAkM,GAAA9iC,KAAA42B,IAEAkM,EAAA9iC,GAAA42B,EACAlkB,EAAAzL,UA/xBA,GAEAi7B,GAFA4E,EAAA,mBAAAoC,yBAAA5hB,YAAA4hB,wBACApG,IAoyBAxxC,MAAAykB,eACAzkB,KAAA4kB,iBACA5kB,KAAAq0C,wBACAr0C,KAAAs3C,oBACAt3C,KAAA03C,2BAQA,QAAAG,MAIA,QAAAj6B,GAAAvS,GAEA,GAAAoU,GAAApU,EAAAoU,KACA0C,EAAA+tB,EAAAzwB,EASA,OAPAhX,UAAA0Z,IAEAA,KACA+tB,EAAAzwB,GAAA0C,GAIAA,EAIA,QAAA8W,GAAA5tB,SAEA6kC,GAAA7kC,EAAAoU,MAIA,QAAA9J,GAAAtK,EAAAjM,EAAA4L,GAEA,GAAAyU,GAAApU,EAAAoU,KACA0C,EAAA+tB,EAAAzwB,EAEA0C,GAAA/iB,GAAA4L,EAIA,QAAAuR,KAEA2zB,KAnCA,GAAAA,KAuCA,QACAtyB,MACAqb,SACAtjB,SACA4G,WASA,QAAAu7B,IAAA70B,EAAA+c,EAAAmQ,GAEA,QAAA4H,KAEA,GAAAC,IAAA,EAEAnyC,EAAA,GAAAgb,GACAo3B,EAAA,KACAC,EAAA,GAAAr3B,GAAA,QAEA,QAEAkN,QAAA,SAAAoqB,GAEAF,IAAAE,GAAAH,IAEA/0B,EAAAk1B,mBACAF,EAAAE,IAMAC,UAAA,SAAAC,GAEAL,EAAAK,GAIAniB,SAAA,SAAA5uB,EAAAC,EAAA/B,EAAAiI,EAAAigB,GAEAA,KAAA,IAEApmB,GAAAmG,EAAalG,GAAAkG,EAAQjI,GAAAiI,GAIrB5H,EAAA2O,IAAAlN,EAAAC,EAAA/B,EAAAiI,GAEAyqC,EAAAI,OAAAzyC,MAAA,IAEAod,EAAAqe,WAAAh6B,EAAAC,EAAA/B,EAAAiI,GACAyqC,EAAAtmC,KAAA/L,KAMAmV,MAAA,WAEAg9B,GAAA,EAEAC,EAAA,KACAC,EAAA1jC,KAAA,WAQA,QAAA+jC,KAEA,GAAAP,IAAA,EAEAQ,EAAA,KACAC,EAAA,KACAC,EAAA,IAEA,QAEA7qB,QAAA,SAAAC,GAEAA,EAEAlC,EAAA3I,EAAA01B,YAIAjtB,EAAAzI,EAAA01B,aAMA5qB,QAAA,SAAA6qB,GAEAJ,IAAAI,GAAAZ,IAEA/0B,EAAA21B,aACAJ,EAAAI,IAMAC,QAAA,SAAA1pB,GAEA,GAAAspB,IAAAtpB,EAAA,CAEA,GAAAA,EAEA,OAAAA,GAEA,IAAA2pB,IAEA71B,EAAAkM,UAAAlM,EAAA81B,MACA,MAEA,KAAAC,IAEA/1B,EAAAkM,UAAAlM,EAAAg2B,OACA,MAEA,KAAAC,IAEAj2B,EAAAkM,UAAAlM,EAAAk2B,KACA,MAEA,KAAA/pB,IAEAnM,EAAAkM,UAAAlM,EAAAm2B,OACA,MAEA,KAAAC,IAEAp2B,EAAAkM,UAAAlM,EAAAq2B,MACA,MAEA,KAAAC,IAEAt2B,EAAAkM,UAAAlM,EAAAu2B,OACA,MAEA,KAAAC,IAEAx2B,EAAAkM,UAAAlM,EAAAy2B,QACA,MAEA,KAAAC,IAEA12B,EAAAkM,UAAAlM,EAAA22B,SACA,MAEA,SAEA32B,EAAAkM,UAAAlM,EAAAm2B,YAMAn2B,GAAAkM,UAAAlM,EAAAm2B,OAIAX,GAAAtpB,IAMAipB,UAAA,SAAAC,GAEAL,EAAAK,GAIAniB,SAAA,SAAAtI,GAEA8qB,IAAA9qB,IAEA3K,EAAA42B,WAAAjsB,GACA8qB,EAAA9qB,IAMA5S,MAAA,WAEAg9B,GAAA,EAEAQ,EAAA,KACAC,EAAA,KACAC,EAAA,OAQA,QAAAoB,KAEA,GAAA9B,IAAA,EAEA+B,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,IAEA,QAEAzsB,QAAA,SAAA0sB,GAEAA,EAEA3uB,EAAA3I,EAAAu3B,cAIA9uB,EAAAzI,EAAAu3B,eAMAzsB,QAAA,SAAA0sB,GAEAV,IAAAU,GAAAzC,IAEA/0B,EAAAw3B,eACAV,EAAAU,IAMA5B,QAAA,SAAA6B,EAAAC,EAAAF,GAEAT,IAAAU,GACAT,IAAAU,GACAT,IAAAO,IAEAx3B,EAAAy3B,cAAAC,EAAAF,GAEAT,EAAAU,EACAT,EAAAU,EACAT,EAAAO,IAMAG,MAAA,SAAAC,EAAAC,EAAAC,GAEAZ,IAAAU,GACAT,IAAAU,GACAT,IAAAU,IAEA93B,EAAA+3B,UAAAH,EAAAC,EAAAC,GAEAZ,EAAAU,EACAT,EAAAU,EACAT,EAAAU,IAMA3C,UAAA,SAAAC,GAEAL,EAAAK,GAIAniB,SAAA,SAAA+kB,GAEAX,IAAAW,IAEAh4B,EAAAi4B,aAAAD,GACAX,EAAAW,IAMAjgC,MAAA,WAEAg9B,GAAA,EAEA+B,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,OAkEA,QAAAxH,GAAAl1C,EAAA+b,EAAA/Q,GAEA,GAAAgZ,GAAA,GAAA4W,YAAA,GACApX,EAAA6B,EAAA6vB,eAEA7vB,GAAA2vB,YAAAh1C,EAAAwjB,GACA6B,EAAAsxB,cAAA32C,EAAAqlB,EAAA0xB,mBAAA1xB,EAAAkuB,SACAluB,EAAAsxB,cAAA32C,EAAAqlB,EAAAyxB,mBAAAzxB,EAAAkuB,QAEA,QAAAhyC,GAAA,EAAmBA,EAAAyJ,EAAWzJ,IAE9B8jB,EAAAkxB,WAAAx6B,EAAAxa,EAAA,EAAA8jB,EAAAk4B,KAAA,MAAAl4B,EAAAk4B,KAAAl4B,EAAAwV,cAAA7W,EAIA,OAAAR,GA0BA,QAAAmK,KAEA,OAAApsB,GAAA,EAAAgQ,EAAAisC,EAAAr9C,OAA6CoB,EAAAgQ,EAAOhQ,IAEpDi8C,EAAAj8C,GAAA,EAMA,QAAAqsB,GAAAiM,GAWA,GATA2jB,EAAA3jB,GAAA,EAEA,IAAA4jB,EAAA5jB,KAEAxU,EAAAq4B,wBAAA7jB,GACA4jB,EAAA5jB,GAAA,GAIA,IAAA8jB,EAAA9jB,GAAA,CAEA,GAAA6M,GAAAtE,EAAApiB,IAAA,yBAEA0mB,GAAAkX,yBAAA/jB,EAAA,GACA8jB,EAAA9jB,GAAA,GAMA,QAAAgkB,GAAAhkB,EAAAikB,GAWA,GATAN,EAAA3jB,GAAA,EAEA,IAAA4jB,EAAA5jB,KAEAxU,EAAAq4B,wBAAA7jB,GACA4jB,EAAA5jB,GAAA,GAIA8jB,EAAA9jB,KAAAikB,EAAA,CAEA,GAAApX,GAAAtE,EAAApiB,IAAA,yBAEA0mB,GAAAkX,yBAAA/jB,EAAAikB,GACAH,EAAA9jB,GAAAikB,GAMA,QAAAjwB,KAEA,OAAAtsB,GAAA,EAAAgQ,EAAAksC,EAAAt9C,OAAiDoB,IAAAgQ,IAAShQ,EAE1Dk8C,EAAAl8C,KAAAi8C,EAAAj8C,KAEA8jB,EAAA04B,yBAAAx8C,GACAk8C,EAAAl8C,GAAA,GAQA,QAAAysB,GAAAld,GAEAuZ,EAAAvZ,MAAA,IAEAuU,EAAA2I,OAAAld,GACAuZ,EAAAvZ,IAAA,GAMA,QAAAgd,GAAAhd,GAEAuZ,EAAAvZ,MAAA,IAEAuU,EAAAyI,QAAAhd,GACAuZ,EAAAvZ,IAAA,GAMA,QAAAslC,KAEA,UAAA4H,IAEAA,KAEA5b,EAAApiB,IAAA,mCACAoiB,EAAApiB,IAAA,kCACAoiB,EAAApiB,IAAA,kCACAoiB,EAAApiB,IAAA,kCAIA,OAFAi+B,GAAA54B,EAAA64B,aAAA74B,EAAA84B,4BAEA58C,EAAA,EAAqBA,EAAA08C,EAAA99C,OAAoBoB,IAEzCy8C,EAAAv6C,KAAAw6C,EAAA18C,GAQA,OAAAy8C,GAIA,QAAAtwB,GAAAlE,GAEA,MAAA40B,KAAA50B,IAEAnE,EAAAqI,WAAAlE,GAEA40B,EAAA50B,GAEA,GAQA,QAAA8F,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAYA,GAVAP,IAAA8uB,GAEArwB,EAAA3I,EAAA4I,OAIAH,EAAAzI,EAAA4I,OAIAsB,IAAA+uB,GAAA,CAEA,GAAA/uB,IAAAgvB,GAAAzuB,IAAA0uB,EAEA,OAAAjvB,GAEA,IAAAkvB,IAEA3uB,GAEAzK,EAAAq5B,sBAAAr5B,EAAAs5B,SAAAt5B,EAAAs5B,UACAt5B,EAAAu5B,kBAAAv5B,EAAAw5B,IAAAx5B,EAAAw5B,IAAAx5B,EAAAw5B,IAAAx5B,EAAAw5B,OAIAx5B,EAAAmK,cAAAnK,EAAAs5B,UACAt5B,EAAAy5B,UAAAz5B,EAAA05B,UAAA15B,EAAAw5B,KAGA,MAEA,KAAAG,IAEAlvB,GAEAzK,EAAAq5B,sBAAAr5B,EAAAs5B,SAAAt5B,EAAAs5B,UACAt5B,EAAAu5B,kBAAAv5B,EAAA45B,KAAA55B,EAAA45B,KAAA55B,EAAA65B,oBAAA75B,EAAA85B,uBAIA95B,EAAAmK,cAAAnK,EAAAs5B,UACAt5B,EAAAy5B,UAAAz5B,EAAA45B,KAAA55B,EAAA65B,qBAGA,MAEA,KAAAE,IAEAtvB,GAEAzK,EAAAq5B,sBAAAr5B,EAAAs5B,SAAAt5B,EAAAs5B,UACAt5B,EAAAu5B,kBAAAv5B,EAAA45B,KAAA55B,EAAAg6B,UAAAh6B,EAAA45B,KAAA55B,EAAA05B,aAIA15B,EAAAmK,cAAAnK,EAAAs5B,UACAt5B,EAAAy5B,UAAAz5B,EAAA45B,KAAA55B,EAAAg6B,WAGA,MAEA,SAEAvvB,GAEAzK,EAAAq5B,sBAAAr5B,EAAAs5B,SAAAt5B,EAAAs5B,UACAt5B,EAAAu5B,kBAAAv5B,EAAAw5B,IAAAx5B,EAAA85B,oBAAA95B,EAAAw5B,IAAAx5B,EAAA85B,uBAIA95B,EAAAq5B,sBAAAr5B,EAAAs5B,SAAAt5B,EAAAs5B,UACAt5B,EAAAu5B,kBAAAv5B,EAAA05B,UAAA15B,EAAA85B,oBAAA95B,EAAAw5B,IAAAx5B,EAAA85B,sBAQAG,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,SAIAhwB,MAAAH,EACAI,KAAAH,EACAI,KAAAH,EAEAF,IAAA8vB,GAAA3vB,IAAA8vB,IAEAp6B,EAAAq5B,sBAAAnM,EAAAsD,QAAArmB,GAAA+iB,EAAAsD,QAAAlmB,IAEA2vB,EAAA9vB,EACAiwB,EAAA9vB,GAIAF,IAAA8vB,GAAA7vB,IAAA8vB,GAAA5vB,IAAA8vB,GAAA7vB,IAAA8vB,IAEAt6B,EAAAu5B,kBAAArM,EAAAsD,QAAApmB,GAAA8iB,EAAAsD,QAAAnmB,GAAA6iB,EAAAsD,QAAAjmB,GAAA2iB,EAAAsD,QAAAhmB,IAEA0vB,EAAA9vB,EACA+vB,EAAA9vB,EACAgwB,EAAA9vB,EACA+vB,EAAA9vB,EAMA0uB,GAAAhvB,EACAivB,EAAA1uB,EAIA,QAAA8vB,GAAAhxC,EAAAixC,GAEAjxC,EAAAkiB,OAAA8G,GACA9J,EAAAzI,EAAA0I,WACAC,EAAA3I,EAAA0I,UAEA,IAAAmf,GAAAt+B,EAAAkiB,OAAA2G,EACAooB,KAAA3S,MAEA4S,EAAA5S,GAEAt+B,EAAAuiB,eAAA,EACA7B,EAAA1gB,EAAA2gB,SAAA3gB,EAAA4gB,cAAA5gB,EAAA6gB,SAAA7gB,EAAA8gB,SAAA9gB,EAAA+gB,mBAAA/gB,EAAAghB,cAAAhhB,EAAAihB,cAAAjhB,EAAAkhB,oBACAR,EAAA+uB,IAEA56B,EAAAw3B,QAAArsC,EAAA2iB,WACA9N,EAAAwM,QAAArhB,EAAAshB,WACAzM,EAAA0M,QAAAvhB,EAAAwhB,YACA2vB,EAAA5vB,QAAAvhB,EAAAyhB,YAEA2vB,EAAApxC,EAAAijB,cAAAjjB,EAAAkjB,oBAAAljB,EAAAmjB,oBAMA,QAAA+tB,GAAA5S,GAEA+S,IAAA/S,IAEAA,EAEA7nB,EAAA66B,UAAA76B,EAAA86B,IAIA96B,EAAA66B,UAAA76B,EAAA+6B,KAIAH,EAAA/S,GAMA,QAAAmT,GAAAC,GAEAA,IAAAC,IAEAvyB,EAAA3I,EAAA0I,WAEAuyB,IAAAE,IAEAF,IAAAG,GAEAp7B,EAAAi7B,SAAAj7B,EAAAq7B,MAEMJ,IAAAK,GAENt7B,EAAAi7B,SAAAj7B,EAAAu7B,OAIAv7B,EAAAi7B,SAAAj7B,EAAAw7B,kBAQA/yB,EAAAzI,EAAA0I,WAIAyyB,EAAAF,EAIA,QAAAQ,GAAA39B,GAEAA,IAAA49B,IAEAC,IAAA37B,EAAA47B,UAAA99B,GAEA49B,EAAA59B,GAMA,QAAA68B,GAAAnuB,EAAAqvB,EAAA74B,GAEAwJ,GAEA7D,EAAA3I,EAAA87B,qBAEAC,IAAAF,GAAAG,IAAAh5B,IAEAhD,EAAAwM,cAAAqvB,EAAA74B,GAEA+4B,EAAAF,EACAG,EAAAh5B,IAMAyF,EAAAzI,EAAA87B,qBAMA,QAAA5oB,GAAAjV,GAEAA,EAEA0K,EAAA3I,EAAAi8B,cAIAxzB,EAAAzI,EAAAi8B,cAQA,QAAAlzB,GAAAmzB,GAEA12C,SAAA02C,MAAAl8B,EAAAgJ,SAAAmzB,EAAA,GAEAC,KAAAF,IAEAl8B,EAAA+I,cAAAmzB,GACAE,GAAAF,GAMA,QAAAvM,GAAA0M,EAAA3H,GAEA,OAAA0H,IAEArzB,GAIA,IAAAuzB,GAAAC,GAAAH,GAEA52C,UAAA82C,IAEAA,GAAoB3hD,KAAA6K,OAAA2Y,QAAA3Y,QACpB+2C,GAAAH,IAAAE,GAIAA,EAAA3hD,OAAA0hD,GAAAC,EAAAn+B,UAAAu2B,IAEA10B,EAAA2vB,YAAA0M,EAAA3H,GAAA8H,GAAAH,IAEAC,EAAA3hD,KAAA0hD,EACAC,EAAAn+B,QAAAu2B,GAMA,QAAA1D,KAEA,IAEAhxB,EAAAgxB,qBAAA3yC,MAAA2hB,EAAA9kB,WAEI,MAAAogB,GAEJjP,QAAAiP,MAAA,oBAAAA,IAMA,QAAA41B,KAEA,IAEAlxB,EAAAkxB,WAAA7yC,MAAA2hB,EAAA9kB,WAEI,MAAAogB,GAEJjP,QAAAiP,MAAA,oBAAAA,IAQA,QAAA0C,MAEAy+B,GAAApH,OAAAr3B,MAAA,IAEAgC,EAAAhC,UAAA3L,EAAA2L,EAAAxL,EAAAwL,EAAAzC,EAAAyC,EAAAxC,GACAihC,GAAA9tC,KAAAqP,IAMA,QAAAE,MAEAw+B,GAAArH,OAAAn3B,MAAA,IAEA8B,EAAA9B,WAAA7L,EAAA6L,EAAA1L,EAAA0L,EAAA3C,EAAA2C,EAAA1C,GACAkhC,GAAA/tC,KAAAuP,IAQA,QAAAnG,KAEA,OAAA7b,GAAA,EAAmBA,EAAAk8C,EAAAt9C,OAA8BoB,IAEjD,IAAAk8C,EAAAl8C,KAEA8jB,EAAA04B,yBAAAx8C,GACAk8C,EAAAl8C,GAAA,EAMA8oB,MAEA2zB,EAAA,KAEAyD,GAAA,KACAG,MAEAxD,EAAA,KAEAG,EAAA,KAEA0B,EAAA,KACAO,EAAA,KAEAT,EAAA3iC,QACAqG,EAAArG,QACAsG,EAAAtG,QA/lBA,GAAA2iC,GAAA,GAAA5F,GACA12B,EAAA,GAAAk3B,GACAj3B,EAAA,GAAAw4B,GAEA8F,EAAA38B,EAAA64B,aAAA74B,EAAA48B,oBACAzE,EAAA,GAAA5iB,YAAAonB,GACAvE,EAAA,GAAA7iB,YAAAonB,GACArE,EAAA,GAAA/iB,YAAAonB,GAEA33B,KAEA2zB,EAAA,KAEAI,EAAA,KAEAG,EAAA,KACAe,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAC,EAAA,KACAnB,GAAA,EAEAyB,EAAA,KACAO,EAAA,KAEAO,EAAA,KAEAK,EAAA,KACAC,EAAA,KAEAG,EAAAn8B,EAAA64B,aAAA74B,EAAA68B,kCAEAlB,IAAA,EACAj9C,GAAA,EACAo+C,GAAA98B,EAAA64B,aAAA74B,EAAA+8B,QAEAD,IAAAvwC,QAAA,eAEA7N,GAAAwO,WAAA,kBAAAD,KAAA6vC,IAAA,IACAnB,GAAAj9C,IAAA,GAEGo+C,GAAAvwC,QAAA,oBAEH7N,GAAAwO,WAAA,uBAAAD,KAAA6vC,IAAA,IACAnB,GAAAj9C,IAAA,EAIA,IAAA09C,IAAA,KACAG,MAEAE,GAAA,GAAA7+B,GACA8+B,GAAA,GAAA9+B,GAqBA4+B,KAwhBA,OAvhBAA,IAAAx8B,EAAA4vB,YAAAC,EAAA7vB,EAAA4vB,WAAA5vB,EAAA4vB,WAAA,GACA4M,GAAAx8B,EAAA8vB,kBAAAD,EAAA7vB,EAAA8vB,iBAAA9vB,EAAAixB,4BAAA,GAIAyJ,EAAAznB,SAAA,SACA7U,EAAA6U,SAAA,GACA5U,EAAA4U,SAAA,GAEAtK,EAAA3I,EAAA01B,YACAt3B,EAAAw3B,QAAAzpB,IAEAsuB,GAAA,GACAO,EAAAI,IACAzyB,EAAA3I,EAAA0I,WAEAC,EAAA3I,EAAA4I,OACAqB,EAAAuB,KAwgBAd,SACA9nB,MAAA83C,EACA/vB,MAAAvM,EACA45B,QAAA35B,GAGAiK,iBACAC,kBACAiwB,4BACAhwB,0BACAG,SACAF,UACAsoB,8BAEA1oB,aAEA4B,cACAswB,cAEAE,eACAO,cAEAS,eACAd,mBAEAznB,iBAEAnK,gBACA4mB,cACAqB,uBACAE,aAEAlzB,UACAE,WAEAnG,SAUA,QAAAilC,IAAAh9B,EAAA+c,EAAAhQ,GAIA,QAAAklB,KAEA,GAAAzsC,SAAAy3C,EAAA,MAAAA,EAEA,IAAA5b,GAAAtE,EAAApiB,IAAA,iCAYA,OARAsiC,GAFA,OAAA5b,EAEArhB,EAAA64B,aAAAxX,EAAA6b,gCAIA,EAQA,QAAAvR,GAAAnkB,GAEA,aAAAA,EAAA,CAEA,GAAAxH,EAAAm9B,yBAAAn9B,EAAAoH,cAAApH,EAAAo9B,YAAA51B,UAAA,GACAxH,EAAAm9B,yBAAAn9B,EAAAsH,gBAAAtH,EAAAo9B,YAAA51B,UAAA,EAEA,aAIAA,GAAA,UAIA,kBAAAA,GAEAxH,EAAAm9B,yBAAAn9B,EAAAoH,cAAApH,EAAAq9B,cAAA71B,UAAA,GACAxH,EAAAm9B,yBAAAn9B,EAAAsH,gBAAAtH,EAAAq9B,cAAA71B,UAAA,EAEA,UAMA,OAhDA,GAAAy1B,GAoDAz1B,EAAAhiB,SAAAunB,EAAAvF,UAAAuF,EAAAvF,UAAA,QACA81B,EAAA3R,EAAAnkB,EAEA81B,KAAA91B,IAEAnb,QAAA4E,KAAA,uBAAAuW,EAAA,uBAAA81B,EAAA,YACA91B,EAAA81B,EAIA,IAAAhZ,GAAAvX,EAAAuX,0BAAA,EAEA6X,EAAAn8B,EAAA64B,aAAA74B,EAAAu9B,yBACAC,EAAAx9B,EAAA64B,aAAA74B,EAAAy9B,gCACA1uB,EAAA/O,EAAA64B,aAAA74B,EAAA09B,kBACArN,EAAArwB,EAAA64B,aAAA74B,EAAA29B,2BAEAC,EAAA59B,EAAA64B,aAAA74B,EAAA48B,oBACAtS,EAAAtqB,EAAA64B,aAAA74B,EAAA69B,4BACAC,EAAA99B,EAAA64B,aAAA74B,EAAA+9B,qBACAC,EAAAh+B,EAAA64B,aAAA74B,EAAAi+B,8BAEAnS,EAAA0R,EAAA,EACAU,IAAAnhB,EAAApiB,IAAA,qBACAyvB,EAAA0B,GAAAoS,CAEA,QAEAjM,mBACAtG,kBAEAnkB,YACA8c,yBAEA6X,cACAqB,oBACAzuB,iBACAshB,iBAEAuN,gBACAtT,oBACAwT,cACAE,sBAEAlS,iBACAoS,wBACA9T,uBAaA,QAAA35B,IAAAyJ,EAAAikC,EAAA90B,EAAAC,GAEAgO,GAAAx6B,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAAmd,IAAA1U,SAAA0U,IAAA,GACAnd,KAAA6T,KAAA,EAEA7T,KAAAssB,KAAA7jB,SAAA6jB,IAAA,GACAtsB,KAAAusB,IAAA9jB,SAAA8jB,IAAA,IACAvsB,KAAAqhD,MAAA,GAEArhD,KAAAohD,OAAA34C,SAAA24C,IAAA,EACAphD,KAAAw6B,KAAA,KAEAx6B,KAAAshD,UAAA,GACAthD,KAAAuhD,WAAA,EAEAvhD,KAAAgU,yBAuNA,QAAAwtC,IAAAzgD,GAEA2S,GAAA3T,KAAAC,MAEAA,KAAAyhD,QAAA1gD,MAgBA,QAAA2gD,IAAA9+B,GAoCA,QAAA++B,KAEA,UAAAC,KAAAC,aAAA,CAEA,GAAAC,GAAAF,EAAAG,iBAAA,QACAC,EAAAF,EAAAE,YACAC,EAAAH,EAAAG,YAEAC,GAAAt/B,EAAAu/B,gBACAC,EAAAx/B,EAAAy/B,UAEAz/B,EAAA0/B,qBAAA,EAAAN,EAAAC,EAAA,OAEIx3C,GAAAmN,SAEJgL,EAAA0/B,qBAAAF,EAAArhC,MAAAqhC,EAAAphC,OAAAkhC,GAjDA,GAAAz3C,GAAAzK,KAEA4hD,EAAA,KACAW,EAAA,KAEAC,EAAA,KAEAC,EAAA,GAAApkC,GACAqkC,EAAA,GAAArkC,EAEA,oBAAA7B,SAAA,eAAAA,UAEA+lC,EAAA,GAAA/lC,QAAAmmC,YAIA,IAAA/1B,GAAA,GAAAvO,GAEAukC,EAAA,GAAAlvC,GACAkvC,GAAAC,OAAA,GAAAhiC,GAAA,UACA+hC,EAAA7uB,OAAAnI,OAAA,EAEA,IAAAk3B,GAAA,GAAApvC,GACAovC,GAAAD,OAAA,GAAAhiC,GAAA,WACAiiC,EAAA/uB,OAAAnI,OAAA,EAEA,IAAAm3B,GAAA,GAAAvB,KAAAoB,EAAAE,GACAC,GAAAhvB,OAAAnI,OAAA,GACAm3B,EAAAhvB,OAAAnI,OAAA,EAIA,IAAAw2B,GAAAF,CAuBA,oBAAA1lC,SAEAA,OAAA/D,iBAAA,yBAAAkpC,GAAA,GAMA3hD,KAAA4X,SAAA,EACA5X,KAAAgjD,WAAA,IAEAhjD,KAAAijD,UAAA,WAEA,MAAArB,IAIA5hD,KAAAkjD,UAAA,SAAAl4C,GAEAvC,SAAAuC,IAAA42C,EAAA52C,IAIAhL,KAAAmjD,cAAA,SAAA93C,GAEA5C,SAAA4C,IAAAm3C,EAAAn3C,IAIArL,KAAAojD,UAAA,SAAA/3B,GAEA,UAAAu2B,EAAA,MAAAv2B,EAEAu2B,GAAAyB,UAAAh4B,EAAAiB,KACAs1B,EAAA0B,SAAAj4B,EAAAkB,IAEAq1B,EAAA2B,aAAAhB,EAIA,IAAAiB,GAAAjB,EAAAiB,KACAC,EAAA,OAAAjB,IAAAn3B,CAEA,QAAAm4B,EAAA7oC,SAEA8oC,EAAA9oC,SAAA+oC,UAAAF,EAAA7oC,UAIA8oC,EAAA9oC,SAAAnG,IAAA,OAIA,OAAAgvC,EAAAG,aAEAF,EAAAnnC,WAAAonC,UAAAF,EAAAG,YAIA,IAAAC,GAAAhC,EAAAgC,eAeA,IAbAA,EAEAnB,EAAAiB,UAAAE,EAAAC,4BAIApB,EAAAzrB,gBAAA,EAAAvsB,EAAAu4C,WAAA,GAIAS,EAAA9oC,SAAAmpC,aAAArB,GACAgB,EAAAxsB,oBAEA2qB,EAAAC,gBAAA,QAAAx2B,EAIAu3B,GAAAt2B,KAAAjB,EAAAiB,KACAw2B,EAAAx2B,KAAAjB,EAAAiB,KAEAs2B,EAAAr2B,IAAAlB,EAAAkB,IACAu2B,EAAAv2B,IAAAlB,EAAAkB,IAEAw2B,EAAAl2B,YAAAjb,KAAAyZ,EAAAwB,aACAk2B,EAAAn2B,mBAAAhb,KAAAyZ,EAAAuB,oBAEAg2B,EAAAh2B,mBAAA82B,UAAAnB,EAAAwB,gBACAjB,EAAAl2B,mBAAA82B,UAAAnB,EAAAyB,iBAIAtB,EAAAuB,WAAAxB,GAEAG,EAAAh2B,mBAAAsK,SAAAwrB,GACAI,EAAAl2B,mBAAAsK,SAAAwrB,EAEA,IAAA3oB,GAAA0pB,EAAA1pB,MAEA,QAAAA,IAEAnN,EAAAq3B,WAAAlqB,EAAAlN,aAEA+1B,EAAAh2B,mBAAAsK,SAAAtK,GACAk2B,EAAAl2B,mBAAAsK,SAAAtK,IAMAg2B,EAAA/1B,YAAAo3B,WAAArB,EAAAh2B,oBACAk2B,EAAAj2B,YAAAo3B,WAAAnB,EAAAl2B,oBAEAg2B,EAAAt5B,iBAAAo6B,UAAAnB,EAAA2B,sBACApB,EAAAx5B,iBAAAo6B,UAAAnB,EAAA4B,uBAKApB,EAAAz5B,iBAAA1X,KAAAgxC,EAAAt5B,iBAIA,IAAAyK,GAAA6tB,EAAAwC,WAEA,IAAArwB,EAAAh2B,OAAA,CAEA,GAAAsmD,GAAAtwB,EAAA,EAEA,QAAAswB,EAAAC,YAAA,IAAAD,EAAAC,WAAAvmD,QAEA6kD,EAAAC,OAAAa,UAAAW,EAAAC,YAIA,OAAAD,EAAAE,aAAA,IAAAF,EAAAE,YAAAxmD,QAEA+kD,EAAAD,OAAAa,UAAAW,EAAAE,aAMA,MAAAxB,IAIA/iD,KAAAwkD,kBAAA,WAEA,MAAA/B,IAIAziD,KAAAykD,YAAA,WAEA7C,KAAAC,cAAAD,EAAA6C,eAIAzkD,KAAAuc,QAAA,WAEA,mBAAAC,SAEAA,OAAA1D,oBAAA,yBAAA6oC,IAYA,QAAA+C,IAAAzhC,GAEA,GAAA+c,KAEA,QAEApiB,IAAA,SAAA9f,GAEA,GAAA2K,SAAAu3B,EAAAliC,GAEA,MAAAkiC,GAAAliC,EAIA,IAAAwmC,EAEA,QAAAxmC,GAEA,0BACAwmC,EAAArhB,EAAA0hC,aAAA,wBAAA1hC,EAAA0hC,aAAA,4BAAA1hC,EAAA0hC,aAAA,6BACA,MAEA,sCACArgB,EAAArhB,EAAA0hC,aAAA,mCAAA1hC,EAAA0hC,aAAA,uCAAA1hC,EAAA0hC,aAAA,wCACA,MAEA,qCACArgB,EAAArhB,EAAA0hC,aAAA,kCAAA1hC,EAAA0hC,aAAA,sCAAA1hC,EAAA0hC,aAAA,uCACA,MAEA,sCACArgB,EAAArhB,EAAA0hC,aAAA,mCAAA1hC,EAAA0hC,aAAA,wCACA,MAEA,qCACArgB,EAAArhB,EAAA0hC,aAAA,gCACA,MAEA,SACArgB,EAAArhB,EAAA0hC,aAAA7mD,GAYA,MARA,QAAAwmC,GAEAh1B,QAAA4E,KAAA,wBAAApW,EAAA,6BAIAkiC,EAAAliC,GAAAwmC,EAEAA,IAYA,QAAAsgB,MA+FA,QAAAC,KAEAC,EAAA95C,QAAA+5C,IAEAD,EAAA95C,MAAA+5C,EACAD,EAAAh9B,YAAAk9B,EAAA,GAIAv6C,EAAAw6C,UAAAD,EACAv6C,EAAAy6C,gBAAA,EAIA,QAAAC,GAAAvzB,EAAAvG,EAAA+5B,EAAAC,GAEA,GAAAC,GAAA,OAAA1zB,IAAA7zB,OAAA,EACAwnD,EAAA,IAEA,QAAAD,EAAA,CAIA,GAFAC,EAAAT,EAAA95C,MAEAq6C,KAAA,UAAAE,EAAA,CAEA,GAAAC,GAAAJ,EAAA,EAAAE,EACAG,EAAAp6B,EAAAuB,kBAEA84B,GAAAC,gBAAAF,IAEA,OAAAF,KAAAxnD,OAAAynD,KAEAD,EAAA,GAAAn0C,cAAAo0C,GAIA,QAAArmD,GAAA,EAAAymD,EAAAR,EAAqCjmD,IAAAmmD,IAAenmD,EAAAymD,GAAA,EAEpDC,EAAAj0C,KAAAggB,EAAAzyB,IAAA2kD,aAAA2B,EAAAC,GAEAG,EAAA10B,OAAAzO,QAAA6iC,EAAAK,GACAL,EAAAK,EAAA,GAAAC,EAAAz0B,SAMA0zB,EAAA95C,MAAAu6C,EACAT,EAAAh9B,aAAA,EAMA,MAFArd,GAAAw6C,UAAAK,EAEAC,EAnJA,GAAA96C,GAAAzK,KAEA+kD,EAAA,KACAC,EAAA,EACA3xB,GAAA,EACAyyB,GAAA,EAEAD,EAAA,GAAA30B,IACAw0B,EAAA,GAAA5mC,GAEAgmC,GAAc95C,MAAA,KAAA8c,aAAA,EAEd9nB,MAAA8kD,UACA9kD,KAAAilD,UAAA,EACAjlD,KAAAklD,gBAAA,EAEAllD,KAAAkoB,KAAA,SAAA0J,EAAAm0B,EAAA16B,GAEA,GAAAzT,GACA,IAAAga,EAAA7zB,QACAgoD,GAGA,IAAAf,GACA3xB,CAOA,OALAA,GAAA0yB,EAEAhB,EAAAI,EAAAvzB,EAAAvG,EAAA,GACA25B,EAAApzB,EAAA7zB,OAEA6Z,GAIA5X,KAAAgmD,aAAA,WAEAF,GAAA,EACAX,EAAA,OAIAnlD,KAAAimD,WAAA,WAEAH,GAAA,EACAjB,KAIA7kD,KAAAkmD,SAAA,SAAAt0B,EAAAtC,EAAAC,EAAAlE,EAAA86B,EAAAC,GAEA,IAAA/yB,GAAA,OAAAzB,GAAA,IAAAA,EAAA7zB,QAAA+nD,IAAAv2B,EAIAu2B,EAIAX,EAAA,MAIAN,QAII,CAEJ,GAAAwB,GAAAP,EAAA,EAAAd,EACAsB,EAAA,EAAAD,EAEAd,EAAAY,EAAAI,eAAA,IAEAzB,GAAA95C,MAAAu6C,EAEAA,EAAAJ,EAAAvzB,EAAAvG,EAAAi7B,EAAAF,EAEA,QAAAjnD,GAAA,EAAoBA,IAAAmnD,IAAennD,EAEnComD,EAAApmD,GAAA4lD,EAAA5lD,EAIAgnD,GAAAI,cAAAhB,EACAvlD,KAAAklD,gBAAA51B,EAAAtvB,KAAAilD,UAAA,EACAjlD,KAAAilD,WAAAoB,IAuEA,QAAAG,IAAAvjC,EAAA+c,GAEA,QAAAyT,GAAAtsC,GAEA,GAAAm9B,EAEA,IAAAn9B,IAAAs/C,GAAA,MAAAxjC,GAAAyjC,MACA,IAAAv/C,IAAA4Y,GAAA,MAAAkD,GAAA2xB,aACA,IAAAztC,IAAAw/C,GAAA,MAAA1jC,GAAA2jC,eAEA,IAAAz/C,IAAA0a,GAAA,MAAAoB,GAAAkuB,OACA,IAAAhqC,IAAA8pC,GAAA,MAAAhuB,GAAA4jC,sBACA,IAAA1/C,IAAA+pC,GAAA,MAAAjuB,GAAA6jC,qBAEA,IAAA3/C,IAAA6Y,GAAA,MAAAiD,GAAAmuB,MACA,IAAAjqC,IAAA4/C,GAAA,MAAA9jC,GAAA+jC,qBACA,IAAA7/C,IAAA8Y,GAAA,MAAAgD,GAAAgkC,oBAEA,IAAA9/C,IAAAgZ,GAAA,MAAA8C,GAAAwV,aACA,IAAAtxB,IAAA+/C,GAAA,MAAAjkC,GAAAkkC,sBACA,IAAAhgD,IAAAigD,GAAA,MAAAnkC,GAAAokC,sBACA,IAAAlgD,IAAAmgD,GAAA,MAAArkC,GAAAskC,oBAEA,IAAApgD,IAAAqgD,GAAA,MAAAvkC,GAAAsV,IACA,IAAApxB,IAAAsgD,GAAA,MAAAxkC,GAAAiV,KACA,IAAA/wB,IAAAyuC,GAAA,MAAA3yB,GAAAmL,cACA,IAAAjnB,IAAAugD,GAAA,MAAAzkC,GAAAoV,GACA,IAAAlxB,IAAA0uC,GAAA,MAAA5yB,GAAAmV,YACA,IAAAjxB,IAAA0tC,GAAA,MAAA5xB,GAAA8I,KAEA,IAAA5kB,IAAA2tC,KAEAxQ,EAAAtE,EAAApiB,IAAA,0BAEA,OAAA0mB,GAAA,MAAAA,GAAAqjB,cAIA,IAAAxgD,IAAAygD,GAAA,MAAA3kC,GAAA4kC,KACA,IAAA1gD,IAAA4sC,GAAA,MAAA9wB,GAAA6kC,GACA,IAAA3gD,IAAA+Y,GAAA,MAAA+C,GAAAk4B,IACA,IAAAh0C,IAAA4gD,GAAA,MAAA9kC,GAAA+kC,SACA,IAAA7gD,IAAA8gD,GAAA,MAAAhlC,GAAAilC,eACA,IAAA/gD,IAAAwuC,GAAA,MAAA1yB,GAAAsyB,eACA,IAAApuC,IAAA2uC,GAAA,MAAA7yB,GAAA8yB,aAEA,IAAA5uC,IAAA+nB,GAAA,MAAAjM,GAAAs5B,QACA,IAAAp1C,IAAAghD,GAAA,MAAAllC,GAAAmlC,aACA,IAAAjhD,IAAAkhD,GAAA,MAAAplC,GAAAqlC,qBAEA,IAAAnhD,IAAAohD,GAAA,MAAAtlC,GAAA45B,IACA,IAAA11C,IAAAqhD,GAAA,MAAAvlC,GAAAw5B,GACA,IAAAt1C,IAAAshD,GAAA,MAAAxlC,GAAAg6B,SACA,IAAA91C,IAAAuhD,GAAA,MAAAzlC,GAAA65B,mBACA,IAAA31C,IAAA6nB,GAAA,MAAA/L,GAAA05B,SACA,IAAAx1C,IAAA8nB,GAAA,MAAAhM,GAAA85B,mBACA,IAAA51C,IAAAwhD,GAAA,MAAA1lC,GAAA2lC,SACA,IAAAzhD,IAAA0hD,GAAA,MAAA5lC,GAAA6lC,mBAEA,IAAA3hD,IAAA4hD,GAAA,MAAA9lC,GAAA+lC,SACA,IAAA7hD,IAAA8hD,GAAA,MAAAhmC,GAAAimC,mBACA,IAAA/hD,IAAAgiD,GAAA,MAAAlmC,GAAAmmC,kBAEA,KAAAjiD,IAAAkiD,IAAAliD,IAAAmiD,IACAniD,IAAAoiD,IAAApiD,IAAAqiD,MAEAllB,EAAAtE,EAAApiB,IAAA,iCAEA,OAAA0mB,GAAA,CAEA,GAAAn9B,IAAAkiD,GAAA,MAAA/kB,GAAAmlB,4BACA,IAAAtiD,IAAAmiD,GAAA,MAAAhlB,GAAAolB,6BACA,IAAAviD,IAAAoiD,GAAA,MAAAjlB,GAAAqlB,6BACA,IAAAxiD,IAAAqiD,GAAA,MAAAllB,GAAAslB,8BAMA,IAAAziD,IAAA0iD,IAAA1iD,IAAA2iD,IACA3iD,IAAA4iD,IAAA5iD,IAAA6iD,MAEA1lB,EAAAtE,EAAApiB,IAAA,kCAEA,OAAA0mB,GAAA,CAEA,GAAAn9B,IAAA0iD,GAAA,MAAAvlB,GAAA2lB,+BACA,IAAA9iD,IAAA2iD,GAAA,MAAAxlB,GAAA4lB,+BACA,IAAA/iD,IAAA4iD,GAAA,MAAAzlB,GAAA6lB,gCACA,IAAAhjD,IAAA6iD,GAAA,MAAA1lB,GAAA8lB,iCAMA,GAAAjjD,IAAAkjD,KAEA/lB,EAAAtE,EAAApiB,IAAA,iCAEA,OAAA0mB,GAAA,MAAAA,GAAAgmB,yBAIA,KAAAnjD,IAAAojD,IAAApjD,IAAAqjD,IAAArjD,IAAAsjD,IACAtjD,IAAAujD,IAAAvjD,IAAAwjD,IAAAxjD,IAAAyjD,IACAzjD,IAAA0jD,IAAA1jD,IAAA2jD,IAAA3jD,IAAA4jD,IACA5jD,IAAA6jD,IAAA7jD,IAAA8jD,IAAA9jD,IAAA+jD,IACA/jD,IAAAgkD,IAAAhkD,IAAAikD,MAEA9mB,EAAAtE,EAAApiB,IAAA,iCAEA,OAAA0mB,GAEA,MAAAn9B,EAMA,KAAAA,IAAAkkD,IAAAlkD,IAAAmkD,MAEAhnB,EAAAtE,EAAApiB,IAAA,oBAEA,OAAA0mB,GAAA,CAEA,GAAAn9B,IAAAkkD,GAAA,MAAA/mB,GAAAinB,OACA,IAAApkD,IAAAmkD,GAAA,MAAAhnB,GAAAknB,QAMA,MAAArkD,KAAA6uC,KAEA1R,EAAAtE,EAAApiB,IAAA,uBAEA,OAAA0mB,KAAAmnB,wBAIA;CAIA,OAAUhY,WAQV,QAAAiY,MAEA,GAAAl9B,KAEA,QAEA5Q,IAAA,SAAA0Y,GAEA,GAAA7tB,SAAA+lB,EAAA8H,EAAA5nB,IAEA,MAAA8f,GAAA8H,EAAA5nB,GAIA,IAAAua,EAEA,QAAAqN,EAAA14B,MAEA,uBACAqrB,GACA0X,UAAA,GAAA/mB,GACA/T,MAAA,GAAA6hB,GAEA6O,QAAA,EACAo1B,WAAA,EACAC,aAAA,EACAC,cAAA,GAAAnvC,GAEA,MAEA,iBACAuM,GACAtO,SAAA,GAAAf,GACA+mB,UAAA,GAAA/mB,GACA/T,MAAA,GAAA6hB,GACAtQ,SAAA,EACA00C,QAAA,EACAC,YAAA,EACAC,MAAA,EAEAz1B,QAAA,EACAo1B,WAAA,EACAC,aAAA,EACAC,cAAA,GAAAnvC,GAEA,MAEA,kBACAuM,GACAtO,SAAA,GAAAf,GACA/T,MAAA,GAAA6hB,GACAtQ,SAAA,EACA40C,MAAA,EAEAz1B,QAAA,EACAo1B,WAAA,EACAC,aAAA,EACAC,cAAA,GAAAnvC,GACA0V,iBAAA,EACAC,gBAAA,IAEA,MAEA,uBACApJ,GACA0X,UAAA,GAAA/mB,GACAqyC,SAAA,GAAAvkC,GACAwkC,YAAA,GAAAxkC,GAEA,MAEA,qBACAuB,GACApjB,MAAA,GAAA6hB,GACA/M,SAAA,GAAAf,GACAuyC,UAAA,GAAAvyC,GACAwyC,WAAA,GAAAxyC,IASA,MAFA4U,GAAA8H,EAAA5nB,IAAAua,EAEAA,IAUA,QAAAojC,MA6BA,QAAAC,GAAA99B,EAAAggB,EAAAnjB,GAYA,OAVA/jB,GAAA,EAAAC,EAAA,EAAA/B,EAAA,EAEA+mD,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAEAlH,EAAAp6B,EAAAuB,mBAEAztB,EAAA,EAAAgQ,EAAAqf,EAAAzwB,OAAsCoB,EAAAgQ,EAAOhQ,IAAA,CAE7C,GAAAm3B,GAAA9H,EAAArvB,GAEA0G,EAAAywB,EAAAzwB,MACA+mD,EAAAt2B,EAAAs2B,UACAx1C,EAAAkf,EAAAlf,SAEAyf,EAAAP,EAAAC,QAAAD,EAAAC,OAAApU,IAAAmU,EAAAC,OAAApU,IAAAf,QAAA,IAEA,IAAAkV,EAAAu2B,eAEAvlD,GAAAzB,EAAAyB,EAAAslD,EACArlD,GAAA1B,EAAA0B,EAAAqlD,EACApnD,GAAAK,EAAAL,EAAAonD,MAEK,IAAAt2B,EAAAw2B,mBAAA,CAEL,GAAA7jC,GAAAk9B,EAAAvoC,IAAA0Y,EAUA,IARArN,EAAApjB,MAAA+L,KAAA0kB,EAAAzwB,OAAAiX,eAAAwZ,EAAAs2B,WACA3jC,EAAA0X,UAAA5J,sBAAAT,EAAAzJ,aACAkgC,EAAAh2B,sBAAAT,EAAA3c,OAAAkT,aACA5D,EAAA0X,UAAAhlB,IAAAoxC,GACA9jC,EAAA0X,UAAAqsB,mBAAAvH,GAEAx8B,EAAAsN,OAAAD,EAAApC,WAEAoC,EAAApC,WAAA,CAEA,GAAAqC,GAAAD,EAAAC,MAEAtN,GAAA0iC,WAAAp1B,EAAA02B,KACAhkC,EAAA2iC,aAAAr1B,EAAAxa,OACAkN,EAAA4iC,cAAAt1B,EAAAC,QAIArrB,EAAA+hD,qBAAAX,GAAA11B,EACA1rB,EAAAgiD,wBAAAZ,GAAAj2B,EAAAC,OAAAnZ,OACAjS,EAAAkkC,YAAAkd,GAAAtjC,EAEAsjC,QAEK,IAAAj2B,EAAA82B,YAAA,CAEL,GAAAnkC,GAAAk9B,EAAAvoC,IAAA0Y,EAmBA,IAjBArN,EAAAtO,SAAAoc,sBAAAT,EAAAzJ,aACA5D,EAAAtO,SAAAmpC,aAAA2B,GAEAx8B,EAAApjB,MAAA+L,KAAA/L,GAAAiX,eAAA8vC,GACA3jC,EAAA7R,WAEA6R,EAAA0X,UAAA5J,sBAAAT,EAAAzJ,aACAkgC,EAAAh2B,sBAAAT,EAAA3c,OAAAkT,aACA5D,EAAA0X,UAAAhlB,IAAAoxC,GACA9jC,EAAA0X,UAAAqsB,mBAAAvH,GAEAx8B,EAAA6iC,QAAApnD,KAAA2oD,IAAA/2B,EAAAnjB,OACA8V,EAAA8iC,YAAArnD,KAAA2oD,IAAA/2B,EAAAnjB,OAAA,EAAAmjB,EAAAg3B,WACArkC,EAAA+iC,MAAA,IAAA11B,EAAAlf,SAAA,EAAAkf,EAAA01B,MAEA/iC,EAAAsN,OAAAD,EAAApC,WAEAoC,EAAApC,WAAA,CAEA,GAAAqC,GAAAD,EAAAC,MAEAtN,GAAA0iC,WAAAp1B,EAAA02B,KACAhkC,EAAA2iC,aAAAr1B,EAAAxa,OACAkN,EAAA4iC,cAAAt1B,EAAAC,QAIArrB,EAAAoiD,cAAAd,GAAA51B,EACA1rB,EAAAqiD,iBAAAf,GAAAn2B,EAAAC,OAAAnZ,OACAjS,EAAAokC,KAAAkd,GAAAxjC,EAEAwjC,QAEK,IAAAn2B,EAAAm3B,gBAAA,CAEL,GAAAxkC,GAAAk9B,EAAAvoC,IAAA0Y,EAMArN,GAAApjB,MAAA+L,KAAA/L,GAAAiX,eAAA8vC,GAEA3jC,EAAAtO,SAAAoc,sBAAAT,EAAAzJ,aACA5D,EAAAtO,SAAAmpC,aAAA2B,GAGAiI,EAAAC,WACAC,EAAAh8C,KAAA0kB,EAAAzJ,aACA+gC,EAAAC,YAAApI,GACAiI,EAAAI,gBAAAF,GAEA3kC,EAAAkjC,UAAA33C,IAAA,GAAA8hB,EAAAvV,MAAA,KACAkI,EAAAmjC,WAAA53C,IAAA,KAAA8hB,EAAAtV,OAAA,GAEAiI,EAAAkjC,UAAArI,aAAA4J,GACAzkC,EAAAmjC,WAAAtI,aAAA4J,GAKAviD,EAAAqkC,SAAAkd,GAAAzjC,EAEAyjC,QAEK,IAAAp2B,EAAApE,aAAA,CAEL,GAAAjJ,GAAAk9B,EAAAvoC,IAAA0Y,EAWA,IATArN,EAAAtO,SAAAoc,sBAAAT,EAAAzJ,aACA5D,EAAAtO,SAAAmpC,aAAA2B,GAEAx8B,EAAApjB,MAAA+L,KAAA0kB,EAAAzwB,OAAAiX,eAAAwZ,EAAAs2B,WACA3jC,EAAA7R,SAAAkf,EAAAlf,SACA6R,EAAA+iC,MAAA,IAAA11B,EAAAlf,SAAA,EAAAkf,EAAA01B,MAEA/iC,EAAAsN,OAAAD,EAAApC,WAEAoC,EAAApC,WAAA,CAEA,GAAAqC,GAAAD,EAAAC,MAEAtN,GAAA0iC,WAAAp1B,EAAA02B,KACAhkC,EAAA2iC,aAAAr1B,EAAAxa,OACAkN,EAAA4iC,cAAAt1B,EAAAC,QACAvN,EAAAmJ,iBAAAmE,EAAAlL,OAAAiB,KACArD,EAAAoJ,gBAAAkE,EAAAlL,OAAAkB,IAIAphB,EAAA4iD,eAAAvB,GAAA31B,EACA1rB,EAAA6iD,kBAAAxB,GAAAl2B,EAAAC,OAAAnZ,OACAjS,EAAAmkC,MAAAkd,GAAAvjC,EAEAujC,QAEK,IAAAl2B,EAAA23B,kBAAA,CAEL,GAAAhlC,GAAAk9B,EAAAvoC,IAAA0Y,EAEArN,GAAA0X,UAAA5J,sBAAAT,EAAAzJ,aACA5D,EAAA0X,UAAAqsB,mBAAAvH,GACAx8B,EAAA0X,UAAAutB,YAEAjlC,EAAAgjC,SAAAr6C,KAAA0kB,EAAAzwB,OAAAiX,eAAA8vC,GACA3jC,EAAAijC,YAAAt6C,KAAA0kB,EAAA41B,aAAApvC,eAAA8vC,GAEAzhD,EAAAskC,KAAAkd,GAAA1jC,EAEA0jC,KAMAxhD,EAAAgjD,QAAA,GAAA7mD,EACA6D,EAAAgjD,QAAA,GAAA5mD,EACA4D,EAAAgjD,QAAA,GAAA3oD,EAEA2F,EAAAkkC,YAAAtxC,OAAAwuD,EACAphD,EAAAokC,KAAAxxC,OAAA0uD,EACAthD,EAAAqkC,SAAAzxC,OAAA2uD,EACAvhD,EAAAmkC,MAAAvxC,OAAAyuD,EACArhD,EAAAskC,KAAA1xC,OAAA4uD,EAEAxhD,EAAA83B,KAAA93B,EAAAuD,GAAA,IAAA69C,EAAA,IAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,IAAAC,EAAA,IAAAne,EAAAzwC,OApNA,GAAAooD,GAAA,GAAAuF,IAEAvgD,GAEAuD,GAAA9F,KAEAq6B,KAAA,GAEAkrB,SAAA,OACA9e,eACA6d,wBACAC,2BACA5d,QACAge,iBACAC,oBACAhe,YACAF,SACAye,kBACAC,qBACAve,SAIAsd,EAAA,GAAAnzC,GACAg0C,EAAA,GAAAvvC,GACAqvC,EAAA,GAAArvC,EA+LA,QACAiuC,QACAnhD,SASA,QAAAijD,MAQA,QAAAlmC,KAEAmmC,EAAAtwD,OAAA,EACAuwD,EAAAvwD,OAAA,EACAwwD,EAAAxwD,OAAA,EAIA,QAAAywD,GAAAl4B,GAEA+3B,EAAAhtD,KAAAi1B,GAIA,QAAAm4B,GAAAC,GAEAJ,EAAAjtD,KAAAqtD,GAIA,QAAAC,GAAAD,GAEAH,EAAAltD,KAAAqtD,GAIA,QAAAE,GAAAvjC,GAEAmD,EAAA89B,MAAA+B,EAAAC,EAAAjjC,GAlCA,GAAAmD,GAAA,GAAA69B,IAEAgC,KACAC,KACAC,KAkCApjD,GACAkjD,cACAC,eACAC,eAEA//B,SAGA,QACAtG,OACA/c,QACAyjD,cAEAJ,YACAC,aACAE,cAKA,QAAAE,MAIA,QAAAjxC,GAAAwN,EAAAC,GAEA,GAAA4X,GAAA7X,EAAA1c,GAAA,IAAA2c,EAAA3c,GAEAogD,EAAAC,EAAA9rB,EASA,OAPAx6B,UAAAqmD,IAEAA,EAAA,GAAAV,IACAW,EAAA9rB,GAAA6rB,GAIAA,EAIA,QAAAvyC,KAEAwyC,KArBA,GAAAA,KAyBA,QACAnxC,MACArB,WAaA,QAAAyyC,IAAAh/B,GA4IA,QAAAi/B,KAEAC,GAAA5pB,QACA4pB,GAAAhrB,MAAA,EACAgrB,GAAA5jD,SAAA,EACA4jD,GAAA/mC,MAAA,EACA+mC,GAAA9qB,OAAA,EAIA,QAAA+qB,KAEA,cAAAC,GAAAC,GAAA,EAoEA,QAAAC,KAEAtvB,GAAA,GAAA0kB,IAAA1uB,IACAgK,GAAApiB,IAAA,uBACAoiB,GAAApiB,IAAA,qBACAoiB,GAAApiB,IAAA,4BACAoiB,GAAApiB,IAAA,0BACAoiB,GAAApiB,IAAA,iCACAoiB,GAAApiB,IAAA,4BACAoiB,GAAApiB,IAAA,0BACAoiB,GAAApiB,IAAA,0BAEAuyB,GAAA,GAAAqW,IAAAxwB,GAAAgK,IAEA/X,GAAA,GAAAg4B,IAAAjqB,GAAAgK,GAAAhQ,GAEA7kB,GAAA,GAAA2sC,IAAA9hB,GAAAgK,GAAAmQ,IACAhlC,GAAA8V,QAAAsuC,GAAA39C,KAAA49C,IAAA1yC,eAAAuyC,KACAlkD,GAAAgW,SAAAsuC,GAAA79C,KAAA89C,IAAA5yC,eAAAuyC,KAEAnf,GAAA,GAAA2H,IACA7vB,GAAA,GAAAioB,IAAAja,GAAAgK,GAAA70B,GAAA+kC,GAAAjoB,GAAAkoB,GAAAwf,GAAAT,IACApmC,GAAA,GAAA0O,IAAAxB,IACAkL,GAAA,GAAA0D,IAAA5O,GAAAlN,GAAA6mC,IACAvkD,GAAA,GAAAi6B,IAAAnE,GAAAguB,IACAU,GAAA,GAAAtsB,IAAAtN,IACA65B,GAAA,GAAA5iB,IAAA6iB,EAAA9vB,GAAA/X,IACA8nC,GAAA,GAAA/sB,IACA+rB,GAAA,GAAAF,IAEAxtB,GAAA,GAAAJ,IAAA6uB,EAAA3kD,GAAA+1B,GAAA8uB,GAEAC,GAAA,GAAAxrB,IAAAzO,GAAAgK,GAAAkvB,IACAgB,GAAA,GAAApsB,IAAA9N,GAAAgK,GAAAkvB,IAEAiB,GAAA,GAAApoC,GAAA+nC,EAAA95B,GAAA7qB,GAAA6c,GAAAC,IAEA6nC,EAAAvoC,KAAAqmB,SAAAiiB,GAAAjiB,SAEAkiB,EAAA/lC,QAAAiM,GACA85B,EAAA7nC,gBACA6nC,EAAA9vB,cACA8vB,EAAA5f,cACA4f,EAAAC,eACAD,EAAA3kD,SAuOA,QAAAilD,GAAA97C,GAEAA,EAAAuD,iBAEAvI,QAAAi9B,IAAA,sCAEA8jB,GAAA,EAIA,QAAAC,KAEAhhD,QAAAi9B,IAAA,0CAEA8jB,GAAA,EAEAf,IAIA,QAAAiB,GAAAj8C,GAEA,GAAA9H,GAAA8H,EAAAqF,MAEAnN,GAAAsM,oBAAA,UAAAy3C,GAEAC,EAAAhkD,GAMA,QAAAgkD,GAAAhkD,GAEAikD,EAAAjkD,GAEA0jC,GAAAjX,OAAAzsB,GAKA,QAAAikD,GAAAjkD,GAEA,GAAAsjC,GAAAI,GAAAtyB,IAAApR,GAAA4a,OAEA5a,GAAA4a,QAAA3e,OAEAA,SAAAqnC,GAEA+f,GAAA9f,eAAAD,GAQA,QAAA4gB,GAAArlD,EAAA+b,EAAA5a,GAEAnB,EAAA6f,OAAA,SAAA7f,GAEAykD,EAAAa,sBAAAtlD,EAAA+b,EAAA5a,KAwQA,QAAAokD,GAAApkD,EAAA4a,EAAArb,EAAA8kD,GAEA,GAAA9kD,KAAA+kD,2BAEA,OAAA9wB,GAAApiB,IAAA,0BAGA,WADAtO,SAAAiP,MAAA,iJAOA9V,UAAAooD,MAAA,GAEA1lD,GAAAogB,gBAEA,IAAA2Z,GAAAn5B,EAAA+c,WAEAioC,EAAA3pC,EAAAwlB,gBAEAokB,EAAAxkD,EAAA6zB,sBAEA,QAAAviC,KAAAizD,GAAA,CAEA,GAAAE,GAAAF,EAAAjzD,EAEA,IAAAmzD,GAAA,GAEA,GAAAC,GAAAhsB,EAAApnC,EAEA,IAAA2K,SAAAyoD,EAAA,CAEA,GAAAp1B,GAAAo1B,EAAAp1B,WACApW,EAAAwrC,EAAAr1B,SAEApE,EAAA3O,GAAAlL,IAAAszC,EAIA,IAAAzoD,SAAAgvB,EAAA,QAEA,IAAAK,GAAAL,EAAAK,OACAl6B,EAAA65B,EAAA75B,KACA86B,EAAAjB,EAAAiB,eAEA,IAAAw4B,EAAAl4B,6BAAA,CAEA,GAAApX,GAAAsvC,EAAAtvC,KACAuvC,EAAAvvC,EAAAuvC,OACAj2C,EAAAg2C,EAAAh2C,MAEA0G,MAAAwvC,8BAEAjmD,GAAAswC,0BAAAwV,EAAArvC,EAAA85B,kBAEAjzC,SAAAsD,EAAAy4B,oBAEAz4B,EAAAy4B,kBAAA5iB,EAAA85B,iBAAA95B,EAAAhZ,QAMAuC,GAAAqgB,gBAAAylC,GAIAj7B,GAAAxN,WAAAwN,GAAAvN,aAAAqP,GACA9B,GAAAlK,oBAAAmlC,EAAAvrC,EAAA9nB,EAAAk+B,EAAAq1B,EAAAz4B,GAAAm4B,EAAAM,EAAAj2C,GAAAwd,OAIAw4B,GAAAG,4BAEAlmD,GAAAswC,0BAAAwV,EAAAC,EAAAxV,kBAEAjzC,SAAAsD,EAAAy4B,oBAEAz4B,EAAAy4B,kBAAA0sB,EAAAxV,iBAAAwV,EAAAtoD,QAMAuC,GAAAqgB,gBAAAylC,GAIAj7B,GAAAxN,WAAAwN,GAAAvN,aAAAqP,GACA9B,GAAAlK,oBAAAmlC,EAAAvrC,EAAA9nB,EAAAk+B,EAAA,EAAA+0B,EAAAnrC,EAAAgT,OAIM,IAAAjwB,SAAAuoD,EAAA,CAEN,GAAAhmD,GAAAgmD,EAAAlzD,EAEA,IAAA2K,SAAAuC,EAEA,OAAAA,EAAAjN,QAEA,OACAi4B,GAAAs7B,gBAAAL,EAAAjmD,EACA,MAEA,QACAgrB,GAAAu7B,gBAAAN,EAAAjmD,EACA,MAEA,QACAgrB,GAAAw7B,gBAAAP,EAAAjmD,EACA,MAEA,SACAgrB,GAAAy7B,gBAAAR,EAAAjmD,MAYAG,GAAAsgB,0BA0DA,QAAAimC,KAEAC,KAEAC,IAEAD,IAAA,GAIA,QAAAE,KAEAF,IAAA,EAIA,QAAAC,KAEA,GAAAhQ,GAAAkQ,GAAA7O,WAEArB,MAAAC,aAEAD,EAAAmQ,sBAAAC,GAIAx1C,OAAAu1C,sBAAAC,GAMA,QAAAA,GAAAziD,GAEAoiD,MAAA,IAEAM,GAAA1iD,GAEAqiD,KAoNA,QAAAM,GAAA7mD,EAAAggB,EAAA8mC,GAEA,GAAA9mD,EAAA0hB,WAAA,GAEA,GAAAA,GAAA1hB,EAAA0oB,OAAApjB,KAAA0a,EAAA0I,OAEA,IAAAhH,EAEA,GAAA1hB,EAAA+mD,QAEAC,EAAA7D,UAAAnjD,GAEAA,EAAA6oB,YAEAm+B,EAAA5D,WAAApjD,OAIK,IAAAA,EAAAinD,SAELjnD,EAAA8oB,gBAAAC,GAAAm+B,iBAAAlnD,IAEAgnD,EAAA1D,WAAAtjD,OAIK,IAAAA,EAAAmnD,wBAELL,GAEAM,GAAA17B,sBAAA1rB,EAAAwhB,aACAi3B,aAAA/uB,IAIA29B,EAAArxD,KAAAgK,EAAA,KAAAA,EAAAmB,SAAAimD,GAAAj0C,EAAA,UAEK,KAAAnT,EAAA2oB,QAAA3oB,EAAA0F,QAAA1F,EAAA4oB,YAEL5oB,EAAA2nB,eAEA3nB,EAAA8hC,SAAAx3B,UAIAtK,EAAA8oB,eAAAC,GAAAC,iBAAAhpB,IAAA,CAEA8mD,GAEAM,GAAA17B,sBAAA1rB,EAAAwhB,aACAi3B,aAAA/uB,GAIA,IAAAhpB,GAAAX,GAAAuK,OAAAtK,GACAmB,EAAAnB,EAAAmB,QAEA,IAAApL,MAAAsL,QAAAF,GAIA,OAFA8nB,GAAAvoB,EAAAuoB,OAEAn1B,EAAA,EAAAgQ,EAAAmlB,EAAAv2B,OAA0CoB,EAAAgQ,EAAOhQ,IAAA,CAEjD,GAAAq1B,GAAAF,EAAAn1B,GACAs1B,EAAAjoB,EAAAgoB,EAAAE,cAEAD,MAAA1H,SAEA2lC,EAAArxD,KAAAgK,EAAAU,EAAA0oB,EAAAg+B,GAAAj0C,EAAAgW,OAMOhoB,GAAAugB,SAEP2lC,EAAArxD,KAAAgK,EAAAU,EAAAS,EAAAimD,GAAAj0C,EAAA,MAYA,OAFAsW,GAAAzpB,EAAAypB,SAEA31B,EAAA,EAAAgQ,EAAA2lB,EAAA/2B,OAAwCoB,EAAAgQ,EAAOhQ,IAE/C+yD,EAAAp9B,EAAA31B,GAAAksB,EAAA8mC,IAMA,QAAAQ,GAAAxxB,EAAA/V,EAAAC,EAAAunC,GAEA,OAAAzzD,GAAA,EAAAgQ,EAAAgyB,EAAApjC,OAA0CoB,EAAAgQ,EAAOhQ,IAAA,CAEjD,GAAA2jC,GAAA3B,EAAAhiC,GAEAkM,EAAAy3B,EAAAz3B,OACAU,EAAA+2B,EAAA/2B,SACAS,EAAA/D,SAAAmqD,EAAA9vB,EAAAt2B,SAAAomD,EACAp+B,EAAAsO,EAAAtO,KAEA,IAAAnJ,EAAAwnC,cAAA,CAEAC,GAAAznC,CAIA,QAFAo2B,GAAAp2B,EAAAo2B,QAEA5N,EAAA,EAAAC,EAAA2N,EAAA1jD,OAA0C81C,EAAAC,EAAQD,IAAA,CAElD,GAAAkf,GAAAtR,EAAA5N,EAEA,IAAAxoC,EAAA0oB,OAAApjB,KAAAoiD,EAAAh/B,QAAA,CAEA,GAAA8uB,GAAAkQ,EAAAlQ,OAEAvtC,EAAAutC,EAAAvtC,EAAA09C,GACAv9C,EAAAotC,EAAAptC,EAAAw9C,GACAlyC,EAAA8hC,EAAArkC,EAAAw0C,GACAhyC,EAAA6hC,EAAApkC,EAAAw0C,EAEA9nD,IAAAgW,SAAAsuC,GAAAj7C,IAAAc,EAAAG,EAAAsL,EAAAC,GAAAlE,eAAAuyC,KAEAx7B,EAAAxoB,EAAA+f,EAAA2nC,EAAAhnD,EAAAS,EAAAgoB,SAQAs+B,IAAA,KAEAj/B,EAAAxoB,EAAA+f,EAAAC,EAAAtf,EAAAS,EAAAgoB,IAQA,QAAAX,GAAAxoB,EAAA+f,EAAAC,EAAAtf,EAAAS,EAAAgoB,GAQA,GANAnpB,EAAA2hB,eAAA8iC,EAAA1kC,EAAAC,EAAAtf,EAAAS,EAAAgoB,GACA69B,EAAAtD,GAAAnxC,IAAAwN,EAAA0nC,IAAAznC,GAEAhgB,EAAAge,gBAAAsD,iBAAAtB,EAAAuB,mBAAAvhB,EAAAwhB,aACAxhB,EAAA8uB,aAAAwrB,gBAAAt6C,EAAAge,iBAEAhe,EAAAmnD,wBAAA,CAEA,GAAA/U,GAAApyC,EAAA2oB,QAAA3oB,EAAAwhB,YAAAqmC,cAAA,CAEA/nD,IAAAqyC,YAAAhxC,EAAAixC,EAEA,IAAAr2B,GAAA+rC,EAAA9nC,EAAAD,EAAAgB,IAAA5f,EAAAnB,EAEA+nD,IAAA,GAEA1C,EAAArlD,EAAA+b,EAAA5a,OAIAsjD,GAAAj7B,mBAAAxJ,EAAAD,EAAAgB,IAAArgB,EAAAS,EAAAnB,EAAAmpB,EAIAnpB,GAAAgjB,cAAAyhC,EAAA1kC,EAAAC,EAAAtf,EAAAS,EAAAgoB,GACA69B,EAAAtD,GAAAnxC,IAAAwN,EAAA0nC,IAAAznC,GAIA,QAAAgoC,GAAA7mD,EAAA4f,EAAA/gB,GAEA,GAAAioD,GAAApjB,GAAAtyB,IAAApR,GAEAgiB,EAAA6jC,EAAAlnD,MAAAqjB,OACA8/B,EAAA+D,EAAAlnD,MAAAmjD,aAEAt+B,EAAA6/B,GAAAthB,cACA/hC,EAAAgiB,EAAArjB,MAAAmjD,EAAAliC,EAAAmnC,GAAAtO,UAAAsO,GAAArO,gBAAA75C,GAEA09B,EAAA8mB,GAAAngB,eAAAljC,EAAAwjB,GAEA5I,EAAAksC,EAAAlsC,QACAosC,GAAA,CAEA,IAAA/qD,SAAA2e,EAGA5a,EAAAiM,iBAAA,UAAA83C,OAEI,IAAAnpC,EAAA2hB,SAGJ0nB,EAAAjkD,OAEI,IAAA8mD,EAAAG,aAAAjlC,EAAArjB,MAAA83B,KAEJiN,GAAAv6B,OAAAnJ,EAAA,aAAAgiB,EAAArjB,MAAA83B,MACAuwB,GAAA,MAEI,IAAA/qD,SAAAunB,EAAA2e,SAGJ,MAKA6kB,IAAA,EAIA,GAAAA,EAAA,CAEA,GAAAxjC,EAAA2e,SAAA,CAEA,GAAAhJ,GAAA7D,GAAA9R,EAAA2e,SAEA2kB,GAAA3tB,QACA7nC,KAAA0O,EAAA5O,KACAqrB,SAAAyqC,GAAA7mD,MAAA84B,EAAA1c,UACAkB,aAAAwb,EAAAxb,aACAG,eAAAqb,EAAArb,oBAKAgpC,GAAA3tB,QACA7nC,KAAA0O,EAAA5O,KACAqrB,SAAAzc,EAAAyc,SACAkB,aAAA3d,EAAA2d,aACAG,eAAA9d,EAAA8d,eAKA9d,GAAAmjC,gBAAA2jB,EAAA3tB,QAEAve,EAAAyoC,GAAAjgB,eAAApjC,EAAA8mD,EAAA3tB,OAAA3V,EAAA+Y,GAEAuqB,EAAAlsC,UACA5a,EAAA4a,UAIA,GAAA2pC,GAAA3pC,EAAAwlB,eAEA,IAAApgC,EAAA4jB,aAAA,CAEA5jB,EAAAmnD,yBAAA,CAEA,QAAAx0D,GAAA,EAAoBA,EAAA2wD,EAAA3gB,gBAA2BhwC,IAE/C4xD,EAAA,cAAA5xD,IAAA,GAEAqN,EAAAmnD,2BAQA,GAAAnnD,EAAAwuB,aAAA,CAEAxuB,EAAAonD,yBAAA,CAEA,QAAAz0D,GAAA,EAAoBA,EAAA2wD,EAAA1gB,gBAA2BjwC,IAE/C4xD,EAAA,cAAA5xD,IAAA,GAEAqN,EAAAonD,2BAQA,GAAA3qC,GAAAqqC,EAAA3tB,OAAA1c,UAEAzc,EAAAqnD,kBACArnD,EAAA49B,sBACA59B,EAAAuzB,YAAA,IAEAuzB,EAAAjrB,kBAAAkrB,GAAAtO,UACAqO,EAAApO,gBAAAqO,GAAArO,gBACAj8B,EAAAoG,eAAAkkC,GAAAzO,SAIAwO,EAAAlnC,MAIAknC,EAAAG,WAAAjlC,EAAArjB,MAAA83B,KAEAz2B,EAAAgiB,SAIAvF,EAAA6qC,kBAAA9oD,MAAAwjB,EAAArjB,MAAAgjD,QACAllC,EAAA8qC,kBAAA/oD,MAAAwjB,EAAArjB,MAAAkkC,YACApmB,EAAA+qC,WAAAhpD,MAAAwjB,EAAArjB,MAAAokC,KACAtmB,EAAAgrC,eAAAjpD,MAAAwjB,EAAArjB,MAAAqkC,SACAvmB,EAAAirC,YAAAlpD,MAAAwjB,EAAArjB,MAAAmkC,MACArmB,EAAAkrC,iBAAAnpD,MAAAwjB,EAAArjB,MAAAskC,KAEAxmB,EAAAikC,qBAAAliD,MAAAwjB,EAAArjB,MAAA+hD,qBACAjkC,EAAAkkC,wBAAAniD,MAAAwjB,EAAArjB,MAAAgiD,wBACAlkC,EAAAskC,cAAAviD,MAAAwjB,EAAArjB,MAAAoiD,cACAtkC,EAAAukC,iBAAAxiD,MAAAwjB,EAAArjB,MAAAqiD,iBACAvkC,EAAA8kC,eAAA/iD,MAAAwjB,EAAArjB,MAAA4iD,eACA9kC,EAAA+kC,kBAAAhjD,MAAAwjB,EAAArjB,MAAA6iD,kBAKA,IAAAoG,GAAAd,EAAAlsC,QAAAyc,cACAwwB,EACAltC,EAAAmtC,aAAAF,EAAAlyC,IAAA+G,EAEAqqC,GAAAe,eAIA,QAAAlB,GAAA9nC,EAAAe,EAAA5f,EAAAnB,GAEAkpD,GAAA,CAEA,IAAAjB,GAAApjB,GAAAtyB,IAAApR,GACAgiB,EAAA6jC,EAAAlnD,MAAAqjB,MAEA,IAAAgmC,KAEAC,IAAAppC,IAAAqpC,IAAA,CAEA,GAAAC,GACAtpC,IAAAqpC,IACAloD,EAAAkC,KAAAkmD,EAKArB,IAAArN,SACA15C,EAAA6iB,eAAA7iB,EAAA8iB,iBAAA9iB,EAAA+iB,YACAlE,EAAAioC,EAAAqB,GAMAnoD,EAAAsb,eAAA,IAEArf,SAAA6qD,EAAAlsC,QAEA5a,EAAAsb,aAAA,EAEKtb,EAAA4f,KAAAknC,EAAAlnC,QAEL5f,EAAAsb,aAAA,EAEKtb,EAAAgiB,QAAA8kC,EAAAG,aAAAjlC,EAAArjB,MAAA83B,KAELz2B,EAAAsb,aAAA,EAEKrf,SAAA6qD,EAAAjrB,mBACLirB,EAAAjrB,oBAAAkrB,GAAAtO,WACAqO,EAAApO,kBAAAqO,GAAArO,kBAEA14C,EAAAsb,aAAA,IAMAtb,EAAAsb,cAEAurC,EAAA7mD,EAAA4f,EAAA/gB,GACAmB,EAAAsb,aAAA,EAIA,IAAA+sC,IAAA,EACAC,GAAA,EACAC,GAAA,EAEA3tC,EAAAksC,EAAAlsC,QACA4tC,EAAA5tC,EAAAyc,cACAoxB,EAAA3B,EAAA3tB,OAAA1c,QAkBA,IAhBA9d,GAAAmgB,WAAAlE,aAEAytC,GAAA,EACAC,GAAA,EACAC,GAAA,GAIAvoD,EAAAkC,KAAAkmD,KAEAA,GAAApoD,EAAAkC,GAEAomD,GAAA,GAIAD,GAAAxpC,IAAAqpC,GAAA,CA6BA,GA3BAM,EAAA1uC,SAAA0P,GAAA,mBAAA3K,EAAA/B,kBAEArB,GAAAsf,wBAEAytB,EAAA1uC,SAAA0P,GAAA,gBACA,GAAAtxB,KAAA6nC,IAAAlhB,EAAAkB,IAAA,GAAA7nB,KAAAwwD,MAMAR,MAAA5B,IAAAznC,KAEAqpC,GAAA5B,IAAAznC,EAMAypC,GAAA,EACAC,GAAA,GAOAvoD,EAAAqnD,kBACArnD,EAAA2oD,qBACA3oD,EAAA4oD,wBACA5oD,EAAA8yB,OAAA,CAEA,GAAA+1B,GAAAL,EAAA7yC,IAAAmzC,cAEA7sD,UAAA4sD,GAEAA,EAAA/uC,SAAA0P,GACAy8B,GAAA17B,sBAAA1L,EAAAwB,eAMArgB,EAAA2oD,qBACA3oD,EAAA+oD,uBACA/oD,EAAAgpD,qBACAhpD,EAAA4oD,wBACA5oD,EAAAqnD,kBACArnD,EAAA2jB,WAEA6kC,EAAA1uC,SAAA0P,GAAA,aAAA3K,EAAAuB,oBAUA,GAAApgB,EAAA2jB,SAAA,CAEA6kC,EAAAS,YAAAz/B,GAAA3qB,EAAA,cACA2pD,EAAAS,YAAAz/B,GAAA3qB,EAAA,oBAEA,IAAA8hC,GAAA9hC,EAAA8hC,QAEA,IAAAA,EAAA,CAEA,GAAAC,GAAAD,EAAAC,KAEA,IAAAnlB,GAAAolB,oBAAA,CAEA,GAAA5kC,SAAA0kC,EAAAuoB,YAAA,CAUA,GAAAhwC,GAAAhhB,KAAA2S,KAAA,EAAA+1B,EAAArvC,OACA2nB,GAAAhG,GAAAi2C,eAAAjwC,GACAA,EAAAhhB,KAAA0B,IAAAsf,EAAA,EAEA,IAAAkwC,GAAA,GAAAxkD,cAAAsU,IAAA,EACAkwC,GAAAphD,IAAA24B,EAAAyoB,aAEA,IAAAF,GAAA,GAAA/zC,GAAAi0C,EAAAlwC,IAAAxF,GAAA20B,GACA6gB,GAAA5tC,aAAA,EAEAqlB,EAAAyoB,eACAzoB,EAAAuoB,cACAvoB,EAAA0oB,gBAAAnwC,EAIAsvC,EAAA1uC,SAAA0P,GAAA,cAAAmX,EAAAuoB,aACAV,EAAA1uC,SAAA0P,GAAA,kBAAAmX,EAAA0oB,qBAIAb,GAAAS,YAAAz/B,GAAAmX,EAAA,iBAoIA,MA5HA2nB,KAEAE,EAAA1uC,SAAA0P,GAAA,sBAAA85B,EAAAgG,qBACAd,EAAA1uC,SAAA0P,GAAA,wBAAA85B,EAAAiG,uBAEAvpD,EAAAgiB,QAWAwnC,EAAAf,EAAAF,GAMA3oC,GAAA5f,EAAA4f,KAEA6pC,EAAAhB,EAAA7oC,GAIA5f,EAAAgpD,oBAEAU,EAAAjB,EAAAzoD,GAEKA,EAAA+oD,uBAELW,EAAAjB,EAAAzoD,GACA2pD,EAAAlB,EAAAzoD,IAEKA,EAAA2oD,qBAELe,EAAAjB,EAAAzoD,GAEAA,EAAA4pD,mBAEAC,EAAApB,EAAAzoD,GAIA8pD,EAAArB,EAAAzoD,IAIKA,EAAA4oD,wBAELc,EAAAjB,EAAAzoD,GAEAA,EAAA+pD,uBAEAC,EAAAvB,EAAAzoD,GAIAiqD,EAAAxB,EAAAzoD,IAIKA,EAAAkqD,qBAELR,EAAAjB,EAAAzoD,GACAmqD,EAAA1B,EAAAzoD,IAEKA,EAAAonB,wBAELsiC,EAAAjB,EAAAzoD,GACAoqD,EAAA3B,EAAAzoD,IAEKA,EAAAqqD,sBAELX,EAAAjB,EAAAzoD,GACAsqD,EAAA7B,EAAAzoD,IAEKA,EAAAuqD,qBAELC,EAAA/B,EAAAzoD,GAEAA,EAAAyqD,sBAEAC,EAAAjC,EAAAzoD,IAIKA,EAAA2qD,iBAELC,EAAAnC,EAAAzoD,GAEKA,EAAA6qD,mBAELpC,EAAApvD,MAAAmF,MAAAwB,EAAA3G,MACAovD,EAAA7rC,QAAApe,MAAAwB,EAAA4c,SAOA3gB,SAAAwsD,EAAAqC,QAAArC,EAAAqC,MAAAtsD,MAAAusD,GAAAC,OACA/uD,SAAAwsD,EAAAwC,QAAAxC,EAAAwC,MAAAzsD,MAAAusD,GAAAG,OAEAvwC,EAAAwwC,OAAA3hC,GAAAs9B,EAAAe,aAAAY,EAAAnF,IAIAtjD,EAAAqnD,kBAAArnD,EAAAg0B,sBAAA,IAEArZ,EAAAwwC,OAAA3hC,GAAAs9B,EAAAe,aAAAY,EAAAnF,GACAtjD,EAAAg0B,oBAAA,GAMAw0B,EAAA1uC,SAAA0P,GAAA,kBAAA3qB,EAAAge,iBACA2rC,EAAA1uC,SAAA0P,GAAA,eAAA3qB,EAAA8uB,cACA66B,EAAA1uC,SAAA0P,GAAA,cAAA3qB,EAAAwhB,aAEAzF,EAMA,QAAA8uC,GAAAjtC,EAAAzc,GAEAyc,EAAAG,QAAApe,MAAAwB,EAAA4c,QAEA5c,EAAA3G,QAEAojB,EAAA2uC,QAAA5sD,MAAAwB,EAAA3G,OAIA2G,EAAAqrD,UAEA5uC,EAAA4uC,SAAA7sD,MAAA4G,KAAApF,EAAAqrD,UAAA/6C,eAAAtQ,EAAAsrD,mBAIAtrD,EAAA2V,MAEA8G,EAAA9G,IAAAnX,MAAAwB,EAAA2V,KAIA3V,EAAA6jB,WAEApH,EAAAoH,SAAArlB,MAAAwB,EAAA6jB,UAIA7jB,EAAA6yB,cAEApW,EAAAoW,YAAAr0B,MAAAwB,EAAA6yB,aAIA7yB,EAAA8yB,SAEArW,EAAAqW,OAAAt0B,MAAAwB,EAAA8yB,OAMArW,EAAA8uC,WAAA/sD,MAAAwB,EAAA8yB,QAAA9yB,EAAA8yB,OAAAsC,eAAA,IAEA3Y,EAAAwW,aAAAz0B,MAAAwB,EAAAizB,aACAxW,EAAAyW,gBAAA10B,MAAAwB,EAAAkzB,iBAIAlzB,EAAAyyB,WAEAhW,EAAAgW,SAAAj0B,MAAAwB,EAAAyyB,SACAhW,EAAAiW,kBAAAl0B,MAAAwB,EAAA0yB,mBAIA1yB,EAAA2yB,QAEAlW,EAAAkW,MAAAn0B,MAAAwB,EAAA2yB,MACAlW,EAAAmW,eAAAp0B,MAAAwB,EAAA4yB,eAYA,IAAA44B,EAwCA,IAtCAxrD,EAAA2V,IAEA61C,EAAAxrD,EAAA2V,IAEI3V,EAAA6yB,YAEJ24B,EAAAxrD,EAAA6yB,YAEI7yB,EAAA8jB,gBAEJ0nC,EAAAxrD,EAAA8jB,gBAEI9jB,EAAA86B,UAEJ0wB,EAAAxrD,EAAA86B,UAEI96B,EAAA66B,QAEJ2wB,EAAAxrD,EAAA66B,QAEI76B,EAAAk+B,aAEJstB,EAAAxrD,EAAAk+B,aAEIl+B,EAAAm+B,aAEJqtB,EAAAxrD,EAAAm+B,aAEIn+B,EAAA6jB,SAEJ2nC,EAAAxrD,EAAA6jB,SAEI7jB,EAAAi+B,cAEJutB,EAAAxrD,EAAAi+B,aAIAhiC,SAAAuvD,EAAA,CASA,GANAA,EAAArqB,sBAEAqqB,IAAA52C,SAIA42C,EAAA13C,oBAAA,GAEA,GAAApF,GAAA88C,EAAA98C,OACAkF,EAAA43C,EAAA53C,OACAC,EAAA23C,EAAA33C,SACA1C,EAAAq6C,EAAAr6C,MAEAq6C,GAAA56C,OAAA66C,eAAA/8C,EAAA5F,EAAA4F,EAAAzF,EAAA2K,EAAA9K,EAAA8K,EAAA3K,EAAA4K,EAAA1C,EAAArI,EAAAqI,EAAAlI,GAIAwT,EAAAivC,YAAAltD,MAAA4G,KAAAomD,EAAA56C,SAMA,QAAA45C,GAAA/tC,EAAAzc,GAEAyc,EAAA2uC,QAAA5sD,MAAAwB,EAAA3G,MACAojB,EAAAG,QAAApe,MAAAwB,EAAA4c,QAIA,QAAA8tC,GAAAjuC,EAAAzc,GAEAyc,EAAAkvC,SAAAntD,MAAAwB,EAAA2rD,SACAlvC,EAAAmvC,UAAAptD,MAAAwB,EAAA2rD,SAAA3rD,EAAA6rD,QACApvC,EAAAtV,MAAA3I,MAAAwB,EAAAmH,MAIA,QAAAyjD,GAAAnuC,EAAAzc,GASA,GAPAyc,EAAA2uC,QAAA5sD,MAAAwB,EAAA3G,MACAojB,EAAAG,QAAApe,MAAAwB,EAAA4c,QACAH,EAAAvD,KAAA1a,MAAAwB,EAAAkZ,KAAA2pC,GACApmC,EAAAtV,MAAA3I,MAAA,GAAAioD,GAEAhqC,EAAA9G,IAAAnX,MAAAwB,EAAA2V,IAEA,OAAA3V,EAAA2V,IAAA,CAEA,GAAA3V,EAAA2V,IAAA7B,oBAAA,GAEA,GAAApF,GAAA1O,EAAA2V,IAAAjH,OACAkF,EAAA5T,EAAA2V,IAAA/B,OACAC,EAAA7T,EAAA2V,IAAA9B,SACA1C,EAAAnR,EAAA2V,IAAAxE,MAEAnR,GAAA2V,IAAA/E,OAAA66C,eAAA/8C,EAAA5F,EAAA4F,EAAAzF,EAAA2K,EAAA9K,EAAA8K,EAAA3K,EAAA4K,EAAA1C,EAAArI,EAAAqI,EAAAlI,GAIAwT,EAAAivC,YAAAltD,MAAA4G,KAAApF,EAAA2V,IAAA/E,SAMA,QAAA64C,GAAAhtC,EAAAmD,GAEAnD,EAAAU,SAAA3e,MAAAohB,EAAAvmB,MAEAumB,EAAAC,OAEApD,EAAAQ,QAAAze,MAAAohB,EAAAE,KACArD,EAAAS,OAAA1e,MAAAohB,EAAAG,KAEIH,EAAAI,YAEJvD,EAAAO,WAAAxe,MAAAohB,EAAAK,SAMA,QAAA0pC,GAAAltC,EAAAzc,GAEAA,EAAAi+B,cAEAxhB,EAAAwhB,YAAAz/B,MAAAwB,EAAAi+B,aAMA,QAAA6rB,GAAArtC,EAAAzc,GAEAyc,EAAAqvC,SAAAttD,MAAAwB,EAAA8rD,SACArvC,EAAAsvC,UAAAvtD,MAAAtG,KAAA0B,IAAAoG,EAAA+rD,UAAA,MAEA/rD,EAAAi+B,cAEAxhB,EAAAwhB,YAAAz/B,MAAAwB,EAAAi+B,aAIAj+B,EAAA66B,UAEApe,EAAAoe,QAAAr8B,MAAAwB,EAAA66B,QACApe,EAAAuvC,UAAAxtD,MAAAwB,EAAAgsD,WAIAhsD,EAAA86B,YAEAre,EAAAqe,UAAAt8B,MAAAwB,EAAA86B,UACAre,EAAAwvC,YAAAztD,MAAA4G,KAAApF,EAAAisD,cAIAjsD,EAAA8jB,kBAEArH,EAAAqH,gBAAAtlB,MAAAwB,EAAA8jB,gBACArH,EAAAsH,kBAAAvlB,MAAAwB,EAAA+jB,kBACAtH,EAAAuH,iBAAAxlB,MAAAwB,EAAAgkB,kBAMA,QAAA6lC,GAAAptC,EAAAzc,GAEA8pD,EAAArtC,EAAAzc,GAEAA,EAAAy+B,cAEAhiB,EAAAgiB,YAAAjgC,MAAAwB,EAAAy+B,aAMA,QAAAwrB,GAAAxtC,EAAAzc,GAEAyc,EAAAyvC,UAAA1tD,MAAAwB,EAAAksD,UACAzvC,EAAA0vC,UAAA3tD,MAAAwB,EAAAmsD,UAEAnsD,EAAAk+B,eAEAzhB,EAAAyhB,aAAA1/B,MAAAwB,EAAAk+B,cAIAl+B,EAAAm+B,eAEA1hB,EAAA0hB,aAAA3/B,MAAAwB,EAAAm+B,cAIAn+B,EAAAi+B,cAEAxhB,EAAAwhB,YAAAz/B,MAAAwB,EAAAi+B,aAIAj+B,EAAA66B,UAEApe,EAAAoe,QAAAr8B,MAAAwB,EAAA66B,QACApe,EAAAuvC,UAAAxtD,MAAAwB,EAAAgsD,WAIAhsD,EAAA86B,YAEAre,EAAAqe,UAAAt8B,MAAAwB,EAAA86B,UACAre,EAAAwvC,YAAAztD,MAAA4G,KAAApF,EAAAisD,cAIAjsD,EAAA8jB,kBAEArH,EAAAqH,gBAAAtlB,MAAAwB,EAAA8jB,gBACArH,EAAAsH,kBAAAvlB,MAAAwB,EAAA+jB,kBACAtH,EAAAuH,iBAAAxlB,MAAAwB,EAAAgkB,kBAIAhkB,EAAA8yB,SAGArW,EAAA2vC,gBAAA5tD,MAAAwB,EAAAosD,iBAMA,QAAApC,GAAAvtC,EAAAzc,GAEAyc,EAAA4vC,UAAA7tD,MAAAwB,EAAAqsD,UACA5vC,EAAA6vC,mBAAA9tD,MAAAwB,EAAAssD,mBAEArC,EAAAxtC,EAAAzc,GAIA,QAAAmqD,GAAA1tC,EAAAzc,GAEAA,EAAA8jB,kBAEArH,EAAAqH,gBAAAtlB,MAAAwB,EAAA8jB,gBACArH,EAAAsH,kBAAAvlB,MAAAwB,EAAA+jB,kBACAtH,EAAAuH,iBAAAxlB,MAAAwB,EAAAgkB,kBAMA,QAAAomC,GAAA3tC,EAAAzc,GAEAA,EAAA8jB,kBAEArH,EAAAqH,gBAAAtlB,MAAAwB,EAAA8jB,gBACArH,EAAAsH,kBAAAvlB,MAAAwB,EAAA+jB,kBACAtH,EAAAuH,iBAAAxlB,MAAAwB,EAAAgkB,kBAIAvH,EAAA4H,kBAAA7lB,MAAA4G,KAAApF,EAAAqkB,mBACA5H,EAAA6H,aAAA9lB,MAAAwB,EAAAskB,aACA7H,EAAA8H,YAAA/lB,MAAAwB,EAAAukB,YAIA,QAAA+lC,GAAA7tC,EAAAzc,GAEAA,EAAA66B,UAEApe,EAAAoe,QAAAr8B,MAAAwB,EAAA66B,QACApe,EAAAuvC,UAAAxtD,MAAAwB,EAAAgsD,WAIAhsD,EAAA86B,YAEAre,EAAAqe,UAAAt8B,MAAAwB,EAAA86B,UACAre,EAAAwvC,YAAAztD,MAAA4G,KAAApF,EAAAisD,cAIAjsD,EAAA8jB,kBAEArH,EAAAqH,gBAAAtlB,MAAAwB,EAAA8jB,gBACArH,EAAAsH,kBAAAvlB,MAAAwB,EAAA+jB,kBACAtH,EAAAuH,iBAAAxlB,MAAAwB,EAAAgkB,kBAQA,QAAAwlC,GAAA/sC,EAAAje,GAEAie,EAAA6qC,kBAAAhsC,YAAA9c,EAEAie,EAAA8qC,kBAAAjsC,YAAA9c,EACAie,EAAAirC,YAAApsC,YAAA9c,EACAie,EAAA+qC,WAAAlsC,YAAA9c,EACAie,EAAAgrC,eAAAnsC,YAAA9c,EACAie,EAAAkrC,iBAAArsC,YAAA9c,EAMA,QAAA+X,KAEA,GAAAg2C,GAAAxE,EAUA,OARAwE,IAAA9wC,GAAAm3B,aAEA9vC,QAAA4E,KAAA,sCAAA6kD,EAAA,+CAAA9wC,GAAAm3B,aAIAmV,IAAA,EAEAwE,EAtwEAzpD,QAAAi9B,IAAA,sBAAAysB,IAEAhpC,OAEA,IAAA4gB,GAAAnoC,SAAAunB,EAAAnI,OAAAmI,EAAAnI,OAAAzS,SAAA0U,gBAAA,yCACAmvC,EAAAxwD,SAAAunB,EAAAjG,QAAAiG,EAAAjG,QAAA,KAEAmvC,EAAAzwD,SAAAunB,EAAAvrB,OAAAurB,EAAAvrB,MACA00D,EAAA1wD,SAAAunB,EAAApC,OAAAoC,EAAApC,MACAwrC,EAAA3wD,SAAAunB,EAAAirB,SAAAjrB,EAAAirB,QACAoe,EAAA5wD,SAAAunB,EAAAspC,WAAAtpC,EAAAspC,UACAtJ,EAAAvnD,SAAAunB,EAAAtC,oBAAAsC,EAAAtC,mBACA6rC,EAAA9wD,SAAAunB,EAAAwpC,uBAAAxpC,EAAAwpC,sBACAC,EAAAhxD,SAAAunB,EAAA0pC,gBAAA1pC,EAAA0pC,gBAAA,UAEAhH,EAAA,KACAL,EAAA,IAIAryD,MAAA2S,WAAAi+B,EACA5wC,KAAA+pB,QAAA,KAIA/pB,KAAAwhC,WAAA,EACAxhC,KAAAyhC,gBAAA,EACAzhC,KAAA0hC,gBAAA,EACA1hC,KAAA2hC,kBAAA,EAIA3hC,KAAAmyD,aAAA,EAIAnyD,KAAAqvB,kBACArvB,KAAAqzB,sBAAA,EAIArzB,KAAAiqC,YAAA,EACAjqC,KAAAivC,YAAA,EACAjvC,KAAAgvC,aAAA,EAIAhvC,KAAAkrC,yBAAA,EAIAlrC,KAAA2mC,YAAAE,GACA7mC,KAAA81D,oBAAA,EACA91D,KAAA+1D,sBAAA,EAIA/1D,KAAAmvC,gBAAA,EACAnvC,KAAAovC,gBAAA,CAIA,IAAA0gB,GAAA9vD,KAEAqwD,GAAA,EAIAjB,GAAA,KACAuK,GAAA,KACA/E,IAAA,EACAxB,GAAA,GAEAsB,GAAA,KACA5B,GAAA,KAEArD,GAAA,GAAA5uC,GACA0uC,GAAA,GAAA1uC,GACA+4C,GAAA,KAIArF,GAAA,EAIAvB,GAAApiB,EAAA7vB,MACAkyC,GAAAriB,EAAA5vB,OAEAquC,GAAA,EAEAK,GAAA,GAAA7uC,GAAA,IAAAmyC,GAAAC,IACAzD,GAAA,GAAA3uC,GAAA,IAAAmyC,GAAAC,IACA4G,IAAA,EAIAzlC,GAAA,GAAA/C,IAIAkiC,GAAA,GAAA3O,IACA4P,IAAA,EACAC,IAAA,EAIA1/B,GAAA,GAAA1W,GAEAo0C,GAAA,GAAA74C,GAIA+1C,IACAzuB,WAAA,EACAlZ,SAAA,GAGAknC,IAEA5pB,MAAA,EACApB,MAAA,EACA54B,SAAA,EACA6c,MAAA,EACAic,OAAA,EAIApkC,MAAAunB,MAEA2D,OAAAgkC,GACA4K,OAAAnK,GACA/hB,SAAA,KACAmsB,WAAA,EACA/+C,MAAAi0C,EAsBA,IAAAj5B,GAEA,KAEA,GAAAgkC,KACAv1D,MAAAy0D,EACAtrC,MAAAurC,EACAle,QAAAme,EACAE,UAAAD,EACA3rC,mBAAAsiC,EACAwJ,sBAAAD,EACAG,gBAAAD,EAUA,IALA7oB,EAAAn4B,iBAAA,mBAAA23C,GAAA,GACAxf,EAAAn4B,iBAAA,uBAAA63C,GAAA,GAEAt6B,GAAAijC,GAAAroB,EAAA5mB,WAAA,QAAAgwC,KAAAppB,EAAA5mB,WAAA,qBAAAgwC,IAEA,OAAAhkC,GAEA,aAAA4a,EAAA5mB,WAAA,SAEA,GAAAvqB,OAAA,+DAIA,GAAAA,OAAA,gCAQAgJ,UAAAutB,GAAAoqB,2BAEApqB,GAAAoqB,yBAAA,WAEA,OAAa6Z,SAAA,EAAAC,SAAA,EAAAzvC,UAAA,KAMV,MAAAlM,GAEHjP,QAAAiP,MAAA,wBAAAA,EAAA47C,SAIA,GAAAn6B,IAAA/X,GAAA9c,GACA+kC,GAAAloB,GAAAc,GAAAoY,GAAA91B,GACAykD,GAAAE,GAAAhB,GAEA1tB,GAAAuuB,GAAAK,GAAAC,GACAC,GAEAhgB,EAkDAmf,IAIA,IAAAwC,IAAA,GAAApQ,IAAAoO,EAEA9vD,MAAA8xD,KAIA,IAAAj7B,IAAA,GAAAhF,IAAAi+B,EAAA1kD,GAAA6c,GAAA+J,eAEAhyB,MAAA62B,aAIA72B,KAAAgqB,WAAA,WAEA,MAAAgM,KAIAh2B,KAAAo6D,qBAAA,WAEA,MAAApkC,IAAAokC,wBAIAp6D,KAAAq6D,iBAAA,WAEA,GAAA/1B,GAAAtE,GAAApiB,IAAA,qBACA0mB,MAAAg2B,eAIAt6D,KAAAu6D,oBAAA,WAEA,GAAAj2B,GAAAtE,GAAApiB,IAAA,qBACA0mB,MAAAk2B,kBAIAx6D,KAAAmiD,cAAA,WAEA,MAAAkN,KAIArvD,KAAAy6D,cAAA,SAAAzvD,GAEAvC,SAAAuC,IAEAqkD,GAAArkD,EAEAhL,KAAA06D,QAAA1H,GAAAC,IAAA,KAIAjzD,KAAAqiD,QAAA,WAEA,OACAthC,MAAAiyC,GACAhyC,OAAAiyC,KAKAjzD,KAAA06D,QAAA,SAAA35C,EAAAC,EAAA25C,GAEA,GAAA/Y,GAAAkQ,GAAA7O,WAEA,OAAArB,MAAAC,iBAEAvyC,SAAA4E,KAAA,0EAKA8+C,GAAAjyC,EACAkyC,GAAAjyC,EAEA4vB,EAAA7vB,QAAAsuC,GACAze,EAAA5vB,SAAAquC,GAEAsL,KAAA,IAEA/pB,EAAAgqB,MAAA75C,QAAA,KACA6vB,EAAAgqB,MAAA55C,SAAA,UAIAhhB,MAAA66D,YAAA,IAAA95C,EAAAC,KAIAhhB,KAAA86D,qBAAA,WAEA,OACA/5C,MAAAiyC,GAAA3D,GACAruC,OAAAiyC,GAAA5D,KAKArvD,KAAAsiD,qBAAA,SAAAvhC,EAAAC,EAAA+5C,GAEA/H,GAAAjyC,EACAkyC,GAAAjyC,EAEAquC,GAAA0L,EAEAnqB,EAAA7vB,QAAAg6C,EACAnqB,EAAA5vB,SAAA+5C,EAEA/6D,KAAA66D,YAAA,IAAA95C,EAAAC,IAIAhhB,KAAAg7D,mBAAA,WAEA,MAAAvL,KAIAzvD,KAAA66D,YAAA,SAAAvlD,EAAAG,EAAAsL,EAAAC,GAEA0uC,GAAAl7C,IAAAc,EAAA29C,GAAAx9C,EAAAuL,EAAAD,EAAAC,GACA7V,GAAAgW,SAAAsuC,GAAA79C,KAAA89C,IAAA5yC,eAAAuyC,MAIArvD,KAAAi7D,WAAA,SAAA3lD,EAAAG,EAAAsL,EAAAC,GAEAwuC,GAAAh7C,IAAAc,EAAA29C,GAAAx9C,EAAAuL,EAAAD,EAAAC,GACA7V,GAAA8V,QAAAsuC,GAAA39C,KAAA49C,IAAA1yC,eAAAuyC,MAIArvD,KAAAm2B,eAAA,SAAA+kC,GAEA/vD,GAAAgrB,eAAA0jC,GAAAqB,IAMAl7D,KAAAsiC,cAAA,WAEA,MAAAjB,IAAAiB,iBAIAtiC,KAAAuiC,cAAA,WAEAlB,GAAAkB,cAAAjhC,MAAA+/B,GAAAljC,YAIA6B,KAAAwiC,cAAA,WAEA,MAAAnB,IAAAmB,iBAIAxiC,KAAAyiC,cAAA,WAEApB,GAAAoB,cAAAnhC,MAAA+/B,GAAAljC,YAIA6B,KAAAo3B,MAAA,SAAAvxB,EAAA+nB,EAAAqtB,GAEA,GAAAkgB,GAAA,GAEA1yD,SAAA5C,QAAAs1D,GAAAnlC,GAAAolC,mBACA3yD,SAAAmlB,QAAAutC,GAAAnlC,GAAAqlC,mBACA5yD,SAAAwyC,QAAAkgB,GAAAnlC,GAAAslC,oBAEAtlC,GAAAoB,MAAA+jC,IAIAn7D,KAAAshC,WAAA,WAEAthC,KAAAo3B,OAAA,UAIAp3B,KAAA65C,WAAA,WAEA75C,KAAAo3B,OAAA,UAIAp3B,KAAAk7C,aAAA,WAEAl7C,KAAAo3B,OAAA,UAIAp3B,KAAAu7D,YAAA,SAAA7pB,EAAA7rC,EAAA+nB,EAAAqtB,GAEAj7C,KAAAm3B,gBAAAua,GACA1xC,KAAAo3B,MAAAvxB,EAAA+nB,EAAAqtB,IAMAj7C,KAAAuc,QAAA,WAEAq0B,EAAA93B,oBAAA,mBAAAs3C,GAAA,GACAxf,EAAA93B,oBAAA,uBAAAw3C,GAAA,GAEAP,GAAAxzC,UACAwyC,GAAAxyC,UACA2zB,GAAA3zB,UACAnR,GAAAmR,UAEAu1C,GAAAv1C,UAEAs1C,KAyEA7xD,KAAA2wD,sBAAA,SAAAtlD,EAAA+b,EAAA5a,GAEArB,GAAAogB,gBAEA,IAAAoC,GAAAuiB,GAAAtyB,IAAAvS,EAEAA,GAAAmwD,eAAA7tC,EAAAhT,WAAAgT,EAAAhT,SAAAqb,GAAA1N,gBACAjd,EAAAowD,aAAA9tC,EAAAwD,SAAAxD,EAAAwD,OAAA6E,GAAA1N,gBACAjd,EAAAqwD,SAAA/tC,EAAA3E,KAAA2E,EAAA3E,GAAAgN,GAAA1N,gBACAjd,EAAAswD,YAAAhuC,EAAA9nB,QAAA8nB,EAAA9nB,MAAAmwB,GAAA1N,eAEA,IAAAyoC,GAAA3pC,EAAAwlB,eAYA,IAVAvhC,EAAAmwD,eAEAxlC,GAAAxN,WAAAwN,GAAAvN,aAAAkF,EAAAhT,UACAqb,GAAAtN,WAAAsN,GAAAvN,aAAApd,EAAAuwD,cAAA5lC,GAAA6B,cAEA1sB,GAAAqgB,gBAAAulC,EAAAp2C,UACAqb,GAAAlK,oBAAAilC,EAAAp2C,SAAA,EAAAqb,GAAAjK,OAAA,QAIA1gB,EAAAowD,WAAA,CAIA,GAFAzlC,GAAAxN,WAAAwN,GAAAvN,aAAAkF,EAAAwD,SAEA3kB,EAAA2oD,sBACA3oD,EAAA4oD,yBACA5oD,EAAAqqD,sBACArqD,EAAAoiB,eAAA,EAEA,OAAAzvB,GAAA,EAAAgQ,EAAA,EAAA9D,EAAAzC,MAA2CzJ,EAAAgQ,EAAOhQ,GAAA,GAElD,GAAA4B,GAAAsK,EAAAwwD,YAEAC,GAAA/6D,EAAA5B,EAAA,GAAA4B,EAAA5B,EAAA,GAAA4B,EAAA5B,EAAA,MACA48D,GAAAh7D,EAAA5B,EAAA,GAAA4B,EAAA5B,EAAA,GAAA4B,EAAA5B,EAAA,MACA68D,GAAAj7D,EAAA5B,EAAA,GAAA4B,EAAA5B,EAAA,GAAA4B,EAAA5B,EAAA,KAEA4B,GAAA5B,EAAA,GAAA28D,EACA/6D,EAAA5B,EAAA,GAAA48D,EACAh7D,EAAA5B,EAAA,GAAA68D,EAEAj7D,EAAA5B,EAAA,GAAA28D,EACA/6D,EAAA5B,EAAA,GAAA48D,EACAh7D,EAAA5B,EAAA,GAAA68D,EAEAj7D,EAAA5B,EAAA,GAAA28D,EACA/6D,EAAA5B,EAAA,GAAA48D,EACAh7D,EAAA5B,EAAA,GAAA68D,EAMAhmC,GAAAtN,WAAAsN,GAAAvN,aAAApd,EAAAwwD,YAAA7lC,GAAA6B,cAEA1sB,GAAAqgB,gBAAAulC,EAAA5/B,QAEA6E,GAAAlK,oBAAAilC,EAAA5/B,OAAA,EAAA6E,GAAAjK,OAAA,OAIA1gB,EAAAqwD,QAAAlvD,EAAA2V,MAEA6T,GAAAxN,WAAAwN,GAAAvN,aAAAkF,EAAA3E,IACAgN,GAAAtN,WAAAsN,GAAAvN,aAAApd,EAAA4wD,QAAAjmC,GAAA6B,cAEA1sB,GAAAqgB,gBAAAulC,EAAA/nC,IAEAgN,GAAAlK,oBAAAilC,EAAA/nC,GAAA,EAAAgN,GAAAjK,OAAA,QAIA1gB,EAAAswD,WAAAnvD,EAAAqiB,eAAAC,KAEAkH,GAAAxN,WAAAwN,GAAAvN,aAAAkF,EAAA9nB,OACAmwB,GAAAtN,WAAAsN,GAAAvN,aAAApd,EAAA6wD,WAAAlmC,GAAA6B,cAEA1sB,GAAAqgB,gBAAAulC,EAAAlrD,OAEAmwB,GAAAlK,oBAAAilC,EAAAlrD,MAAA,EAAAmwB,GAAAjK,OAAA,QAIA5gB,GAAAsgB,0BAEAuK,GAAA0O,WAAA1O,GAAA7H,UAAA,EAAA9iB,EAAAzC,OAEAyC,EAAAzC,MAAA,GAIA5I,KAAA60B,mBAAA,SAAAxJ,EAAAe,EAAArgB,EAAAS,EAAAnB,EAAAmpB,GAEA,GAAAipB,GAAApyC,EAAA2oB,QAAA3oB,EAAAwhB,YAAAqmC,cAAA,CAEA/nD,IAAAqyC,YAAAhxC,EAAAixC,EAEA,IAAAr2B,GAAA+rC,EAAA9nC,EAAAe,EAAA5f,EAAAnB,GACA8wD,EAAApwD,EAAA2C,GAAA,IAAA0Y,EAAA1Y,GAAA,KAAAlC,EAAAikB,aAAA,GAEA2rC,GAAA,CAEAD,KAAA/I,KAEAA,GAAA+I,EACAC,GAAA,GAIA/wD,EAAAm4B,wBAEAosB,GAAAj6C,OAAAtK,EAAAU,EAAAS,EAAA4a,GAEAg1C,GAAA,EAMA,IAAA7vD,GAAAR,EAAAQ,MACAoO,EAAA5O,EAAA+c,WAAAnO,SACA0hD,EAAA,CAEA7vD,GAAAikB,aAAA,IAEAlkB,EAAA20B,GAAAiE,sBAAAp5B,GACAswD,EAAA,EAIA,IAAA5kC,GACA7U,EAAAqtC,EAEA,QAAA1jD,IAEAkrB,EAAA3O,GAAAlL,IAAArR,GAEAqW,EAAAstC,GACAttC,EAAA6b,SAAAhH,IAIA2kC,IAEAxL,EAAApkD,EAAA4a,EAAArb,GAEA,OAAAQ,GAEAypB,GAAAxN,WAAAwN,GAAApN,qBAAA6O,EAAAK,QAQA,IAAAwkC,GAAAviD,GAEA,QAAAxN,EAEA+vD,EAAA/vD,EAAA3D,MAEIH,SAAAkS,IAEJ2hD,EAAA3hD,EAAA/R,MAIA,IAAA2zD,GAAAxwD,EAAA+wB,UAAAC,MAAAs/B,EACAG,EAAAzwD,EAAA+wB,UAAAl0B,MAAAyzD,EAEA1vD,EAAA,OAAA6nB,IAAAuI,MAAAs/B,EAAA,EACAhwD,EAAA,OAAAmoB,IAAA5rB,MAAAyzD,EAAAtiD,IAEA0iD,EAAA/3D,KAAA0B,IAAAm2D,EAAA5vD,GACA+vD,EAAAh4D,KAAA2B,IAAAi2D,EAAAC,EAAAC,EAAA7vD,EAAAN,GAAA,EAEAswD,EAAAj4D,KAAA0B,IAAA,EAAAs2D,EAAAD,EAAA,EAEA,QAAAE,EAAA,CAIA,GAAAtxD,EAAA2oB,OAEA,GAAAxnB,EAAAikB,aAAA,EAEAtlB,GAAAuzC,aAAAlyC,EAAAkkB,mBAAAy+B,KACAvsC,EAAAohB,QAAAhO,GAAA4mC,WAIA,QAAAvxD,EAAAy1B,UAEA,IAAAC,IACAne,EAAAohB,QAAAhO,GAAA7H,UACA,MAEA,KAAA0uC,IACAj6C,EAAAohB,QAAAhO,GAAA8mC,eACA,MAEA,KAAAC,IACAn6C,EAAAohB,QAAAhO,GAAAgnC,kBAQI,IAAA3xD,EAAA0F,OAAA,CAEJ,GAAA8tC,GAAAryC,EAAAmnB,SAEAlrB,UAAAo2C,MAAA,GAEA1zC,GAAAuzC,aAAAG,EAAAsQ,KAEA9jD,EAAA4xD,eAEAr6C,EAAAohB,QAAAhO,GAAA4mC,OAEKvxD,EAAA6xD,WAELt6C,EAAAohB,QAAAhO,GAAAmnC,WAIAv6C,EAAAohB,QAAAhO,GAAAonC,gBAII/xD,GAAA4oB,UAEJrR,EAAAohB,QAAAhO,GAAAmO,OAIAp4B,MAAA+kD,0BAEA/kD,EAAAy4B,kBAAA,GAEA5hB,EAAAyhB,gBAAAt4B,EAAA0wD,EAAAE,GAMA/5C,EAAAsI,OAAAuxC,EAAAE,KA2IA38D,KAAAq9D,QAAA,SAAAjyC,EAAAC,GAEAgnC,EAAAtD,GAAAnxC,IAAAwN,EAAAC,GACAgnC,EAAAnqC,OAEAkD,EAAAkyC,SAAA,SAAAjyD,GAEAA,EAAA+mD,UAEAC,EAAA7D,UAAAnjD,GAEAA,EAAA6oB,YAEAm+B,EAAA5D,WAAApjD,MAQAgnD,EAAAzD,YAAAvjC,GAEAD,EAAAkyC,SAAA,SAAAjyD,GAEA,GAAAA,EAAAmB,SAEA,GAAApL,MAAAsL,QAAArB,EAAAmB,UAEA,OAAArN,GAAA,EAAsBA,EAAAkM,EAAAmB,SAAAzO,OAA4BoB,IAElDk0D,EAAAhoD,EAAAmB,SAAArN,GAAAisB,EAAAgB,IAAA/gB,OAMAgoD,GAAAhoD,EAAAmB,SAAA4e,EAAAgB,IAAA/gB,KAYA,IAAAsmD,KAAA,EACAM,GAAA,IA4CAjyD,MAAAu9D,QAAA,SAAAC,GAEAvL,GAAAuL,EACA,OAAAvL,GAAAP,IAAAG,KAMA7xD,KAAAkrB,OAAA,SAAAE,EAAAC,EAAAqmB,EAAAtQ,GAEA,IAAA/V,MAAAoyC,SAGA,WADAnuD,SAAAiP,MAAA,yEAKA,KAAA8xC,EAAA,CAIA+C,GAAA,GACAwB,IAAA,EACAF,GAAA,KAIAtpC,EAAA0K,cAAA,GAAA1K,EAAA6L,oBAIA,OAAA5L,EAAA0O,QAAA1O,EAAA4L,oBAEA66B,GAAAl6C,UAEAyT,EAAAymC,GAAA1O,UAAA/3B,IAMAgnC,EAAAtD,GAAAnxC,IAAAwN,EAAAC,GACAgnC,EAAAnqC,OAEAkD,EAAA4B,eAAA8iC,EAAA1kC,EAAAC,EAAAqmB,GAEA3c,GAAApI,iBAAAtB,EAAA/B,iBAAA+B,EAAAuB,oBACAwH,GAAAmD,cAAAxC,IAEA0/B,GAAAz0D,KAAAqzB,qBACAmhC,GAAAjB,GAAArrC,KAAAloB,KAAAqvB,eAAAolC,GAAAppC,GAEAqnC,EAAA3C,GAAAnyC,IAAAwN,EAAAC,GACAqnC,EAAAxqC,OAEAgqC,EAAA9mC,EAAAC,EAAAykC,EAAAqC,aAEArC,EAAAqC,eAAA,GAEAO,EAAA5lC,OAMA0nC,IAAAjB,GAAAvN,cAEA,IAAAsI,GAAA+D,EAAAlnD,MAAAmjD,YAEAz3B,IAAA3L,OAAAojC,EAAAljC,EAAAC,GAEAgnC,EAAAzD,YAAAvjC,GAEAmpC,IAAAjB,GAAAtN,aAIAjmD,KAAAunB,KAAAwyC,WAAA/5D,KAAAunB,KAAAvM,QAEAvS,SAAAipC,IAEAA,EAAA,MAIA1xC,KAAAm3B,gBAAAua,GAIArQ,GAAAnW,OAAAwnC,EAAAtnC,EAAAC,EAAA+V,EAIA,IAAAs8B,GAAAhL,EAAA7vB,OACA86B,EAAAjL,EAAA3jC,WAEA,IAAA3D,EAAAwnC,iBAAA,CAEA,GAAAA,GAAAxnC,EAAAwnC,gBAEA8K,GAAA3/D,QAAA40D,EAAA+K,EAAAtyC,EAAAC,EAAAunC,GACA+K,EAAA5/D,QAAA40D,EAAAgL,EAAAvyC,EAAAC,EAAAunC,OAMA8K,GAAA3/D,QAAA40D,EAAA+K,EAAAtyC,EAAAC,GAIAsyC,EAAA5/D,QAAA40D,EAAAgL,EAAAvyC,EAAAC,EAMA,IAAAkjC,GAAA8D,EAAAlnD,MAAAojD,YAEA4B,IAAAjlC,OAAAqjC,EAAAnjC,EAAAC,GAIAqmB,GAEA1pB,GAAA0vB,yBAAAhG,GAMAvmC,GAAAwiB,QAAAC,MAAAC,SAAA,GACA1iB,GAAAwiB,QAAAC,MAAAG,SAAA,GACA5iB,GAAAwiB,QAAA9nB,MAAAkoB,SAAA,GAEA5iB,GAAAyyC,kBAAA,GAEAxyB,EAAAiD,cAAAyhC,EAAA1kC,EAAAC,GAEAymC,GAAAl6C,SAEAk6C,GAAArN,cAMAiO,EAAA,KACAL,EAAA,OAgmCAryD,KAAA+iB,mBAGA/iB,KAAAykB,aAAA,WAEA,GAAAm5C,IAAA,CAGA,iBAAAx8C,EAAAmxB,GAEAnxB,KAAAusB,sBAEAiwB,IAEAtuD,QAAA4E,KAAA,gHACA0pD,GAAA,GAIAx8C,aAIA4G,GAAAvD,aAAArD,EAAAmxB,OAMAvyC,KAAA69D,WAAA,WAEA,GAAAD,IAAA,CAEA,iBAAAx8C,EAAAmxB,GAEAqrB,IAEAtuD,QAAA4E,KAAA,6EACA0pD,GAAA,GAIA51C,GAAAvD,aAAArD,EAAAmxB,OAMAvyC,KAAA4kB,eAAA,WAEA,GAAAg5C,IAAA,CAEA,iBAAAx8C,EAAAmxB,GAGAnxB,KAAA8wB,0BAEA0rB,IAEAtuD,QAAA4E,KAAA,uHACA0pD,GAAA,GAIAx8C,aAMAA,KAAAwgB,eACAxgC,MAAAsL,QAAA0U,EAAApC,QAAA,IAAAoC,EAAApC,MAAAjhB,OAKAiqB,GAAApD,eAAAxD,EAAAmxB,GAMAvqB,GAAAqsB,sBAAAjzB,EAAAmxB,OAQAvyC,KAAA8uC,gBAAA,WAEA,MAAAsgB,KAIApvD,KAAAm3B,gBAAA,SAAAua,GAEA0d,GAAA1d,EAEAA,GAAAjpC,SAAAynC,GAAAtyB,IAAA8zB,GAAAU,oBAEApqB,GAAAsvB,kBAAA5F,EAIA,IAAAwE,GAAA,KACAgB,GAAA,CAEA,IAAAxF,EAAA,CAEA,GAAAU,GAAAlC,GAAAtyB,IAAA8zB,GAAAU,kBAEAV,GAAAQ,yBAEAgE,EAAA9D,EAAAV,EAAAjwB,gBACAy1B,GAAA,GAIAhB,EAAA9D,EAIAqd,GAAA79C,KAAA8/B,EAAAvwB,UACAouC,GAAA39C,KAAA8/B,EAAAzwB,SACA24C,GAAAloB,EAAAxwB,gBAIAuuC,IAAA79C,KAAA89C,IAAA5yC,eAAAuyC,IACAE,GAAA39C,KAAA49C,IAAA1yC,eAAAuyC,IACAuK,GAAAC,EAeA,IAXAF,KAAAzjB,IAEAlgB,GAAAqgB,gBAAArgB,GAAAsgB,YAAAJ,GACAyjB,GAAAzjB,GAIA/qC,GAAAgW,SAAAsuC,IACAtkD,GAAA8V,QAAAsuC,IACApkD,GAAAgrB,eAAAyjC,IAEA1iB,EAAA,CAEA,GAAAtF,GAAA1B,GAAAtyB,IAAA8zB,EAAAtwB,QACA4U,IAAAugB,qBAAAvgB,GAAAsgB,YAAAtgB,GAAAyhB,kBAAAzhB,GAAAke,4BAAAxC,EAAAjwB,eAAAmwB,EAAAI,eAAAN,EAAAhwB,qBAMA1hB,KAAA89D,uBAAA,SAAApsB,EAAAp8B,EAAAG,EAAAsL,EAAAC,EAAA8W,GAEA,IAAA4Z,MAAA/D,oBAGA,WADAr+B,SAAAiP,MAAA,2FAKA,IAAA23B,GAAAhG,GAAAtyB,IAAA8zB,GAAAU,kBAEA,IAAA8D,EAAA,CAEA,GAAA6nB,IAAA,CAEA7nB,KAAAyjB,KAEA3jC,GAAAqgB,gBAAArgB,GAAAsgB,YAAAJ,GAEA6nB,GAAA,EAIA,KAEA,GAAA38C,GAAAswB,EAAAtwB,QACA48C,EAAA58C,EAAA/c,OACAiwC,EAAAlzB,EAAAxjB,IAEA,IAAAogE,IAAA99C,IAAAiwB,GAAAsD,QAAAuqB,KAAAhoC,GAAA8lB,aAAA9lB,GAAAioC,kCAGA,WADA3uD,SAAAiP,MAAA,4GAKA,MAAA+1B,IAAAn0B,IAAAgwB,GAAAsD,QAAAa,KAAAte,GAAA8lB,aAAA9lB,GAAAkoC,iCACA5pB,IAAAO,KAAA7U,GAAApiB,IAAA,sBAAAoiB,GAAApiB,IAAA,8BACA02B,IAAAQ,IAAA9U,GAAApiB,IAAA,gCAGA,WADAtO,SAAAiP,MAAA,sHAKAyX,IAAAmoC,uBAAAnoC,GAAAsgB,eAAAtgB,GAAAooC,qBAIA9oD,GAAA,GAAAA,GAAAo8B,EAAA3wB,SAAAtL,GAAA,GAAAA,GAAAi8B,EAAA1wB,UAEAgV,GAAAqoC,WAAA/oD,EAAAG,EAAAsL,EAAAC,EAAAmvB,GAAAsD,QAAAuqB,GAAA7tB,GAAAsD,QAAAa,GAAAxc,GAMAxoB,QAAAiP,MAAA,8GAIK,QAELw/C,GAEA/nC,GAAAqgB,gBAAArgB,GAAAsgB,YAAAqjB,OAUA35D,KAAAs+D,yBAAA,SAAA3jD,EAAAyG,EAAAm9C,GAEA,GAAAx9C,GAAAK,EAAApC,MAAA+B,MACAC,EAAAI,EAAApC,MAAAgC,OACAs0B,EAAAnF,GAAAsD,QAAAryB,EAAA/c,OAEArE,MAAAykB,aAAArD,EAAA,GAEA4U,GAAAwoC,eAAAxoC,GAAA6c,WAAA0rB,GAAA,EAAAjpB,EAAA36B,EAAArF,EAAAqF,EAAAlF,EAAAsL,EAAAC,EAAA,IAWA,QAAAy9C,IAAA54D,EAAA4mB,GAEAzsB,KAAAlC,KAAA,GAEAkC,KAAA6F,MAAA,GAAA6hB,GAAA7hB,GACA7F,KAAAysB,QAAAhkB,SAAAgkB,IAAA,MA2BA,QAAAiyC,IAAA74D,EAAAymB,EAAAC,GAEAvsB,KAAAlC,KAAA,GAEAkC,KAAA6F,MAAA,GAAA6hB,GAAA7hB,GAEA7F,KAAAssB,KAAA7jB,SAAA6jB,IAAA,EACAtsB,KAAAusB,IAAA9jB,SAAA8jB,IAAA,IA2BA,QAAAoyC,MAEAllC,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,QAEAoC,KAAAqhC,WAAA,KACArhC,KAAAosB,IAAA,KACApsB,KAAA4yD,iBAAA,KAEA5yD,KAAA81B,YAAA,EAiDA,QAAA8oC,IAAA5uC,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,iBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UACA1nB,KAAAmiB,IAAA,KAEAniB,KAAAqgB,SAAA,EAEArgB,KAAAosB,KAAA,EACApsB,KAAAwuB,QAAA,EAEAxuB,KAAA2wB,UAAAX,GA0BA,QAAA6uC,IAAAryD,GAEAitB,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,SAEAoC,KAAAwM,SAAA/D,SAAA+D,IAAA,GAAAoyD,IAEA5+D,KAAA2d,OAAA,GAAAjB,GAAA,OAoEA,QAAAoiD,MAEArlC,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,MAEAU,OAAAof,iBAAA1d,MACA++D,QACA7kC,YAAA,EACAlvB,YAmKA,QAAAg0D,IAAA5xB,EAAA6xB,GAWA,GAPA7xB,QAEAptC,KAAAotC,QAAA8xB,MAAA,GACAl/D,KAAA41D,aAAA,GAAAxkD,cAAA,GAAApR,KAAAotC,MAAArvC,QAIA0K,SAAAw2D,EAEAj/D,KAAAm/D,wBAIA,IAAAn/D,KAAAotC,MAAArvC,SAAAkhE,EAAAlhE,OAEAiC,KAAAi/D,eAAAC,MAAA,OAEI,CAEJ5vD,QAAA4E,KAAA,oDAEAlU,KAAAi/D,eAEA,QAAA9/D,GAAA,EAAAk3B,EAAAr2B,KAAAotC,MAAArvC,OAA4CoB,EAAAk3B,EAAQl3B,IAEpDa,KAAAi/D,aAAA59D,KAAA,GAAAgd,KAgJA,QAAA+gD,MAEA3lC,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,OAkBA,QAAAyhE,IAAAtzD,EAAAS,GAEA8F,GAAAvS,KAAAC,KAAA+L,EAAAS,GAEAxM,KAAApC,KAAA,cAEAoC,KAAAs/D,SAAA,WACAt/D,KAAAu/D,WAAA,GAAAlhD,GACAre,KAAAw/D,kBAAA,GAAAnhD,EAEA,IAAA+uB,GAAAptC,KAAAy/D,YACAtyB,EAAA,GAAA6xB,IAAA5xB,EAEAptC,MAAA+M,KAAAogC,EAAAntC,KAAA6sB,aAEA7sB,KAAA0/D,uBAkMA,QAAAhuD,IAAAse,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UAEA1nB,KAAA2zB,UAAA,EACA3zB,KAAA2/D,QAAA,QACA3/D,KAAA4/D,SAAA,QAEA5/D,KAAAwuB,QAAA,EAEAxuB,KAAA2wB,UAAAX,GA2BA,QAAA6vC,IAAA9zD,EAAAS,EAAAy3B,GAEA,WAAAA,GAEA30B,QAAA4E,KAAA,mGACA,GAAA7B,IAAAtG,EAAAS,KAIAitB,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,OAEAoC,KAAA+L,SAAAtD,SAAAsD,IAAA,GAAAkF,SACAjR,KAAAwM,SAAA/D,SAAA+D,IAAA,GAAAkF,KAA8E7L,MAAA,SAAAnB,KAAAC,aAqO9E,QAAA0N,IAAAtG,EAAAS,GAEAqzD,GAAA9/D,KAAAC,KAAA+L,EAAAS,GAEAxM,KAAApC,KAAA,eA2EA,QAAAkiE,IAAA/zD,EAAAS,GAEAqzD,GAAA9/D,KAAAC,KAAA+L,EAAAS,GAEAxM,KAAApC,KAAA,WA0BA,QAAAwwC,IAAApe,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,iBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UAEA1nB,KAAAmiB,IAAA,KAEAniB,KAAA0lB,KAAA,EACA1lB,KAAAgrC,iBAAA,EAEAhrC,KAAAwuB,QAAA,EAEAxuB,KAAA2wB,UAAAX,GA4BA,QAAA+vC,IAAAh0D,EAAAS,GAEAitB,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,SAEAoC,KAAA+L,SAAAtD,SAAAsD,IAAA,GAAAkF,IACAjR,KAAAwM,SAAA/D,SAAA+D,IAAA,GAAA4hC,KAA2EvoC,MAAA,SAAAnB,KAAAC,WAkI3E,QAAAmM,MAEA2oB,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,QAgBA,QAAAoiE,IAAAC,EAAAhhD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,GAEAP,EAAAhf,KAAAC,KAAAigE,EAAAhhD,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,GAEAtf,KAAAugB,iBAAA,EA4BA,QAAA2/C,IAAArgD,EAAAkB,EAAAC,EAAA3c,EAAAzG,EAAAqhB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEAR,EAAAhf,KAAAC,KAAA,KAAAif,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,EAAAC,GAEAvf,KAAAgf,OAAgB+B,QAAAC,UAChBhhB,KAAA6f,UAKA7f,KAAAygB,OAAA,EAKAzgB,KAAAugB,iBAAA,EAcA,QAAA4/C,IAAAp/C,EAAAC,EAAApjB,EAAAqhB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAjb,GAIA,GAFAA,EAAAoE,SAAApE,IAAAsxC,GAEAtxC,IAAAsxC,IAAAtxC,IAAAyxC,GAEA,SAAAr2C,OAAA,mFAIAgJ,UAAA7K,GAAAyG,IAAAsxC,KAAA/3C,EAAAg4C,IACAntC,SAAA7K,GAAAyG,IAAAyxC,KAAAl4C,EAAAo4C,IAEAj3B,EAAAhf,KAAAC,KAAA,KAAAif,EAAAC,EAAAC,EAAAC,EAAAC,EAAAhb,EAAAzG,EAAA0hB,GAEAtf,KAAAgf,OAAgB+B,QAAAC,UAEhBhhB,KAAAof,UAAA3W,SAAA2W,IAAAyC,GACA7hB,KAAAqf,UAAA5W,SAAA4W,IAAAwC,GAEA7hB,KAAAygB,OAAA,EACAzgB,KAAAugB,iBAAA,EAaA,QAAA6/C,IAAAr0D,GAEAkF,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,mBAIA,IAIAuB,GAAA00C,EAAA1kC,EAAAkxD,EAAAC,EACiChhE,EAAAihE,EAAAC,EACjCphE,EACAqhE,EAPAn1D,KAKAo1D,GAAA,KAAAC,KACA1hE,GAAA,YAKA,IAAA8M,KAAAgnB,WAAA,CAIA,GAAA5K,GAAApc,EAAAoc,KAEA,KAAAhpB,EAAA,EAAAgQ,EAAAgZ,EAAApqB,OAAiCoB,EAAAgQ,EAAOhQ,IAAA,CAExC,GAAAk4B,GAAAlP,EAAAhpB,EAEA,KAAA00C,EAAA,EAAgBA,EAAA,EAAOA,IAEvB0sB,EAAAlpC,EAAAp4B,EAAA40C,IACA2sB,EAAAnpC,EAAAp4B,GAAA40C,EAAA,OACA6sB,EAAA,GAAAh8D,KAAA2B,IAAAk6D,EAAAC,GACAE,EAAA,GAAAh8D,KAAA0B,IAAAm6D,EAAAC,GAEAphE,EAAAshE,EAAA,OAAAA,EAAA,GAEAj4D,SAAAk4D,EAAAvhE,KAEAuhE,EAAAvhE,IAAsBwhE,OAAAF,EAAA,GAAAG,OAAAH,EAAA,KAUtB,IAAAthE,IAAAuhE,GAEArhE,EAAAqhE,EAAAvhE,GAEAqhE,EAAA10D,EAAAT,SAAAhM,EAAAshE;AACAt1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAEAiiD,EAAA10D,EAAAT,SAAAhM,EAAAuhE,QACAv1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,OAIG,IAAAzS,KAAA8mB,iBAAA,CAEH,GAAAlY,GAAA+hB,EAAApI,EACAE,EAAAuI,EAAAn0B,EACAg4D,EAAAC,CAIA,IAFAJ,EAAA,GAAA7mD,GAEA,OAAA7N,EAAAQ,MAAA,CAgBA,IAZAoO,EAAA5O,EAAA+c,WAAAnO,SACA+hB,EAAA3wB,EAAAQ,MACA+nB,EAAAvoB,EAAAuoB,OAEA,IAAAA,EAAAv2B,SAEAu2B,IAAiByI,MAAA,EAAAn0B,MAAA8zB,EAAA9zB,MAAA8rB,cAAA,KAMjB2rC,EAAA,EAAAC,EAAAhsC,EAAAv2B,OAAoCsiE,EAAAC,IAAQD,EAO5C,IALA7rC,EAAAF,EAAA+rC,GAEAtjC,EAAAvI,EAAAuI,MACAn0B,EAAA4rB,EAAA5rB,MAEAzJ,EAAA49B,EAAA5tB,EAAA4tB,EAAAn0B,EAA4CzJ,EAAAgQ,EAAOhQ,GAAA,EAEnD,IAAA00C,EAAA,EAAkBA,EAAA,EAAOA,IAEzB0sB,EAAA7jC,EAAAokC,KAAA3hE,EAAA00C,GACA2sB,EAAA9jC,EAAAokC,KAAA3hE,GAAA00C,EAAA,MACA6sB,EAAA,GAAAh8D,KAAA2B,IAAAk6D,EAAAC,GACAE,EAAA,GAAAh8D,KAAA0B,IAAAm6D,EAAAC,GAEAphE,EAAAshE,EAAA,OAAAA,EAAA,GAEAj4D,SAAAk4D,EAAAvhE,KAEAuhE,EAAAvhE,IAAwBwhE,OAAAF,EAAA,GAAAG,OAAAH,EAAA,IAYxB,KAAAthE,IAAAuhE,GAEArhE,EAAAqhE,EAAAvhE,GAEAqhE,EAAAM,oBAAApmD,EAAArb,EAAAshE,QACAt1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAEAiiD,EAAAM,oBAAApmD,EAAArb,EAAAuhE,QACAv1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,OAUA,KAFA7D,EAAA5O,EAAA+c,WAAAnO,SAEAxb,EAAA,EAAAgQ,EAAAwL,EAAA/R,MAAA,EAA4CzJ,EAAAgQ,EAAOhQ,IAEnD,IAAA00C,EAAA,EAAiBA,EAAA,EAAOA,IAKxB+sB,EAAA,EAAAzhE,EAAA00C,EACA4sB,EAAAM,oBAAApmD,EAAAimD,GACAt1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAEAqiD,EAAA,EAAA1hE,GAAA00C,EAAA,KACA4sB,EAAAM,oBAAApmD,EAAAkmD,GACAv1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAYAxe,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IAiBA,QAAA01D,IAAAC,EAAAC,EAAAC,GAEAtmC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAAgwB,YACAixC,OACAC,SACAC,UAGAnhE,KAAAo9B,mBAAA,GAAAgkC,IAAAH,EAAAC,EAAAC,IACAnhE,KAAAs9B,gBASA,QAAA8jC,IAAAH,EAAAC,EAAAC,GAEAlwD,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,2BAEAoC,KAAAgwB,YACAixC,OACAC,SACAC,SAKA,IAYAhiE,GAAA00C,EAZAnX,KACApxB,KACAC,KACAC,KAEA4Q,EAAA,KAEA+U,EAAA,GAAAvX,GAEA0X,EAAA,GAAA1X,GAAA2X,EAAA,GAAA3X,GACAynD,EAAA,GAAAznD,GAAA0nD,EAAA,GAAA1nD,GAMA2nD,EAAAL,EAAA,CAEA,KAAA/hE,EAAA,EAAcA,GAAAgiE,EAAahiE,IAAA,CAE3B,GAAA6H,GAAA7H,EAAAgiE,CAEA,KAAAttB,EAAA,EAAeA,GAAAqtB,EAAartB,IAAA,CAE5B,GAAArW,GAAAqW,EAAAqtB,CAIA5vC,GAAA2vC,EAAAzjC,EAAAx2B,EAAAsqB,GACAhmB,EAAAjK,KAAAiwB,EAAAhc,EAAAgc,EAAA7b,EAAA6b,EAAA9S,GAMAgf,EAAAphB,GAAA,GAEAmV,EAAA0vC,EAAAzjC,EAAAphB,EAAApV,EAAAuqB,GACA8vC,EAAAnsD,WAAAoc,EAAAC,KAIAA,EAAA0vC,EAAAzjC,EAAAphB,EAAApV,EAAAuqB,GACA8vC,EAAAnsD,WAAAqc,EAAAD,IAIAtqB,EAAAoV,GAAA,GAEAmV,EAAA0vC,EAAAzjC,EAAAx2B,EAAAoV,EAAAmV,GACA+vC,EAAApsD,WAAAoc,EAAAC,KAIAA,EAAA0vC,EAAAzjC,EAAAx2B,EAAAoV,EAAAmV,GACA+vC,EAAApsD,WAAAqc,EAAAD,IAMAH,EAAAqwC,aAAAH,EAAAC,GAAApT,YACA3iD,EAAAlK,KAAA8vB,EAAA7b,EAAA6b,EAAA1b,EAAA0b,EAAA3S,GAIAhT,EAAAnK,KAAAm8B,EAAAx2B,IAQA,IAAA7H,EAAA,EAAcA,EAAAgiE,EAAYhiE,IAE1B,IAAA00C,EAAA,EAAeA,EAAAqtB,EAAYrtB,IAAA,CAE3B,GAAApmC,GAAAtO,EAAAoiE,EAAA1tB,EACAruC,EAAArG,EAAAoiE,EAAA1tB,EAAA,EACArtC,GAAArH,EAAA,GAAAoiE,EAAA1tB,EAAA,EACA5lC,GAAA9O,EAAA,GAAAoiE,EAAA1tB,CAIAnX,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAQAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IAgBA,QAAAi2D,IAAAn2D,EAAAoxB,EAAA3gB,EAAA2lD,GAEA7mC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAAgwB,YACA1kB,WACAoxB,UACA3gB,SACA2lD,UAGA1hE,KAAAo9B,mBAAA,GAAAukC,IAAAr2D,EAAAoxB,EAAA3gB,EAAA2lD,IACA1hE,KAAAs9B,gBASA,QAAAqkC,IAAAr2D,EAAAoxB,EAAA3gB,EAAA2lD,GAmDA,QAAAE,GAAAF,GAQA,OANAj0D,GAAA,GAAAmM,GACApU,EAAA,GAAAoU,GACApT,EAAA,GAAAoT,GAIAza,EAAA,EAAmBA,EAAAu9B,EAAA3+B,OAAoBoB,GAAA,EAIvC0iE,EAAAnlC,EAAAv9B,EAAA,GAAAsO,GACAo0D,EAAAnlC,EAAAv9B,EAAA,GAAAqG,GACAq8D,EAAAnlC,EAAAv9B,EAAA,GAAAqH,GAIAs7D,EAAAr0D,EAAAjI,EAAAgB,EAAAk7D,GAMA,QAAAI,GAAAr0D,EAAAjI,EAAAgB,EAAAk7D,GAEA,GAMAviE,GAAA00C,EANAkuB,EAAAr9D,KAAAsO,IAAA,EAAA0uD,GAIA16D,IAMA,KAAA7H,EAAA,EAAeA,GAAA4iE,EAAW5iE,IAAA,CAE1B6H,EAAA7H,KAEA,IAAA6iE,GAAAv0D,EAAAZ,QAAAo1D,KAAAz7D,EAAArH,EAAA4iE,GACAG,EAAA18D,EAAAqH,QAAAo1D,KAAAz7D,EAAArH,EAAA4iE,GAEAI,EAAAJ,EAAA5iE,CAEA,KAAA00C,EAAA,EAAgBA,GAAAsuB,EAAWtuB,IAE3B,IAAAA,GAAA10C,IAAA4iE,EAEA/6D,EAAA7H,GAAA00C,GAAAmuB,EAIAh7D,EAAA7H,GAAA00C,GAAAmuB,EAAAn1D,QAAAo1D,KAAAC,EAAAruB,EAAAsuB,GAUA,IAAAhjE,EAAA,EAAeA,EAAA4iE,EAAU5iE,IAEzB,IAAA00C,EAAA,EAAgBA,EAAA,GAAAkuB,EAAA5iE,GAAA,EAA0B00C,IAAA,CAE1C,GAAA5rC,GAAAvD,KAAAyB,MAAA0tC,EAAA,EAEAA,GAAA,OAEAuuB,EAAAp7D,EAAA7H,GAAA8I,EAAA,IACAm6D,EAAAp7D,EAAA7H,EAAA,GAAA8I,IACAm6D,EAAAp7D,EAAA7H,GAAA8I,MAIAm6D,EAAAp7D,EAAA7H,GAAA8I,EAAA,IACAm6D,EAAAp7D,EAAA7H,EAAA,GAAA8I,EAAA,IACAm6D,EAAAp7D,EAAA7H,EAAA,GAAA8I,MAUA,QAAAo6D,GAAAtmD,GAMA,OAJA0kD,GAAA,GAAA7mD,GAIAza,EAAA,EAAmBA,EAAAkpB,EAAAtqB,OAAyBoB,GAAA,EAE5CshE,EAAAnrD,EAAA+S,EAAAlpB,EAAA,GACAshE,EAAAhrD,EAAA4S,EAAAlpB,EAAA,GACAshE,EAAAjiD,EAAA6J,EAAAlpB,EAAA,GAEAshE,EAAAvS,YAAApxC,eAAAf,GAEAsM,EAAAlpB,EAAA,GAAAshE,EAAAnrD,EACA+S,EAAAlpB,EAAA,GAAAshE,EAAAhrD,EACA4S,EAAAlpB,EAAA,GAAAshE,EAAAjiD,EAMA,QAAA8jD,KAIA,OAFA7B,GAAA,GAAA7mD,GAEAza,EAAA,EAAmBA,EAAAkpB,EAAAtqB,OAAyBoB,GAAA,GAE5CshE,EAAAnrD,EAAA+S,EAAAlpB,EAAA,GACAshE,EAAAhrD,EAAA4S,EAAAlpB,EAAA,GACAshE,EAAAjiD,EAAA6J,EAAAlpB,EAAA,EAEA,IAAAq+B,GAAA+kC,EAAA9B,GAAA,EAAA/7D,KAAAmO,GAAA,GACA7L,EAAAw7D,EAAA/B,GAAA/7D,KAAAmO,GAAA,EACA4vD,GAAAphE,KAAAm8B,EAAA,EAAAx2B,GAIA07D,IAEAC,IAIA,QAAAA,KAIA,OAAAxjE,GAAA,EAAmBA,EAAAsjE,EAAA1kE,OAAqBoB,GAAA,GAIxC,GAAAyjE,GAAAH,EAAAtjE,EAAA,GACA0jE,EAAAJ,EAAAtjE,EAAA,GACA2jE,EAAAL,EAAAtjE,EAAA,GAEAiH,EAAA1B,KAAA0B,IAAAw8D,EAAAC,EAAAC,GACAz8D,EAAA3B,KAAA2B,IAAAu8D,EAAAC,EAAAC,EAIA18D,GAAA,IAAAC,EAAA,KAEAu8D,EAAA,KAAAH,EAAAtjE,EAAA,OACA0jE,EAAA,KAAAJ,EAAAtjE,EAAA,OACA2jE,EAAA,KAAAL,EAAAtjE,EAAA,SAQA,QAAAijE,GAAA3B,GAEAp4C,EAAAhnB,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIA,QAAAqjD,GAAAt1D,EAAAk0D,GAEA,GAAAtP,GAAA,EAAA5kD,CAEAk0D,GAAAnrD,EAAAhK,EAAA6lD,EAAA,GACAsP,EAAAhrD,EAAAnK,EAAA6lD,EAAA,GACAsP,EAAAjiD,EAAAlT,EAAA6lD,EAAA,GAIA,QAAAuR,KAYA,OAVAj1D,GAAA,GAAAmM,GACApU,EAAA,GAAAoU,GACApT,EAAA,GAAAoT,GAEAmpD,EAAA,GAAAnpD,GAEAopD,EAAA,GAAAtmD,GACAumD,EAAA,GAAAvmD,GACAwmD,EAAA,GAAAxmD,GAEAvd,EAAA,EAAA00C,EAAA,EAA0B10C,EAAAkpB,EAAAtqB,OAAyBoB,GAAA,EAAA00C,GAAA,GAEnDpmC,EAAA+G,IAAA6T,EAAAlpB,EAAA,GAAAkpB,EAAAlpB,EAAA,GAAAkpB,EAAAlpB,EAAA,IACAqG,EAAAgP,IAAA6T,EAAAlpB,EAAA,GAAAkpB,EAAAlpB,EAAA,GAAAkpB,EAAAlpB,EAAA,IACAqH,EAAAgO,IAAA6T,EAAAlpB,EAAA,GAAAkpB,EAAAlpB,EAAA,GAAAkpB,EAAAlpB,EAAA,IAEA6jE,EAAAxuD,IAAAiuD,EAAA5uB,EAAA,GAAA4uB,EAAA5uB,EAAA,IACAovB,EAAAzuD,IAAAiuD,EAAA5uB,EAAA,GAAA4uB,EAAA5uB,EAAA,IACAqvB,EAAA1uD,IAAAiuD,EAAA5uB,EAAA,GAAA4uB,EAAA5uB,EAAA,IAEAkvB,EAAAnxD,KAAAnE,GAAA8E,IAAA/M,GAAA+M,IAAA/L,GAAA28D,aAAA,EAEA,IAAAC,GAAAb,EAAAQ,EAEAM,GAAAL,EAAAnvB,EAAA,EAAApmC,EAAA21D,GACAC,EAAAJ,EAAApvB,EAAA,EAAAruC,EAAA49D,GACAC,EAAAH,EAAArvB,EAAA,EAAArtC,EAAA48D,IAMA,QAAAC,GAAAr6C,EAAAmoC,EAAA5yB,EAAAgkC,GAEAA,EAAA,OAAAv5C,EAAA1T,IAEAmtD,EAAAtR,GAAAnoC,EAAA1T,EAAA,GAIA,IAAAipB,EAAAjpB,GAAA,IAAAipB,EAAA/f,IAEAikD,EAAAtR,GAAAoR,EAAA,EAAA79D,KAAAmO,GAAA,IAQA,QAAA0vD,GAAAhkC,GAEA,MAAA75B,MAAA4+D,MAAA/kC,EAAA/f,GAAA+f,EAAAjpB,GAOA,QAAAktD,GAAAjkC,GAEA,MAAA75B,MAAA4+D,OAAA/kC,EAAA9oB,EAAA/Q,KAAA2S,KAAAknB,EAAAjpB,EAAAipB,EAAAjpB,EAAAipB,EAAA/f,EAAA+f,EAAA/f,IAlSAvN,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,2BAEAoC,KAAAgwB,YACA1kB,WACAoxB,UACA3gB,SACA2lD,UAGA3lD,KAAA,EACA2lD,KAAA,CAIA,IAAAr5C,MACAo6C,IAIAb,GAAAF,GAIAW,EAAAtmD,GAIAumD,IAIAtiE,KAAAkR,aAAA,cAAAqrB,IAAAlU,EAAA,IACAroB,KAAAkR,aAAA,YAAAqrB,IAAAlU,EAAA62C,QAAA,IACAl/D,KAAAkR,aAAA,QAAAqrB,IAAAkmC,EAAA,IAEA,IAAAf,EAEA1hE,KAAAqR,uBAIArR,KAAAujE,mBAuQA,QAAAC,IAAAznD,EAAA2lD,GAEA7mC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAAgwB,YACAjU,SACA2lD,UAGA1hE,KAAAo9B,mBAAA,GAAAqmC,IAAA1nD,EAAA2lD,IACA1hE,KAAAs9B,gBASA,QAAAmmC,IAAA1nD,EAAA2lD,GAEA,GAAAp2D,IACA,+BAGAoxB,GACA,wBAGAilC,IAAA5hE,KAAAC,KAAAsL,EAAAoxB,EAAA3gB,EAAA2lD,GAEA1hE,KAAApC,KAAA,4BAEAoC,KAAAgwB,YACAjU,SACA2lD,UAeA,QAAAgC,IAAA3nD,EAAA2lD,GAEA7mC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAAgwB,YACAjU,SACA2lD,UAGA1hE,KAAAo9B,mBAAA,GAAAumC,IAAA5nD,EAAA2lD,IACA1hE,KAAAs9B,gBASA,QAAAqmC,IAAA5nD,EAAA2lD,GAEA,GAAAp2D,IACA,mBACA,qBAGAoxB,GACA,kBACA,kBACA,YAGAilC,IAAA5hE,KAAAC,KAAAsL,EAAAoxB,EAAA3gB,EAAA2lD,GAEA1hE,KAAApC,KAAA,2BAEAoC,KAAAgwB,YACAjU,SACA2lD,UAeA,QAAAkC,IAAA7nD,EAAA2lD,GAEA7mC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAAgwB,YACAjU,SACA2lD,UAGA1hE,KAAAo9B,mBAAA,GAAAymC,IAAA9nD,EAAA2lD,IACA1hE,KAAAs9B,gBASA,QAAAumC,IAAA9nD,EAAA2lD,GAEA,GAAAr6D,IAAA,EAAA3C,KAAA2S,KAAA,MAEA/L,IACA,EAAAjE,EAAA,IAAAA,EAAA,MAAAA,EAAA,KAAAA,EAAA,EACA,KAAAA,EAAA,IAAAA,EAAA,MAAAA,EAAA,KAAAA,EACAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,MAAAA,EAAA,KAGAq1B,GACA,kCACA,kCACA,8BACA,gCAGAilC,IAAA5hE,KAAAC,KAAAsL,EAAAoxB,EAAA3gB,EAAA2lD,GAEA1hE,KAAApC,KAAA,4BAEAoC,KAAAgwB,YACAjU,SACA2lD,UAeA,QAAAoC,IAAA/nD,EAAA2lD,GAEA7mC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,uBAEAoC,KAAAgwB,YACAjU,SACA2lD,UAGA1hE,KAAAo9B,mBAAA,GAAA2mC,IAAAhoD,EAAA2lD,IACA1hE,KAAAs9B,gBASA,QAAAymC,IAAAhoD,EAAA2lD,GAEA,GAAAr6D,IAAA,EAAA3C,KAAA2S,KAAA,MACA/P,EAAA,EAAAD,EAEAiE,IAGA,iBACA,cACA,eACA,aAGA,GAAAhE,GAAAD,EAAA,GAAAC,EAAAD,EACA,EAAAC,GAAAD,EAAA,EAAAC,EAAAD,GAGAC,GAAAD,EAAA,GAAAC,EAAAD,EAAA,EACAC,GAAAD,EAAA,EAAAC,EAAAD,EAAA,GAGAA,EAAA,GAAAC,EAAAD,EAAA,GAAAC,GACAD,EAAA,EAAAC,EAAAD,EAAA,EAAAC,GAGAo1B,GACA,sBACA,sBACA,uBACA,qBACA,sBACA,sBACA,sBACA,uBACA,qBACA,uBACA,wBACA,qBAGAilC,IAAA5hE,KAAAC,KAAAsL,EAAAoxB,EAAA3gB,EAAA2lD,GAEA1hE,KAAApC,KAAA,6BAEAoC,KAAAgwB,YACAjU,SACA2lD,UAoBA,QAAAsC,IAAAn5D,EAAAo5D,EAAAloD,EAAAmoD,EAAAC,EAAAC,GAEAvpC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,eAEAoC,KAAAgwB,YACAnlB,OACAo5D,kBACAloD,SACAmoD,iBACAC,UAGA17D,SAAA27D,GAAA90D,QAAA4E,KAAA,8CAEA,IAAAmwD,GAAA,GAAAC,IAAAz5D,EAAAo5D,EAAAloD,EAAAmoD,EAAAC,EAIAnkE,MAAAukE,SAAAF,EAAAE,SACAvkE,KAAAuL,QAAA84D,EAAA94D,QACAvL,KAAAwkE,UAAAH,EAAAG,UAIAxkE,KAAAo9B,mBAAAinC,GACArkE,KAAAs9B,gBASA,QAAAgnC,IAAAz5D,EAAAo5D,EAAAloD,EAAAmoD,EAAAC,GAwDA,QAAAM,KAEA,IAAAtlE,EAAA,EAAeA,EAAA8kE,EAAqB9kE,IAEpCulE,EAAAvlE,EASAulE,GAAAP,KAAA,EAAAF,EAAA,GAKA3B,IAIAqC,IAIA,QAAAD,GAAAvlE,GAIAylE,EAAA/5D,EAAAg6D,WAAA1lE,EAAA8kE,EAAAW,EAIA,IAAAE,GAAAC,EAAAx5D,QAAApM,GACAwJ,EAAAo8D,EAAAP,UAAArlE,EAIA,KAAA00C,EAAA,EAAeA,GAAAqwB,EAAqBrwB,IAAA,CAEpC,GAAA7sC,GAAA6sC,EAAAqwB,EAAAx/D,KAAAmO,GAAA,EAEAmyD,EAAAtgE,KAAAsgE,IAAAh+D,GACAqmD,GAAA3oD,KAAA2oD,IAAArmD,EAIAmqB,GAAA7b,EAAA+3C,EAAAyX,EAAAxvD,EAAA0vD,EAAAr8D,EAAA2M,EACA6b,EAAA1b,EAAA43C,EAAAyX,EAAArvD,EAAAuvD,EAAAr8D,EAAA8M,EACA0b,EAAA3S,EAAA6uC,EAAAyX,EAAAtmD,EAAAwmD,EAAAr8D,EAAA6V,EACA2S,EAAA+8B,YAEA3iD,EAAAlK,KAAA8vB,EAAA7b,EAAA6b,EAAA1b,EAAA0b,EAAA3S,GAIAiiD,EAAAnrD,EAAAsvD,EAAAtvD,EAAAyG,EAAAoV,EAAA7b,EACAmrD,EAAAhrD,EAAAmvD,EAAAnvD,EAAAsG,EAAAoV,EAAA1b,EACAgrD,EAAAjiD,EAAAomD,EAAApmD,EAAAzC,EAAAoV,EAAA3S,EAEAlT,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,IAMA,QAAAmmD,KAEA,IAAA9wB,EAAA,EAAeA,GAAAowB,EAAsBpwB,IAErC,IAAA10C,EAAA,EAAgBA,GAAA+kE,EAAqB/kE,IAAA,CAErC,GAAAsO,IAAAy2D,EAAA,IAAArwB,EAAA,IAAA10C,EAAA,GACAqG,GAAA0+D,EAAA,GAAArwB,GAAA10C,EAAA,GACAqH,GAAA09D,EAAA,GAAArwB,EAAA10C,EACA8O,GAAAi2D,EAAA,IAAArwB,EAAA,GAAA10C,CAIAu9B,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,IAQA,QAAAq0D,KAEA,IAAAnjE,EAAA,EAAeA,GAAA8kE,EAAsB9kE,IAErC,IAAA00C,EAAA,EAAgBA,GAAAqwB,EAAqBrwB,IAErC7qB,EAAA1T,EAAAnW,EAAA8kE,EACAj7C,EAAAvT,EAAAo+B,EAAAqwB,EAEA14D,EAAAnK,KAAA2nB,EAAA1T,EAAA0T,EAAAvT,GAxJAxE,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAAgwB,YACAnlB,OACAo5D,kBACAloD,SACAmoD,iBACAC,UAGAF,KAAA,GACAloD,KAAA,EACAmoD,KAAA,EACAC,MAAA,CAEA,IAAAY,GAAAl6D,EAAAo6D,oBAAAhB,EAAAE,EAIAnkE,MAAAukE,SAAAQ,EAAAR,SACAvkE,KAAAuL,QAAAw5D,EAAAx5D,QACAvL,KAAAwkE,UAAAO,EAAAP,SAIA,IAKArlE,GAAA00C,EALA4sB,EAAA,GAAA7mD,GACAuX,EAAA,GAAAvX,GACAoP,EAAA,GAAAtM,GACAkoD,EAAA,GAAAhrD,GAMAtO,KACAC,KACAC,KACAkxB,IAIA+nC,KAIAzkE,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IA4HA,QAAA05D,IAAAnpD,EAAAopD,EAAAlB,EAAAC,EAAA/8D,EAAAC,EAAAg+D,GAEAvqC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAAgwB,YACAjU,SACAopD,OACAlB,kBACAC,iBACA/8D,IACAC,KAGAqB,SAAA28D,GAAA91D,QAAA4E,KAAA,4FAEAlU,KAAAo9B,mBAAA,GAAAioC,IAAAtpD,EAAAopD,EAAAlB,EAAAC,EAAA/8D,EAAAC,IACApH,KAAAs9B,gBASA,QAAA+nC,IAAAtpD,EAAAopD,EAAAlB,EAAAC,EAAA/8D,EAAAC,GAqIA,QAAAk+D,GAAA9nC,EAAAr2B,EAAAC,EAAA2U,EAAApB,GAEA,GAAA4qD,GAAA7gE,KAAA2oD,IAAA7vB,GACAgoC,EAAA9gE,KAAAsgE,IAAAxnC,GACAioC,EAAAr+D,EAAAD,EAAAq2B,EACAkoC,EAAAhhE,KAAA2oD,IAAAoY,EAEA9qD,GAAArF,EAAAyG,GAAA,EAAA2pD,GAAA,GAAAH,EACA5qD,EAAAlF,EAAAsG,GAAA,EAAA2pD,GAAAF,EAAA,GACA7qD,EAAA6D,EAAAzC,EAAArX,KAAAsgE,IAAAS,GAAA,GA5IAx0D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,0BAEAoC,KAAAgwB,YACAjU,SACAopD,OACAlB,kBACAC,iBACA/8D,IACAC,KAGA2U,KAAA,EACAopD,KAAA,GACAlB,EAAAv/D,KAAAyB,MAAA89D,IAAA,GACAC,EAAAx/D,KAAAyB,MAAA+9D,IAAA,EACA/8D,KAAA,EACAC,KAAA,CAIA,IAOAjI,GAAA00C,EAPAnX,KACApxB,KACAC,KACAC,KAMAi1D,EAAA,GAAA7mD,GACAuX,EAAA,GAAAvX,GAEA+rD,EAAA,GAAA/rD,GACAgsD,EAAA,GAAAhsD,GAEAjR,EAAA,GAAAiR,GACAisD,EAAA,GAAAjsD,GACAkrD,EAAA,GAAAlrD,EAIA,KAAAza,EAAA,EAAcA,GAAA8kE,IAAsB9kE,EAAA,CAIpC,GAAAq+B,GAAAr+B,EAAA8kE,EAAA98D,EAAAzC,KAAAmO,GAAA,CAoBA,KAfAyyD,EAAA9nC,EAAAr2B,EAAAC,EAAA2U,EAAA4pD,GACAL,EAAA9nC,EAAA,IAAAr2B,EAAAC,EAAA2U,EAAA6pD,GAIAC,EAAA3wD,WAAA0wD,EAAAD,GACAb,EAAAgB,WAAAF,EAAAD,GACAh9D,EAAA64D,aAAAqE,EAAAf,GACAA,EAAAtD,aAAA74D,EAAAk9D,GAIAl9D,EAAAulD,YACA4W,EAAA5W,YAEAra,EAAA,EAAeA,GAAAqwB,IAAqBrwB,EAAA,CAKpC,GAAA7sC,GAAA6sC,EAAAqwB,EAAAx/D,KAAAmO,GAAA,EACAkzD,GAAAZ,EAAAzgE,KAAA2oD,IAAArmD,GACAg/D,EAAAb,EAAAzgE,KAAAsgE,IAAAh+D,EAKAy5D,GAAAnrD,EAAAqwD,EAAArwD,GAAAywD,EAAAjB,EAAAxvD,EAAA0wD,EAAAr9D,EAAA2M,GACAmrD,EAAAhrD,EAAAkwD,EAAAlwD,GAAAswD,EAAAjB,EAAArvD,EAAAuwD,EAAAr9D,EAAA8M,GACAgrD,EAAAjiD,EAAAmnD,EAAAnnD,GAAAunD,EAAAjB,EAAAtmD,EAAAwnD,EAAAr9D,EAAA6V,GAEAlT,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIA2S,EAAAjc,WAAAurD,EAAAkF,GAAAzX,YAEA3iD,EAAAlK,KAAA8vB,EAAA7b,EAAA6b,EAAA1b,EAAA0b,EAAA3S,GAIAhT,EAAAnK,KAAAlC,EAAA8kE,GACAz4D,EAAAnK,KAAAwyC,EAAAqwB,IAQA,IAAArwB,EAAA,EAAcA,GAAAowB,EAAsBpwB,IAEpC,IAAA10C,EAAA,EAAeA,GAAA+kE,EAAqB/kE,IAAA,CAIpC,GAAAsO,IAAAy2D,EAAA,IAAArwB,EAAA,IAAA10C,EAAA,GACAqG,GAAA0+D,EAAA,GAAArwB,GAAA10C,EAAA,GACAqH,GAAA09D,EAAA,GAAArwB,EAAA10C,EACA8O,GAAAi2D,EAAA,IAAArwB,EAAA,GAAA10C,CAIAu9B,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAQAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IA8BA,QAAAy6D,IAAAlqD,EAAAopD,EAAAjB,EAAAD,EAAAiC,GAEArrC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,gBAEAoC,KAAAgwB,YACAjU,SACAopD,OACAjB,iBACAD,kBACAiC,OAGAlmE,KAAAo9B,mBAAA,GAAA+oC,IAAApqD,EAAAopD,EAAAjB,EAAAD,EAAAiC,IACAlmE,KAAAs9B,gBASA,QAAA6oC,IAAApqD,EAAAopD,EAAAjB,EAAAD,EAAAiC,GAEAj1D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAAgwB,YACAjU,SACAopD,OACAjB,iBACAD,kBACAiC,OAGAnqD,KAAA,EACAopD,KAAA,GACAjB,EAAAx/D,KAAAyB,MAAA+9D,IAAA,EACAD,EAAAv/D,KAAAyB,MAAA89D,IAAA,EACAiC,KAAA,EAAAxhE,KAAAmO,EAIA,IAWAghC,GAAA10C,EAXAu9B,KACApxB,KACAC,KACAC,KAIAmS,EAAA,GAAA/D,GACA6mD,EAAA,GAAA7mD,GACAuX,EAAA,GAAAvX,EAMA,KAAAi6B,EAAA,EAAcA,GAAAqwB,EAAqBrwB,IAEnC,IAAA10C,EAAA,EAAeA,GAAA8kE,EAAsB9kE,IAAA,CAErC,GAAAq+B,GAAAr+B,EAAA8kE,EAAAiC,EACAl/D,EAAA6sC,EAAAqwB,EAAAx/D,KAAAmO,GAAA,CAIA4tD,GAAAnrD,GAAAyG,EAAAopD,EAAAzgE,KAAA2oD,IAAArmD,IAAAtC,KAAA2oD,IAAA7vB,GACAijC,EAAAhrD,GAAAsG,EAAAopD,EAAAzgE,KAAA2oD,IAAArmD,IAAAtC,KAAAsgE,IAAAxnC,GACAijC,EAAAjiD,EAAA2mD,EAAAzgE,KAAAsgE,IAAAh+D,GAEAsE,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIAb,EAAArI,EAAAyG,EAAArX,KAAA2oD,IAAA7vB,GACA7f,EAAAlI,EAAAsG,EAAArX,KAAAsgE,IAAAxnC,GACArM,EAAAjc,WAAAurD,EAAA9iD,GAAAuwC,YAEA3iD,EAAAlK,KAAA8vB,EAAA7b,EAAA6b,EAAA1b,EAAA0b,EAAA3S,GAIAhT,EAAAnK,KAAAlC,EAAA8kE,GACAz4D,EAAAnK,KAAAwyC,EAAAqwB,GAQA,IAAArwB,EAAA,EAAcA,GAAAqwB,EAAqBrwB,IAEnC,IAAA10C,EAAA,EAAeA,GAAA8kE,EAAsB9kE,IAAA,CAIrC,GAAAsO,IAAAw2D,EAAA,GAAApwB,EAAA10C,EAAA,EACAqG,GAAAy+D,EAAA,IAAApwB,EAAA,GAAA10C,EAAA,EACAqH,GAAAy9D,EAAA,IAAApwB,EAAA,GAAA10C,EACA8O,GAAAg2D,EAAA,GAAApwB,EAAA10C,CAIAu9B,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAQAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IAgEA,QAAA46D,IAAAxkD,EAAAmb,EAAA/vB,EAAAq5D,EAAAC,GAEA,GAAAnnE,GAAAonE,CAEA,IAAAD,IAAAE,GAAA5kD,EAAAmb,EAAA/vB,EAAAq5D,GAAA,EAEA,IAAAlnE,EAAA49B,EAAmB59B,EAAA6N,EAAS7N,GAAAknE,EAAAE,EAAAE,GAAAtnE,EAAAyiB,EAAAziB,GAAAyiB,EAAAziB,EAAA,GAAAonE,OAI5B,KAAApnE,EAAA6N,EAAAq5D,EAAuBlnE,GAAA49B,EAAY59B,GAAAknE,EAAAE,EAAAE,GAAAtnE,EAAAyiB,EAAAziB,GAAAyiB,EAAAziB,EAAA,GAAAonE,EAWnC,OAPAA,IAAAjuB,GAAAiuB,IAAAr/C,QAEAw/C,GAAAH,GACAA,IAAAr/C,MAIAq/C,EAMA,QAAAI,IAAA5pC,EAAA/vB,GAEA,IAAA+vB,EAAA,MAAAA,EACA/vB,OAAA+vB,EAEA,IAAA6pC,GAAAz/D,EAAA41B,CAEA,GAIA,IAFA6pC,GAAA,EAEAz/D,EAAA0/D,UAAAvuB,GAAAnxC,IAAA+f,OAAA,IAAA4/C,GAAA3/D,EAAA4/D,KAAA5/D,IAAA+f,MASA/f,IAAA+f,SATA,CAIA,GAFAw/C,GAAAv/D,GACAA,EAAA6F,EAAA7F,EAAA4/D,KACA5/D,MAAA+f,KAAA,KACA0/C,IAAA,QAQGA,GAAAz/D,IAAA6F,EAEH,OAAAA,GAMA,QAAAg6D,IAAAC,EAAAC,EAAAb,EAAAc,EAAAC,EAAAC,EAAAC,GAEA,GAAAL,EAAA,EAIAK,GAAAD,GAAAE,GAAAN,EAAAE,EAAAC,EAAAC,EAMA,KAJA,GAAAN,GAAA7/C,EAAAsgD,EAAAP,EAIAA,EAAAF,OAAAE,EAAA//C,MAKA,GAHA6/C,EAAAE,EAAAF,KACA7/C,EAAA+/C,EAAA//C,KAEAmgD,EAAAI,GAAAR,EAAAE,EAAAC,EAAAC,GAAAK,GAAAT,GAGAC,EAAA7lE,KAAA0lE,EAAA5nE,EAAAknE,GACAa,EAAA7lE,KAAA4lE,EAAA9nE,EAAAknE,GACAa,EAAA7lE,KAAA6lB,EAAA/nB,EAAAknE,GAEAK,GAAAO,GAGAA,EAAA//C,OACAsgD,EAAAtgD,WAUA,IAJA+/C,EAAA//C,EAIA+/C,IAAAO,EAAA,CAIAF,EAMK,IAAAA,GAELL,EAAAU,GAAAV,EAAAC,EAAAb,GACAW,GAAAC,EAAAC,EAAAb,EAAAc,EAAAC,EAAAC,EAAA,IAIK,IAAAC,GAELM,GAAAX,EAAAC,EAAAb,EAAAc,EAAAC,EAAAC,GAbAL,GAAAL,GAAAM,GAAAC,EAAAb,EAAAc,EAAAC,EAAAC,EAAA,EAiBA,SAUA,QAAAK,IAAAT,GAEA,GAAAx5D,GAAAw5D,EAAAF,KACAvhE,EAAAyhE,EACAzgE,EAAAygE,EAAA//C,IAEA,IAAA4/C,GAAAr5D,EAAAjI,EAAAgB,IAAA,UAKA,KAFA,GAAAW,GAAA8/D,EAAA//C,UAEA/f,IAAA8/D,EAAAF,MAAA,CAEA,GAAAc,GAAAp6D,EAAA6H,EAAA7H,EAAAgI,EAAAjQ,EAAA8P,EAAA9P,EAAAiQ,EAAAjP,EAAA8O,EAAA9O,EAAAiP,EAAAtO,EAAAmO,EAAAnO,EAAAsO,IAAAqxD,GAAA3/D,EAAA4/D,KAAA5/D,IAAA+f,OAAA,EAEA,QAIA/f,KAAA+f,KAIA,SAIA,QAAAugD,IAAAR,EAAAE,EAAAC,EAAAC,GAEA,GAAA55D,GAAAw5D,EAAAF,KACAvhE,EAAAyhE,EACAzgE,EAAAygE,EAAA//C,IAEA,IAAA4/C,GAAAr5D,EAAAjI,EAAAgB,IAAA,UAkBA,KAdA,GAAAshE,GAAAr6D,EAAA6H,EAAA9P,EAAA8P,EAAA7H,EAAA6H,EAAA9O,EAAA8O,EAAA7H,EAAA6H,EAAA9O,EAAA8O,EAAA9P,EAAA8P,EAAA9O,EAAA8O,EAAA9P,EAAA8P,EAAA9O,EAAA8O,EACAyyD,EAAAt6D,EAAAgI,EAAAjQ,EAAAiQ,EAAAhI,EAAAgI,EAAAjP,EAAAiP,EAAAhI,EAAAgI,EAAAjP,EAAAiP,EAAAjQ,EAAAiQ,EAAAjP,EAAAiP,EAAAjQ,EAAAiQ,EAAAjP,EAAAiP,EACAuyD,EAAAv6D,EAAA6H,EAAA9P,EAAA8P,EAAA7H,EAAA6H,EAAA9O,EAAA8O,EAAA7H,EAAA6H,EAAA9O,EAAA8O,EAAA9P,EAAA8P,EAAA9O,EAAA8O,EAAA9P,EAAA8P,EAAA9O,EAAA8O,EACA2yD,EAAAx6D,EAAAgI,EAAAjQ,EAAAiQ,EAAAhI,EAAAgI,EAAAjP,EAAAiP,EAAAhI,EAAAgI,EAAAjP,EAAAiP,EAAAjQ,EAAAiQ,EAAAjP,EAAAiP,EAAAjQ,EAAAiQ,EAAAjP,EAAAiP,EAIAyyD,EAAAC,GAAAL,EAAAC,EAAAZ,EAAAC,EAAAC,GACAe,EAAAD,GAAAH,EAAAC,EAAAd,EAAAC,EAAAC,GAIAlgE,EAAA8/D,EAAAoB,MAEAlhE,KAAAqX,GAAA4pD,GAAA,CAEA,GAAAjhE,IAAA8/D,EAAAF,MAAA5/D,IAAA8/D,EAAA//C,MACA2gD,GAAAp6D,EAAA6H,EAAA7H,EAAAgI,EAAAjQ,EAAA8P,EAAA9P,EAAAiQ,EAAAjP,EAAA8O,EAAA9O,EAAAiP,EAAAtO,EAAAmO,EAAAnO,EAAAsO,IACAqxD,GAAA3/D,EAAA4/D,KAAA5/D,IAAA+f,OAAA,UACA/f,KAAAkhE,MAQA,IAFAlhE,EAAA8/D,EAAAqB,MAEAnhE,KAAAqX,GAAA0pD,GAAA,CAEA,GAAA/gE,IAAA8/D,EAAAF,MAAA5/D,IAAA8/D,EAAA//C,MACA2gD,GAAAp6D,EAAA6H,EAAA7H,EAAAgI,EAAAjQ,EAAA8P,EAAA9P,EAAAiQ,EAAAjP,EAAA8O,EAAA9O,EAAAiP,EAAAtO,EAAAmO,EAAAnO,EAAAsO,IACAqxD,GAAA3/D,EAAA4/D,KAAA5/D,IAAA+f,OAAA,UAEA/f,KAAAmhE,MAIA,SAMA,QAAAX,IAAA5qC,EAAAmqC,EAAAb,GAEA,GAAAl/D,GAAA41B,CAEA,IAEA,GAAAtvB,GAAAtG,EAAA4/D,KAAAvhE,EAAA2B,EAAA+f,WAEAoxB,GAAA7qC,EAAAjI,IAAA+iE,GAAA96D,EAAAtG,IAAA+f,KAAA1hB,IAAAgjE,GAAA/6D,EAAAjI,IAAAgjE,GAAAhjE,EAAAiI,KAEAy5D,EAAA7lE,KAAAoM,EAAAtO,EAAAknE,GACAa,EAAA7lE,KAAA8F,EAAAhI,EAAAknE,GACAa,EAAA7lE,KAAAmE,EAAArG,EAAAknE,GAIAK,GAAAv/D,GACAu/D,GAAAv/D,EAAA+f,MAEA/f,EAAA41B,EAAAv3B,GAIA2B,IAAA+f,WAEG/f,IAAA41B,EAEH,OAAA51B,GAMA,QAAAygE,IAAA7qC,EAAAmqC,EAAAb,EAAAc,EAAAC,EAAAC,GAIA,GAAA55D,GAAAsvB,CAEA,IAIA,IAFA,GAAAv3B,GAAAiI,EAAAyZ,UAEA1hB,IAAAiI,EAAAs5D,MAAA,CAEA,GAAAt5D,EAAAtO,IAAAqG,EAAArG,GAAAspE,GAAAh7D,EAAAjI,GAAA,CAIA,GAAAgB,GAAAkiE,GAAAj7D,EAAAjI,EAWA,OAPAiI,GAAAk5D,GAAAl5D,IAAAyZ,MACA1gB,EAAAmgE,GAAAngE,IAAA0gB,MAIA8/C,GAAAv5D,EAAAy5D,EAAAb,EAAAc,EAAAC,EAAAC,OACAL,IAAAxgE,EAAA0gE,EAAAb,EAAAc,EAAAC,EAAAC,GAKA7hE,IAAA0hB,KAIAzZ,IAAAyZ,WAEGzZ,IAAAsvB,GAMH,QAAA4rC,IAAA/mD,EAAAgnD,EAAAC,EAAAxC,GAEA,GAAAlnE,GAAAyB,EAAAm8B,EAAA/vB,EAAAk2B,EAAA1iC,IAEA,KAAArB,EAAA,EAAAyB,EAAAgoE,EAAA7qE,OAAwCoB,EAAAyB,EAASzB,IAEjD49B,EAAA6rC,EAAAzpE,GAAAknE,EACAr5D,EAAA7N,EAAAyB,EAAA,EAAAgoE,EAAAzpE,EAAA,GAAAknE,EAAAzkD,EAAA7jB,OACAmlC,EAAAkjC,GAAAxkD,EAAAmb,EAAA/vB,EAAAq5D,GAAA,GACAnjC,MAAAhc,OAAAgc,EAAA2jC,SAAA,GACArmE,EAAAa,KAAAynE,GAAA5lC,GAQA,KAJA1iC,EAAAssB,KAAAi8C,IAIA5pE,EAAA,EAAcA,EAAAqB,EAAAzC,OAAkBoB,IAEhC6pE,GAAAxoE,EAAArB,GAAA0pE,GACAA,EAAAlC,GAAAkC,IAAA3hD,KAIA,OAAA2hD,GAIA,QAAAE,IAAAt7D,EAAAjI,GAEA,MAAAiI,GAAA6H,EAAA9P,EAAA8P,EAMA,QAAA0zD,IAAAC,EAAAJ,GAIA,GAFAA,EAAAK,GAAAD,EAAAJ,GAEA,CAEA,GAAArjE,GAAAkjE,GAAAG,EAAAI,EAEAtC,IAAAnhE,IAAA0hB,OAQA,QAAAgiD,IAAAD,EAAAJ,GAEA,GAIAtjE,GAJA4B,EAAA0hE,EACAM,EAAAF,EAAA3zD,EACA8zD,EAAAH,EAAAxzD,EACA4zD,IAAAtvD,IAMA,IAEA,GAAAqvD,GAAAjiE,EAAAsO,GAAA2zD,GAAAjiE,EAAA+f,KAAAzR,GAAAtO,EAAA+f,KAAAzR,IAAAtO,EAAAsO,EAAA,CAEA,GAAAH,GAAAnO,EAAAmO,GAAA8zD,EAAAjiE,EAAAsO,IAAAtO,EAAA+f,KAAA5R,EAAAnO,EAAAmO,IAAAnO,EAAA+f,KAAAzR,EAAAtO,EAAAsO,EAEA,IAAAH,GAAA6zD,GAAA7zD,EAAA+zD,EAAA,CAIA,GAFAA,EAAA/zD,EAEAA,IAAA6zD,EAAA,CAEA,GAAAC,IAAAjiE,EAAAsO,EAAA,MAAAtO,EACA,IAAAiiE,IAAAjiE,EAAA+f,KAAAzR,EAAA,MAAAtO,GAAA+f,KAIA3hB,EAAA4B,EAAAmO,EAAAnO,EAAA+f,KAAA5R,EAAAnO,IAAA+f,MAMA/f,IAAA+f,WAEG/f,IAAA0hE,EAEH,KAAAtjE,EAAA,WAEA,IAAA4jE,IAAAE,EAAA,MAAA9jE,GAAAwhE,IAMA,IAIA7pD,GAJAsqD,EAAAjiE,EACA+jE,EAAA/jE,EAAA+P,EACAi0D,EAAAhkE,EAAAkQ,EACA+zD,EAAAzvD,GAKA,KAFA5S,EAAA5B,EAAA2hB,KAEA/f,IAAAqgE,GAEA2B,GAAAhiE,EAAAmO,GAAAnO,EAAAmO,GAAAg0D,GAAAH,IAAAhiE,EAAAmO,GACAuyD,GAAAuB,EAAAG,EAAAJ,EAAAE,EAAAD,EAAAE,EAAAC,EAAAH,EAAAG,EAAAF,EAAAF,EAAAC,EAAAjiE,EAAAmO,EAAAnO,EAAAsO,KAEAyH,EAAAxY,KAAA2+B,IAAA+lC,EAAAjiE,EAAAsO,IAAA0zD,EAAAhiE,EAAAmO,IAEA4H,EAAAssD,GAAAtsD,IAAAssD,GAAAriE,EAAAmO,EAAA/P,EAAA+P,IAAAkzD,GAAArhE,EAAA8hE,KAEA1jE,EAAA4B,EACAqiE,EAAAtsD,IAMA/V,IAAA+f,IAIA,OAAA3hB,GAMA,QAAAgiE,IAAAxqC,EAAAoqC,EAAAC,EAAAC,GAEA,GAAAlgE,GAAA41B,CAEA,GAEA,QAAA51B,EAAAqX,IAAArX,EAAAqX,EAAA2pD,GAAAhhE,EAAAmO,EAAAnO,EAAAsO,EAAA0xD,EAAAC,EAAAC,IACAlgE,EAAAmhE,MAAAnhE,EAAA4/D,KACA5/D,EAAAkhE,MAAAlhE,EAAA+f,KACA/f,IAAA+f,WAEG/f,IAAA41B,EAEH51B,GAAAmhE,MAAAD,MAAA,KACAlhE,EAAAmhE,MAAA,KAEAmB,GAAAtiE,GAOA,QAAAsiE,IAAAvmC,GAEA,GAAA/jC,GAAAgI,EAAAC,EAAA9H,EAAAoqE,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,CAEA,IAOA,IALA3iE,EAAA+7B,EACAA,EAAA,KACAwmC,EAAA,KACAC,EAAA,EAEAxiE,GAAA,CAMA,IAJAwiE,IACAviE,EAAAD,EACAyiE,EAAA,EAEAzqE,EAAA,EAAgBA,EAAA2qE,IAEhBF,IACAxiE,IAAAihE,MACAjhE,GAJ4BjI,KAU5B,IAFA0qE,EAAAC,EAEAF,EAAA,GAAAC,EAAA,GAAAziE,GAEA,IAAAwiE,IAAA,IAAAC,IAAAziE,GAAAD,EAAAqX,GAAApX,EAAAoX,IAEAlf,EAAA6H,EACAA,IAAAkhE,MACAuB,MAIAtqE,EAAA8H,EACAA,IAAAihE,MACAwB,KAIAH,IAAArB,MAAA/oE,EACA4jC,EAAA5jC,EAEAA,EAAAgpE,MAAAoB,EACAA,EAAApqE,CAIA6H,GAAAC,EAIAsiE,EAAArB,MAAA,KACAyB,GAAA,QAEGH,EAAA,EAEH,OAAAzmC,GAMA,QAAAilC,IAAA7yD,EAAAG,EAAA0xD,EAAAC,EAAAC,GAiBA,MAbA/xD,GAAA,OAAAA,EAAA6xD,GAAAE,EACA5xD,EAAA,OAAAA,EAAA2xD,GAAAC,EAEA/xD,EAAA,UAAAA,KAAA,GACAA,EAAA,WAAAA,KAAA,GACAA,EAAA,WAAAA,KAAA,GACAA,EAAA,YAAAA,KAAA,GAEAG,EAAA,UAAAA,KAAA,GACAA,EAAA,WAAAA,KAAA,GACAA,EAAA,WAAAA,KAAA,GACAA,EAAA,YAAAA,KAAA,GAEAH,EAAAG,GAAA,EAMA,QAAAqzD,IAAA/rC,GAEA,GAAA51B,GAAA41B,EAAAgtC,EAAAhtC,CAEA,GAEA51B,GAAAmO,EAAAy0D,EAAAz0D,IAAAy0D,EAAA5iE,GACAA,IAAA+f,WAEG/f,IAAA41B,EAEH,OAAAgtC,GAMA,QAAAlC,IAAAmC,EAAAC,EAAAC,EAAAC,EAAApE,EAAAC,EAAAoE,EAAAC,GAEA,OAAAtE,EAAAqE,IAAAH,EAAAI,IAAAL,EAAAI,IAAApE,EAAAqE,IAAA,IACAL,EAAAI,IAAAD,EAAAE,IAAAH,EAAAE,IAAAH,EAAAI,IAAA,IACAH,EAAAE,IAAApE,EAAAqE,IAAAtE,EAAAqE,IAAAD,EAAAE,IAAA,EAMA,QAAA5B,IAAAh7D,EAAAjI,GAEA,MAAAiI,GAAAyZ,KAAA/nB,IAAAqG,EAAArG,GAAAsO,EAAAs5D,KAAA5nE,IAAAqG,EAAArG,IAAAmrE,GAAA78D,EAAAjI,IACAgjE,GAAA/6D,EAAAjI,IAAAgjE,GAAAhjE,EAAAiI,IAAA88D,GAAA98D,EAAAjI,GAMA,QAAAshE,IAAA3/D,EAAAC,EAAAE,GAEA,OAAAF,EAAAqO,EAAAtO,EAAAsO,IAAAnO,EAAAgO,EAAAlO,EAAAkO,IAAAlO,EAAAkO,EAAAnO,EAAAmO,IAAAhO,EAAAmO,EAAArO,EAAAqO,GAMA,QAAA6iC,IAAA/mB,EAAAC,GAEA,MAAAD,GAAAjc,IAAAkc,EAAAlc,GAAAic,EAAA9b,IAAA+b,EAAA/b,EAMA,QAAA8yD,IAAAh3C,EAAAi5C,EAAAh5C,EAAAi5C,GAEA,SAAAnyB,GAAA/mB,EAAAi5C,IAAAlyB,GAAA9mB,EAAAi5C,IACAnyB,GAAA/mB,EAAAk5C,IAAAnyB,GAAA9mB,EAAAg5C,KAEA1D,GAAAv1C,EAAAi5C,EAAAh5C,GAAA,GAAAs1C,GAAAv1C,EAAAi5C,EAAAC,GAAA,GACA3D,GAAAt1C,EAAAi5C,EAAAl5C,GAAA,GAAAu1C,GAAAt1C,EAAAi5C,EAAAD,GAAA,EAMA,QAAAF,IAAA78D,EAAAjI,GAEA,GAAA2B,GAAAsG,CAEA,IAEA,GAAAtG,EAAAhI,IAAAsO,EAAAtO,GAAAgI,EAAA+f,KAAA/nB,IAAAsO,EAAAtO,GAAAgI,EAAAhI,IAAAqG,EAAArG,GAAAgI,EAAA+f,KAAA/nB,IAAAqG,EAAArG,GACAopE,GAAAphE,IAAA+f,KAAAzZ,EAAAjI,GAEA,QAIA2B,KAAA+f,WAEG/f,IAAAsG,EAEH,UAMA,QAAA+6D,IAAA/6D,EAAAjI,GAEA,MAAAshE,IAAAr5D,EAAAs5D,KAAAt5D,IAAAyZ,MAAA,EACA4/C,GAAAr5D,EAAAjI,EAAAiI,EAAAyZ,OAAA,GAAA4/C,GAAAr5D,IAAAs5D,KAAAvhE,IAAA,EACAshE,GAAAr5D,EAAAjI,EAAAiI,EAAAs5D,MAAA,GAAAD,GAAAr5D,IAAAyZ,KAAA1hB,GAAA,EAMA,QAAA+kE,IAAA98D,EAAAjI,GAEA,GAAA2B,GAAAsG,EACAi9D,GAAA,EACAN,GAAA38D,EAAA6H,EAAA9P,EAAA8P,GAAA,EACA+0D,GAAA58D,EAAAgI,EAAAjQ,EAAAiQ,GAAA,CAEA,GAEAtO,GAAAsO,EAAA40D,GAAAljE,EAAA+f,KAAAzR,EAAA40D,GAAAljE,EAAA+f,KAAAzR,IAAAtO,EAAAsO,GACA20D,GAAAjjE,EAAA+f,KAAA5R,EAAAnO,EAAAmO,IAAA+0D,EAAAljE,EAAAsO,IAAAtO,EAAA+f,KAAAzR,EAAAtO,EAAAsO,GAAAtO,EAAAmO,IAEAo1D,MAIAvjE,IAAA+f,WAEG/f,IAAAsG,EAEH,OAAAi9D,GAOA,QAAAhC,IAAAj7D,EAAAjI,GAEA,GAAAmlE,GAAA,GAAAC,IAAAn9D,EAAAtO,EAAAsO,EAAA6H,EAAA7H,EAAAgI,GACAo1D,EAAA,GAAAD,IAAAplE,EAAArG,EAAAqG,EAAA8P,EAAA9P,EAAAiQ,GACAq1D,EAAAr9D,EAAAyZ,KACA6jD,EAAAvlE,EAAAuhE,IAcA,OAZAt5D,GAAAyZ,KAAA1hB,EACAA,EAAAuhE,KAAAt5D,EAEAk9D,EAAAzjD,KAAA4jD,EACAA,EAAA/D,KAAA4D,EAEAE,EAAA3jD,KAAAyjD,EACAA,EAAA5D,KAAA8D,EAEAE,EAAA7jD,KAAA2jD,EACAA,EAAA9D,KAAAgE,EAEAF,EAMA,QAAApE,IAAAtnE,EAAAmW,EAAAG,EAAA8wD,GAEA,GAAAp/D,GAAA,GAAAyjE,IAAAzrE,EAAAmW,EAAAG,EAgBA,OAdA8wD,IAOAp/D,EAAA+f,KAAAq/C,EAAAr/C,KACA/f,EAAA4/D,KAAAR,EACAA,EAAAr/C,KAAA6/C,KAAA5/D,EACAo/D,EAAAr/C,KAAA/f,IARAA,EAAA4/D,KAAA5/D,EACAA,EAAA+f,KAAA/f,GAWAA,EAIA,QAAAu/D,IAAAv/D,GAEAA,EAAA+f,KAAA6/C,KAAA5/D,EAAA4/D,KACA5/D,EAAA4/D,KAAA7/C,KAAA/f,EAAA+f,KAEA/f,EAAAmhE,QAAAnhE,EAAAmhE,MAAAD,MAAAlhE,EAAAkhE,OACAlhE,EAAAkhE,QAAAlhE,EAAAkhE,MAAAC,MAAAnhE,EAAAmhE,OAIA,QAAAsC,IAAAzrE,EAAAmW,EAAAG,GAGAzV,KAAAb,IAGAa,KAAAsV,IACAtV,KAAAyV,IAGAzV,KAAA+mE,KAAA,KACA/mE,KAAAknB,KAAA,KAGAlnB,KAAAwe,EAAA,KAGAxe,KAAAsoE,MAAA,KACAtoE,KAAAqoE,MAAA,KAGAroE,KAAA6mE,SAAA,EAIA,QAAAL,IAAA5kD,EAAAmb,EAAA/vB,EAAAq5D,GAIA,OAFA2E,GAAA,EAEA7rE,EAAA49B,EAAA8W,EAAA7mC,EAAAq5D,EAAqClnE,EAAA6N,EAAS7N,GAAAknE,EAE9C2E,IAAAppD,EAAAiyB,GAAAjyB,EAAAziB,KAAAyiB,EAAAziB,EAAA,GAAAyiB,EAAAiyB,EAAA,IACAA,EAAA10C,CAIA,OAAA6rE,GA0EA,QAAAC,IAAA7mC,GAEA,GAAAj1B,GAAAi1B,EAAArmC,MAEAoR,GAAA,GAAAi1B,EAAAj1B,EAAA,GAAAmpC,OAAAlU,EAAA,KAEAA,EAAA4L,MAMA,QAAAk7B,IAAA5/D,EAAA6/D,GAEA,OAAAhsE,GAAA,EAAkBA,EAAAgsE,EAAAptE,OAAoBoB,IAEtCmM,EAAAjK,KAAA8pE,EAAAhsE,GAAAmW,GACAhK,EAAAjK,KAAA8pE,EAAAhsE,GAAAsW,GAgCA,QAAA21D,IAAAC,EAAAnoE,GAEA23B,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,kBAEAoC,KAAAgwB,YACAq7C,SACAnoE,WAGAlD,KAAAo9B,mBAAA,GAAAkuC,IAAAD,EAAAnoE,IACAlD,KAAAs9B,gBASA,QAAAguC,IAAAD,EAAAnoE,GAEA,wBAMA+N,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,wBAEAytE,EAAAjqE,MAAAsL,QAAA2+D,SAEArrE,KAAAurE,aAAAF,EAAAnoE,GAEAlD,KAAAqR,wBA2vBA,QAAAm6D,IAAA1gE,EAAAklB,GAEA6K,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,eAEAoC,KAAAgwB,YACAllB,OACAklB,cAGAhwB,KAAAo9B,mBAAA,GAAAquC,IAAA3gE,EAAAklB,IACAhwB,KAAAs9B,gBASA,QAAAmuC,IAAA3gE,EAAAklB,GAEAA,OAEA,IAAA07C,GAAA17C,EAAA07C,IAEA,KAAAA,MAAAC,OAGA,MADAr8D,SAAAiP,MAAA,wEACA,GAAAsc,GAIA,IAAAwwC,GAAAK,EAAAE,eAAA9gE,EAAAklB,EAAAtK,KAAAsK,EAAA67C,cAIA77C,GAAA87C,OAAArjE,SAAAunB,EAAAhP,OAAAgP,EAAAhP,OAAA,GAIAvY,SAAAunB,EAAA+7C,iBAAA/7C,EAAA+7C,eAAA,IACAtjE,SAAAunB,EAAAg8C,YAAAh8C,EAAAg8C,UAAA,GACAvjE,SAAAunB,EAAAi8C,eAAAj8C,EAAAi8C,cAAA,GAEAX,GAAAvrE,KAAAC,KAAAqrE,EAAAr7C,GAEAhwB,KAAApC,KAAA,qBAeA,QAAAsuE,IAAAnwD,EAAAkhB,EAAAC,EAAAivC,EAAAC,EAAAC,EAAAC,GAEAzxC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,iBAEAoC,KAAAgwB,YACAjU,SACAkhB,gBACAC,iBACAivC,WACAC,YACAC,aACAC,eAGAtsE,KAAAo9B,mBAAA,GAAAmvC,IAAAxwD,EAAAkhB,EAAAC,EAAAivC,EAAAC,EAAAC,EAAAC,IACAtsE,KAAAs9B,gBASA,QAAAivC,IAAAxwD,EAAAkhB,EAAAC,EAAAivC,EAAAC,EAAAC,EAAAC,GAEAr7D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,uBAEAoC,KAAAgwB,YACAjU,SACAkhB,gBACAC,iBACAivC,WACAC,YACAC,aACAC,eAGAvwD,KAAA,EAEAkhB,EAAAv4B,KAAA0B,IAAA,EAAA1B,KAAAyB,MAAA82B,IAAA,GACAC,EAAAx4B,KAAA0B,IAAA,EAAA1B,KAAAyB,MAAA+2B,IAAA,GAEAivC,EAAA1jE,SAAA0jE,IAAA,EACAC,EAAA3jE,SAAA2jE,IAAA,EAAA1nE,KAAAmO,GAEAw5D,EAAA5jE,SAAA4jE,IAAA,EACAC,EAAA7jE,SAAA6jE,IAAA5nE,KAAAmO,EAEA,IAEAgrB,GAAAC,EAFA0uC,EAAAH,EAAAC,EAIA//D,EAAA,EACAkgE,KAEAhM,EAAA,GAAA7mD,GACAuX,EAAA,GAAAvX,GAIA8iB,KACApxB,KACAC,KACAC,IAIA,KAAAsyB,EAAA,EAAeA,GAAAZ,EAAsBY,IAAA,CAErC,GAAA4uC,MAEA1lE,EAAA82B,EAAAZ,CAEA,KAAAW,EAAA,EAAgBA,GAAAZ,EAAqBY,IAAA,CAErC,GAAAL,GAAAK,EAAAZ,CAIAwjC,GAAAnrD,GAAAyG,EAAArX,KAAA2oD,IAAA8e,EAAA3uC,EAAA4uC,GAAA1nE,KAAAsgE,IAAAqH,EAAArlE,EAAAslE,GACA7L,EAAAhrD,EAAAsG,EAAArX,KAAA2oD,IAAAgf,EAAArlE,EAAAslE,GACA7L,EAAAjiD,EAAAzC,EAAArX,KAAAsgE,IAAAmH,EAAA3uC,EAAA4uC,GAAA1nE,KAAAsgE,IAAAqH,EAAArlE,EAAAslE,GAEAhhE,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIA2S,EAAA3c,IAAAisD,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAAA0vC,YACA3iD,EAAAlK,KAAA8vB,EAAA7b,EAAA6b,EAAA1b,EAAA0b,EAAA3S,GAIAhT,EAAAnK,KAAAm8B,EAAA,EAAAx2B,GAEA0lE,EAAArrE,KAAAkL,KAIAkgE,EAAAprE,KAAAqrE,GAMA,IAAA5uC,EAAA,EAAeA,EAAAZ,EAAqBY,IAEpC,IAAAD,EAAA,EAAgBA,EAAAZ,EAAoBY,IAAA,CAEpC,GAAApwB,GAAAg/D,EAAA3uC,GAAAD,EAAA,GACAr4B,EAAAinE,EAAA3uC,GAAAD,GACAr3B,EAAAimE,EAAA3uC,EAAA,GAAAD,GACA5vB,EAAAw+D,EAAA3uC,EAAA,GAAAD,EAAA,IAEA,IAAAC,GAAAuuC,EAAA,IAAA3vC,EAAAr7B,KAAAoM,EAAAjI,EAAAyI,IACA6vB,IAAAZ,EAAA,GAAAsvC,EAAA9nE,KAAAmO,KAAA6pB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAQAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IAcA,QAAAmhE,IAAAC,EAAAC,EAAAC,EAAAC,EAAAV,EAAAC,GAEAzxC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,eAEAoC,KAAAgwB,YACA48C,cACAC,cACAC,gBACAC,cACAV,aACAC,eAGAtsE,KAAAo9B,mBAAA,GAAA4vC,IAAAJ,EAAAC,EAAAC,EAAAC,EAAAV,EAAAC,IACAtsE,KAAAs9B,gBASA,QAAA0vC,IAAAJ,EAAAC,EAAAC,EAAAC,EAAAV,EAAAC,GAEAr7D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAAgwB,YACA48C,cACAC,cACAC,gBACAC,cACAV,aACAC,eAGAM,KAAA,GACAC,KAAA,EAEAR,EAAA5jE,SAAA4jE,IAAA,EACAC,EAAA7jE,SAAA6jE,IAAA,EAAA5nE,KAAAmO,GAEAi6D,EAAArkE,SAAAqkE,EAAApoE,KAAA0B,IAAA,EAAA0mE,GAAA,EACAC,EAAAtkE,SAAAskE,EAAAroE,KAAA0B,IAAA,EAAA2mE,GAAA,CAIA,IAOAE,GAKAp5B,EAAA10C,EAZAu9B,KACApxB,KACAC,KACAC,KAKAuQ,EAAA6wD,EACAM,GAAAL,EAAAD,GAAAG,EACAtM,EAAA,GAAA7mD,GACAoP,EAAA,GAAAtM,EAKA,KAAAm3B,EAAA,EAAcA,GAAAk5B,EAAkBl5B,IAAA,CAEhC,IAAA10C,EAAA,EAAeA,GAAA2tE,EAAoB3tE,IAInC8tE,EAAAZ,EAAAltE,EAAA2tE,EAAAR,EAIA7L,EAAAnrD,EAAAyG,EAAArX,KAAA2oD,IAAA4f,GACAxM,EAAAhrD,EAAAsG,EAAArX,KAAAsgE,IAAAiI,GAEA3hE,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIAjT,EAAAlK,KAAA,OAIA2nB,EAAA1T,GAAAmrD,EAAAnrD,EAAAu3D,EAAA,KACA7jD,EAAAvT,GAAAgrD,EAAAhrD,EAAAo3D,EAAA,KAEArhE,EAAAnK,KAAA2nB,EAAA1T,EAAA0T,EAAAvT,EAMAsG,IAAAmxD,EAMA,IAAAr5B,EAAA,EAAcA,EAAAk5B,EAAiBl5B,IAAA,CAE/B,GAAAs5B,GAAAt5B,GAAAi5B,EAAA,EAEA,KAAA3tE,EAAA,EAAeA,EAAA2tE,EAAmB3tE,IAAA,CAElC8tE,EAAA9tE,EAAAguE,CAEA,IAAA1/D,GAAAw/D,EACAznE,EAAAynE,EAAAH,EAAA,EACAtmE,EAAAymE,EAAAH,EAAA,EACA7+D,EAAAg/D,EAAA,CAIAvwC,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,IAQAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IAgBA,QAAA4hE,IAAAhpC,EAAAipC,EAAAlB,EAAAC,GAEAvxC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,gBAEAoC,KAAAgwB,YACAoU,SACAipC,WACAlB,WACAC,aAGApsE,KAAAo9B,mBAAA,GAAAkwC,IAAAlpC,EAAAipC,EAAAlB,EAAAC,IACApsE,KAAAs9B,gBASA,QAAAgwC,IAAAlpC,EAAAipC,EAAAlB,EAAAC,GAEAn7D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAAgwB,YACAoU,SACAipC,WACAlB,WACAC,aAGAiB,EAAA3oE,KAAAyB,MAAAknE,IAAA,GACAlB,KAAA,EACAC,KAAA,EAAA1nE,KAAAmO,GAIAu5D,EAAA1sD,GAAA6tD,MAAAnB,EAAA,IAAA1nE,KAAAmO,GAKA,IAMA26D,GAIAruE,EAAA00C,EAVAnX,KACApxB,KACAE,KAKAiiE,EAAA,EAAAJ,EACA5M,EAAA,GAAA7mD,GACAoP,EAAA,GAAAtM,EAKA,KAAAvd,EAAA,EAAcA,GAAAkuE,EAAeluE,IAAA,CAE7B,GAAAoU,GAAA44D,EAAAhtE,EAAAsuE,EAAArB,EAEApH,EAAAtgE,KAAAsgE,IAAAzxD,GACA85C,EAAA3oD,KAAA2oD,IAAA95C,EAEA,KAAAsgC,EAAA,EAAeA,GAAAzP,EAAArmC,OAAA,EAA4B81C,IAI3C4sB,EAAAnrD,EAAA8uB,EAAAyP,GAAAv+B,EAAA0vD,EACAvE,EAAAhrD,EAAA2uB,EAAAyP,GAAAp+B,EACAgrD,EAAAjiD,EAAA4lB,EAAAyP,GAAAv+B,EAAA+3C,EAEA/hD,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIAwK,EAAA1T,EAAAnW,EAAAkuE,EACArkD,EAAAvT,EAAAo+B,GAAAzP,EAAArmC,OAAA,GAEAyN,EAAAnK,KAAA2nB,EAAA1T,EAAA0T,EAAAvT,GASA,IAAAtW,EAAA,EAAcA,EAAAkuE,EAAcluE,IAE5B,IAAA00C,EAAA,EAAeA,EAAAzP,EAAArmC,OAAA,EAA2B81C,IAAA,CAE1C25B,EAAA35B,EAAA10C,EAAAilC,EAAArmC,MAEA,IAAA0P,GAAA+/D,EACAhoE,EAAAgoE,EAAAppC,EAAArmC,OACAyI,EAAAgnE,EAAAppC,EAAArmC,OAAA,EACAkQ,EAAAu/D,EAAA,CAIA9wC,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAmBA,GAXAjO,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IAIAxL,KAAAqR,uBAKA+6D,IAAA,EAAA1nE,KAAAmO,GAAA,CAEA,GAAAtH,GAAAvL,KAAA8oB,WAAAqI,OAAApwB,MACA2sE,EAAA,GAAA9zD,GACA+zD,EAAA,GAAA/zD,GACA4I,EAAA,GAAA5I,EAMA,KAFA4zD,EAAAH,EAAAjpC,EAAArmC,OAAA,EAEAoB,EAAA,EAAA00C,EAAA,EAAsB10C,EAAAilC,EAAArmC,OAAmBoB,IAAA00C,GAAA,EAIzC65B,EAAAp4D,EAAA/J,EAAAsoC,EAAA,GACA65B,EAAAj4D,EAAAlK,EAAAsoC,EAAA,GACA65B,EAAAlvD,EAAAjT,EAAAsoC,EAAA,GAIA85B,EAAAr4D,EAAA/J,EAAAiiE,EAAA35B,EAAA,GACA85B,EAAAl4D,EAAAlK,EAAAiiE,EAAA35B,EAAA,GACA85B,EAAAnvD,EAAAjT,EAAAiiE,EAAA35B,EAAA,GAIArxB,EAAAsjD,WAAA4H,EAAAC,GAAAzf,YAIA3iD,EAAAsoC,EAAA,GAAAtoC,EAAAiiE,EAAA35B,EAAA,GAAArxB,EAAAlN,EACA/J,EAAAsoC,EAAA,GAAAtoC,EAAAiiE,EAAA35B,EAAA,GAAArxB,EAAA/M,EACAlK,EAAAsoC,EAAA,GAAAtoC,EAAAiiE,EAAA35B,EAAA,GAAArxB,EAAAhE,GAkBA,QAAAovD,IAAAvC,EAAAQ,GAEAhxC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,gBAEA,gBAAAiuE,KAEAv8D,QAAA4E,KAAA,4DAEA23D,mBAIA7rE,KAAAgwB,YACAq7C,SACAQ,iBAGA7rE,KAAAo9B,mBAAA,GAAAywC,IAAAxC,EAAAQ,IACA7rE,KAAAs9B,gBAmBA,QAAAuwC,IAAAxC,EAAAQ,GAwDA,QAAAiC,GAAAC,GAEA,GAAA5uE,GAAAgQ,EAAA6+D,EAEAC,EAAA3iE,EAAAvN,OAAA,EACAqmC,EAAA2pC,EAAAG,cAAArC,GAEAsC,EAAA/pC,EAAA2pC,MACAK,EAAAhqC,EAAAiqC,KAIA,IAAAC,GAAAC,YAAAJ,MAAA,EAMA,IAJAA,IAAAK,UAIArvE,EAAA,EAAAgQ,EAAAi/D,EAAArwE,OAAuCoB,EAAAgQ,EAAOhQ,IAE9C6uE,EAAAI,EAAAjvE,GAEAmvE,GAAAC,YAAAP,MAAA,IAEAI,EAAAjvE,GAAA6uE,EAAAQ,UAQA,IAAArmD,GAAAmmD,GAAAG,iBAAAN,EAAAC,EAIA,KAAAjvE,EAAA,EAAAgQ,EAAAi/D,EAAArwE,OAAsCoB,EAAAgQ,EAAOhQ,IAE7C6uE,EAAAI,EAAAjvE,GACAgvE,IAAAjvE,OAAA8uE,EAMA,KAAA7uE,EAAA,EAAAgQ,EAAAg/D,EAAApwE,OAAyCoB,EAAAgQ,EAAOhQ,IAAA,CAEhD,GAAAshE,GAAA0N,EAAAhvE,EAEAmM,GAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAA,GACAlK,EAAAlK,KAAA,OACAmK,EAAAnK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,GAMA,IAAAtW,EAAA,EAAAgQ,EAAAgZ,EAAApqB,OAAiCoB,EAAAgQ,EAAOhQ,IAAA,CAExC,GAAAk4B,GAAAlP,EAAAhpB,GAEAsO,EAAA4pB,EAAA,GAAA42C,EACAzoE,EAAA6xB,EAAA,GAAA42C,EACAznE,EAAA6wB,EAAA,GAAA42C,CAEAvxC,GAAAr7B,KAAAoM,EAAAjI,EAAAgB,GACA6F,GAAA,GAxHA4E,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAAgwB,YACAq7C,SACAQ,iBAGAA,KAAA,EAIA,IAAAnvC,MACApxB,KACAC,KACAC,KAIAmB,EAAA,EACAN,EAAA,CAIA,IAAAjL,MAAAsL,QAAA2+D,MAAA,EAEAyC,EAAAzC,OAIA,QAAAlsE,GAAA,EAAmBA,EAAAksE,EAAAttE,OAAmBoB,IAEtC2uE,EAAAzC,EAAAlsE,IAEAa,KAAAkS,SAAAvF,EAAAN,EAAAlN,GAEAwN,GAAAN,EACAA,EAAA,CAQArM,MAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IA8FA,QAAAkjE,IAAArD,EAAAzpD,GAIA,GAFAA,EAAAypD,UAEAjqE,MAAAsL,QAAA2+D,GAEA,OAAAlsE,GAAA,EAAAgQ,EAAAk8D,EAAAttE,OAAsCoB,EAAAgQ,EAAOhQ,IAAA,CAE7C,GAAA4uE,GAAA1C,EAAAlsE,EAEAyiB,GAAAypD,OAAAhqE,KAAA0sE,EAAAtuD,UAMAmC,GAAAypD,OAAAhqE,KAAAgqE,EAAA5rD,KAIA,OAAAmC,GASA,QAAA+sD,IAAA5iE,EAAA6iE,GAEA39D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,gBAEAoC,KAAAgwB,YACA4+C,kBAGAA,EAAAnmE,SAAAmmE,IAAA,CAIA,IAKiCrO,GAAAC,EACjCphE,EAIAyvE,EAVAvjE,KAIAwjE,EAAApqE,KAAA2oD,IAAA3tC,GAAAqvD,QAAAH,GACAlO,GAAA,KAAAC,KACA1hE,GAAA,YAMA8M,GAAA8mB,kBAEAg8C,EAAA,GAAAh0C,IACAg0C,EAAAzxC,mBAAArxB,IAIA8iE,EAAA9iE,EAAAc,QAIAgiE,EAAAvxC,gBACAuxC,EAAAG,oBAOA,QALAC,GAAAJ,EAAAvjE,SACA6c,EAAA0mD,EAAA1mD,MAIAhpB,EAAA,EAAAgQ,EAAAgZ,EAAApqB,OAAoCoB,EAAAgQ,EAAOhQ,IAI3C,OAFAk4B,GAAAlP,EAAAhpB,GAEA00C,EAAA,EAAmBA,EAAA,EAAOA,IAE1B0sB,EAAAlpC,EAAAp4B,EAAA40C,IACA2sB,EAAAnpC,EAAAp4B,GAAA40C,EAAA,OACA6sB,EAAA,GAAAh8D,KAAA2B,IAAAk6D,EAAAC,GACAE,EAAA,GAAAh8D,KAAA0B,IAAAm6D,EAAAC,GAEAphE,EAAAshE,EAAA,OAAAA,EAAA,GAEAj4D,SAAAk4D,EAAAvhE,GAEAuhE,EAAAvhE,IAAqBwhE,OAAAF,EAAA,GAAAG,OAAAH,EAAA,GAAAwO,MAAA/vE,EAAAgwE,MAAA1mE,QAIrBk4D,EAAAvhE,GAAA+vE,MAAAhwE,CAUA,KAAAC,IAAAuhE,GAAA,CAEA,GAAArhE,GAAAqhE,EAAAvhE,EAIA,IAAAqJ,SAAAnJ,EAAA6vE,OAAAhnD,EAAA7oB,EAAA4vE,OAAA/9C,OAAA9U,IAAA8L,EAAA7oB,EAAA6vE,OAAAh+C,SAAA29C,EAAA,CAEA,GAAArO,GAAAwO,EAAA3vE,EAAAshE,OACAt1D,GAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAEAiiD,EAAAwO,EAAA3vE,EAAAuhE,QACAv1D,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,IAQAxe,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IAcA,QAAA8jE,IAAAC,EAAAC,EAAAtuD,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,GAEAzxC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,mBAEAoC,KAAAgwB,YACAq/C,YACAC,eACAtuD,SACAkjD,iBACAhnC,iBACAqyC,YACAlD,aACAC,eAGAtsE,KAAAo9B,mBAAA,GAAAoyC,IAAAH,EAAAC,EAAAtuD,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,IACAtsE,KAAAs9B,gBASA,QAAAkyC,IAAAH,EAAAC,EAAAtuD,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,GA8DA,QAAAmD,KAEA,GAAAn6D,GAAAG,EACA0b,EAAA,GAAAvX,GACA6mD,EAAA,GAAA7mD,GAEAvN,EAAA,EAGAqjE,GAAAJ,EAAAD,GAAAruD,CAIA,KAAAvL,EAAA,EAAeA,GAAAynB,EAAqBznB,IAAA,CAEpC,GAAAk6D,MAEA3oE,EAAAyO,EAAAynB,EAIAnhB,EAAA/U,GAAAsoE,EAAAD,IAEA,KAAA/5D,EAAA,EAAgBA,GAAA4uD,EAAqB5uD,IAAA,CAErC,GAAAkoB,GAAAloB,EAAA4uD,EAEA7wD,EAAAmqB,EAAA8uC,EAAAD,EAEAuD,EAAAlrE,KAAAsgE,IAAA3xD,GACAw8D,EAAAnrE,KAAA2oD,IAAAh6C,EAIAotD,GAAAnrD,EAAAyG,EAAA6zD,EACAnP,EAAAhrD,GAAAzO,EAAAga,EAAAorC,EACAqU,EAAAjiD,EAAAzC,EAAA8zD,EACAvkE,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIA2S,EAAA3c,IAAAo7D,EAAAF,EAAAG,GAAA3hB,YACA3iD,EAAAlK,KAAA8vB,EAAA7b,EAAA6b,EAAA1b,EAAA0b,EAAA3S,GAIAhT,EAAAnK,KAAAm8B,EAAA,EAAAx2B,GAIA2oE,EAAAtuE,KAAAkL,KAMAujE,EAAAzuE,KAAAsuE,GAMA,IAAAr6D,EAAA,EAAeA,EAAA4uD,EAAoB5uD,IAEnC,IAAAG,EAAA,EAAgBA,EAAAynB,EAAoBznB,IAAA,CAIpC,GAAAhI,GAAAqiE,EAAAr6D,GAAAH,GACA9P,EAAAsqE,EAAAr6D,EAAA,GAAAH,GACA9O,EAAAspE,EAAAr6D,EAAA,GAAAH,EAAA,GACArH,EAAA6hE,EAAAr6D,GAAAH,EAAA,EAIAonB,GAAAr7B,KAAAoM,EAAAjI,EAAAyI,GACAyuB,EAAAr7B,KAAAmE,EAAAgB,EAAAyH,GAIA5B,GAAA,EAQA5B,EAAAyH,SAAAvF,EAAAN,EAAA,GAIAM,GAAAN,EAIA,QAAA0jE,GAAAxyD,GAEA,GAAAjI,GAAA06D,EAAAC,EAEAjnD,EAAA,GAAAtM,GACA+jD,EAAA,GAAA7mD,GAEAvN,EAAA,EAEA0P,EAAAwB,KAAA,EAAA8xD,EAAAC,EACAY,EAAA3yD,KAAA,MASA,KANAyyD,EAAAzjE,EAMA+I,EAAA,EAAeA,GAAA4uD,EAAqB5uD,IAIpChK,EAAAjK,KAAA,EAAA+qD,EAAA8jB,EAAA,GAIA3kE,EAAAlK,KAAA,EAAA6uE,EAAA,GAIA1kE,EAAAnK,KAAA,OAIAkL,GAUA,KAJA0jE,EAAA1jE,EAIA+I,EAAA,EAAeA,GAAA4uD,EAAqB5uD,IAAA,CAEpC,GAAAkoB,GAAAloB,EAAA4uD,EACA7wD,EAAAmqB,EAAA8uC,EAAAD,EAEAwD,EAAAnrE,KAAA2oD,IAAAh6C,GACAu8D,EAAAlrE,KAAAsgE,IAAA3xD,EAIAotD,GAAAnrD,EAAAyG,EAAA6zD,EACAnP,EAAAhrD,EAAA22C,EAAA8jB,EACAzP,EAAAjiD,EAAAzC,EAAA8zD,EACAvkE,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIAjT,EAAAlK,KAAA,EAAA6uE,EAAA,GAIAlnD,EAAA1T,EAAA,GAAAu6D,EAAA,GACA7mD,EAAAvT,EAAA,GAAAm6D,EAAAM,EAAA,GACA1kE,EAAAnK,KAAA2nB,EAAA1T,EAAA0T,EAAAvT,GAIAlJ,IAMA,IAAA+I,EAAA,EAAeA,EAAA4uD,EAAoB5uD,IAAA,CAEnC,GAAA9O,GAAAwpE,EAAA16D,EACAnW,EAAA8wE,EAAA36D,CAEAiI,MAAA,EAIAmf,EAAAr7B,KAAAlC,IAAA,EAAAqH,GAMAk2B,EAAAr7B,KAAAlC,EAAA,EAAAA,EAAAqH,GAIA6F,GAAA,EAMA5B,EAAAyH,SAAAvF,EAAAN,EAAAkR,KAAA,OAIA5Q,GAAAN,EAvQA4E,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,yBAEAoC,KAAAgwB,YACAq/C,YACAC,eACAtuD,SACAkjD,iBACAhnC,iBACAqyC,YACAlD,aACAC,cAGA,IAAA7hE,GAAAzK,IAEAqvE,GAAA5mE,SAAA4mE,IAAA,EACAC,EAAA7mE,SAAA6mE,IAAA,EACAtuD,KAAA,EAEAkjD,EAAAx/D,KAAAyB,MAAA+9D,IAAA,EACAhnC,EAAAx4B,KAAAyB,MAAA+2B,IAAA,EAEAqyC,EAAA9mE,SAAA8mE,KACAlD,EAAA5jE,SAAA4jE,IAAA,EACAC,EAAA7jE,SAAA6jE,IAAA,EAAA5nE,KAAAmO,EAIA,IAAA6pB,MACApxB,KACAC,KACAC,KAIAe,EAAA,EACAujE,KACA1jB,EAAAprC,EAAA,EACArU,EAAA,CAIA8iE,KAEAF,KAAA,IAEAF,EAAA,GAAAU,GAAA,GACAT,EAAA,GAAAS,GAAA,IAMA/vE,KAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IA4NA,QAAA2kE,IAAAp0D,EAAAiF,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,GAEA8C,GAAArvE,KAAAC,KAAA,EAAA+b,EAAAiF,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,GAEAtsE,KAAApC,KAAA,eAEAoC,KAAAgwB,YACAjU,SACAiF,SACAkjD,iBACAhnC,iBACAqyC,YACAlD,aACAC,eAUA,QAAA8D,IAAAr0D,EAAAiF,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,GAEAkD,GAAAzvE,KAAAC,KAAA,EAAA+b,EAAAiF,EAAAkjD,EAAAhnC,EAAAqyC,EAAAlD,EAAAC,GAEAtsE,KAAApC,KAAA,qBAEAoC,KAAAgwB,YACAjU,SACAiF,SACAkjD,iBACAhnC,iBACAqyC,YACAlD,aACAC,eAgBA,QAAA+D,IAAAt0D,EAAAsxD,EAAAhB,EAAAC,GAEAzxC,GAAA96B,KAAAC,MAEAA,KAAApC,KAAA,iBAEAoC,KAAAgwB,YACAjU,SACAsxD,WACAhB,aACAC,eAGAtsE,KAAAo9B,mBAAA,GAAAkzC,IAAAv0D,EAAAsxD,EAAAhB,EAAAC,IACAtsE,KAAAs9B,gBASA,QAAAgzC,IAAAv0D,EAAAsxD,EAAAhB,EAAAC,GAEAr7D,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,uBAEAoC,KAAAgwB,YACAjU,SACAsxD,WACAhB,aACAC,eAGAvwD,KAAA,EACAsxD,EAAA5kE,SAAA4kE,EAAA3oE,KAAA0B,IAAA,EAAAinE,GAAA,EAEAhB,EAAA5jE,SAAA4jE,IAAA,EACAC,EAAA7jE,SAAA6jE,IAAA,EAAA5nE,KAAAmO,EAIA,IAOA1T,GAAA4H,EAPA21B,KACApxB,KACAC,KACAC,KAKAi1D,EAAA,GAAA7mD,GACAoP,EAAA,GAAAtM,EAQA,KAJApR,EAAAjK,KAAA,OACAkK,EAAAlK,KAAA,OACAmK,EAAAnK,KAAA,OAEA0F,EAAA,EAAA5H,EAAA,EAAqB4H,GAAAsmE,EAAetmE,IAAA5H,GAAA,GAEpC,GAAA8tE,GAAAZ,EAAAtlE,EAAAsmE,EAAAf,CAIA7L,GAAAnrD,EAAAyG,EAAArX,KAAA2oD,IAAA4f,GACAxM,EAAAhrD,EAAAsG,EAAArX,KAAAsgE,IAAAiI,GAEA3hE,EAAAjK,KAAAo/D,EAAAnrD,EAAAmrD,EAAAhrD,EAAAgrD,EAAAjiD,GAIAjT,EAAAlK,KAAA,OAIA2nB,EAAA1T,GAAAhK,EAAAnM,GAAA4c,EAAA,KACAiN,EAAAvT,GAAAnK,EAAAnM,EAAA,GAAA4c,EAAA,KAEAvQ,EAAAnK,KAAA2nB,EAAA1T,EAAA0T,EAAAvT,GAMA,IAAAtW,EAAA,EAAcA,GAAAkuE,EAAeluE,IAE7Bu9B,EAAAr7B,KAAAlC,IAAA,IAMAa,MAAAy+B,SAAA/B,GACA18B,KAAAkR,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAtL,KAAAkR,aAAA,YAAAqrB,IAAAhxB,EAAA,IACAvL,KAAAkR,aAAA,QAAAqrB,IAAA/wB,EAAA,IA+DA,QAAA6iC,IAAAre,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,iBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,GACA1nB,KAAAopB,QAAA,EAEAppB,KAAAwuB,QAAA,EACAxuB,KAAA+uB,aAAA,EAEA/uB,KAAA2wB,UAAAX,GAaA,QAAAugD,IAAAvgD,GAEA6P,GAAA9/B,KAAAC,KAAAgwB,GAEAhwB,KAAApC,KAAA,oBA4DA,QAAAqwC,IAAAje,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAA8/B,SAAkB0wC,SAAA,IAElBxwE,KAAApC,KAAA,uBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UACA1nB,KAAA04D,UAAA,GACA14D,KAAA24D,UAAA,GAEA34D,KAAAmiB,IAAA,KAEAniB,KAAAi/B,SAAA,KACAj/B,KAAAk/B,kBAAA,EAEAl/B,KAAAm/B,MAAA,KACAn/B,KAAAo/B,eAAA,EAEAp/B,KAAA63D,SAAA,GAAAnwC,GAAA,GACA1nB,KAAA83D,kBAAA,EACA93D,KAAAyqC,YAAA,KAEAzqC,KAAAqnC,QAAA,KACArnC,KAAAw4D,UAAA,EAEAx4D,KAAAsnC,UAAA,KACAtnC,KAAAy4D,YAAA,GAAA/7C,GAAA,KAEA1c,KAAAswB,gBAAA,KACAtwB,KAAAuwB,kBAAA,EACAvwB,KAAAwwB,iBAAA,EAEAxwB,KAAA0qC,aAAA,KAEA1qC,KAAA2qC,aAAA,KAEA3qC,KAAAqwB,SAAA,KAEArwB,KAAAs/B,OAAA,KACAt/B,KAAA44D,gBAAA,EAEA54D,KAAA0/B,gBAAA,IAEA1/B,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EACA1wB,KAAA2/B,iBAAA,QACA3/B,KAAA4/B,kBAAA,QAEA5/B,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EACApwB,KAAAg7B,cAAA,EAEAh7B,KAAA2wB,UAAAX,GAyEA,QAAAke,IAAAle,GAEAie,GAAAluC,KAAAC,MAEAA,KAAA8/B,SAAkB2wC,SAAA,IAElBzwE,KAAApC,KAAA,uBAEAoC,KAAAy/B,aAAA,GAEAz/B,KAAA64D,UAAA,EACA74D,KAAA84D,mBAAA,EAEA94D,KAAA2wB,UAAAX,GA0EA,QAAAne,IAAAme,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UACA1nB,KAAAs4D,SAAA,GAAA5wC,GAAA,SACA1nB,KAAAu4D,UAAA,GAEAv4D,KAAAmiB,IAAA,KAEAniB,KAAAi/B,SAAA,KACAj/B,KAAAk/B,kBAAA,EAEAl/B,KAAAm/B,MAAA,KACAn/B,KAAAo/B,eAAA,EAEAp/B,KAAA63D,SAAA,GAAAnwC,GAAA,GACA1nB,KAAA83D,kBAAA,EACA93D,KAAAyqC,YAAA,KAEAzqC,KAAAqnC,QAAA,KACArnC,KAAAw4D,UAAA,EAEAx4D,KAAAsnC,UAAA,KACAtnC,KAAAy4D,YAAA,GAAA/7C,GAAA,KAEA1c,KAAAswB,gBAAA,KACAtwB,KAAAuwB,kBAAA,EACAvwB,KAAAwwB,iBAAA,EAEAxwB,KAAAq/B,YAAA,KAEAr/B,KAAAqwB,SAAA,KAEArwB,KAAAs/B,OAAA,KACAt/B,KAAAu/B,QAAAC,GACAx/B,KAAAy/B,aAAA,EACAz/B,KAAA0/B,gBAAA,IAEA1/B,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EACA1wB,KAAA2/B,iBAAA,QACA3/B,KAAA4/B,kBAAA,QAEA5/B,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EACApwB,KAAAg7B,cAAA,EAEAh7B,KAAA2wB,UAAAX,GAqEA,QAAAge,IAAAhe,GAEAne,GAAA9R,KAAAC,MAEAA,KAAA8/B,SAAkB4wC,KAAA,IAElB1wE,KAAApC,KAAA,mBAEAoC,KAAAirC,YAAA,KAEAjrC,KAAA2wB,UAAAX,GA6CA,QAAA8d,IAAA9d,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAAqnC,QAAA,KACArnC,KAAAw4D,UAAA,EAEAx4D,KAAAsnC,UAAA,KACAtnC,KAAAy4D,YAAA,GAAA/7C,GAAA,KAEA1c,KAAAswB,gBAAA,KACAtwB,KAAAuwB,kBAAA,EACAvwB,KAAAwwB,iBAAA,EAEAxwB,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EAEA1wB,KAAAosB,KAAA,EACApsB,KAAAwuB,QAAA,EAEAxuB,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EACApwB,KAAAg7B,cAAA,EAEAh7B,KAAA2wB,UAAAX,GAwEA,QAAA+d,IAAA/d,GAEA1B,EAAAvuB,KAAAC,MAEAA,KAAApC,KAAA,sBAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA,UAEA1nB,KAAAmiB,IAAA,KAEAniB,KAAAi/B,SAAA,KACAj/B,KAAAk/B,kBAAA,EAEAl/B,KAAAm/B,MAAA,KACAn/B,KAAAo/B,eAAA,EAEAp/B,KAAA63D,SAAA,GAAAnwC,GAAA,GACA1nB,KAAA83D,kBAAA,EACA93D,KAAAyqC,YAAA,KAEAzqC,KAAAq/B,YAAA,KAEAr/B,KAAAqwB,SAAA,KAEArwB,KAAAs/B,OAAA,KACAt/B,KAAAu/B,QAAAC,GACAx/B,KAAAy/B,aAAA,EACAz/B,KAAA0/B,gBAAA,IAEA1/B,KAAAywB,WAAA,EACAzwB,KAAA0wB,mBAAA,EACA1wB,KAAA2/B,iBAAA,QACA3/B,KAAA4/B,kBAAA,QAEA5/B,KAAAmwB,UAAA,EACAnwB,KAAAowB,cAAA,EACApwB,KAAAg7B,cAAA,EAEAh7B,KAAA2wB,UAAAX,GAgEA,QAAAme,IAAAne,GAEAte,GAAA3R,KAAAC,MAEAA,KAAApC,KAAA,qBAEAoC,KAAA2T,MAAA,EACA3T,KAAAm4D,SAAA,EACAn4D,KAAAq4D,QAAA,EAEAr4D,KAAA2wB,UAAAX,GA2FA,QAAA2gD,IAAArmE,EAAAC,EAAAC,GAEA,GAAAC,GAAAzK,KAEA4wE,GAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAAtoE,MAEAzI,MAAAgxE,QAAAvoE,OACAzI,KAAAsK,SACAtK,KAAAuK,aACAvK,KAAAwK,UAEAxK,KAAAixE,UAAA,SAAA5mE,GAEAymE,IAEAF,KAAA,GAEAnoE,SAAAgC,EAAAumE,SAEAvmE,EAAAumE,QAAA3mE,EAAAwmE,EAAAC,GAMAF,GAAA,GAIA5wE,KAAAkxE,QAAA,SAAA7mE,GAEAwmE,IAEApoE,SAAAgC,EAAAF,YAEAE,EAAAF,WAAAF,EAAAwmE,EAAAC,GAIAD,IAAAC,IAEAF,GAAA,EAEAnoE,SAAAgC,EAAAH,QAEAG,EAAAH,WAQAtK,KAAAmxE,UAAA,SAAA9mE,GAEA5B,SAAAgC,EAAAD,SAEAC,EAAAD,QAAAH,IAMArK,KAAAoxE,WAAA,SAAA/mE,GAEA,MAAA0mE,GAEAA,EAAA1mE,GAIAA,GAIArK,KAAAqxE,eAAA,SAAAC,GAGA,MADAP,GAAAO,EACAtxE,MAcA,QAAA2K,IAAAvB,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAiTA,QAAAkoE,IAAAnoE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAGArJ,KAAAwxE,QAAA,KAiIA,QAAAC,IAAAroE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAGArJ,KAAAwxE,QAAA,KAiFA,QAAAE,IAAAtoE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAmGA,QAAAsoE,IAAAvoE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAoEA,QAAAuoE,IAAAxoE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAyFA,QAAAwoE,MAEA7xE,KAAApC,KAAA,QAEAoC,KAAA8xE,mBAAA,IA4XA,QAAAC,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEAV,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,eAEAoC,KAAAgyE,MAAA,EACAhyE,KAAAiyE,MAAA,EAEAjyE,KAAAkyE,WAAA,EACAlyE,KAAAmyE,WAAA,EAEAnyE,KAAAoyE,eAAA,EACApyE,KAAAqyE,aAAA,EAAA3tE,KAAAmO,GAEA7S,KAAAsyE,eAAA,EAEAtyE,KAAAuyE,aAAA,EAuIA,QAAAC,IAAAR,EAAAC,EAAAQ,EAAAL,EAAAC,EAAAC,GAEAP,GAAAhyE,KAAAC,KAAAgyE,EAAAC,EAAAQ,IAAAL,EAAAC,EAAAC,GAEAtyE,KAAApC,KAAA,WA+BA,QAAA80E,MAYA,QAAAxqD,GAAA06C,EAAAC,EAAA8P,EAAAC,GAEAC,EAAAjQ,EACAkQ,EAAAH,EACAI,GAAA,EAAAnQ,EAAA,EAAAC,EAAA,EAAA8P,EAAAC,EACAI,EAAA,EAAApQ,EAAA,EAAAC,EAAA8P,EAAAC,EAfA,GAAAC,GAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,CAmBA,QAEAC,eAAA,SAAArQ,EAAAC,EAAAC,EAAAoQ,EAAAC,GAEAjrD,EAAA26C,EAAAC,EAAAqQ,GAAArQ,EAAAF,GAAAuQ,GAAAD,EAAArQ,KAIAuQ,yBAAA,SAAAxQ,EAAAC,EAAAC,EAAAoQ,EAAAG,EAAAC,EAAAC,GAGA,GAAAX,IAAA/P,EAAAD,GAAAyQ,GAAAvQ,EAAAF,IAAAyQ,EAAAC,IAAAxQ,EAAAD,GAAAyQ,EACAE,GAAA1Q,EAAAD,GAAAyQ,GAAAJ,EAAArQ,IAAAyQ,EAAAC,IAAAL,EAAApQ,GAAAyQ,CAGAX,IAAAU,EACAE,GAAAF,EAEAprD,EAAA26C,EAAAC,EAAA8P,EAAAY,IAIAC,KAAA,SAAApsE,GAEA,GAAAmsE,GAAAnsE,IACAqsE,EAAAF,EAAAnsE,CACA,OAAAwrE,GAAAC,EAAAzrE,EAAA0rE,EAAAS,EAAAR,EAAAU,IAeA,QAAAC,IAAAvvC,EAAA+/B,EAAAyP,EAAAT,GAEAtB,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,mBAEAoC,KAAAokC,aACApkC,KAAAmkE,WAAA,EACAnkE,KAAA4zE,aAAA,cACA5zE,KAAAmzE,WAAA,GAsKA,QAAAU,IAAAxsE,EAAAiqB,EAAAC,EAAAC,EAAAC,GAEA,GAAAqiD,GAAA,IAAAtiD,EAAAF,GACAlsB,EAAA,IAAAqsB,EAAAF,GACAiiD,EAAAnsE,IACAqsE,EAAArsE,EAAAmsE,CACA,UAAAjiD,EAAA,EAAAC,EAAAsiD,EAAA1uE,GAAAsuE,IAAA,EAAAniD,EAAA,EAAAC,EAAA,EAAAsiD,EAAA1uE,GAAAouE,EAAAM,EAAAzsE,EAAAkqB,EAMA,QAAAwiD,IAAA1sE,EAAAF,GAEA,GAAAc,GAAA,EAAAZ,CACA,OAAAY,KAAAd,EAIA,QAAA6sE,IAAA3sE,EAAAF,GAEA,YAAAE,KAAAF,EAIA,QAAA8sE,IAAA5sE,EAAAF,GAEA,MAAAE,KAAAF,EAIA,QAAA+sE,IAAA7sE,EAAAiqB,EAAAC,EAAAC,GAEA,MAAAuiD,IAAA1sE,EAAAiqB,GAAA0iD,GAAA3sE,EAAAkqB,GACA0iD,GAAA5sE,EAAAmqB,GAMA,QAAA2iD,IAAA9sE,EAAAF,GAEA,GAAAc,GAAA,EAAAZ,CACA,OAAAY,OAAAd,EAIA,QAAAitE,IAAA/sE,EAAAF,GAEA,GAAAc,GAAA,EAAAZ,CACA,UAAAY,IAAAZ,EAAAF,EAIA,QAAAktE,IAAAhtE,EAAAF,GAEA,YAAAE,OAAAF,EAIA,QAAAmtE,IAAAjtE,EAAAF,GAEA,MAAAE,OAAAF,EAIA,QAAAotE,IAAAltE,EAAAiqB,EAAAC,EAAAC,EAAAC,GAEA,MAAA0iD,IAAA9sE,EAAAiqB,GAAA8iD,GAAA/sE,EAAAkqB,GAAA8iD,GAAAhtE,EAAAmqB,GACA8iD,GAAAjtE,EAAAoqB,GAIA,QAAA+iD,IAAAV,EAAA1uE,EAAAE,EAAAmvE,GAEA5C,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,mBAEAoC,KAAA8zE,MAAA,GAAAp3D,GACA1c,KAAAoF,MAAA,GAAAsX,GACA1c,KAAAsF,MAAA,GAAAoX,GACA1c,KAAAy0E,MAAA,GAAA/3D,GA+DA,QAAAg4D,IAAAZ,EAAA1uE,EAAAE,EAAAmvE,GAEA5C,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,oBAEAoC,KAAA8zE,MAAA,GAAAl6D,GACA5Z,KAAAoF,MAAA,GAAAwU,GACA5Z,KAAAsF,MAAA,GAAAsU,GACA5Z,KAAAy0E,MAAA,GAAA76D,GAgEA,QAAA+6D,IAAAvvE,EAAAE,GAEAusE,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,YAEAoC,KAAAoF,MAAA,GAAAsX,GACA1c,KAAAsF,MAAA,GAAAoX,GA6EA,QAAAk4D,IAAAxvE,EAAAE,GAEAusE,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,aAEAoC,KAAAoF,MAAA,GAAAwU,GACA5Z,KAAAsF,MAAA,GAAAsU,GAqEA,QAAAi7D,IAAAf,EAAA1uE,EAAAE,GAEAusE,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,uBAEAoC,KAAA8zE,MAAA,GAAAp3D,GACA1c,KAAAoF,MAAA,GAAAsX,GACA1c,KAAAsF,MAAA,GAAAoX,GA4DA,QAAAo4D,IAAAhB,EAAA1uE,EAAAE,GAEAusE,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,wBAEAoC,KAAA8zE,MAAA,GAAAl6D,GACA5Z,KAAAoF,MAAA,GAAAwU,GACA5Z,KAAAsF,MAAA,GAAAsU,GA6DA,QAAAm7D,IAAA3wC,GAEAytC,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,cAEAoC,KAAAokC,aA8GA,QAAA4wC,MAEAnD,GAAA9xE,KAAAC,MAEAA,KAAApC,KAAA,YAEAoC,KAAAi1E,UACAj1E,KAAAk1E,WAAA,EAoPA,QAAAC,IAAA/wC,GAEA4wC,GAAAj1E,KAAAC,MAEAA,KAAApC,KAAA,OAEAoC,KAAAo1E,aAAA,GAAA14D,GAEA0nB,GAEApkC,KAAAq1E,cAAAjxC,GAyKA,QAAAkxC,IAAAlxC,GAEA+wC,GAAAp1E,KAAAC,KAAAokC,GAEApkC,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAApC,KAAA,QAEAoC,KAAAquE,SAgGA,QAAAkH,IAAA1vE,EAAA+mD,GAEAnzB,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,QAEAoC,KAAA6F,MAAA,GAAA6hB,GAAA7hB,GACA7F,KAAA4sD,UAAAnkD,SAAAmkD,IAAA,EAEA5sD,KAAAs6B,cAAA7xB,OA+CA,QAAA+sE,IAAAvpB,EAAAC,EAAAU,GAEA2oB,GAAAx1E,KAAAC,KAAAisD,EAAAW,GAEA5sD,KAAApC,KAAA,kBAEAoC,KAAAk0B,WAAAzrB,OAEAzI,KAAA2a,SAAA/I,KAAA6nB,GAAAO,WACAh6B,KAAAy1E,eAEAz1E,KAAAksD,YAAA,GAAAxkC,GAAAwkC,GA0BA,QAAAwpB,IAAArqD,GAEArrB,KAAAqrB,SAEArrB,KAAAitD,KAAA,EACAjtD,KAAA+b,OAAA,EAEA/b,KAAAw2B,QAAA,GAAA9Z,GAAA,SAEA1c,KAAAmiB,IAAA,KACAniB,KAAAod,OAAA,GAAAiB,GA8CA,QAAAs3D,MAEAD,GAAA31E,KAAAC,KAAA,GAAA0T,IAAA,cAmCA,QAAAkiE,IAAA/vE,EAAA+mD,EAAAx1C,EAAAjE,EAAAm6C,EAAAtB,GAEAupB,GAAAx1E,KAAAC,KAAA6F,EAAA+mD,GAEA5sD,KAAApC,KAAA,YAEAoC,KAAA2a,SAAA/I,KAAA6nB,GAAAO,WACAh6B,KAAAy1E,eAEAz1E,KAAA2Z,OAAA,GAAA8f,IAEAn7B,OAAAD,eAAA2B,KAAA,SACA4d,IAAA,WAIA,MAAA5d,MAAA4sD,UAAAloD,KAAAmO,IAGA2B,IAAA,SAAAqhE,GAIA71E,KAAA4sD,UAAAipB,EAAAnxE,KAAAmO,MAKA7S,KAAAoX,SAAA3O,SAAA2O,IAAA,EACApX,KAAAmT,MAAA1K,SAAA0K,IAAAzO,KAAAmO,GAAA,EACA7S,KAAAstD,SAAA7kD,SAAA6kD,IAAA,EACAttD,KAAAgsD,MAAAvjD,SAAAujD,IAAA,EAEAhsD,KAAAu2B,OAAA,GAAAo/C,IAkCA,QAAAG,IAAAjwE,EAAA+mD,EAAAx1C,EAAA40C,GAEAupB,GAAAx1E,KAAAC,KAAA6F,EAAA+mD,GAEA5sD,KAAApC,KAAA,aAEAU,OAAAD,eAAA2B,KAAA,SACA4d,IAAA,WAIA,SAAA5d,KAAA4sD,UAAAloD,KAAAmO,IAGA2B,IAAA,SAAAqhE,GAIA71E,KAAA4sD,UAAAipB,GAAA,EAAAnxE,KAAAmO,OAKA7S,KAAAoX,SAAA3O,SAAA2O,IAAA,EACApX,KAAAgsD,MAAAvjD,SAAAujD,IAAA,EAEAhsD,KAAAu2B,OAAA,GAAAm/C,IAAA,GAAAhiE,IAAA,cA6BA,QAAAqiE,MAEAL,GAAA31E,KAAAC,KAAA,GAAA4T,KAAA,kBAeA,QAAAoiE,IAAAnwE,EAAA+mD,GAEA2oB,GAAAx1E,KAAAC,KAAA6F,EAAA+mD,GAEA5sD,KAAApC,KAAA,mBAEAoC,KAAA2a,SAAA/I,KAAA6nB,GAAAO,WACAh6B,KAAAy1E,eAEAz1E,KAAA2Z,OAAA,GAAA8f,IAEAz5B,KAAAu2B,OAAA,GAAAw/C,IA4BA,QAAAE,IAAApwE,EAAA+mD,GAEA2oB,GAAAx1E,KAAAC,KAAA6F,EAAA+mD,GAEA5sD,KAAApC,KAAA,eAEAoC,KAAAk0B,WAAAzrB,OAgBA,QAAAytE,IAAArwE,EAAA+mD,EAAA7rC,EAAAC,GAEAu0D,GAAAx1E,KAAAC,KAAA6F,EAAA+mD,GAEA5sD,KAAApC,KAAA,gBAEAoC,KAAA+gB,MAAAtY,SAAAsY,IAAA,GACA/gB,KAAAghB,OAAAvY,SAAAuY,IAAA,GA4CA,QAAAm1D,IAAAr4E,EAAAs4E,EAAAC,EAAAC,GAEAC,GAAAx2E,KAAAC,KAAAlC,EAAAs4E,EAAAC,EAAAC,GA6BA,QAAAE,IAAA14E,EAAAs4E,EAAAC,GAEAE,GAAAx2E,KAAAC,KAAAlC,EAAAs4E,EAAAC,GA4CA,QAAAI,IAAAC,EAAAC,EAAAC,EAAAC,GAEA72E,KAAA02E,qBACA12E,KAAA82E,aAAA,EAEA92E,KAAA62E,aAAApuE,SAAAouE,EACAA,EAAA,GAAAF,GAAAxsE,YAAAysE,GACA52E,KAAA22E,eACA32E,KAAA+2E,UAAAH,EAyOA,QAAAI,IAAAN,EAAAC,EAAAC,EAAAC,GAEAJ,GAAA12E,KAAAC,KAAA02E,EAAAC,EAAAC,EAAAC,GAuCA,QAAAI,IAAAn5E,EAAAs4E,EAAAC,EAAAC,GAEAC,GAAAx2E,KAAAC,KAAAlC,EAAAs4E,EAAAC,EAAAC,GAkCA,QAAAY,IAAAp5E,EAAAs4E,EAAAC,EAAAC,GAEAC,GAAAx2E,KAAAC,KAAAlC,EAAAs4E,EAAAC,EAAAC,GA4BA,QAAAa,IAAAr5E,EAAAs4E,EAAAC,EAAAC,GAEAC,GAAAx2E,KAAAC,KAAAlC,EAAAs4E,EAAAC,EAAAC,GA0BA,QAAAc,IAAAV,EAAAC,EAAAC,EAAAC;AAEAJ,GAAA12E,KAAAC,KAAA02E,EAAAC,EAAAC,EAAAC,GAEA72E,KAAAq3E,aAAA,EACAr3E,KAAAs3E,aAAA,EACAt3E,KAAAu3E,aAAA,EACAv3E,KAAAw3E,aAAA,EAyIA,QAAAC,IAAAf,EAAAC,EAAAC,EAAAC,GAEAJ,GAAA12E,KAAAC,KAAA02E,EAAAC,EAAAC,EAAAC,GA0CA,QAAAa,IAAAhB,EAAAC,EAAAC,EAAAC,GAEAJ,GAAA12E,KAAAC,KAAA02E,EAAAC,EAAAC,EAAAC,GA8LA,QAAAN,IAAAz4E,EAAAs4E,EAAAC,EAAAC,GAEA,GAAA7tE,SAAA3K,EAAA,SAAA2B,OAAA,+CACA,IAAAgJ,SAAA2tE,GAAA,IAAAA,EAAAr4E,OAAA,SAAA0B,OAAA,oDAAA3B,EAEAkC,MAAAlC,OAEAkC,KAAAo2E,MAAAuB,GAAAC,aAAAxB,EAAAp2E,KAAA63E,gBACA73E,KAAAq2E,OAAAsB,GAAAC,aAAAvB,EAAAr2E,KAAA83E,iBAEA93E,KAAA+3E,iBAAAzB,GAAAt2E,KAAAg4E,sBAEAh4E,KAAAi4E,WACAj4E,KAAAk4E,WA4fA,QAAAC,IAAAr6E,EAAAs4E,EAAAC,EAAAC,GAEAC,GAAAx2E,KAAAC,KAAAlC,EAAAs4E,EAAAC,EAAAC,GAwBA,QAAA8B,IAAAt6E,EAAAu6E,EAAAC,GAEAt4E,KAAAlC,OACAkC,KAAAs4E,SACAt4E,KAAAq4E,SAAA5vE,SAAA4vE,KAAA,EAEAr4E,KAAAyf,KAAAC,GAAAC,eAGA3f,KAAAq4E,SAAA,GAEAr4E,KAAAu4E,gBAIAv4E,KAAAk4E,WA0UA,QAAAM,IAAApvE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GACArJ,KAAAgoB,YAgKA,QAAAywD,IAAArvE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAgGA,QAAAqvE,MAEA14E,KAAA24E,YAAA,aACA34E,KAAA44E,eAAA,aACA54E,KAAA64E,eAAA,aAyWA,QAAAC,IAAA1vE,GAEA,iBAAAA,KAEAkG,QAAA4E,KAAA,6EACA9K,EAAAX,QAIAzI,KAAAoJ,QAAAX,SAAAW,IAAAC,GAEArJ,KAAA+4E,iBAAA,EAsiBA,QAAAC,IAAA5vE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GACArJ,KAAAi5E,YAAA,GA2zBA,QAAAC,IAAA9vE,GAEA,mBAAA+vE,oBAEA7pE,QAAA4E,KAAA,+DAIA,mBAAAklE,QAEA9pE,QAAA4E,KAAA,mDAIAlU,KAAAoJ,QAAAX,SAAAW,IAAAC,GACArJ,KAAAkD,QAAAuF,OAyFA,QAAA4wE,MAEAr5E,KAAApC,KAAA,YAEAoC,KAAAs5E,YACAt5E,KAAAu5E,YAAA,KAgRA,QAAAC,IAAA53D,GAEA5hB,KAAApC,KAAA,OAEAoC,KAAA4hB,OA4BA,QAAA63D,IAAA3uE,EAAA4a,EAAAg0D,EAAA93D,GAUA,OARA+3D,GAAAC,OAAA9uE,GAAA4E,MAAA,IACAiE,EAAA+R,EAAA9D,EAAAi4D,WACAC,GAAAl4D,EAAAwZ,YAAA2+C,KAAAn4D,EAAAwZ,YAAA4+C,KAAAp4D,EAAAq4D,oBAAAtmE,EAEAumE,KAEAC,EAAA,EAAAC,EAAA,EAEAj7E,EAAA,EAAkBA,EAAAw6E,EAAA57E,OAAkBoB,IAAA,CAEpC,GAAAk7E,GAAAV,EAAAx6E,EAEA,WAAAk7E,EAEAF,EAAA,EACAC,GAAAN,MAEI,CAEJ,GAAAQ,GAAAC,GAAAF,EAAAX,EAAA/lE,EAAAwmE,EAAAC,EAAAx4D,EACAu4D,IAAAG,EAAAH,QACAD,EAAA74E,KAAAi5E,EAAAzvE,OAMA,MAAAqvE,GAIA,QAAAK,IAAAF,EAAAX,EAAA/lE,EAAAwmE,EAAAC,EAAAx4D,GAEA,GAAA44D,GAAA54D,EAAA64D,OAAAJ,IAAAz4D,EAAA64D,OAAA,IAEA,IAAAD,EAAA,CAEA,GAEAllE,GAAAG,EAAAilE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAFAlwE,EAAA,GAAAwuE,GAIA,IAAAmB,EAAAna,EAIA,OAFA2a,GAAAR,EAAAS,iBAAAT,EAAAS,eAAAT,EAAAna,EAAA3wD,MAAA,MAEAvQ,EAAA,EAAAgQ,EAAA6rE,EAAAj9E,OAAuCoB,EAAAgQ,GAAO,CAE9C,GAAA+rE,GAAAF,EAAA77E,IAEA,QAAA+7E,GAEA,QAEA5lE,EAAA0lE,EAAA77E,KAAAwU,EAAAwmE,EACA1kE,EAAAulE,EAAA77E,KAAAwU,EAAAymE,EAEAvvE,EAAAswE,OAAA7lE,EAAAG,EAEA,MAEA,SAEAH,EAAA0lE,EAAA77E,KAAAwU,EAAAwmE,EACA1kE,EAAAulE,EAAA77E,KAAAwU,EAAAymE,EAEAvvE,EAAAuwE,OAAA9lE,EAAAG,EAEA,MAEA,SAEAilE,EAAAM,EAAA77E,KAAAwU,EAAAwmE,EACAQ,EAAAK,EAAA77E,KAAAwU,EAAAymE,EACAQ,EAAAI,EAAA77E,KAAAwU,EAAAwmE,EACAU,EAAAG,EAAA77E,KAAAwU,EAAAymE,EAEAvvE,EAAAwwE,iBAAAT,EAAAC,EAAAH,EAAAC,EAEA,MAEA,SAEAD,EAAAM,EAAA77E,KAAAwU,EAAAwmE,EACAQ,EAAAK,EAAA77E,KAAAwU,EAAAymE,EACAQ,EAAAI,EAAA77E,KAAAwU,EAAAwmE,EACAU,EAAAG,EAAA77E,KAAAwU,EAAAymE,EACAU,EAAAE,EAAA77E,KAAAwU,EAAAwmE,EACAY,EAAAC,EAAA77E,KAAAwU,EAAAymE,EAEAvvE,EAAAywE,cAAAV,EAAAC,EAAAC,EAAAC,EAAAL,EAAAC,IAUA,OAAUR,QAAAK,EAAAe,GAAA5nE,EAAA9I,SAQV,QAAA2wE,IAAApyE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GAkFA,QAAAoyE,IAAAryE,GAEApJ,KAAAoJ,QAAAX,SAAAW,IAAAC,GA8BA,QAAAqyE,MAEA17E,KAAApC,KAAA,eAEAoC,KAAAohD,OAAA,EAEAphD,KAAA27E,OAAA,KAEA37E,KAAA4iD,QAAA,GAAAlvC,IACA1T,KAAA4iD,QAAA7uB,OAAAnI,OAAA,GACA5rB,KAAA4iD,QAAAtiC,kBAAA,EAEAtgB,KAAA8iD,QAAA,GAAApvC,IACA1T,KAAA8iD,QAAA/uB,OAAAnI,OAAA,GACA5rB,KAAA8iD,QAAAxiC,kBAAA,EAiFA,QAAAs7D,IAAAtvD,EAAAC,EAAAsvD,GAEApiD,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,YAEA,IAAAuf,GAAA,GAAAikC,EAAA,EAEA06B,EAAA,GAAApoE,IAAAyJ,EAAAikC,EAAA90B,EAAAC,EACAuvD,GAAAxgE,GAAA9G,IAAA,QACAsnE,EAAA5/D,OAAA,GAAAtC,GAAA,QACA5Z,KAAAuS,IAAAupE,EAEA,IAAAC,GAAA,GAAAroE,IAAAyJ,EAAAikC,EAAA90B,EAAAC,EACAwvD,GAAAzgE,GAAA9G,IAAA,QACAunE,EAAA7/D,OAAA,GAAAtC,IAAA,QACA5Z,KAAAuS,IAAAwpE,EAEA,IAAAC,GAAA,GAAAtoE,IAAAyJ,EAAAikC,EAAA90B,EAAAC,EACAyvD,GAAA1gE,GAAA9G,IAAA,OACAwnE,EAAA9/D,OAAA,GAAAtC,GAAA,QACA5Z,KAAAuS,IAAAypE,EAEA,IAAAC,GAAA,GAAAvoE,IAAAyJ,EAAAikC,EAAA90B,EAAAC,EACA0vD,GAAA3gE,GAAA9G,IAAA,QACAynE,EAAA//D,OAAA,GAAAtC,GAAA,SACA5Z,KAAAuS,IAAA0pE,EAEA,IAAAC,GAAA,GAAAxoE,IAAAyJ,EAAAikC,EAAA90B,EAAAC,EACA2vD,GAAA5gE,GAAA9G,IAAA,QACA0nE,EAAAhgE,OAAA,GAAAtC,GAAA,QACA5Z,KAAAuS,IAAA2pE,EAEA,IAAAC,GAAA,GAAAzoE,IAAAyJ,EAAAikC,EAAA90B,EAAAC,EACA4vD,GAAA7gE,GAAA9G,IAAA,QACA2nE,EAAAjgE,OAAA,GAAAtC,GAAA,SACA5Z,KAAAuS,IAAA4pE,EAEA,IAAAj5E,IAAiBmB,OAAA0vC,GAAA30B,UAAAY,GAAAX,UAAAW,GAEjBhgB,MAAA0xC,aAAA,GAAAlwB,GAAAq6D,IAAA34E,GACAlD,KAAA0xC,aAAAtwB,QAAAtjB,KAAA,aAEAkC,KAAA2V,OAAA,SAAAiN,EAAAwI,GAEA,OAAAprB,KAAA+5B,QAAA/5B,KAAAi3B,mBAEA,IAAAya,GAAA1xC,KAAA0xC,aACAnxB,EAAAmxB,EAAAtwB,QAAAb,eAEAmxB,GAAAtwB,QAAAb,iBAAA,EAEAmxB,EAAAjwB,eAAA,EACAmB,EAAAsI,OAAAE,EAAA0wD,EAAApqC,GAEAA,EAAAjwB,eAAA,EACAmB,EAAAsI,OAAAE,EAAA2wD,EAAArqC,GAEAA,EAAAjwB,eAAA,EACAmB,EAAAsI,OAAAE,EAAA4wD,EAAAtqC,GAEAA,EAAAjwB,eAAA,EACAmB,EAAAsI,OAAAE,EAAA6wD,EAAAvqC,GAEAA,EAAAjwB,eAAA,EACAmB,EAAAsI,OAAAE,EAAA8wD,EAAAxqC,GAEAA,EAAAtwB,QAAAb,kBAEAmxB,EAAAjwB,eAAA,EACAmB,EAAAsI,OAAAE,EAAA+wD,EAAAzqC,GAEA9uB,EAAAuU,gBAAA,OAIAn3B,KAAAo3B,MAAA,SAAAxU,EAAA/c,EAAA+nB,EAAAqtB,GAIA,OAFAvJ,GAAA1xC,KAAA0xC,aAEAvyC,EAAA,EAAmBA,EAAA,EAAOA,IAE1BuyC,EAAAjwB,eAAAtiB,EACAyjB,EAAAuU,gBAAAua,GAEA9uB,EAAAwU,MAAAvxB,EAAA+nB,EAAAqtB,EAIAr4B,GAAAuU,gBAAA,OAaA,QAAAilD,MAEA3iD,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,gBAEAoC,KAAA+pB,QAAAsyD,GAAAryD,aAEAhqB,KAAAs8E,KAAAt8E,KAAA+pB,QAAAwyD,aACAv8E,KAAAs8E,KAAAE,QAAAx8E,KAAA+pB,QAAA0yD,aAEAz8E,KAAAwnC,OAAA,KAiHA,QAAAk1C,IAAAC,GAEAljD,GAAA15B,KAAAC,MAEAA,KAAApC,KAAA,QAEAoC,KAAA+pB,QAAA4yD,EAAA5yD,QAEA/pB,KAAAs8E,KAAAt8E,KAAA+pB,QAAAwyD,aACAv8E,KAAAs8E,KAAAE,QAAAG,EAAAC,YAEA58E,KAAA68E,UAAA,EAEA78E,KAAA83B,OAAA,KACA93B,KAAA88E,MAAA,EACA98E,KAAA+8E,UAAA,EACA/8E,KAAAkb,OAAA,EACAlb,KAAAg9E,aAAA,EACAh9E,KAAAi9E,WAAA,EACAj9E,KAAAk9E,oBAAA,EACAl9E,KAAAm9E,WAAA,QAEAn9E,KAAAo9E,WAwRA,QAAAC,IAAAV,GAEAD,GAAA38E,KAAAC,KAAA28E,GAEA38E,KAAAs9E,OAAAt9E,KAAA+pB,QAAAwzD,eACAv9E,KAAAs9E,OAAAd,QAAAx8E,KAAAs8E,MAqFA,QAAAkB,IAAAC,EAAAC,GAEA19E,KAAA29E,SAAAF,EAAA1zD,QAAA6zD,iBACA59E,KAAA29E,SAAAD,QAAAj1E,SAAAi1E,IAAA,KAEA19E,KAAA4hB,KAAA,GAAA4W,YAAAx4B,KAAA29E,SAAAE,mBAEAJ,EAAAK,YAAAtB,QAAAx8E,KAAA29E,UAwCA,QAAAI,IAAAx7E,EAAAy7E,EAAAjH,GAEA/2E,KAAAuC,UACAvC,KAAA+2E,WAEA,IACAkH,GADAvmD,EAAAM,YAGA,QAAAgmD,GAEA,iBACAC,EAAAj+E,KAAAk+E,MACA,MAEA,cACA,WACAxmD,EAAAt2B,MACA68E,EAAAj+E,KAAAm+E,OACA,MAEA,SACAF,EAAAj+E,KAAAo+E,MAIAp+E,KAAA83B,OAAA,GAAAJ,GAAA,EAAAq/C,GAYA/2E,KAAAq+E,iBAAAJ,EAEAj+E,KAAAs+E,iBAAA,EAEAt+E,KAAAu+E,SAAA,EACAv+E,KAAAw+E,eAAA,EAsKA,QAAAC,IAAAC,EAAA7zE,EAAA8zE,GAEA,GAAAC,GAAAD,GAAAE,GAAAC,eAAAj0E,EAEA7K,MAAA++E,aAAAL,EACA1+E,KAAAg/E,UAAAN,EAAAO,WAAAp0E,EAAA+zE,GA4DA,QAAAC,IAAAK,EAAAr0E,EAAA+zE,GAEA5+E,KAAA6K,OACA7K,KAAA4+E,cAAAC,GAAAC,eAAAj0E,GAEA7K,KAAAm/E,KAAAN,GAAAO,SAAAF,EAAAl/E,KAAA4+E,WAAAS,WAAAH,EAEAl/E,KAAAk/E,WA+pBA,QAAAI,MAEAt/E,KAAAyf,KAAAC,GAAAC,eAGA3f,KAAA+xB,SAAA3wB,MAAApD,UAAAkhE,MAAAn/D,KAAA5B,WAEA6B,KAAAu/E,gBAAA,CAGA,IAAA7iD,KACA18B,MAAAw/E,eAAA9iD,CAEA,QAAAv9B,GAAA,EAAAqjB,EAAArkB,UAAAJ,OAAwCoB,IAAAqjB,IAASrjB,EAEjDu9B,EAAAv+B,UAAAgB,GAAAsgB,MAAAtgB,CAIAa,MAAAy/E,UACAz/E,KAAA0/E,gBACA1/E,KAAAg/E,aACAh/E,KAAA2/E,yBAEA,IAAAl1E,GAAAzK,IAEAA,MAAA4/E,OAEAx0E,SACA/C,YAEA,MAAAoC,GAAAsnB,SAAAh0B,QAGA8hF,YAEA,MAAA7/E,MAAAqI,MAAAoC,EAAA80E,kBAIAO,wBAEA,MAAAr1E,GAAAu0E,UAAAjhF,SA0TA,QAAAgiF,IAAAC,EAAAC,EAAAC,GAEAlgF,KAAAmgF,OAAAH,EACAhgF,KAAAogF,MAAAH,EACAjgF,KAAAqgF,WAAAH,GAAA,IAWA,QATA5H,GAAA2H,EAAA3H,OACAgI,EAAAhI,EAAAv6E,OACAwiF,EAAA,GAAAn/E,OAAAk/E,GAEAE,GACAC,YAAAC,GACAC,UAAAD,IAGAvhF,EAAA,EAAkBA,IAAAmhF,IAAenhF,EAAA,CAEjC,GAAAyhF,GAAAtI,EAAAn5E,GAAA0hF,kBAAA,KACAN,GAAAphF,GAAAyhF,EACAA,EAAAE,SAAAN,EAIAxgF,KAAA+gF,qBAAAP,EAEAxgF,KAAAghF,cAAAT,EAGAvgF,KAAAihF,kBAAA,GAAA7/E,OAAAk/E,GAEAtgF,KAAAkhF,YAAA,KACAlhF,KAAAmhF,kBAAA,KAEAnhF,KAAAohF,sBAAA,KACAphF,KAAAqhF,mBAAA,KAEArhF,KAAA88E,KAAAwE,GACAthF,KAAAuhF,YAAA,EAIAvhF,KAAAwhF,WAAA,KAIAxhF,KAAAuP,KAAA,EAEAvP,KAAAyhF,UAAA,EACAzhF,KAAA0hF,oBAAA,EAEA1hF,KAAA2hF,OAAA,EACA3hF,KAAA4hF,iBAAA,EAEA5hF,KAAA6hF,YAAA9nE,IAEA/Z,KAAA8hF,QAAA,EACA9hF,KAAA4X,SAAA,EAEA5X,KAAA+hF,mBAAA,EAEA/hF,KAAAgiF,kBAAA,EACAhiF,KAAAiiF,gBAAA,EA0lBA,QAAAC,IAAAp/E,GAEA9C,KAAAmiF,MAAAr/E,EACA9C,KAAAoiF,qBACApiF,KAAAqiF,WAAA,EAEAriF,KAAAuP,KAAA,EAEAvP,KAAAyhF,UAAA,EAkuBA,QAAAa,IAAAt3E,GAEA,gBAAAA,KAEAsE,QAAA4E,KAAA,sDACAlJ,EAAA7M,UAAA,IAIA6B,KAAAgL,QAcA,QAAAu3E,MAEAtxE,GAAAlR,KAAAC,MAEAA,KAAApC,KAAA,0BACAoC,KAAAwkC,kBAAA/7B,OAgCA,QAAA+5E,IAAAC,EAAA5mD,EAAA3gB,EAAA4gB,GAEA97B,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAA4hB,KAAA6gE,EACAziF,KAAA67B,WACA77B,KAAAkb,SAEAlb,KAAA87B,gBAAA,EAkIA,QAAA4mD,IAAA3hF,EAAAowD,GAEAnxD,KAAAyf,KAAAC,GAAAC,eAEA3f,KAAAe,QACAf,KAAAmxD,SACAnxD,KAAA4I,MAAAH,SAAA1H,IAAAhD,OAAAozD,EAAA,EAEAnxD,KAAA43B,SAAA,EACA53B,KAAA64B,aAAsB3d,OAAA,EAAAtS,OAAA,GAEtB5I,KAAA+3B,iBAAA,aAEA/3B,KAAA2B,QAAA,EA+FA,QAAAghF,IAAA5hF,EAAAowD,EAAAzV,GAEAgnC,GAAA3iF,KAAAC,KAAAe,EAAAowD,GAEAnxD,KAAA07C,oBAAA,EA0BA,QAAAknC,IAAA7hF,EAAA86B,EAAA6f,GAEAvqC,GAAApR,KAAAC,KAAAe,EAAA86B,GAEA77B,KAAA07C,oBAAA,EA4BA,QAAAmnC,IAAAniD,EAAAC,EAAArU,EAAAC,GAEAvsB,KAAA8iF,IAAA,GAAAriD,IAAAC,EAAAC,GAGA3gC,KAAAssB,QAAA,EACAtsB,KAAAusB,OAAAxS,IAEA/Z,KAAA+iF,QACAzwE,QACAutD,QACAf,OACAiB,QAAYijB,UAAA,GACZnkB,WAGAvgE,OAAAof,iBAAA1d,KAAA+iF,QACAE,YACArlE,IAAA,WAGA,MADAtO,SAAA4E,KAAA,yEACAlU,KAAA+/D,WAQA,QAAAmjB,IAAAz1E,EAAAjI,GAEA,MAAAiI,GAAA2J,SAAA5R,EAAA4R,SAIA,QAAA+rE,IAAA93E,EAAA+3E,EAAA7a,EAAA8a,GAEA,GAAAh4E,EAAA0hB,WAAA,IAEA1hB,EAAAi4E,QAAAF,EAAA7a,GAEA8a,KAAA,GAIA,OAFAvuD,GAAAzpB,EAAAypB,SAEA31B,EAAA,EAAAgQ,EAAA2lB,EAAA/2B,OAAwCoB,EAAAgQ,EAAOhQ,IAE/CgkF,GAAAruD,EAAA31B,GAAAikF,EAAA7a,GAAA,GAiFA,QAAAgb,IAAAC,GAEAxjF,KAAAwjF,UAAA/6E,SAAA+6E,KAEAxjF,KAAA+8E,UAAA,EACA/8E,KAAAyjF,QAAA,EACAzjF,KAAA0jF,YAAA,EAEA1jF,KAAA2jF,SAAA,EAqEA,QAAAlnE,IAAAV,EAAAxI,EAAAF,GAMA,MAJArT,MAAA+b,OAAAtT,SAAAsT,IAAA,EACA/b,KAAAuT,IAAA9K,SAAA8K,IAAA,EACAvT,KAAAqT,MAAA5K,SAAA4K,IAAA,EAEArT,KAuEA,QAAA4jF,IAAA7nE,EAAA1I,EAAAoC,GAMA,MAJAzV,MAAA+b,OAAAtT,SAAAsT,IAAA,EACA/b,KAAAqT,MAAA5K,SAAA4K,IAAA,EACArT,KAAAyV,EAAAhN,SAAAgN,IAAA,EAEAzV,KAgDA,QAAA6jF,IAAAx9E,EAAAD,GAEApG,KAAAqG,IAAAoC,SAAApC,IAAA,GAAAqW,KAAA3C,aACA/Z,KAAAoG,IAAAqC,SAAArC,IAAA,GAAAsW,KAAA3C,aAsNA,QAAA+pE,IAAAt3E,GAEAitB,GAAA15B,KAAAC,MAEAA,KAAAwM,WACAxM,KAAAkrB,OAAA,aAcA,QAAA64D,IAAA14E,EAAAqa,EAAAjf,EAAAktB,GAEA3zB,KAAAqL,SAEArL,KAAA0lB,KAAAjd,SAAAid,IAAA,CAEA,IAAA7f,GAAA4C,SAAAhC,IAAA,SAEAsa,EAAAtY,SAAAkrB,IAAA,EAIAqwD,EAAA,EAEAC,EAAAjkF,KAAAqL,OAAAU,QAEAk4E,MAAAlxD,WAEAixD,EAAA,EAAAC,EAAA97D,MAAApqB,OAEGkmF,KAAApxD,mBAEHmxD,EAAAC,EAAAn7D,WAAAqI,OAAAvoB,MAMA,IAAAmD,GAAA,GAAAkF,IAEAizE,EAAA,GAAA3nD,IAAA,EAAAynD,EAAA,IAEAj4E,GAAAmF,aAAA,WAAAgzE,GAEA7xE,GAAAtS,KAAAC,KAAA+L,EAAA,GAAA2F,KAA6D7L,QAAA8tB,UAAA5S,KAI7D/gB,KAAAsgB,kBAAA,EAEAtgB,KAAA2V,SAyGA,QAAAwuE,IAAA7tD,EAAAzwB,GAEA4zB,GAAA15B,KAAAC,MAEAA,KAAAs2B,QACAt2B,KAAAs2B,MAAAW,oBAEAj3B,KAAAod,OAAAkZ,EAAAzJ,YACA7sB,KAAAsgB,kBAAA,EAEAtgB,KAAA6F,OAYA,QAVAkG,GAAA,GAAAkF,IAEAizE,GACA,YACA,YACA,aACA,YACA,cAGA/kF,EAAA,EAAA00C,EAAA,EAAA1kC,EAAA,GAAiChQ,EAAAgQ,EAAOhQ,IAAA00C,IAAA,CAExC,GAAAtiB,GAAApyB,EAAAgQ,EAAAzK,KAAAmO,GAAA,EACA2e,EAAAqiB,EAAA1kC,EAAAzK,KAAAmO,GAAA,CAEAqxE,GAAA7iF,KACAqD,KAAA2oD,IAAA97B,GAAA7sB,KAAAsgE,IAAAzzC,GAAA,EACA7sB,KAAA2oD,IAAA77B,GAAA9sB,KAAAsgE,IAAAxzC,GAAA,GAKAzlB,EAAAmF,aAAA,cAAAqrB,IAAA2nD,EAAA,GAEA,IAAA13E,GAAA,GAAAkF,KAAyC0a,KAAA,GAEzCpsB,MAAAokF,KAAA,GAAA/xE,IAAAtG,EAAAS,GACAxM,KAAAuS,IAAAvS,KAAAokF,MAEApkF,KAAA2V,SAuDA,QAAA0uE,IAAAh5E,GAEA,GAAAi5E,KAEAj5E,MAAAk5E,QAEAD,EAAAjjF,KAAAgK,EAIA,QAAAlM,GAAA,EAAkBA,EAAAkM,EAAAypB,SAAA/2B,OAA4BoB,IAE9CmlF,EAAAjjF,KAAAC,MAAAgjF,EAAAD,GAAAh5E,EAAAypB,SAAA31B,IAIA,OAAAmlF,GAIA,QAAAE,IAAAn5E,GAYA,OAVA+hC,GAAAi3C,GAAAh5E,GAEAU,EAAA,GAAAkF,IAEA3F,KACAxC,KAEA27E,EAAA,GAAA/8D,GAAA,OACAg9D,EAAA,GAAAh9D,GAAA,OAEAvoB,EAAA,EAAkBA,EAAAiuC,EAAArvC,OAAkBoB,IAAA,CAEpC,GAAAwlF,GAAAv3C,EAAAjuC,EAEAwlF,GAAA5qD,QAAA4qD,EAAA5qD,OAAAwqD,SAEAj5E,EAAAjK,KAAA,OACAiK,EAAAjK,KAAA,OACAyH,EAAAzH,KAAAojF,EAAAn9E,EAAAm9E,EAAAl9E,EAAAk9E,EAAAj/E,GACAsD,EAAAzH,KAAAqjF,EAAAp9E,EAAAo9E,EAAAn9E,EAAAm9E,EAAAl/E,IAMAuG,EAAAmF,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAS,EAAAmF,aAAA,WAAAqrB,IAAAzzB,EAAA,GAEA,IAAA0D,GAAA,GAAAkF,KAAyCmd,aAAA+1D,GAAA92D,WAAA,EAAAE,YAAA,EAAAe,aAAA,GAEzC1c,IAAAtS,KAAAC,KAAA+L,EAAAS,GAEAxM,KAAA8C,KAAAuI,EACArL,KAAAotC,QAEAptC,KAAAod,OAAA/R,EAAAwhB,YACA7sB,KAAAsgB,kBAAA,EAwDA,QAAAukE,IAAAvuD,EAAAwuD,EAAAj/E,GAEA7F,KAAAs2B,QACAt2B,KAAAs2B,MAAAW,oBAEAj3B,KAAA6F,OAEA,IAAAkG,GAAA,GAAAwgE,IAAAuY,EAAA,KACAt4E,EAAA,GAAAwyB,KAAyCvO,WAAA,EAAArE,KAAA,GAEzC9Z,IAAAvS,KAAAC,KAAA+L,EAAAS,GAEAxM,KAAAod,OAAApd,KAAAs2B,MAAAzJ,YACA7sB,KAAAsgB,kBAAA,EAEAtgB,KAAA2V,SAwEA,QAAAovE,IAAAzuD,EAAAzwB,GAEA4zB,GAAA15B,KAAAC,MAEAA,KAAAs2B,QACAt2B,KAAAs2B,MAAAW,oBAEAj3B,KAAAod,OAAAkZ,EAAAzJ,YACA7sB,KAAAsgB,kBAAA,EAEAtgB,KAAA6F,OAEA,IAAA2G,GAAA,GAAAkF,KAAyC0a,KAAA,IAEzCrgB,EAAA,GAAAkF,GAEAlF,GAAAmF,aAAA,cAAAC,IAAA,GAAAC,cAAA,QAEApR,KAAA2P,KAAA,GAAAkwD,IAAA9zD,EAAAS,GACAxM,KAAAuS,IAAAvS,KAAA2P,MAGA3P,KAAA2V,SAoDA,QAAAqvE,IAAA1uD,EAAA5Q,EAAA7f,GAEA4zB,GAAA15B,KAAAC,MAEAA,KAAAs2B,QACAt2B,KAAAs2B,MAAAW,oBAEAj3B,KAAAod,OAAAkZ,EAAAzJ,YACA7sB,KAAAsgB,kBAAA,EAEAtgB,KAAA6F,OAEA,IAAAkG,GAAA,GAAA43D,IAAAj+C,EACA3Z,GAAAk5E,QAAA,GAAAvgF,KAAAmO,IAEA7S,KAAAwM,SAAA,GAAAwyB,KAA0CvO,WAAA,EAAArE,KAAA,IAC1C3jB,SAAAzI,KAAA6F,QAAA7F,KAAAwM,SAAAqiB,aAAA+1D,GAEA,IAAAjqE,GAAA5O,EAAAm5E,aAAA,YACAp8E,EAAA,GAAAsI,cAAA,EAAAuJ,EAAA/R,MAEAmD,GAAAmF,aAAA,WAAAC,IAAArI,EAAA,IAEA9I,KAAAuS,IAAA,GAAAD,IAAAvG,EAAA/L,KAAAwM,WAEAxM,KAAA2V,SA0DA,QAAAwvE,IAAAz/D,EAAAg0D,EAAA+K,EAAAC,GAEAh/D,KAAA,GACAg0D,KAAA,GACA+K,EAAA,GAAA/8D,GAAAjf,SAAAg8E,IAAA,SACAC,EAAA,GAAAh9D,GAAAjf,SAAAi8E,IAAA,QAQA,QANA/mE,GAAA+7D,EAAA,EACA0L,EAAA1/D,EAAAg0D,EACA2L,EAAA3/D,EAAA,EAEApa,KAAAxC,KAEA3J,EAAA,EAAA00C,EAAA,EAAA5rC,GAAAo9E,EAAyClmF,GAAAu6E,EAAgBv6E,IAAA8I,GAAAm9E,EAAA,CAEzD95E,EAAAjK,MAAAgkF,EAAA,EAAAp9E,EAAAo9E,EAAA,EAAAp9E,GACAqD,EAAAjK,KAAA4G,EAAA,GAAAo9E,EAAAp9E,EAAA,EAAAo9E,EAEA,IAAAx/E,GAAA1G,IAAAwe,EAAA8mE,EAAAC,CAEA7+E,GAAA6c,QAAA5Z,EAAA+qC,GAA8BA,GAAA,EAC9BhuC,EAAA6c,QAAA5Z,EAAA+qC,GAA8BA,GAAA,EAC9BhuC,EAAA6c,QAAA5Z,EAAA+qC,GAA8BA,GAAA,EAC9BhuC,EAAA6c,QAAA5Z,EAAA+qC,GAA8BA,GAAA,EAI9B,GAAA9nC,GAAA,GAAAkF,GACAlF,GAAAmF,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAS,EAAAmF,aAAA,WAAAqrB,IAAAzzB,EAAA,GAEA,IAAA0D,GAAA,GAAAkF,KAAyCmd,aAAA+1D,IAEzCvyE,IAAAtS,KAAAC,KAAA+L,EAAAS,GAaA,QAAA84E,IAAAvpE,EAAAwpE,EAAAC,EAAA9L,EAAA+K,EAAAC,GAEA3oE,KAAA,GACAwpE,KAAA,GACAC,KAAA,EACA9L,KAAA,GACA+K,EAAA,GAAA/8D,GAAAjf,SAAAg8E,IAAA,SACAC,EAAA,GAAAh9D,GAAAjf,SAAAi8E,IAAA,QAEA,IAGApvE,GAAAkJ,EACAxX,EAAA7H,EAAA00C,EAAAvsC,EAAAzB,EAJAyF,KACAxC,IAOA,KAAA3J,EAAA,EAAcA,GAAAomF,EAAcpmF,IAE5B6H,EAAA7H,EAAAomF,GAAA,EAAA7gF,KAAAmO,IAEAyC,EAAA5Q,KAAAsgE,IAAAh+D,GAAA+U,EACAyC,EAAA9Z,KAAA2oD,IAAArmD,GAAA+U,EAEAzQ,EAAAjK,KAAA,OACAiK,EAAAjK,KAAAiU,EAAA,EAAAkJ,GAEA3Y,EAAA,EAAA1G,EAAAslF,EAAAC,EAEA57E,EAAAzH,KAAAwE,EAAAyB,EAAAzB,EAAA0B,EAAA1B,EAAAL,GACAsD,EAAAzH,KAAAwE,EAAAyB,EAAAzB,EAAA0B,EAAA1B,EAAAL,EAMA,KAAArG,EAAA,EAAcA,GAAAqmF,EAAcrmF,IAM5B,IAJA0G,EAAA,EAAA1G,EAAAslF,EAAAC,EAEAp9E,EAAAyU,IAAAypE,EAAArmF,EAEA00C,EAAA,EAAeA,EAAA6lC,EAAe7lC,IAI9B7sC,EAAA6sC,EAAA6lC,GAAA,EAAAh1E,KAAAmO,IAEAyC,EAAA5Q,KAAAsgE,IAAAh+D,GAAAM,EACAkX,EAAA9Z,KAAA2oD,IAAArmD,GAAAM,EAEAgE,EAAAjK,KAAAiU,EAAA,EAAAkJ,GACA1V,EAAAzH,KAAAwE,EAAAyB,EAAAzB,EAAA0B,EAAA1B,EAAAL,GAIAwB,GAAA6sC,EAAA,GAAA6lC,GAAA,EAAAh1E,KAAAmO,IAEAyC,EAAA5Q,KAAAsgE,IAAAh+D,GAAAM,EACAkX,EAAA9Z,KAAA2oD,IAAArmD,GAAAM,EAEAgE,EAAAjK,KAAAiU,EAAA,EAAAkJ,GACA1V,EAAAzH,KAAAwE,EAAAyB,EAAAzB,EAAA0B,EAAA1B,EAAAL,EAMA,IAAAuG,GAAA,GAAAkF,GACAlF,GAAAmF,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAS,EAAAmF,aAAA,WAAAqrB,IAAAzzB,EAAA,GAEA,IAAA0D,GAAA,GAAAkF,KAAyCmd,aAAA+1D,IAEzCvyE,IAAAtS,KAAAC,KAAA+L,EAAAS,GAYA,QAAAi5E,IAAAp6E,EAAAqa,EAAAjf,EAAAktB,GAIA3zB,KAAAqL,SAEArL,KAAA0lB,KAAAjd,SAAAid,IAAA,CAEA,IAAA7f,GAAA4C,SAAAhC,IAAA,SAEAsa,EAAAtY,SAAAkrB,IAAA,EAIAqwD,EAAA,EAEAC,EAAAjkF,KAAAqL,OAAAU,QAEAk4E,MAAAlxD,WAEAixD,EAAAC,EAAA97D,MAAApqB,OAIAuR,QAAA4E,KAAA,qGAMA,IAAAnI,GAAA,GAAAkF,IAEAizE,EAAA,GAAA3nD,IAAA,EAAAynD,EAAA,IAEAj4E,GAAAmF,aAAA,WAAAgzE,GAEA7xE,GAAAtS,KAAAC,KAAA+L,EAAA,GAAA2F,KAA6D7L,QAAA8tB,UAAA5S,KAI7D/gB,KAAAsgB,kBAAA,EACAtgB,KAAA2V,SAqEA,QAAA+vE,IAAApvD,EAAA5Q,EAAA7f,GAEA4zB,GAAA15B,KAAAC,MAEAA,KAAAs2B,QACAt2B,KAAAs2B,MAAAW,oBAEAj3B,KAAAod,OAAAkZ,EAAAzJ,YACA7sB,KAAAsgB,kBAAA,EAEAtgB,KAAA6F,QAEA4C,SAAAid,MAAA,EAEA,IAAA3Z,GAAA,GAAAkF,GACAlF,GAAAmF,aAAA,cAAAqrB,MACA7W,IAAA,EACAA,IAAA,EACAA,KAAA,GACAA,KAAA,GACAA,IAAA,GACA,GAEA,IAAAlZ,GAAA,GAAAkF,KAAyC0a,KAAA,GAEzCpsB,MAAA2lF,WAAA,GAAA9lB,IAAA9zD,EAAAS,GACAxM,KAAAuS,IAAAvS,KAAA2lF,YAEA55E,EAAA,GAAAkF,IACAlF,EAAAmF,aAAA,cAAAqrB,KAAA,iBAEAv8B,KAAA4lF,WAAA,GAAA/lB,IAAA9zD,EAAAS,GACAxM,KAAAuS,IAAAvS,KAAA4lF,YAEA5lF,KAAA2V,SA2DA,QAAAkwE,IAAAx6D,GAiEA,QAAAy6D,GAAAr4E,EAAAjI,EAAAK,GAEAkgF,EAAAt4E,EAAA5H,GACAkgF,EAAAvgF,EAAAK,GAIA,QAAAkgF,GAAAr3E,EAAA7I,GAEAyF,EAAAjK,KAAA,OACAyH,EAAAzH,KAAAwE,EAAAyB,EAAAzB,EAAA0B,EAAA1B,EAAAL,GAEAiD,SAAAu9E,EAAAt3E,KAEAs3E,EAAAt3E,OAIAs3E,EAAAt3E,GAAArN,KAAAiK,EAAAvN,OAAA,KAjFA,GAAAgO,GAAA,GAAAkF,IACAzE,EAAA,GAAAkF,KAAyC7L,MAAA,SAAAgpB,aAAAo3D,KAEzC36E,KACAxC,KAEAk9E,KAIAE,EAAA,GAAAx+D,GAAA,UACAy+D,EAAA,GAAAz+D,GAAA,UACA0+D,EAAA,GAAA1+D,GAAA,OACA2+D,EAAA,GAAA3+D,GAAA,UACA4+D,EAAA,GAAA5+D,GAAA,QAIAo+D,GAAA,UAAAI,GACAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GAIAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GAIAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GACAJ,EAAA,UAAAI,GAIAJ,EAAA,SAAAK,GACAL,EAAA,SAAAK,GACAL,EAAA,SAAAK,GACAL,EAAA,SAAAK,GAIAL,EAAA,UAAAM,GACAN,EAAA,UAAAM,GACAN,EAAA,UAAAM,GAIAN,EAAA,QAAAO,GACAP,EAAA,QAAAQ,GAIAR,EAAA,YAAAQ,GACAR,EAAA,YAAAQ,GAEAR,EAAA,YAAAQ,GACAR,EAAA,YAAAQ,GAwBAv6E,EAAAmF,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAS,EAAAmF,aAAA,WAAAqrB,IAAAzzB,EAAA,IAEAuJ,GAAAtS,KAAAC,KAAA+L,EAAAS,GAEAxM,KAAAqrB,SACArrB,KAAAqrB,OAAArX,wBAAAhU,KAAAqrB,OAAArX,yBAEAhU,KAAAod,OAAAiO,EAAAwB,YACA7sB,KAAAsgB,kBAAA,EAEAtgB,KAAAgmF,WAEAhmF,KAAA2V,SA8FA,QAAA4wE,IAAAl7E,EAAAxF,GAEA7F,KAAAqL,SAEA5C,SAAA5C,MAAA,SAEA,IAAA62B,GAAA,GAAAtU,cAAA,kDACA87D,EAAA,GAAA9yE,cAAA,IAEArF,EAAA,GAAAkF,GACAlF,GAAA0yB,SAAA,GAAAttB,IAAAurB,EAAA,IACA3wB,EAAAmF,aAAA,cAAAC,IAAA+yE,EAAA,IAEA7xE,GAAAtS,KAAAC,KAAA+L,EAAA,GAAA2F,KAA6D7L,WAE7D7F,KAAAsgB,kBAAA,EAEAtgB,KAAA2V,SA+EA,QAAA6wE,IAAAC,EAAAhgF,GAEAzG,KAAApC,KAAA,aAEAoC,KAAAymF,KAEA,IAAA5gF,GAAA4C,SAAAhC,IAAA,SAEAi2B,EAAA,GAAAtU,cAAA,kDAEA87D,GAAA,6DAEAn4E,EAAA,GAAAkF,GAEAlF,GAAA0yB,SAAA,GAAAttB,IAAAurB,EAAA,IAEA3wB,EAAAmF,aAAA,cAAAqrB,IAAA2nD,EAAA,IAEA7xE,GAAAtS,KAAAC,KAAA+L,EAAA,GAAA2F,KAA6D7L,WAE7D7F,KAAA+L,SAAA26E,wBA2BA,QAAAC,IAAA9gC,EAAAngC,EAAAjf,GAEAzG,KAAApC,KAAA,cAEAoC,KAAA6lD,QAEA7lD,KAAA0lB,KAAAjd,SAAAid,EAAA,EAAAA,CAEA,IAAA7f,GAAA4C,SAAAhC,IAAA,SAEAy9E,GAAA,qEAEAn4E,EAAA,GAAAkF,GACAlF,GAAAmF,aAAA,cAAAqrB,IAAA2nD,EAAA,IACAn4E,EAAA26E,wBAEA7mB,GAAA9/D,KAAAC,KAAA+L,EAAA,GAAA2F,KAAqD7L,UAIrD,IAAA+gF,IAAA,2CAEA/X,EAAA,GAAA59D,GACA49D,GAAA39D,aAAA,cAAAqrB,IAAAqqD,EAAA,IACA/X,EAAA6X,wBAEA1mF,KAAAuS,IAAA,GAAAD,IAAAu8D,EAAA,GAAA7vC,KAAyDn5B,QAAAujB,QAAA,GAAA2F,aAAA,EAAAf,YAAA,MAwCzD,QAAA64D,IAAAnkF,EAAAg+B,EAAA3iC,EAAA8H,EAAAihF,EAAAC,GAIAttD,GAAA15B,KAAAC,MAEAyI,SAAA5C,MAAA,UACA4C,SAAA1K,MAAA,GACA0K,SAAAq+E,MAAA,GAAA/oF,GACA0K,SAAAs+E,MAAA,GAAAD,GAEAr+E,SAAAu+E,KAEAA,GAAA,GAAA/1E,IACA+1E,GAAA91E,aAAA,cAAAqrB,KAAA,iBAEA0qD,GAAA,GAAAzX,IAAA,YACAyX,GAAAC,UAAA,UAIAlnF,KAAA2a,SAAA/I,KAAA8uB,GAEA1gC,KAAA2P,KAAA,GAAAkwD,IAAAmnB,GAAA,GAAAt1E,KAA8D7L,WAC9D7F,KAAA2P,KAAA2Q,kBAAA,EACAtgB,KAAAuS,IAAAvS,KAAA2P,MAEA3P,KAAAokF,KAAA,GAAA9xE,IAAA20E,GAAA,GAAAjoD,KAA8Dn5B,WAC9D7F,KAAAokF,KAAA9jE,kBAAA,EACAtgB,KAAAuS,IAAAvS,KAAAokF,MAEApkF,KAAAmnF,aAAAzkF,GACA1C,KAAAonF,UAAArpF,EAAA+oF,EAAAC,GAgEA,QAAAM,IAAA3hE,GAEAA,KAAA,CAEA,IAAApa,IACA,MAAAoa,EAAA,IACA,QAAAA,EAAA,EACA,UAAAA,GAGA5c,GACA,aACA,aACA,cAGAiD,EAAA,GAAAkF,GACAlF,GAAAmF,aAAA,cAAAqrB,IAAAjxB,EAAA,IACAS,EAAAmF,aAAA,WAAAqrB,IAAAzzB,EAAA,GAEA,IAAA0D,GAAA,GAAAkF,KAAyCmd,aAAA+1D,IAEzCvyE,IAAAtS,KAAAC,KAAA+L,EAAAS,GAWA,QAAA86E,IAAA75E,EAAAjI,EAAAgB,EAAAyH,EAAAkjB,EAAAtrB,EAAA6uB,GAGA,MADAplB,SAAA4E,KAAA,wEACA,GAAAumB,IAAAhtB,EAAAjI,EAAAgB,EAAA2qB,EAAAtrB,EAAA6uB,GAQA,QAAA6yD,IAAAj+E,GAGA,MADAgG,SAAA4E,KAAA,kEACA5K,EAIA,QAAA8I,IAAA9I,GAYA,MAVAb,UAAAa,UAEAgG,QAAA4E,KAAA,+DACA5K,EAAAk+E,iBAAA,EACAl+E,cACAA,EAAAuD,MAAA,WAEA,MAAAvD,GAAA41D,SAGA51D,EAIA,QAAA25E,IAAAl3E,EAAAS,GAGA,MADA8C,SAAA4E,KAAA,sDACA,GAAA6rD,IAAAh0D,EAAAS,GAIA,QAAAi7E,IAAAj7E,GAGA,MADA8C,SAAA4E,KAAA,oDACA,GAAA2qD,IAAAryD,GAIA,QAAAk7E,IAAA37E,EAAAS,GAGA,MADA8C,SAAA4E,KAAA,0DACA,GAAA6rD,IAAAh0D,EAAAS,GAIA,QAAAm7E,IAAA33D,GAGA,MADA1gB,SAAA4E,KAAA,sEACA,GAAAk6B,IAAApe,GAIA,QAAA43D,IAAA53D,GAGA,MADA1gB,SAAA4E,KAAA,yEACA,GAAAk6B,IAAApe,GAIA,QAAA63D,IAAA73D,GAGA,MADA1gB,SAAA4E,KAAA,0EACA,GAAAk6B,IAAApe,GAIA,QAAA83D,IAAAxyE,EAAAG,EAAA+I,GAGA,MADAlP,SAAA4E,KAAA,6DACA,GAAA0F,GAAAtE,EAAAG,EAAA+I,GAMA,QAAAupE,IAAAhnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,8GACA,GAAA/C,IAAApQ,EAAA86B,GAAAmsD,YAAA,GAIA,QAAAC,IAAAlnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,sFACA,GAAA6nB,IAAAh7B,EAAA86B,GAIA,QAAAqsD,IAAAnnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,wFACA,GAAA8nB,IAAAj7B,EAAA86B,GAIA,QAAAssD,IAAApnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,sGACA,GAAA+nB,IAAAl7B,EAAA86B,GAIA,QAAAusD,IAAArnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,wFACA,GAAAioB,IAAAp7B,EAAA86B,GAIA,QAAAwsD,IAAAtnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,0FACA,GAAAkoB,IAAAr7B,EAAA86B,GAIA,QAAAysD,IAAAvnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,wFACA,GAAAmoB,IAAAt7B,EAAA86B,GAIA,QAAA0sD,IAAAxnF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,0FACA,GAAAooB,IAAAv7B,EAAA86B,GAIA,QAAA2sD,IAAAznF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,4FACA,GAAAqoB,IAAAx7B,EAAA86B,GAIA,QAAA4sD,IAAA1nF,EAAA86B,GAGA,MADAvsB,SAAA4E,KAAA,4FACA,GAAAsoB,IAAAz7B,EAAA86B,GA8EA,QAAA6sD,IAAAtkD,GAEA90B,QAAA4E,KAAA,qFAEAy/D,GAAA5zE,KAAAC,KAAAokC,GACApkC,KAAApC,KAAA,aACAoC,KAAAmkE,QAAA,EAQA,QAAAwkB,IAAAvkD,GAEA90B,QAAA4E,KAAA,+EAEAy/D,GAAA5zE,KAAAC,KAAAokC,GACApkC,KAAApC,KAAA,aAQA,QAAAgrF,IAAAxkD,GAEA90B,QAAA4E,KAAA,sEAEAy/D,GAAA5zE,KAAAC,KAAAokC,GACApkC,KAAApC,KAAA,aA4BA,QAAAirF,IAAAnjE,GAGA,MADApW,SAAA4E,KAAA,0DACA,GAAAmzE,IAAA3hE,GAIA,QAAAojE,IAAAz9E,EAAAxF,GAGA,MADAyJ,SAAA4E,KAAA,oFACA,GAAAqyE,IAAAl7E,EAAAxF,GAIA,QAAAkjF,IAAA19E,EAAA5E,GAGA,MADA6I,SAAA4E,KAAA,wEACA,GAAA7B,IAAA,GAAAs8D,IAAAtjE,EAAAU,UAAA,GAAA2F,KAAyF7L,MAAA4C,SAAAhC,IAAA,YAgBzF,QAAAuiF,IAAA39E,EAAA5E,GAGA,MADA6I,SAAA4E,KAAA,gFACA,GAAA7B,IAAA,GAAA+tD,IAAA/0D,EAAAU,UAAA,GAAA2F,KAA6F7L,MAAA4C,SAAAhC,IAAA,YAiB7F,QAAAwiF,IAAA7/E,GAGA,MADAkG,SAAA4E,KAAA,yDACA,GAAAvJ,IAAAvB,GAIA,QAAA8/E,IAAA9/E,GAGA,MADAkG,SAAA4E,KAAA,0EACA,GAAAu9D,IAAAroE,GAowCA,QAAA+/E,MAEA75E,QAAAiP,MAAA,0EAEAve,KAAAopF,cAAA,SAAA7qD,EAAAlT,GAEA/b,QAAA4E,KAAA,8DACAqqB,EAAA8qD,QAAAh+D,IAIArrB,KAAAspF,gBAAA,SAAA/qD,EAAAlT,GAEA/b,QAAA4E,KAAA,kEACAqqB,EAAAgrD,UAAAl+D,IAIArrB,KAAAwpF,WAAA,WAEAl6E,QAAAiP,MAAA,qEAQA,QAAAkrE,MAEAn6E,QAAAiP,MAAA,mFAEAve,KAAA2S,WAAAyC,SAAA0U,gBAAA,yCACA9pB,KAAAo3B,MAAA,aACAp3B,KAAAkrB,OAAA,aACAlrB,KAAAuiC,cAAA,aACAviC,KAAA06D,QAAA,aA8BA,QAAAgvB,MAEAp6E,QAAAiP,MAAA,uEAx94CA9V,SAAAH,OAAAqhF,UAEArhF,OAAAqhF,QAAAjlF,KAAAsO,IAAA,QAIAvK,SAAAH,OAAAshF,YAKAthF,OAAAshF,UAAA,SAAA5+E,GAEA,sBAAAA,IAAA6+E,SAAA7+E,IAAAtG,KAAAyB,MAAA6E,SAQAvC,SAAA/D,KAAAwrE,OAIAxrE,KAAAwrE,KAAA,SAAA56D,GAEA,MAAAA,GAAA,KAAAA,EAAA,KAAAA,IAMA,QAAAw0E,UAAA9rF,YAAA,GAKAM,OAAAD,eAAAyrF,SAAA9rF,UAAA,QAEA4f,IAAA,WAEA,MAAA5d,MAAA0G,WAAAZ,MAAA,mCAQA2C,SAAAnK,OAAAyrF,SAKA,WAEAzrF,OAAAyrF,OAAA,SAAApwE,GAEA,GAAAlR,SAAAkR,GAAA,OAAAA,EAEA,SAAAjR,WAAA,6CAMA,QAFAshF,GAAA1rF,OAAAqb,GAEApN,EAAA,EAAwBA,EAAApO,UAAAJ,OAA0BwO,IAAA,CAElD,GAAA09E,GAAA9rF,UAAAoO,EAEA,IAAA9D,SAAAwhF,GAAA,OAAAA,EAEA,OAAAC,KAAAD,GAEA3rF,OAAAN,UAAAmsF,eAAApqF,KAAAkqF,EAAAC,KAEAF,EAAAE,GAAAD,EAAAC,IAUA,MAAAF,OAcA1rF,OAAAyrF,OAAAtsE,EAAAzf,WAEAya,iBAAA,SAAA7a,EAAA++E,GAEAl0E,SAAAzI,KAAAoqF,aAAApqF,KAAAoqF,cAEA,IAAA9nF,GAAAtC,KAAAoqF,UAEA3hF,UAAAnG,EAAA1E,KAEA0E,EAAA1E,OAIA0E,EAAA1E,GAAA4R,QAAAmtE,MAAA,GAEAr6E,EAAA1E,GAAAyD,KAAAs7E,IAMA0N,iBAAA,SAAAzsF,EAAA++E,GAEA,GAAAl0E,SAAAzI,KAAAoqF,WAAA,QAEA,IAAA9nF,GAAAtC,KAAAoqF,UAEA,OAAA3hF,UAAAnG,EAAA1E,IAAA0E,EAAA1E,GAAA4R,QAAAmtE,MAAA,GAIA7jE,oBAAA,SAAAlb,EAAA++E,GAEA,GAAAl0E,SAAAzI,KAAAoqF,WAAA,CAEA,GAAA9nF,GAAAtC,KAAAoqF,WACAE,EAAAhoF,EAAA1E,EAEA,IAAA6K,SAAA6hF,EAAA,CAEA,GAAA/9E,GAAA+9E,EAAA96E,QAAAmtE,EAEApwE,MAAA,GAEA+9E,EAAAh+E,OAAAC,EAAA,MAQAqM,cAAA,SAAAtE,GAEA,GAAA7L,SAAAzI,KAAAoqF,WAAA,CAEA,GAAA9nF,GAAAtC,KAAAoqF,WACAE,EAAAhoF,EAAAgS,EAAA1W,KAEA,IAAA6K,SAAA6hF,EAAA,CAEAh2E,EAAAqF,OAAA3Z,IAIA,QAFAe,GAAAupF,EAAAprB,MAAA,GAEA//D,EAAA,EAAAgQ,EAAApO,EAAAhD,OAAsCoB,EAAAgQ,EAAOhQ,IAE7C4B,EAAA5B,GAAAY,KAAAC,KAAAsU,OAUA,IAAA0kD,IAAA,KACAz+C,IAAc5D,KAAA,EAAA6D,OAAA,EAAA5D,MAAA,GACdunC,GAAA,EACAE,GAAA,EACAE,GAAA,EACAgsC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACA30D,GAAA,EACAmT,GAAA,EACAva,GAAA,EACA0G,GAAA,EACAG,GAAA,EACAxjB,GAAA,EACAD,GAAA,EACA+c,GAAA,EACAm3D,GAAA,EACArB,GAAA,EACA3oC,GAAA,EACAxtB,GAAA,EACA4tB,GAAA,EACAO,GAAA,EACAI,GAAA,EACAd,GAAA,EACAhtB,GAAA,IACAi5B,GAAA,IACAE,GAAA,IACAgD,GAAA,IACAC,GAAA,IACA/C,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,IACA15B,GAAA,IACAC,GAAA,IACA05B,GAAA,IACAE,GAAA,IACAE,GAAA,IACAE,GAAA,IACAE,GAAA,IACArQ,GAAA,EACAE,GAAA,EACAE,GAAA,EACA9pB,GAAA,EACAiqB,GAAA,EACAE,GAAA,EACAE,GAAA,EACAE,GAAA,EACAna,GAAA,EACAoK,GAAA,EACAC,GAAA,EACAsB,GAAA,EACAtE,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACA2jD,GAAA,IACA3oE,GAAA,IACAsnB,GAAA,IACAG,GAAA,IACAC,GAAA,IACAC,GAAA,IACAJ,GAAA,IACAC,GAAA,IACAid,GAAA,IACA1mC,GAAA,KACA4mC,GAAA,KACA9kC,GAAA,KACAovB,GAAA,KACAC,GAAA,KACAlxB,GAAA,KACA+mC,GAAA,KACA9mC,GAAA,KACAE,GAAA,KACAqnC,GAAA,KACAC,GAAA,KACA7R,GAAA,KACA8R,GAAA,KACA7R,GAAA,KACAhB,GAAA,KACAC,GAAA,KACAoS,GAAA,KACAE,GAAA,KACAE,GAAA,KACAtR,GAAA,KACA4R,GAAA,KACA7T,GAAA,KACA7zB,GAAA,KACA6nC,GAAA,KACAE,GAAA,KACA2iC,GAAA1qE,GACAy1B,GAAA,KACAG,GAAA,KACAuT,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAK,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAK,GAAA,MACAE,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAy/B,GAAA,KACAvJ,GAAA,KACAwJ,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAvK,GAAA,KACAwK,GAAA,KACAC,GAAA,KACApqD,GAAA,EACA87B,GAAA,EACAE,GAAA,EACAp8C,GAAA,IACAqlB,GAAA,KACAK,GAAA,KACAJ,GAAA,KACAmlD,GAAA,KACAllD,GAAA,KACAC,GAAA,KACAC,GAAA,KACAlW,GAAA,KACA0F,GAAA,KAOAlW,IAEAqvD,QAAArqE,KAAAmO,GAAA,IACAw4E,QAAA,IAAA3mF,KAAAmO,GAEA8M,aAAA,WAMA,OAFA2rE,MAEAnsF,EAAA,EAAmBA,EAAA,IAASA,IAE5BmsF,EAAAnsF,MAAA,aAAAuH,SAAA,IAAA6kF,aAIA,mBAEA,GAAAC,GAAA,WAAA9mF,KAAAC,SAAA,EACA8mF,EAAA,WAAA/mF,KAAAC,SAAA,EACA+mF,EAAA,WAAAhnF,KAAAC,SAAA,EACAgnF,EAAA,WAAAjnF,KAAAC,SAAA,CACA,OAAA2mF,GAAA,IAAAE,GAAAF,EAAAE,GAAA,OAAAF,EAAAE,GAAA,QAAAF,EAAAE,GAAA,YACAF,EAAA,IAAAG,GAAAH,EAAAG,GAAA,WAAAH,EAAAG,GAAA,UAAAH,EAAAG,GAAA,YACAH,EAAA,GAAAI,EAAA,KAAAJ,EAAAI,GAAA,WAAAJ,EAAAI,GAAA,QAAAJ,EAAAI,GAAA,QACAJ,EAAA,IAAAK,GAAAL,EAAAK,GAAA,OAAAL,EAAAK,GAAA,QAAAL,EAAAK,GAAA,YAMApe,MAAA,SAAAviE,EAAA3E,EAAAD,GAEA,MAAA1B,MAAA0B,IAAAC,EAAA3B,KAAA2B,IAAAD,EAAA4E,KAOA4gF,gBAAA,SAAAppE,EAAAjd,GAEA,OAAAid,EAAAjd,QAMAsmF,UAAA,SAAAv2E,EAAAw2E,EAAAnhB,EAAAohB,EAAAlhB,GAEA,MAAAkhB,IAAAz2E,EAAAw2E,IAAAjhB,EAAAkhB,IAAAphB,EAAAmhB,IAMA7pB,KAAA,SAAA3sD,EAAAG,EAAApO,GAEA,SAAAA,GAAAiO,EAAAjO,EAAAoO,GAMAu2E,WAAA,SAAA12E,EAAAjP,EAAAD,GAEA,MAAAkP,IAAAjP,EAAA,EACAiP,GAAAlP,EAAA,GAEAkP,KAAAjP,IAAAD,EAAAC,GAEAiP,KAAA,IAAAA,KAIA22E,aAAA,SAAA32E,EAAAjP,EAAAD,GAEA,MAAAkP,IAAAjP,EAAA,EACAiP,GAAAlP,EAAA,GAEAkP,KAAAjP,IAAAD,EAAAC,GAEAiP,UAAA,EAAAA,EAAA,UAMA42E,QAAA,SAAAC,EAAAC,GAEA,MAAAD,GAAAznF,KAAAyB,MAAAzB,KAAAC,UAAAynF,EAAAD,EAAA,KAMAE,UAAA,SAAAF,EAAAC,GAEA,MAAAD,GAAAznF,KAAAC,UAAAynF,EAAAD,IAMAG,gBAAA,SAAArmF,GAEA,MAAAA,IAAA,GAAAvB,KAAAC,WAIA4nF,SAAA,SAAAC,GAEA,MAAAA,GAAA9sE,GAAAqvD,SAIA0d,SAAA,SAAAC,GAEA,MAAAA,GAAAhtE,GAAA2rE,SAIA96C,aAAA,SAAAvlC,GAEA,YAAAA,IAAA,QAAAA,GAIA2qD,eAAA,SAAA3qD,GAEA,MAAAtG,MAAAsO,IAAA,EAAAtO,KAAAioF,KAAAjoF,KAAA6nC,IAAAvhC,GAAAtG,KAAAwwD,OAIArkB,gBAAA,SAAA7lC,GAEA,MAAAtG,MAAAsO,IAAA,EAAAtO,KAAAyB,MAAAzB,KAAA6nC,IAAAvhC,GAAAtG,KAAAwwD,OAoBA52D,QAAAof,iBAAAhB,EAAA1e,WAEA+iB,OAEAnD,IAAA,WAEA,MAAA5d,MAAAsV,GAIAd,IAAA,SAAAxJ,GAEAhL,KAAAsV,EAAAtK,IAMAgW,QAEApD,IAAA,WAEA,MAAA5d,MAAAyV,GAIAjB,IAAA,SAAAxJ,GAEAhL,KAAAyV,EAAAzK,MAQA1M,OAAAyrF,OAAArtE,EAAA1e,WAEA4uF,WAAA,EAEAp4E,IAAA,SAAAc,EAAAG,GAKA,MAHAzV,MAAAsV,IACAtV,KAAAyV,IAEAzV,MAIA6sF,UAAA,SAAAC,GAKA,MAHA9sF,MAAAsV,EAAAw3E,EACA9sF,KAAAyV,EAAAq3E,EAEA9sF,MAIA+sF,KAAA,SAAAz3E,GAIA,MAFAtV,MAAAsV,IAEAtV,MAIAgtF,KAAA,SAAAv3E,GAIA,MAFAzV,MAAAyV,IAEAzV,MAIAitF,aAAA,SAAA1gF,EAAAvB,GAEA,OAAAuB,GAEA,OAAAvM,KAAAsV,EAAAtK,CAA2B,MAC3B,QAAAhL,KAAAyV,EAAAzK,CAA2B,MAC3B,kBAAAvL,OAAA,0BAAA8M,GAIA,MAAAvM,OAIAktF,aAAA,SAAA3gF,GAEA,OAAAA,GAEA,aAAAvM,MAAAsV,CACA,cAAAtV,MAAAyV,CACA,kBAAAhW,OAAA,0BAAA8M,KAMAM,MAAA,WAEA,UAAA7M,MAAAmK,YAAAnK,KAAAsV,EAAAtV,KAAAyV,IAIA7D,KAAA,SAAA5K,GAKA,MAHAhH,MAAAsV,EAAAtO,EAAAsO,EACAtV,KAAAyV,EAAAzO,EAAAyO,EAEAzV,MAIAuS,IAAA,SAAAvL,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,yFACAlU,KAAA8lE,WAAA9+D,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EAEAzV,OAIAmtF,UAAA,SAAApmF,GAKA,MAHA/G,MAAAsV,GAAAvO,EACA/G,KAAAyV,GAAA1O,EAEA/G,MAIA8lE,WAAA,SAAAr4D,EAAAjI,GAKA,MAHAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EAEAzV,MAIAotF,gBAAA,SAAApmF,EAAAD,GAKA,MAHA/G,MAAAsV,GAAAtO,EAAAsO,EAAAvO,EACA/G,KAAAyV,GAAAzO,EAAAyO,EAAA1O,EAEA/G,MAIA2b,IAAA,SAAA3U,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,yFACAlU,KAAAkV,WAAAlO,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EAEAzV,OAIAqtF,UAAA,SAAAtmF,GAKA,MAHA/G,MAAAsV,GAAAvO,EACA/G,KAAAyV,GAAA1O,EAEA/G,MAIAkV,WAAA,SAAAzH,EAAAjI,GAKA,MAHAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EAEAzV,MAIAk3B,SAAA,SAAAlwB,GAKA,MAHAhH,MAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EAEAzV,MAIA8c,eAAA,SAAAgwE,GAKA,MAHA9sF,MAAAsV,GAAAw3E,EACA9sF,KAAAyV,GAAAq3E,EAEA9sF,MAIAstF,OAAA,SAAAtmF,GAKA,MAHAhH,MAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EAEAzV,MAIAmjE,aAAA,SAAA2pB,GAEA,MAAA9sF,MAAA8c,eAAA,EAAAgwE,IAIAS,aAAA,SAAAhoF,GAEA,GAAA+P,GAAAtV,KAAAsV,EAAAG,EAAAzV,KAAAyV,EACAnW,EAAAiG,EAAA+Y,QAKA,OAHAte,MAAAsV,EAAAhW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GACAU,KAAAyV,EAAAnW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAEAU,MAIAqG,IAAA,SAAAW,GAKA,MAHAhH,MAAAsV,EAAA5Q,KAAA2B,IAAArG,KAAAsV,EAAAtO,EAAAsO,GACAtV,KAAAyV,EAAA/Q,KAAA2B,IAAArG,KAAAyV,EAAAzO,EAAAyO,GAEAzV,MAIAoG,IAAA,SAAAY,GAKA,MAHAhH,MAAAsV,EAAA5Q,KAAA0B,IAAApG,KAAAsV,EAAAtO,EAAAsO,GACAtV,KAAAyV,EAAA/Q,KAAA0B,IAAApG,KAAAyV,EAAAzO,EAAAyO,GAEAzV,MAIAutE,MAAA,SAAAlnE,EAAAD,GAOA,MAHApG,MAAAsV,EAAA5Q,KAAA0B,IAAAC,EAAAiP,EAAA5Q,KAAA2B,IAAAD,EAAAkP,EAAAtV,KAAAsV,IACAtV,KAAAyV,EAAA/Q,KAAA0B,IAAAC,EAAAoP,EAAA/Q,KAAA2B,IAAAD,EAAAqP,EAAAzV,KAAAyV,IAEAzV,MAIAwtF,YAAA,WAEA,GAAAnnF,GAAA,GAAAqW,GACAtW,EAAA,GAAAsW,EAEA,iBAAA+wE,EAAAC,GAKA,MAHArnF,GAAAmO,IAAAi5E,KACArnF,EAAAoO,IAAAk5E,KAEA1tF,KAAAutE,MAAAlnE,EAAAD,OAMAunF,YAAA,SAAAtnF,EAAAD,GAEA,GAAArI,GAAAiC,KAAAjC,QAEA,OAAAiC,MAAAmjE,aAAAplE,GAAA,GAAA+e,eAAApY,KAAA0B,IAAAC,EAAA3B,KAAA2B,IAAAD,EAAArI,MAIAoI,MAAA,WAKA,MAHAnG,MAAAsV,EAAA5Q,KAAAyB,MAAAnG,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAyB,MAAAnG,KAAAyV,GAEAzV,MAIA2sF,KAAA,WAKA,MAHA3sF,MAAAsV,EAAA5Q,KAAAioF,KAAA3sF,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAioF,KAAA3sF,KAAAyV,GAEAzV,MAIAkI,MAAA,WAKA,MAHAlI,MAAAsV,EAAA5Q,KAAAwD,MAAAlI,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAwD,MAAAlI,KAAAyV,GAEAzV,MAIA4tF,YAAA,WAKA,MAHA5tF,MAAAsV,EAAAtV,KAAAsV,EAAA,EAAA5Q,KAAAioF,KAAA3sF,KAAAsV,GAAA5Q,KAAAyB,MAAAnG,KAAAsV,GACAtV,KAAAyV,EAAAzV,KAAAyV,EAAA,EAAA/Q,KAAAioF,KAAA3sF,KAAAyV,GAAA/Q,KAAAyB,MAAAnG,KAAAyV,GAEAzV,MAIA6tF,OAAA,WAKA,MAHA7tF,MAAAsV,GAAAtV,KAAAsV,EACAtV,KAAAyV,GAAAzV,KAAAyV,EAEAzV,MAIAqc,IAAA,SAAArV,GAEA,MAAAhH,MAAAsV,EAAAtO,EAAAsO,EAAAtV,KAAAyV,EAAAzO,EAAAyO,GAIAq4E,SAAA,WAEA,MAAA9tF,MAAAsV,EAAAtV,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAyV,GAIA1X,OAAA,WAEA,MAAA2G,MAAA2S,KAAArX,KAAAsV,EAAAtV,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAyV,IAIAs4E,gBAAA,WAEA,MAAArpF,MAAA2+B,IAAArjC,KAAAsV,GAAA5Q,KAAA2+B,IAAArjC,KAAAyV,IAIAy4C,UAAA,WAEA,MAAAluD,MAAAmjE,aAAAnjE,KAAAjC,UAAA,IAIAoV,MAAA,WAIA,GAAAA,GAAAzO,KAAA4+D,MAAAtjE,KAAAyV,EAAAzV,KAAAsV,EAIA,OAFAnC,GAAA,IAAAA,GAAA,EAAAzO,KAAAmO,IAEAM,GAIA66E,WAAA,SAAAhnF,GAEA,MAAAtC,MAAA2S,KAAArX,KAAAmc,kBAAAnV,KAIAmV,kBAAA,SAAAnV,GAEA,GAAAkQ,GAAAlX,KAAAsV,EAAAtO,EAAAsO,EAAA6B,EAAAnX,KAAAyV,EAAAzO,EAAAyO,CACA,OAAAyB,KAAAC,KAIA82E,oBAAA,SAAAjnF,GAEA,MAAAtC,MAAA2+B,IAAArjC,KAAAsV,EAAAtO,EAAAsO,GAAA5Q,KAAA2+B,IAAArjC,KAAAyV,EAAAzO,EAAAyO,IAIA2xE,UAAA,SAAArpF,GAEA,MAAAiC,MAAAkuD,YAAApxC,eAAA/e,IAIAkkE,KAAA,SAAAj7D,EAAAvC,GAKA,MAHAzE,MAAAsV,IAAAtO,EAAAsO,EAAAtV,KAAAsV,GAAA7Q,EACAzE,KAAAyV,IAAAzO,EAAAyO,EAAAzV,KAAAyV,GAAAhR,EAEAzE,MAIAkuF,YAAA,SAAA9oF,EAAAE,EAAAb,GAEA,MAAAzE,MAAAkV,WAAA5P,EAAAF,GAAA0X,eAAArY,GAAA8N,IAAAnN,IAIAkzC,OAAA,SAAAtxC,GAEA,MAAAA,GAAAsO,IAAAtV,KAAAsV,GAAAtO,EAAAyO,IAAAzV,KAAAyV,GAIAiuC,UAAA,SAAA3iD,EAAAma,GAOA,MALAzS,UAAAyS,MAAA,GAEAlb,KAAAsV,EAAAvU,EAAAma,GACAlb,KAAAyV,EAAA1U,EAAAma,EAAA,GAEAlb,MAIA0iB,QAAA,SAAA3hB,EAAAma,GAQA,MANAzS,UAAA1H,UACA0H,SAAAyS,MAAA,GAEAna,EAAAma,GAAAlb,KAAAsV,EACAvU,EAAAma,EAAA,GAAAlb,KAAAyV,EAEA1U,GAIAggE,oBAAA,SAAAtpC,EAAAlrB,EAAA2O,GAWA,MATAzS,UAAAyS,GAEA5L,QAAA4E,KAAA,uEAIAlU,KAAAsV,EAAAmiB,EAAAqpC,KAAAv0D,GACAvM,KAAAyV,EAAAgiB,EAAA02D,KAAA5hF,GAEAvM,MAIAouF,aAAA,SAAAzwE,EAAAxK,GAEA,GAAA3M,GAAA9B,KAAA2oD,IAAAl6C,GAAApM,EAAArC,KAAAsgE,IAAA7xD,GAEAmC,EAAAtV,KAAAsV,EAAAqI,EAAArI,EACAG,EAAAzV,KAAAyV,EAAAkI,EAAAlI,CAKA,OAHAzV,MAAAsV,IAAA9O,EAAAiP,EAAA1O,EAAA4W,EAAArI,EACAtV,KAAAyV,EAAAH,EAAAvO,EAAA0O,EAAAjP,EAAAmX,EAAAlI,EAEAzV,QAsCA1B,OAAAyrF,OAAA1rE,EAAArgB,WAEAqwF,WAAA,EAEA75E,IAAA,SAAA85E,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,GAAAC,GAAAtvF,KAAAse,QAOA,OALAgxE,GAAA,GAAAhB,EAAiBgB,EAAA,GAAAf,EAAee,EAAA,GAAAd,EAAec,EAAA,IAAAb,EAC/Ca,EAAA,GAAAZ,EAAiBY,EAAA,GAAAX,EAAeW,EAAA,GAAAV,EAAeU,EAAA,IAAAT,EAC/CS,EAAA,GAAAR,EAAiBQ,EAAA,GAAAP,EAAeO,EAAA,IAAAN,EAAgBM,EAAA,IAAAL,EAChDK,EAAA,GAAAJ,EAAiBI,EAAA,GAAAH,EAAeG,EAAA,IAAAF,EAAgBE,EAAA,IAAAD,EAEhDrvF,MAIA2tD,SAAA,WAWA,MATA3tD,MAAAwU,IAEA,QACA,QACA,QACA,SAIAxU,MAIA6M,MAAA,WAEA,UAAAwR,IAAAqlC,UAAA1jD,KAAAse,WAIA1M,KAAA,SAAArM,GAEA,GAAA+pF,GAAAtvF,KAAAse,SACAixE,EAAAhqF,EAAA+Y,QAOA,OALAgxE,GAAA,GAAAC,EAAA,GAAqBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GAC3DD,EAAA,GAAAC,EAAA,GAAqBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GAC3DD,EAAA,GAAAC,EAAA,GAAqBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,IAAAC,EAAA,IAAqBD,EAAA,IAAAC,EAAA,IAC7DD,EAAA,IAAAC,EAAA,IAAuBD,EAAA,IAAAC,EAAA,IAAqBD,EAAA,IAAAC,EAAA,IAAqBD,EAAA,IAAAC,EAAA,IAEjEvvF,MAIAiiC,aAAA,SAAA18B,GAEA,GAAA+pF,GAAAtvF,KAAAse,SAAAixE,EAAAhqF,EAAA+Y,QAMA,OAJAgxE,GAAA,IAAAC,EAAA,IACAD,EAAA,IAAAC,EAAA,IACAD,EAAA,IAAAC,EAAA,IAEAvvF,MAIAwvF,aAAA,SAAAC,EAAAC,EAAAC,GAMA,MAJAF,GAAA5yE,oBAAA7c,KAAA,GACA0vF,EAAA7yE,oBAAA7c,KAAA,GACA2vF,EAAA9yE,oBAAA7c,KAAA,GAEAA,MAIA4vF,UAAA,SAAAH,EAAAC,EAAAC,GASA,MAPA3vF,MAAAwU,IACAi7E,EAAAn6E,EAAAo6E,EAAAp6E,EAAAq6E,EAAAr6E,EAAA,EACAm6E,EAAAh6E,EAAAi6E,EAAAj6E,EAAAk6E,EAAAl6E,EAAA,EACAg6E,EAAAjxE,EAAAkxE,EAAAlxE,EAAAmxE,EAAAnxE,EAAA,EACA,SAGAxe,MAIA8tD,gBAAA,WAEA,GAAA1oD,GAAA,GAAAwU,EAEA,iBAAArU,GAEA,GAAA+pF,GAAAtvF,KAAAse,SACAixE,EAAAhqF,EAAA+Y,SAEAuxE,EAAA,EAAAzqF,EAAAyX,oBAAAtX,EAAA,GAAAxH,SACA+xF,EAAA,EAAA1qF,EAAAyX,oBAAAtX,EAAA,GAAAxH,SACAgyF,EAAA,EAAA3qF,EAAAyX,oBAAAtX,EAAA,GAAAxH,QAcA,OAZAuxF,GAAA,GAAAC,EAAA,GAAAM,EACAP,EAAA,GAAAC,EAAA,GAAAM,EACAP,EAAA,GAAAC,EAAA,GAAAM,EAEAP,EAAA,GAAAC,EAAA,GAAAO,EACAR,EAAA,GAAAC,EAAA,GAAAO,EACAR,EAAA,GAAAC,EAAA,GAAAO,EAEAR,EAAA,GAAAC,EAAA,GAAAQ,EACAT,EAAA,GAAAC,EAAA,GAAAQ,EACAT,EAAA,IAAAC,EAAA,IAAAQ,EAEA/vF,SAMAgwF,sBAAA,SAAAC,GAEAA,KAAAC,SAEA5gF,QAAAiP,MAAA,wGAIA,IAAA+wE,GAAAtvF,KAAAse,SAEAhJ,EAAA26E,EAAA36E,EAAAG,EAAAw6E,EAAAx6E,EAAA+I,EAAAyxE,EAAAzxE,EACA/Q,EAAA/I,KAAA2oD,IAAA/3C,GAAA9P,EAAAd,KAAAsgE,IAAA1vD,GACA9O,EAAA9B,KAAA2oD,IAAA53C,GAAAxH,EAAAvJ,KAAAsgE,IAAAvvD,GACAnW,EAAAoF,KAAA2oD,IAAA7uC,GAAAtX,EAAAxC,KAAAsgE,IAAAxmD,EAEA,YAAAyxE,EAAA72D,MAAA,CAEA,GAAA+2D,GAAA1iF,EAAAnO,EAAA8wF,EAAA3iF,EAAAvG,EAAAmpF,EAAA7qF,EAAAlG,EAAAgxF,EAAA9qF,EAAA0B,CAEAooF,GAAA,GAAA9oF,EAAAlH,EACAgwF,EAAA,IAAA9oF,EAAAU,EACAooF,EAAA,GAAArhF,EAEAqhF,EAAA,GAAAc,EAAAC,EAAApiF,EACAqhF,EAAA,GAAAa,EAAAG,EAAAriF,EACAqhF,EAAA,IAAA9pF,EAAAgB,EAEA8oF,EAAA,GAAAgB,EAAAH,EAAAliF,EACAqhF,EAAA,GAAAe,EAAAD,EAAAniF,EACAqhF,EAAA,IAAA7hF,EAAAjH,MAEI,YAAAypF,EAAA72D,MAAA,CAEJ,GAAAm3D,GAAA/pF,EAAAlH,EAAAkxF,EAAAhqF,EAAAU,EAAAupF,EAAAxiF,EAAA3O,EAAAoxF,EAAAziF,EAAA/G,CAEAooF,GAAA,GAAAiB,EAAAG,EAAAlrF,EACA8pF,EAAA,GAAAmB,EAAAjrF,EAAAgrF,EACAlB,EAAA,GAAA7hF,EAAAQ,EAEAqhF,EAAA,GAAA7hF,EAAAvG,EACAooF,EAAA,GAAA7hF,EAAAnO,EACAgwF,EAAA,IAAA9pF,EAEA8pF,EAAA,GAAAkB,EAAAhrF,EAAAirF,EACAnB,EAAA,GAAAoB,EAAAH,EAAA/qF,EACA8pF,EAAA,IAAA7hF,EAAAjH,MAEI,YAAAypF,EAAA72D,MAAA,CAEJ,GAAAm3D,GAAA/pF,EAAAlH,EAAAkxF,EAAAhqF,EAAAU,EAAAupF,EAAAxiF,EAAA3O,EAAAoxF,EAAAziF,EAAA/G,CAEAooF,GAAA,GAAAiB,EAAAG,EAAAlrF,EACA8pF,EAAA,IAAA7hF,EAAAvG,EACAooF,EAAA,GAAAmB,EAAAD,EAAAhrF,EAEA8pF,EAAA,GAAAkB,EAAAC,EAAAjrF,EACA8pF,EAAA,GAAA7hF,EAAAnO,EACAgwF,EAAA,GAAAoB,EAAAH,EAAA/qF,EAEA8pF,EAAA,IAAA7hF,EAAAQ,EACAqhF,EAAA,GAAA9pF,EACA8pF,EAAA,IAAA7hF,EAAAjH,MAEI,YAAAypF,EAAA72D,MAAA,CAEJ,GAAA+2D,GAAA1iF,EAAAnO,EAAA8wF,EAAA3iF,EAAAvG,EAAAmpF,EAAA7qF,EAAAlG,EAAAgxF,EAAA9qF,EAAA0B,CAEAooF,GAAA,GAAA9oF,EAAAlH,EACAgwF,EAAA,GAAAe,EAAApiF,EAAAmiF,EACAd,EAAA,GAAAa,EAAAliF,EAAAqiF,EAEAhB,EAAA,GAAA9oF,EAAAU,EACAooF,EAAA,GAAAgB,EAAAriF,EAAAkiF,EACAb,EAAA,GAAAc,EAAAniF,EAAAoiF,EAEAf,EAAA,IAAArhF,EACAqhF,EAAA,GAAA9pF,EAAAgB,EACA8oF,EAAA,IAAA7hF,EAAAjH,MAEI,YAAAypF,EAAA72D,MAAA,CAEJ,GAAAu3D,GAAAljF,EAAAjH,EAAAoqF,EAAAnjF,EAAAQ,EAAA4iF,EAAArrF,EAAAgB,EAAAsqF,EAAAtrF,EAAAyI,CAEAqhF,GAAA,GAAA9oF,EAAAlH,EACAgwF,EAAA,GAAAwB,EAAAH,EAAAzpF,EACAooF,EAAA,GAAAuB,EAAA3pF,EAAA0pF,EAEAtB,EAAA,GAAApoF,EACAooF,EAAA,GAAA7hF,EAAAnO,EACAgwF,EAAA,IAAA9pF,EAAAlG,EAEAgwF,EAAA,IAAArhF,EAAA3O,EACAgwF,EAAA,GAAAsB,EAAA1pF,EAAA2pF,EACAvB,EAAA,IAAAqB,EAAAG,EAAA5pF,MAEI,YAAA+oF,EAAA72D,MAAA,CAEJ,GAAAu3D,GAAAljF,EAAAjH,EAAAoqF,EAAAnjF,EAAAQ,EAAA4iF,EAAArrF,EAAAgB,EAAAsqF,EAAAtrF,EAAAyI,CAEAqhF,GAAA,GAAA9oF,EAAAlH,EACAgwF,EAAA,IAAApoF,EACAooF,EAAA,GAAArhF,EAAA3O,EAEAgwF,EAAA,GAAAqB,EAAAzpF,EAAA4pF,EACAxB,EAAA,GAAA7hF,EAAAnO,EACAgwF,EAAA,GAAAsB,EAAA1pF,EAAA2pF,EAEAvB,EAAA,GAAAuB,EAAA3pF,EAAA0pF,EACAtB,EAAA,GAAA9pF,EAAAlG,EACAgwF,EAAA,IAAAwB,EAAA5pF,EAAAypF,EAeA,MAVArB,GAAA,KACAA,EAAA,KACAA,EAAA,MAGAA,EAAA,MACAA,EAAA,MACAA,EAAA,MACAA,EAAA,MAEAtvF,MAIA+wF,2BAAA,SAAA3pF,GAEA,GAAAkoF,GAAAtvF,KAAAse,SAEAhJ,EAAAlO,EAAAsX,GAAAjJ,EAAArO,EAAAuX,GAAAH,EAAApX,EAAAwX,GAAAH,EAAArX,EAAAyX,GACAikD,EAAAxtD,IAAA07E,EAAAv7E,IAAAw7E,EAAAzyE,IACA0yE,EAAA57E,EAAAwtD,EAAAquB,EAAA77E,EAAA07E,EAAAI,EAAA97E,EAAA27E,EACAI,EAAA57E,EAAAu7E,EAAAM,EAAA77E,EAAAw7E,EAAAM,EAAA/yE,EAAAyyE,EACAO,EAAA/yE,EAAAqkD,EAAA2uB,EAAAhzE,EAAAuyE,EAAAU,EAAAjzE,EAAAwyE,CAyBA,OAvBA3B,GAAA,MAAA+B,EAAAE,GACAjC,EAAA,GAAA6B,EAAAO,EACApC,EAAA,GAAA8B,EAAAK,EAEAnC,EAAA,GAAA6B,EAAAO,EACApC,EAAA,MAAA4B,EAAAK,GACAjC,EAAA,GAAAgC,EAAAE,EAEAlC,EAAA,GAAA8B,EAAAK,EACAnC,EAAA,GAAAgC,EAAAE,EACAlC,EAAA,OAAA4B,EAAAG,GAGA/B,EAAA,KACAA,EAAA,KACAA,EAAA,MAGAA,EAAA,MACAA,EAAA,MACAA,EAAA,MACAA,EAAA,MAEAtvF,MAIAkc,OAAA,WAEA,GAAA5G,GAAA,GAAAsE,GACAnE,EAAA,GAAAmE,GACA4E,EAAA,GAAA5E,EAEA,iBAAA+3E,EAAAh4E,EAAA2B,GAEA,GAAAg0E,GAAAtvF,KAAAse,QAyCA,OAvCAE,GAAAtJ,WAAAy8E,EAAAh4E,GAEA,IAAA6E,EAAAsvE,aAIAtvE,IAAA,GAIAA,EAAA0vC,YACA54C,EAAAksD,aAAAlmD,EAAAkD,GAEA,IAAAlJ,EAAAw4E,aAIA,IAAAppF,KAAA2+B,IAAA/nB,EAAAkD,GAEAA,EAAAlJ,GAAA,KAIAkJ,KAAA,KAIAA,EAAA0vC,YACA54C,EAAAksD,aAAAlmD,EAAAkD,IAIAlJ,EAAA44C,YACAz4C,EAAA+rD,aAAAhjD,EAAAlJ,GAEAg6E,EAAA,GAAAh6E,IAAkBg6E,EAAA,GAAA75E,EAAAH,EAAeg6E,EAAA,GAAA9wE,EAAAlJ,EACjCg6E,EAAA,GAAAh6E,EAAAG,EAAkB65E,EAAA,GAAA75E,IAAe65E,EAAA,GAAA9wE,EAAA/I,EACjC65E,EAAA,GAAAh6E,EAAAkJ,EAAkB8wE,EAAA,GAAA75E,EAAA+I,EAAe8wE,EAAA,IAAA9wE,IAEjCxe,SAMAk3B,SAAA,SAAA3xB,EAAAid,GAEA,MAAA/Z,UAAA+Z,GAEAlT,QAAA4E,KAAA,oGACAlU,KAAA2sB,iBAAApnB,EAAAid,IAIAxiB,KAAA2sB,iBAAA3sB,KAAAuF,IAIAsoD,YAAA,SAAAtoD,GAEA,MAAAvF,MAAA2sB,iBAAApnB,EAAAvF,OAIA2sB,iBAAA,SAAAlf,EAAAjI,GAEA,GAAA2qF,GAAA1iF,EAAA6Q,SACA+xE,EAAA7qF,EAAA8Y,SACAgxE,EAAAtvF,KAAAse,SAEAszE,EAAAzB,EAAA,GAAA0B,EAAA1B,EAAA,GAAA2B,EAAA3B,EAAA,GAAA4B,EAAA5B,EAAA,IACA6B,EAAA7B,EAAA,GAAA8B,EAAA9B,EAAA,GAAA+B,EAAA/B,EAAA,GAAAgC,EAAAhC,EAAA,IACAiC,EAAAjC,EAAA,GAAAkC,EAAAlC,EAAA,GAAAmC,EAAAnC,EAAA,IAAAoC,EAAApC,EAAA,IACAqC,EAAArC,EAAA,GAAAsC,EAAAtC,EAAA,GAAAuC,EAAAvC,EAAA,IAAAwC,EAAAxC,EAAA,IAEAyC,EAAAvC,EAAA,GAAAwC,EAAAxC,EAAA,GAAAyC,EAAAzC,EAAA,GAAA0C,EAAA1C,EAAA,IACA2C,EAAA3C,EAAA,GAAA4C,EAAA5C,EAAA,GAAA6C,EAAA7C,EAAA,GAAA8C,EAAA9C,EAAA,IACA+C,EAAA/C,EAAA,GAAAgD,EAAAhD,EAAA,GAAAiD,EAAAjD,EAAA,IAAAkD,EAAAlD,EAAA,IACAmD,EAAAnD,EAAA,GAAAoD,EAAApD,EAAA,GAAAqD,EAAArD,EAAA,IAAAsD,EAAAtD,EAAA,GAsBA,OApBAf,GAAA,GAAAsC,EAAAgB,EAAAf,EAAAmB,EAAAlB,EAAAsB,EAAArB,EAAAyB,EACAlE,EAAA,GAAAsC,EAAAiB,EAAAhB,EAAAoB,EAAAnB,EAAAuB,EAAAtB,EAAA0B,EACAnE,EAAA,GAAAsC,EAAAkB,EAAAjB,EAAAqB,EAAApB,EAAAwB,EAAAvB,EAAA2B,EACApE,EAAA,IAAAsC,EAAAmB,EAAAlB,EAAAsB,EAAArB,EAAAyB,EAAAxB,EAAA4B,EAEArE,EAAA,GAAA0C,EAAAY,EAAAX,EAAAe,EAAAd,EAAAkB,EAAAjB,EAAAqB,EACAlE,EAAA,GAAA0C,EAAAa,EAAAZ,EAAAgB,EAAAf,EAAAmB,EAAAlB,EAAAsB,EACAnE,EAAA,GAAA0C,EAAAc,EAAAb,EAAAiB,EAAAhB,EAAAoB,EAAAnB,EAAAuB,EACApE,EAAA,IAAA0C,EAAAe,EAAAd,EAAAkB,EAAAjB,EAAAqB,EAAApB,EAAAwB,EAEArE,EAAA,GAAA8C,EAAAQ,EAAAP,EAAAW,EAAAV,EAAAc,EAAAb,EAAAiB;AACAlE,EAAA,GAAA8C,EAAAS,EAAAR,EAAAY,EAAAX,EAAAe,EAAAd,EAAAkB,EACAnE,EAAA,IAAA8C,EAAAU,EAAAT,EAAAa,EAAAZ,EAAAgB,EAAAf,EAAAmB,EACApE,EAAA,IAAA8C,EAAAW,EAAAV,EAAAc,EAAAb,EAAAiB,EAAAhB,EAAAoB,EAEArE,EAAA,GAAAkD,EAAAI,EAAAH,EAAAO,EAAAN,EAAAU,EAAAT,EAAAa,EACAlE,EAAA,GAAAkD,EAAAK,EAAAJ,EAAAQ,EAAAP,EAAAW,EAAAV,EAAAc,EACAnE,EAAA,IAAAkD,EAAAM,EAAAL,EAAAS,EAAAR,EAAAY,EAAAX,EAAAe,EACApE,EAAA,IAAAkD,EAAAO,EAAAN,EAAAU,EAAAT,EAAAa,EAAAZ,EAAAgB,EAEA3zF,MAIA8c,eAAA,SAAA/V,GAEA,GAAAuoF,GAAAtvF,KAAAse,QAOA,OALAgxE,GAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,KAAAvoF,EAC5CuoF,EAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,KAAAvoF,EAC5CuoF,EAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,KAAAvoF,EAAeuoF,EAAA,KAAAvoF,EAC7CuoF,EAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,KAAAvoF,EAAeuoF,EAAA,KAAAvoF,EAE7C/G,MAIA4zF,uBAAA,WAEA,GAAAxuF,GAAA,GAAAwU,EAEA,iBAAA6d,GAEA,OAAAt4B,GAAA,EAAAgQ,EAAAsoB,EAAA7uB,MAAyCzJ,EAAAgQ,EAAOhQ,IAEhDiG,EAAAkQ,EAAAmiB,EAAAqpC,KAAA3hE,GACAiG,EAAAqQ,EAAAgiB,EAAA02D,KAAAhvF,GACAiG,EAAAoZ,EAAAiZ,EAAAo8D,KAAA10F,GAEAiG,EAAA0+C,aAAA9jD,MAEAy3B,EAAAq8D,OAAA30F,EAAAiG,EAAAkQ,EAAAlQ,EAAAqQ,EAAArQ,EAAAoZ,EAIA,OAAAiZ,OAMAy7B,YAAA,WAEA,GAAAo8B,GAAAtvF,KAAAse,SAEAgwE,EAAAgB,EAAA,GAAAf,EAAAe,EAAA,GAAAd,EAAAc,EAAA,GAAAb,EAAAa,EAAA,IACAZ,EAAAY,EAAA,GAAAX,EAAAW,EAAA,GAAAV,EAAAU,EAAA,GAAAT,EAAAS,EAAA,IACAR,EAAAQ,EAAA,GAAAP,EAAAO,EAAA,GAAAN,EAAAM,EAAA,IAAAL,EAAAK,EAAA,IACAJ,EAAAI,EAAA,GAAAH,EAAAG,EAAA,GAAAF,EAAAE,EAAA,IAAAD,EAAAC,EAAA,GAKA,OACAJ,KACAT,EAAAG,EAAAG,EACAP,EAAAK,EAAAE,EACAN,EAAAE,EAAAK,EACAT,EAAAM,EAAAG,EACAR,EAAAG,EAAAM,EACAV,EAAAK,EAAAK,GAEAE,IACAb,EAAAM,EAAAK,EACAX,EAAAO,EAAAG,EACAP,EAAAC,EAAAM,EACAR,EAAAE,EAAAO,EACAT,EAAAK,EAAAC,EACAL,EAAAG,EAAAE,GAEAM,IACAd,EAAAO,EAAAE,EACAT,EAAAK,EAAAM,EACAR,EAAAC,EAAAK,EACAR,EAAAG,EAAAO,EACAR,EAAAE,EAAAG,EACAP,EAAAM,EAAAC,GAEAO,IACAb,EAAAG,EAAAG,EACAR,EAAAM,EAAAG,EACAT,EAAAK,EAAAK,EACAR,EAAAE,EAAAK,EACAR,EAAAG,EAAAM,EACAT,EAAAK,EAAAE,IAOAiF,UAAA,WAEA,GACAC,GADA1E,EAAAtvF,KAAAse,QAWA,OARA01E,GAAA1E,EAAA,GAAiBA,EAAA,GAAAA,EAAA,GAAmBA,EAAA,GAAA0E,EACpCA,EAAA1E,EAAA,GAAiBA,EAAA,GAAAA,EAAA,GAAmBA,EAAA,GAAA0E,EACpCA,EAAA1E,EAAA,GAAiBA,EAAA,GAAAA,EAAA,GAAmBA,EAAA,GAAA0E,EAEpCA,EAAA1E,EAAA,GAAiBA,EAAA,GAAAA,EAAA,IAAoBA,EAAA,IAAA0E,EACrCA,EAAA1E,EAAA,GAAiBA,EAAA,GAAAA,EAAA,IAAoBA,EAAA,IAAA0E,EACrCA,EAAA1E,EAAA,IAAkBA,EAAA,IAAAA,EAAA,IAAqBA,EAAA,IAAA0E,EAEvCh0F,MAIAi0F,YAAA,SAAAjtF,GAEA,GAAAsoF,GAAAtvF,KAAAse,QAMA,OAJAgxE,GAAA,IAAAtoF,EAAAsO,EACAg6E,EAAA,IAAAtoF,EAAAyO,EACA65E,EAAA,IAAAtoF,EAAAwX,EAEAxe,MAIAikD,WAAA,SAAA1+C,EAAA2uF,GAGA,GAAA5E,GAAAtvF,KAAAse,SACAixE,EAAAhqF,EAAA+Y,SAEAgwE,EAAAiB,EAAA,GAAAb,EAAAa,EAAA,GAAAT,EAAAS,EAAA,GAAAL,EAAAK,EAAA,GACAhB,EAAAgB,EAAA,GAAAZ,EAAAY,EAAA,GAAAR,EAAAQ,EAAA,GAAAJ,EAAAI,EAAA,GACAf,EAAAe,EAAA,GAAAX,EAAAW,EAAA,GAAAP,EAAAO,EAAA,IAAAH,EAAAG,EAAA,IACAd,EAAAc,EAAA,IAAAV,EAAAU,EAAA,IAAAN,EAAAM,EAAA,IAAAF,EAAAE,EAAA,IAEA4E,EAAAvF,EAAAK,EAAAE,EAAAN,EAAAG,EAAAG,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,EACA+E,EAAA3F,EAAAO,EAAAG,EAAAX,EAAAS,EAAAE,EAAAV,EAAAM,EAAAK,EAAAb,EAAAU,EAAAG,EAAAZ,EAAAO,EAAAM,EAAAd,EAAAS,EAAAK,EACAgF,EAAA7F,EAAAK,EAAAM,EAAAV,EAAAG,EAAAO,EAAAV,EAAAE,EAAAS,EAAAb,EAAAM,EAAAO,EAAAZ,EAAAG,EAAAU,EAAAd,EAAAK,EAAAS,EACAiF,EAAA7F,EAAAG,EAAAG,EAAAP,EAAAK,EAAAE,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,EAEAsF,EAAAjG,EAAA6F,EAAAzF,EAAA0F,EAAAtF,EAAAuF,EAAAnF,EAAAoF,CAEA,QAAAC,EAAA,CAEA,GAAAC,GAAA,oEAEA,IAAAN,KAAA,EAEA,SAAAz0F,OAAA+0F,EAQA,OAJAllF,SAAA4E,KAAAsgF,GAIAx0F,KAAA2tD,WAIA,GAAA8mC,GAAA,EAAAF,CAsBA,OApBAjF,GAAA,GAAA6E,EAAAM,EACAnF,EAAA,IAAAT,EAAAG,EAAAE,EAAAN,EAAAK,EAAAC,EAAAL,EAAAC,EAAAM,EAAAV,EAAAO,EAAAG,EAAAR,EAAAE,EAAAO,EAAAX,EAAAM,EAAAK,GAAAoF,EACAnF,EAAA,IAAAX,EAAAM,EAAAC,EAAAL,EAAAE,EAAAG,EAAAL,EAAAC,EAAAK,EAAAT,EAAAO,EAAAE,EAAAR,EAAAG,EAAAO,EAAAX,EAAAK,EAAAM,GAAAoF,EACAnF,EAAA,IAAAV,EAAAG,EAAAG,EAAAP,EAAAK,EAAAE,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,GAAAqF,EAEAnF,EAAA,GAAA8E,EAAAK,EACAnF,EAAA,IAAAd,EAAAS,EAAAC,EAAAT,EAAAO,EAAAE,EAAAT,EAAAK,EAAAM,EAAAd,EAAAW,EAAAG,EAAAZ,EAAAM,EAAAO,EAAAf,EAAAU,EAAAK,GAAAoF,EACAnF,EAAA,IAAAb,EAAAM,EAAAG,EAAAX,EAAAU,EAAAC,EAAAT,EAAAK,EAAAK,EAAAb,EAAAW,EAAAE,EAAAZ,EAAAO,EAAAO,EAAAf,EAAAS,EAAAM,GAAAoF,EACAnF,EAAA,IAAAf,EAAAS,EAAAE,EAAAV,EAAAO,EAAAG,EAAAV,EAAAM,EAAAK,EAAAb,EAAAU,EAAAG,EAAAZ,EAAAO,EAAAM,EAAAd,EAAAS,EAAAK,GAAAqF,EAEAnF,EAAA,GAAA+E,EAAAI,EACAnF,EAAA,IAAAb,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,EAAAT,EAAAC,EAAAU,EAAAd,EAAAO,EAAAO,EAAAZ,EAAAE,EAAAW,EAAAf,EAAAM,EAAAS,GAAAoF,EACAnF,EAAA,KAAAf,EAAAM,EAAAK,EAAAT,EAAAE,EAAAO,EAAAT,EAAAC,EAAAS,EAAAb,EAAAO,EAAAM,EAAAZ,EAAAG,EAAAW,EAAAf,EAAAK,EAAAU,GAAAoF,EACAnF,EAAA,KAAAd,EAAAG,EAAAO,EAAAX,EAAAK,EAAAM,EAAAV,EAAAE,EAAAS,EAAAb,EAAAM,EAAAO,EAAAZ,EAAAG,EAAAU,EAAAd,EAAAK,EAAAS,GAAAqF,EAEAnF,EAAA,IAAAgF,EAAAG,EACAnF,EAAA,KAAAd,EAAAK,EAAAC,EAAAL,EAAAG,EAAAE,EAAAL,EAAAC,EAAAM,EAAAV,EAAAO,EAAAG,EAAAR,EAAAE,EAAAO,EAAAX,EAAAM,EAAAK,GAAAwF,EACAnF,EAAA,KAAAb,EAAAE,EAAAG,EAAAP,EAAAM,EAAAC,EAAAL,EAAAC,EAAAK,EAAAT,EAAAO,EAAAE,EAAAR,EAAAG,EAAAO,EAAAX,EAAAK,EAAAM,GAAAwF,EACAnF,EAAA,KAAAf,EAAAK,EAAAE,EAAAN,EAAAG,EAAAG,EAAAN,EAAAE,EAAAK,EAAAT,EAAAM,EAAAG,EAAAR,EAAAG,EAAAM,EAAAV,EAAAK,EAAAK,GAAAyF,EAEAz0F,MAIA2T,MAAA,SAAA3M,GAEA,GAAAsoF,GAAAtvF,KAAAse,SACAhJ,EAAAtO,EAAAsO,EAAAG,EAAAzO,EAAAyO,EAAA+I,EAAAxX,EAAAwX,CAOA,OALA8wE,GAAA,IAAAh6E,EAAgBg6E,EAAA,IAAA75E,EAAc65E,EAAA,IAAA9wE,EAC9B8wE,EAAA,IAAAh6E,EAAgBg6E,EAAA,IAAA75E,EAAc65E,EAAA,IAAA9wE,EAC9B8wE,EAAA,IAAAh6E,EAAgBg6E,EAAA,IAAA75E,EAAc65E,EAAA,KAAA9wE,EAC9B8wE,EAAA,IAAAh6E,EAAgBg6E,EAAA,IAAA75E,EAAc65E,EAAA,KAAA9wE,EAE9Bxe,MAIA00F,kBAAA,WAEA,GAAApF,GAAAtvF,KAAAse,SAEAq2E,EAAArF,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAsF,EAAAtF,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAuF,EAAAvF,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,GAEA,OAAA5qF,MAAA2S,KAAA3S,KAAA0B,IAAAuuF,EAAAC,EAAAC,KAIA79D,gBAAA,SAAA1hB,EAAAG,EAAA+I,GAWA,MATAxe,MAAAwU,IAEA,MAAAc,EACA,MAAAG,EACA,MAAA+I,EACA,SAIAxe,MAIA80F,cAAA,SAAAzhF,GAEA,GAAA7M,GAAA9B,KAAA2oD,IAAAh6C,GAAAtM,EAAArC,KAAAsgE,IAAA3xD,EAWA,OATArT,MAAAwU,IAEA,QACA,EAAAhO,GAAAO,EAAA,EACA,EAAAA,EAAAP,EAAA,EACA,SAIAxG,MAIA+0F,cAAA,SAAA1hF,GAEA,GAAA7M,GAAA9B,KAAA2oD,IAAAh6C,GAAAtM,EAAArC,KAAAsgE,IAAA3xD,EAWA,OATArT,MAAAwU,IAEAhO,EAAA,EAAAO,EAAA,EACA,SACAA,EAAA,EAAAP,EAAA,EACA,SAIAxG,MAIAg1F,cAAA,SAAA3hF,GAEA,GAAA7M,GAAA9B,KAAA2oD,IAAAh6C,GAAAtM,EAAArC,KAAAsgE,IAAA3xD,EAWA,OATArT,MAAAwU,IAEAhO,GAAAO,EAAA,IACAA,EAAAP,EAAA,IACA,QACA,SAIAxG,MAIAi1F,iBAAA,SAAAC,EAAA/hF,GAIA,GAAA3M,GAAA9B,KAAA2oD,IAAAl6C,GACApM,EAAArC,KAAAsgE,IAAA7xD,GACA9L,EAAA,EAAAb,EACA8O,EAAA4/E,EAAA5/E,EAAAG,EAAAy/E,EAAAz/E,EAAA+I,EAAA02E,EAAA12E,EACA22E,EAAA9tF,EAAAiO,EAAA8/E,EAAA/tF,EAAAoO,CAWA,OATAzV,MAAAwU,IAEA2gF,EAAA7/E,EAAA9O,EAAA2uF,EAAA1/E,EAAA1O,EAAAyX,EAAA22E,EAAA32E,EAAAzX,EAAA0O,EAAA,EACA0/E,EAAA1/E,EAAA1O,EAAAyX,EAAA42E,EAAA3/E,EAAAjP,EAAA4uF,EAAA52E,EAAAzX,EAAAuO,EAAA,EACA6/E,EAAA32E,EAAAzX,EAAA0O,EAAA2/E,EAAA52E,EAAAzX,EAAAuO,EAAAjO,EAAAmX,IAAAhY,EAAA,EACA,SAIAxG,MAIAq1F,UAAA,SAAA//E,EAAAG,EAAA+I,GAWA,MATAxe,MAAAwU,IAEAc,EAAA,MACA,EAAAG,EAAA,IACA,IAAA+I,EAAA,EACA,SAIAxe,MAIAs1F,UAAA,SAAAhgF,EAAAG,EAAA+I,GAWA,MATAxe,MAAAwU,IAEA,EAAAiB,EAAA+I,EAAA,EACAlJ,EAAA,EAAAkJ,EAAA,EACAlJ,EAAAG,EAAA,IACA,SAIAzV,MAIAu1F,QAAA,SAAA56E,EAAA2B,EAAA3I,GAMA,MAJA3T,MAAA+wF,2BAAAz0E,GACAtc,KAAA2T,SACA3T,KAAAi0F,YAAAt5E,GAEA3a,MAIAitB,UAAA,WAEA,GAAAsR,GAAA,GAAA3kB,GACAwD,EAAA,GAAAiB,EAEA,iBAAA1D,EAAA2B,EAAA3I,GAEA,GAAA27E,GAAAtvF,KAAAse,SAEAk3E,EAAAj3D,EAAA/pB,IAAA86E,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAvxF,SACA03F,EAAAl3D,EAAA/pB,IAAA86E,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAAvxF,SACA23F,EAAAn3D,EAAA/pB,IAAA86E,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAAAvxF,SAGAw2F,EAAAv0F,KAAAkzD,aACAqhC,GAAA,IAAAiB,MAEA76E,EAAArF,EAAAg6E,EAAA,IACA30E,EAAAlF,EAAA65E,EAAA,IACA30E,EAAA6D,EAAA8wE,EAAA,IAGAlyE,EAAAxL,KAAA5R,KAEA,IAAA21F,GAAA,EAAAH,EACAI,EAAA,EAAAH,EACAI,EAAA,EAAAH,CAoBA,OAlBAt4E,GAAAkB,SAAA,IAAAq3E,EACAv4E,EAAAkB,SAAA,IAAAq3E,EACAv4E,EAAAkB,SAAA,IAAAq3E,EAEAv4E,EAAAkB,SAAA,IAAAs3E,EACAx4E,EAAAkB,SAAA,IAAAs3E,EACAx4E,EAAAkB,SAAA,IAAAs3E,EAEAx4E,EAAAkB,SAAA,IAAAu3E,EACAz4E,EAAAkB,SAAA,IAAAu3E,EACAz4E,EAAAkB,SAAA,KAAAu3E,EAEAv5E,EAAAw5E,sBAAA14E,GAEAzJ,EAAA2B,EAAAkgF,EACA7hF,EAAA8B,EAAAggF,EACA9hF,EAAA6K,EAAAk3E,EAEA11F,SAMA+1F,gBAAA,SAAAz4E,EAAAD,EAAAE,EAAAC,EAAA8O,EAAAC,GAEA9jB,SAAA8jB,GAEAjd,QAAA4E,KAAA,uGAIA,IAAAo7E,GAAAtvF,KAAAse,SACAhJ,EAAA,EAAAgX,GAAAjP,EAAAC,GACA7H,EAAA,EAAA6W,GAAA/O,EAAAC,GAEA/P,GAAA4P,EAAAC,IAAAD,EAAAC,GACA9X,GAAA+X,EAAAC,IAAAD,EAAAC,GACAhX,IAAA+lB,EAAAD,IAAAC,EAAAD,GACAre,GAAA,EAAAse,EAAAD,GAAAC,EAAAD,EAOA,OALAgjE,GAAA,GAAAh6E,EAAeg6E,EAAA,KAAaA,EAAA,GAAA7hF,EAAa6hF,EAAA,MACzCA,EAAA,KAAeA,EAAA,GAAA75E,EAAa65E,EAAA,GAAA9pF,EAAa8pF,EAAA,MACzCA,EAAA,KAAeA,EAAA,KAAaA,EAAA,IAAA9oF,EAAc8oF,EAAA,IAAArhF,EAC1CqhF,EAAA,KAAeA,EAAA,KAAaA,EAAA,OAAgBA,EAAA,MAE5CtvF,MAIAg2F,iBAAA,SAAA14E,EAAAD,EAAAE,EAAAC,EAAA8O,EAAAC,GAEA,GAAA+iE,GAAAtvF,KAAAse,SACAG,EAAA,GAAApB,EAAAC,GACAxW,EAAA,GAAAyW,EAAAC,GACArW,EAAA,GAAAolB,EAAAD,GAEAhX,GAAA+H,EAAAC,GAAAmB,EACAhJ,GAAA8H,EAAAC,GAAA1W,EACA0X,GAAA+N,EAAAD,GAAAnlB,CAOA,OALAmoF,GAAA,KAAA7wE,EAAmB6wE,EAAA,KAAaA,EAAA,KAAaA,EAAA,KAAAh6E,EAC7Cg6E,EAAA,KAAeA,EAAA,KAAAxoF,EAAiBwoF,EAAA,KAAaA,EAAA,KAAA75E,EAC7C65E,EAAA,KAAeA,EAAA,KAAaA,EAAA,OAAAnoF,EAAoBmoF,EAAA,KAAA9wE,EAChD8wE,EAAA,KAAeA,EAAA,KAAaA,EAAA,MAAcA,EAAA,MAE1CtvF,MAIAs4C,OAAA,SAAAl7B,GAKA,OAHAkyE,GAAAtvF,KAAAse,SACAixE,EAAAnyE,EAAAkB,SAEAnf,EAAA,EAAmBA,EAAA,GAAQA,IAE3B,GAAAmwF,EAAAnwF,KAAAowF,EAAApwF,GAAA,QAIA,WAIAukD,UAAA,SAAA3iD,EAAAma,GAEAzS,SAAAyS,MAAA,EAEA,QAAA/b,GAAA,EAAmBA,EAAA,GAAQA,IAE3Ba,KAAAse,SAAAnf,GAAA4B,EAAA5B,EAAA+b,EAIA,OAAAlb,OAIA0iB,QAAA,SAAA3hB,EAAAma,GAEAzS,SAAA1H,UACA0H,SAAAyS,MAAA,EAEA,IAAAo0E,GAAAtvF,KAAAse,QAsBA,OApBAvd,GAAAma,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GAEAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GAEAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,IAAAo0E,EAAA,IACAvuF,EAAAma,EAAA,IAAAo0E,EAAA,IAEAvuF,EAAAma,EAAA,IAAAo0E,EAAA,IACAvuF,EAAAma,EAAA,IAAAo0E,EAAA,IACAvuF,EAAAma,EAAA,IAAAo0E,EAAA,IACAvuF,EAAAma,EAAA,IAAAo0E,EAAA,IAEAvuF,KAsBAzC,OAAAyrF,OAAA3uE,GAEA66E,MAAA,SAAAC,EAAAC,EAAAC,EAAA/uF,GAEA,MAAA+uF,GAAAxkF,KAAAskF,GAAAD,MAAAE,EAAA9uF,IAIAgvF,UAAA,SAAA1oF,EAAAy3C,EAAAkxC,EAAAC,EAAAC,EAAAC,EAAApvF,GAIA,GAAAu7D,GAAA0zB,EAAAC,EAAA,GACAG,EAAAJ,EAAAC,EAAA,GACAI,EAAAL,EAAAC,EAAA,GACAK,EAAAN,EAAAC,EAAA,GAEA1zB,EAAA2zB,EAAAC,EAAA,GACAI,EAAAL,EAAAC,EAAA,GACAK,EAAAN,EAAAC,EAAA,GACAM,EAAAP,EAAAC,EAAA,EAEA,IAAAG,IAAAG,GAAAn0B,IAAAC,GAAA6zB,IAAAG,GAAAF,IAAAG,EAAA,CAEA,GAAA/vF,GAAA,EAAAM,EAEAgmD,EAAAuV,EAAAC,EAAA6zB,EAAAG,EAAAF,EAAAG,EAAAF,EAAAG,EAEAr0F,EAAA2qD,GAAA,OACA2pC,EAAA,EAAA3pC,GAGA,IAAA2pC,EAAA1uF,OAAAqhF,QAAA,CAEA,GAAA3kB,GAAAtgE,KAAA2S,KAAA2/E,GACAp2F,EAAA8D,KAAA4+D,MAAA0B,EAAA3X,EAAA3qD,EAEAqE,GAAArC,KAAAsgE,IAAAj+D,EAAAnG,GAAAokE,EACA39D,EAAA3C,KAAAsgE,IAAA39D,EAAAzG,GAAAokE,EAIA,GAAAiyB,GAAA5vF,EAAA3E,CAQA,IANAkgE,IAAA77D,EAAA87D,EAAAo0B,EACAP,IAAA3vF,EAAA8vF,EAAAI,EACAN,IAAA5vF,EAAA+vF,EAAAG,EACAL,IAAA7vF,EAAAgwF,EAAAE,EAGAlwF,IAAA,EAAAM,EAAA,CAEA,GAAAH,GAAA,EAAAxC,KAAA2S,KAAAurD,IAAA8zB,IAAAC,IAAAC,IAEAh0B,IAAA17D,EACAwvF,GAAAxvF,EACAyvF,GAAAzvF,EACA0vF,GAAA1vF,GAMAyG,EAAAy3C,GAAAwd,EACAj1D,EAAAy3C,EAAA,GAAAsxC,EACA/oF,EAAAy3C,EAAA,GAAAuxC,EACAhpF,EAAAy3C,EAAA,GAAAwxC,KAMAt4F,OAAAof,iBAAAtC,EAAApd,WAEAsX,GAEAsI,IAAA,WAEA,MAAA5d,MAAA0e,IAIAlK,IAAA,SAAAxJ,GAEAhL,KAAA0e,GAAA1T,EACAhL,KAAAk3F,qBAMAzhF,GAEAmI,IAAA,WAEA,MAAA5d,MAAA2e,IAIAnK,IAAA,SAAAxJ,GAEAhL,KAAA2e,GAAA3T,EACAhL,KAAAk3F,qBAMA14E,GAEAZ,IAAA,WAEA,MAAA5d,MAAA4e,IAIApK,IAAA,SAAAxJ,GAEAhL,KAAA4e,GAAA5T,EACAhL,KAAAk3F,qBAMAz4E,GAEAb,IAAA,WAEA,MAAA5d,MAAA6e,IAIArK,IAAA,SAAAxJ,GAEAhL,KAAA6e,GAAA7T,EACAhL,KAAAk3F,uBAQA54F,OAAAyrF,OAAA3uE,EAAApd,WAEAwW,IAAA,SAAAc,EAAAG,EAAA+I,EAAAC,GASA,MAPAze,MAAA0e,GAAApJ,EACAtV,KAAA2e,GAAAlJ,EACAzV,KAAA4e,GAAAJ,EACAxe,KAAA6e,GAAAJ,EAEAze,KAAAk3F,mBAEAl3F,MAIA6M,MAAA,WAEA,UAAA7M,MAAAmK,YAAAnK,KAAA0e,GAAA1e,KAAA2e,GAAA3e,KAAA4e,GAAA5e,KAAA6e,KAIAjN,KAAA,SAAA0K,GASA,MAPAtc,MAAA0e,GAAApC,EAAAhH,EACAtV,KAAA2e,GAAArC,EAAA7G,EACAzV,KAAA4e,GAAAtC,EAAAkC,EACAxe,KAAA6e,GAAAvC,EAAAmC,EAEAze,KAAAk3F,mBAEAl3F,MAIA25B,aAAA,SAAAs2D,EAAAt6E,GAEA,IAAAs6E,MAAAC,QAEA,SAAAzwF,OAAA,mGAIA,IAAA6V,GAAA26E,EAAAvxE,GAAAjJ,EAAAw6E,EAAAtxE,GAAAH,EAAAyxE,EAAArxE,GAAAwa,EAAA62D,EAAA72D,MAMAi0B,EAAA3oD,KAAA2oD,IACA2X,EAAAtgE,KAAAsgE,IAEA8N,EAAAzlB,EAAA/3C,EAAA,GACAy9D,EAAA1lB,EAAA53C,EAAA,GACAu9D,EAAA3lB,EAAA7uC,EAAA,GAEArZ,EAAA6/D,EAAA1vD,EAAA,GACAjQ,EAAA2/D,EAAAvvD,EAAA,GACA0hF,EAAAnyB,EAAAxmD,EAAA,EAgDA,OA9CA,QAAA4a,GAEAp5B,KAAA0e,GAAAvZ,EAAA4tE,EAAAC,EAAAF,EAAAztE,EAAA8xF,EACAn3F,KAAA2e,GAAAm0D,EAAAztE,EAAA2tE,EAAA7tE,EAAA4tE,EAAAokB,EACAn3F,KAAA4e,GAAAk0D,EAAAC,EAAAokB,EAAAhyF,EAAAE,EAAA2tE,EACAhzE,KAAA6e,GAAAi0D,EAAAC,EAAAC,EAAA7tE,EAAAE,EAAA8xF,GAEI,QAAA/9D,GAEJp5B,KAAA0e,GAAAvZ,EAAA4tE,EAAAC,EAAAF,EAAAztE,EAAA8xF,EACAn3F,KAAA2e,GAAAm0D,EAAAztE,EAAA2tE,EAAA7tE,EAAA4tE,EAAAokB,EACAn3F,KAAA4e,GAAAk0D,EAAAC,EAAAokB,EAAAhyF,EAAAE,EAAA2tE,EACAhzE,KAAA6e,GAAAi0D,EAAAC,EAAAC,EAAA7tE,EAAAE,EAAA8xF,GAEI,QAAA/9D,GAEJp5B,KAAA0e,GAAAvZ,EAAA4tE,EAAAC,EAAAF,EAAAztE,EAAA8xF,EACAn3F,KAAA2e,GAAAm0D,EAAAztE,EAAA2tE,EAAA7tE,EAAA4tE,EAAAokB,EACAn3F,KAAA4e,GAAAk0D,EAAAC,EAAAokB,EAAAhyF,EAAAE,EAAA2tE,EACAhzE,KAAA6e,GAAAi0D,EAAAC,EAAAC,EAAA7tE,EAAAE,EAAA8xF,GAEI,QAAA/9D,GAEJp5B,KAAA0e,GAAAvZ,EAAA4tE,EAAAC,EAAAF,EAAAztE,EAAA8xF,EACAn3F,KAAA2e,GAAAm0D,EAAAztE,EAAA2tE,EAAA7tE,EAAA4tE,EAAAokB,EACAn3F,KAAA4e,GAAAk0D,EAAAC,EAAAokB,EAAAhyF,EAAAE,EAAA2tE,EACAhzE,KAAA6e,GAAAi0D,EAAAC,EAAAC,EAAA7tE,EAAAE,EAAA8xF,GAEI,QAAA/9D,GAEJp5B,KAAA0e,GAAAvZ,EAAA4tE,EAAAC,EAAAF,EAAAztE,EAAA8xF,EACAn3F,KAAA2e,GAAAm0D,EAAAztE,EAAA2tE,EAAA7tE,EAAA4tE,EAAAokB,EACAn3F,KAAA4e,GAAAk0D,EAAAC,EAAAokB,EAAAhyF,EAAAE,EAAA2tE,EACAhzE,KAAA6e,GAAAi0D,EAAAC,EAAAC,EAAA7tE,EAAAE,EAAA8xF,GAEI,QAAA/9D,IAEJp5B,KAAA0e,GAAAvZ,EAAA4tE,EAAAC,EAAAF,EAAAztE,EAAA8xF,EACAn3F,KAAA2e,GAAAm0D,EAAAztE,EAAA2tE,EAAA7tE,EAAA4tE,EAAAokB,EACAn3F,KAAA4e,GAAAk0D,EAAAC,EAAAokB,EAAAhyF,EAAAE,EAAA2tE,EACAhzE,KAAA6e,GAAAi0D,EAAAC,EAAAC,EAAA7tE,EAAAE,EAAA8xF,GAIAxhF,KAAA,GAAA3V,KAAAk3F,mBAEAl3F,MAIAo3F,iBAAA,SAAAlC,EAAA/hF,GAMA,GAAAkkF,GAAAlkF,EAAA,EAAApM,EAAArC,KAAAsgE,IAAAqyB,EASA,OAPAr3F,MAAA0e,GAAAw2E,EAAA5/E,EAAAvO,EACA/G,KAAA2e,GAAAu2E,EAAAz/E,EAAA1O,EACA/G,KAAA4e,GAAAs2E,EAAA12E,EAAAzX,EACA/G,KAAA6e,GAAAna,KAAA2oD,IAAAgqC,GAEAr3F,KAAAk3F,mBAEAl3F,MAIA81F,sBAAA,SAAAvwF,GAMA,GAOAwB,GAPAuoF,EAAA/pF,EAAA+Y,SAEAg5E,EAAAhI,EAAA,GAAAiI,EAAAjI,EAAA,GAAAkI,EAAAlI,EAAA,GACAmI,EAAAnI,EAAA,GAAAoI,EAAApI,EAAA,GAAAqI,EAAArI,EAAA,GACAsI,EAAAtI,EAAA,GAAAuI,EAAAvI,EAAA,GAAAwI,EAAAxI,EAAA,IAEAyI,EAAAT,EAAAI,EAAAI,CA2CA,OAxCAC,GAAA,GAEAhxF,EAAA,GAAArC,KAAA2S,KAAA0gF,EAAA,GAEA/3F,KAAA6e,GAAA,IAAA9X,EACA/G,KAAA0e,IAAAm5E,EAAAF,GAAA5wF,EACA/G,KAAA2e,IAAA64E,EAAAI,GAAA7wF,EACA/G,KAAA4e,IAAA64E,EAAAF,GAAAxwF,GAEIuwF,EAAAI,GAAAJ,EAAAQ,GAEJ/wF,EAAA,EAAArC,KAAA2S,KAAA,EAAAigF,EAAAI,EAAAI,GAEA93F,KAAA6e,IAAAg5E,EAAAF,GAAA5wF,EACA/G,KAAA0e,GAAA,IAAA3X,EACA/G,KAAA2e,IAAA44E,EAAAE,GAAA1wF,EACA/G,KAAA4e,IAAA44E,EAAAI,GAAA7wF,GAEI2wF,EAAAI,GAEJ/wF,EAAA,EAAArC,KAAA2S,KAAA,EAAAqgF,EAAAJ,EAAAQ,GAEA93F,KAAA6e,IAAA24E,EAAAI,GAAA7wF,EACA/G,KAAA0e,IAAA64E,EAAAE,GAAA1wF,EACA/G,KAAA2e,GAAA,IAAA5X,EACA/G,KAAA4e,IAAA+4E,EAAAE,GAAA9wF,IAIAA,EAAA,EAAArC,KAAA2S,KAAA,EAAAygF,EAAAR,EAAAI,GAEA13F,KAAA6e,IAAA44E,EAAAF,GAAAxwF,EACA/G,KAAA0e,IAAA84E,EAAAI,GAAA7wF,EACA/G,KAAA2e,IAAAg5E,EAAAE,GAAA9wF,EACA/G,KAAA4e,GAAA,IAAA7X,GAIA/G,KAAAk3F,mBAEAl3F,MAIAqb,mBAAA,WAIA,GACA/T,GADAlC,EAAA,GAAAwU,GAGAwC,EAAA,IAEA,iBAAA47E,EAAAC,GA+BA,MA7BAxvF,UAAArD,MAAA,GAAAwU,IAEAtS,EAAA0wF,EAAA37E,IAAA47E,GAAA,EAEA3wF,EAAA8U,GAEA9U,EAAA,EAEA5C,KAAA2+B,IAAA20D,EAAA1iF,GAAA5Q,KAAA2+B,IAAA20D,EAAAx5E,GAEApZ,EAAAoP,KAAAwjF,EAAAviF,EAAAuiF,EAAA1iF,EAAA,GAIAlQ,EAAAoP,IAAA,GAAAwjF,EAAAx5E,EAAAw5E,EAAAviF,IAMArQ,EAAAo8D,aAAAw2B,EAAAC,GAIAj4F,KAAA0e,GAAAtZ,EAAAkQ,EACAtV,KAAA2e,GAAAvZ,EAAAqQ,EACAzV,KAAA4e,GAAAxZ,EAAAoZ,EACAxe,KAAA6e,GAAAvX,EAEAtH,KAAAkuD,gBAMA1yC,QAAA,WAIA,MAAAxb,MAAAk4F,aAIAA,UAAA,WAQA,MANAl4F,MAAA0e,KAAA,EACA1e,KAAA2e,KAAA,EACA3e,KAAA4e,KAAA,EAEA5e,KAAAk3F,mBAEAl3F,MAIAqc,IAAA,SAAArV,GAEA,MAAAhH,MAAA0e,GAAA1X,EAAA0X,GAAA1e,KAAA2e,GAAA3X,EAAA2X,GAAA3e,KAAA4e,GAAA5X,EAAA4X,GAAA5e,KAAA6e,GAAA7X,EAAA6X,IAIAivE,SAAA,WAEA,MAAA9tF,MAAA0e,GAAA1e,KAAA0e,GAAA1e,KAAA2e,GAAA3e,KAAA2e,GAAA3e,KAAA4e,GAAA5e,KAAA4e,GAAA5e,KAAA6e,GAAA7e,KAAA6e,IAIA9gB,OAAA,WAEA,MAAA2G,MAAA2S,KAAArX,KAAA0e,GAAA1e,KAAA0e,GAAA1e,KAAA2e,GAAA3e,KAAA2e,GAAA3e,KAAA4e,GAAA5e,KAAA4e,GAAA5e,KAAA6e,GAAA7e,KAAA6e,KAIAqvC,UAAA,WAEA,GAAA/+C,GAAAnP,KAAAjC,QAsBA,OApBA,KAAAoR,GAEAnP,KAAA0e,GAAA,EACA1e,KAAA2e,GAAA,EACA3e,KAAA4e,GAAA,EACA5e,KAAA6e,GAAA,IAIA1P,EAAA,EAAAA,EAEAnP,KAAA0e,GAAA1e,KAAA0e,GAAAvP,EACAnP,KAAA2e,GAAA3e,KAAA2e,GAAAxP,EACAnP,KAAA4e,GAAA5e,KAAA4e,GAAAzP,EACAnP,KAAA6e,GAAA7e,KAAA6e,GAAA1P,GAIAnP,KAAAk3F,mBAEAl3F,MAIAk3B,SAAA,SAAA9vB,EAAAD,GAEA,MAAAsB,UAAAtB,GAEAmI,QAAA4E,KAAA,0GACAlU,KAAAm4F,oBAAA/wF,EAAAD,IAIAnH,KAAAm4F,oBAAAn4F,KAAAoH,IAIAymD,YAAA,SAAAzmD,GAEA,MAAApH,MAAAm4F,oBAAA/wF,EAAApH,OAIAm4F,oBAAA,SAAA1qF,EAAAjI,GAIA,GAAA4yF,GAAA3qF,EAAAiR,GAAA25E,EAAA5qF,EAAAkR,GAAA25E,EAAA7qF,EAAAmR,GAAA25E,EAAA9qF,EAAAoR,GACA25E,EAAAhzF,EAAAkZ,GAAA+5E,EAAAjzF,EAAAmZ,GAAA+5E,EAAAlzF,EAAAoZ,GAAA+5E,EAAAnzF,EAAAqZ,EASA,OAPA7e,MAAA0e,GAAA05E,EAAAO,EAAAJ,EAAAC,EAAAH,EAAAK,EAAAJ,EAAAG,EACAz4F,KAAA2e,GAAA05E,EAAAM,EAAAJ,EAAAE,EAAAH,EAAAE,EAAAJ,EAAAM,EACA14F,KAAA4e,GAAA05E,EAAAK,EAAAJ,EAAAG,EAAAN,EAAAK,EAAAJ,EAAAG,EACAx4F,KAAA6e,GAAA05E,EAAAI,EAAAP,EAAAI,EAAAH,EAAAI,EAAAH,EAAAI,EAEA14F,KAAAk3F,mBAEAl3F,MAIAi2F,MAAA,SAAAE,EAAA9uF,GAEA,OAAAA,EAAA,MAAArH,KACA,QAAAqH,EAAA,MAAArH,MAAA4R,KAAAukF,EAEA,IAAA7gF,GAAAtV,KAAA0e,GAAAjJ,EAAAzV,KAAA2e,GAAAH,EAAAxe,KAAA4e,GAAAH,EAAAze,KAAA6e,GAIA+5E,EAAAn6E,EAAA03E,EAAAt3E,GAAAvJ,EAAA6gF,EAAAz3E,GAAAjJ,EAAA0gF,EAAAx3E,GAAAH,EAAA23E,EAAAv3E,EAiBA,IAfAg6E,EAAA,GAEA54F,KAAA6e,IAAAs3E,EAAAt3E,GACA7e,KAAA0e,IAAAy3E,EAAAz3E,GACA1e,KAAA2e,IAAAw3E,EAAAx3E,GACA3e,KAAA4e,IAAAu3E,EAAAv3E,GAEAg6E,MAIA54F,KAAA4R,KAAAukF,GAIAyC,GAAA,EAOA,MALA54F,MAAA6e,GAAAJ,EACAze,KAAA0e,GAAApJ,EACAtV,KAAA2e,GAAAlJ,EACAzV,KAAA4e,GAAAJ,EAEAxe,IAIA,IAAA64F,GAAAn0F,KAAA2S,KAAA,EAAAuhF,IAEA,IAAAl0F,KAAA2+B,IAAAw1D,GAAA,KAOA,MALA74F,MAAA6e,GAAA,IAAAJ,EAAAze,KAAA6e,IACA7e,KAAA0e,GAAA,IAAApJ,EAAAtV,KAAA0e,IACA1e,KAAA2e,GAAA,IAAAlJ,EAAAzV,KAAA2e,IACA3e,KAAA4e,GAAA,IAAAJ,EAAAxe,KAAA4e,IAEA5e,IAIA,IAAA84F,GAAAp0F,KAAA4+D,MAAAu1B,EAAAD,GACAG,EAAAr0F,KAAAsgE,KAAA,EAAA39D,GAAAyxF,GAAAD,EACAG,EAAAt0F,KAAAsgE,IAAA39D,EAAAyxF,GAAAD,CASA,OAPA74F,MAAA6e,GAAAJ,EAAAs6E,EAAA/4F,KAAA6e,GAAAm6E,EACAh5F,KAAA0e,GAAApJ,EAAAyjF,EAAA/4F,KAAA0e,GAAAs6E,EACAh5F,KAAA2e,GAAAlJ,EAAAsjF,EAAA/4F,KAAA2e,GAAAq6E,EACAh5F,KAAA4e,GAAAJ,EAAAu6E,EAAA/4F,KAAA4e,GAAAo6E,EAEAh5F,KAAAk3F,mBAEAl3F,MAIAs4C,OAAA,SAAAh8B,GAEA,MAAAA,GAAAoC,KAAA1e,KAAA0e,IAAApC,EAAAqC,KAAA3e,KAAA2e,IAAArC,EAAAsC,KAAA5e,KAAA4e,IAAAtC,EAAAuC,KAAA7e,KAAA6e,IAIA6kC,UAAA,SAAA3iD,EAAAma,GAWA,MATAzS,UAAAyS,MAAA,GAEAlb,KAAA0e,GAAA3d,EAAAma,GACAlb,KAAA2e,GAAA5d,EAAAma,EAAA,GACAlb,KAAA4e,GAAA7d,EAAAma,EAAA,GACAlb,KAAA6e,GAAA9d,EAAAma,EAAA,GAEAlb,KAAAk3F,mBAEAl3F,MAIA0iB,QAAA,SAAA3hB,EAAAma,GAUA,MARAzS,UAAA1H,UACA0H,SAAAyS,MAAA,GAEAna,EAAAma,GAAAlb,KAAA0e,GACA3d,EAAAma,EAAA,GAAAlb,KAAA2e,GACA5d,EAAAma,EAAA,GAAAlb,KAAA4e,GACA7d,EAAAma,EAAA,GAAAlb,KAAA6e,GAEA9d,GAIAk5B,SAAA,SAAAujC,GAIA,MAFAx9D,MAAAk3F,iBAAA15B,EAEAx9D,MAIAk3F,iBAAA,eAqBA54F,OAAAyrF,OAAAnwE,EAAA5b,WAEA08B,WAAA,EAEAlmB,IAAA,SAAAc,EAAAG,EAAA+I,GAMA,MAJAxe,MAAAsV,IACAtV,KAAAyV,IACAzV,KAAAwe,IAEAxe,MAIA6sF,UAAA,SAAAC,GAMA,MAJA9sF,MAAAsV,EAAAw3E,EACA9sF,KAAAyV,EAAAq3E,EACA9sF,KAAAwe,EAAAsuE,EAEA9sF,MAIA+sF,KAAA,SAAAz3E,GAIA,MAFAtV,MAAAsV,IAEAtV,MAIAgtF,KAAA,SAAAv3E,GAIA,MAFAzV,MAAAyV,IAEAzV,MAIAi5F,KAAA,SAAAz6E,GAIA,MAFAxe,MAAAwe,IAEAxe,MAIAitF,aAAA,SAAA1gF,EAAAvB,GAEA,OAAAuB,GAEA,OAAAvM,KAAAsV,EAAAtK,CAA2B,MAC3B,QAAAhL,KAAAyV,EAAAzK,CAA2B,MAC3B,QAAAhL,KAAAwe,EAAAxT,CAA2B,MAC3B,kBAAAvL,OAAA,0BAAA8M,GAIA,MAAAvM,OAIAktF,aAAA,SAAA3gF,GAEA,OAAAA,GAEA,aAAAvM,MAAAsV,CACA,cAAAtV,MAAAyV,CACA,cAAAzV,MAAAwe,CACA,kBAAA/e,OAAA,0BAAA8M,KAMAM,MAAA,WAEA,UAAA7M,MAAAmK,YAAAnK,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAwe,IAIA5M,KAAA,SAAA5K,GAMA,MAJAhH,MAAAsV,EAAAtO,EAAAsO,EACAtV,KAAAyV,EAAAzO,EAAAyO,EACAzV,KAAAwe,EAAAxX,EAAAwX,EAEAxe,MAIAuS,IAAA,SAAAvL,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,yFACAlU,KAAA8lE,WAAA9+D,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EACAzV,KAAAwe,GAAAxX,EAAAwX,EAEAxe,OAIAmtF,UAAA,SAAApmF,GAMA,MAJA/G,MAAAsV,GAAAvO,EACA/G,KAAAyV,GAAA1O,EACA/G,KAAAwe,GAAAzX,EAEA/G,MAIA8lE,WAAA,SAAAr4D,EAAAjI,GAMA,MAJAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EACAzV,KAAAwe,EAAA/Q,EAAA+Q,EAAAhZ,EAAAgZ,EAEAxe,MAIAotF,gBAAA,SAAApmF,EAAAD,GAMA,MAJA/G,MAAAsV,GAAAtO,EAAAsO,EAAAvO,EACA/G,KAAAyV,GAAAzO,EAAAyO,EAAA1O,EACA/G,KAAAwe,GAAAxX,EAAAwX,EAAAzX,EAEA/G,MAIA2b,IAAA,SAAA3U,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,yFACAlU,KAAAkV,WAAAlO,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EACAzV,KAAAwe,GAAAxX,EAAAwX,EAEAxe,OAIAqtF,UAAA,SAAAtmF,GAMA,MAJA/G,MAAAsV,GAAAvO,EACA/G,KAAAyV,GAAA1O,EACA/G,KAAAwe,GAAAzX,EAEA/G,MAIAkV,WAAA,SAAAzH,EAAAjI,GAMA,MAJAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EACAzV,KAAAwe,EAAA/Q,EAAA+Q,EAAAhZ,EAAAgZ,EAEAxe,MAIAk3B,SAAA,SAAAlwB,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,mGACAlU,KAAAk5F,gBAAAlyF,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EACAzV,KAAAwe,GAAAxX,EAAAwX,EAEAxe,OAIA8c,eAAA,SAAAgwE,GAMA,MAJA9sF,MAAAsV,GAAAw3E,EACA9sF,KAAAyV,GAAAq3E,EACA9sF,KAAAwe,GAAAsuE,EAEA9sF,MAIAk5F,gBAAA,SAAAzrF,EAAAjI,GAMA,MAJAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EACAzV,KAAAwe,EAAA/Q,EAAA+Q,EAAAhZ,EAAAgZ,EAEAxe,MAIAm5F,WAAA,WAEA,GAAA78E,GAAA,GAAAlB,EAEA,iBAAA60E,GAQA,MANAA,MAAAC,SAEA5gF,QAAAiP,MAAA,+FAIAve,KAAA4b,gBAAAU,EAAAqd,aAAAs2D,QAMAmJ,eAAA,WAEA,GAAA98E,GAAA,GAAAlB,EAEA,iBAAA85E,EAAA/hF,GAEA,MAAAnT,MAAA4b,gBAAAU,EAAA86E,iBAAAlC,EAAA/hF,QAMAo6E,aAAA,SAAAhoF,GAEA,GAAA+P,GAAAtV,KAAAsV,EAAAG,EAAAzV,KAAAyV,EAAA+I,EAAAxe,KAAAwe,EACAlf,EAAAiG,EAAA+Y,QAMA,OAJAte,MAAAsV,EAAAhW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EACAxe,KAAAyV,EAAAnW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EACAxe,KAAAwe,EAAAlf,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EAEAxe,MAIA8jD,aAAA,SAAAv+C,GAEA,GAAA+P,GAAAtV,KAAAsV,EAAAG,EAAAzV,KAAAyV,EAAA+I,EAAAxe,KAAAwe,EACAlf,EAAAiG,EAAA+Y,SAEAG,EAAA,GAAAnf,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,IAAAkf,EAAAlf,EAAA,IAMA,OAJAU,MAAAsV,GAAAhW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EAAAlf,EAAA,KAAAmf,EACAze,KAAAyV,GAAAnW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EAAAlf,EAAA,KAAAmf,EACAze,KAAAwe,GAAAlf,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,IAAAkf,EAAAlf,EAAA,KAAAmf,EAEAze,MAIA4b,gBAAA,SAAAxU,GAEA,GAAAkO,GAAAtV,KAAAsV,EAAAG,EAAAzV,KAAAyV,EAAA+I,EAAAxe,KAAAwe,EACA6qD,EAAAjiE,EAAAkO,EAAA+jF,EAAAjyF,EAAAqO,EAAA6jF,EAAAlyF,EAAAoX,EAAA+6E,EAAAnyF,EAAAqX,EAIAof,EAAA07D,EAAAjkF,EAAA+jF,EAAA76E,EAAA86E,EAAA7jF,EACAqoB,EAAAy7D,EAAA9jF,EAAA6jF,EAAAhkF,EAAA+zD,EAAA7qD,EACAg7E,EAAAD,EAAA/6E,EAAA6qD,EAAA5zD,EAAA4jF,EAAA/jF,EACAmkF,GAAApwB,EAAA/zD,EAAA+jF,EAAA5jF,EAAA6jF,EAAA96E,CAQA,OAJAxe,MAAAsV,EAAAuoB,EAAA07D,EAAAE,GAAApwB,EAAAvrC,GAAAw7D,EAAAE,GAAAH,EACAr5F,KAAAyV,EAAAqoB,EAAAy7D,EAAAE,GAAAJ,EAAAG,GAAAnwB,EAAAxrC,GAAAy7D,EACAt5F,KAAAwe,EAAAg7E,EAAAD,EAAAE,GAAAH,EAAAz7D,GAAAw7D,EAAAv7D,GAAAurC,EAEArpE,MAIAqpF,QAAA,WAEA,GAAAjsE,GAAA,GAAAiB,EAEA,iBAAAgN,GAGA,MADAjO,GAAAuP,iBAAAtB,EAAA/B,iBAAAlM,EAAA6mC,WAAA54B,EAAAwB,cACA7sB,KAAA8jD,aAAA1mC,OAMAmsE,UAAA,WAEA,GAAAnsE,GAAA,GAAAiB,EAEA,iBAAAgN,GAGA,MADAjO,GAAAuP,iBAAAtB,EAAAwB,YAAAzP,EAAA6mC,WAAA54B,EAAA/B,mBACAtpB,KAAA8jD,aAAA1mC,OAMA4vC,mBAAA,SAAAznD,GAKA,GAAA+P,GAAAtV,KAAAsV,EAAAG,EAAAzV,KAAAyV,EAAA+I,EAAAxe,KAAAwe,EACAlf,EAAAiG,EAAA+Y,QAMA,OAJAte,MAAAsV,EAAAhW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EACAxe,KAAAyV,EAAAnW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EACAxe,KAAAwe,EAAAlf,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,IAAAkf,EAEAxe,KAAAkuD,aAIAo/B,OAAA,SAAAtmF,GAMA,MAJAhH,MAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EACAzV,KAAAwe,GAAAxX,EAAAwX,EAEAxe,MAIAmjE,aAAA,SAAA2pB,GAEA,MAAA9sF,MAAA8c,eAAA,EAAAgwE,IAIAzmF,IAAA,SAAAW,GAMA,MAJAhH,MAAAsV,EAAA5Q,KAAA2B,IAAArG,KAAAsV,EAAAtO,EAAAsO,GACAtV,KAAAyV,EAAA/Q,KAAA2B,IAAArG,KAAAyV,EAAAzO,EAAAyO,GACAzV,KAAAwe,EAAA9Z,KAAA2B,IAAArG,KAAAwe,EAAAxX,EAAAwX,GAEAxe,MAIAoG,IAAA,SAAAY,GAMA,MAJAhH,MAAAsV,EAAA5Q,KAAA0B,IAAApG,KAAAsV,EAAAtO,EAAAsO,GACAtV,KAAAyV,EAAA/Q,KAAA0B,IAAApG,KAAAyV,EAAAzO,EAAAyO,GACAzV,KAAAwe,EAAA9Z,KAAA0B,IAAApG,KAAAwe,EAAAxX,EAAAwX,GAEAxe,MAIAutE,MAAA,SAAAlnE,EAAAD,GAQA,MAJApG,MAAAsV,EAAA5Q,KAAA0B,IAAAC,EAAAiP,EAAA5Q,KAAA2B,IAAAD,EAAAkP,EAAAtV,KAAAsV,IACAtV,KAAAyV,EAAA/Q,KAAA0B,IAAAC,EAAAoP,EAAA/Q,KAAA2B,IAAAD,EAAAqP,EAAAzV,KAAAyV,IACAzV,KAAAwe,EAAA9Z,KAAA0B,IAAAC,EAAAmY,EAAA9Z,KAAA2B,IAAAD,EAAAoY,EAAAxe,KAAAwe,IAEAxe,MAIAwtF,YAAA,WAEA,GAAAnnF,GAAA,GAAAuT,GACAxT,EAAA,GAAAwT,EAEA,iBAAA6zE,EAAAC,GAKA,MAHArnF,GAAAmO,IAAAi5E,OACArnF,EAAAoO,IAAAk5E,OAEA1tF,KAAAutE,MAAAlnE,EAAAD,OAMAunF,YAAA,SAAAtnF,EAAAD,GAEA,GAAArI,GAAAiC,KAAAjC,QAEA,OAAAiC,MAAAmjE,aAAAplE,GAAA,GAAA+e,eAAApY,KAAA0B,IAAAC,EAAA3B,KAAA2B,IAAAD,EAAArI,MAIAoI,MAAA,WAMA,MAJAnG,MAAAsV,EAAA5Q,KAAAyB,MAAAnG,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAyB,MAAAnG,KAAAyV,GACAzV,KAAAwe,EAAA9Z,KAAAyB,MAAAnG,KAAAwe,GAEAxe,MAIA2sF,KAAA,WAMA,MAJA3sF,MAAAsV,EAAA5Q,KAAAioF,KAAA3sF,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAioF,KAAA3sF,KAAAyV,GACAzV,KAAAwe,EAAA9Z,KAAAioF,KAAA3sF,KAAAwe,GAEAxe,MAIAkI,MAAA,WAMA,MAJAlI,MAAAsV,EAAA5Q,KAAAwD,MAAAlI,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAwD,MAAAlI,KAAAyV,GACAzV,KAAAwe,EAAA9Z,KAAAwD,MAAAlI,KAAAwe,GAEAxe,MAIA4tF,YAAA,WAMA,MAJA5tF,MAAAsV,EAAAtV,KAAAsV,EAAA,EAAA5Q,KAAAioF,KAAA3sF,KAAAsV,GAAA5Q,KAAAyB,MAAAnG,KAAAsV,GACAtV,KAAAyV,EAAAzV,KAAAyV,EAAA,EAAA/Q,KAAAioF,KAAA3sF,KAAAyV,GAAA/Q,KAAAyB,MAAAnG,KAAAyV,GACAzV,KAAAwe,EAAAxe,KAAAwe,EAAA,EAAA9Z,KAAAioF,KAAA3sF,KAAAwe,GAAA9Z,KAAAyB,MAAAnG,KAAAwe,GAEAxe,MAIA6tF,OAAA,WAMA,MAJA7tF,MAAAsV,GAAAtV,KAAAsV,EACAtV,KAAAyV,GAAAzV,KAAAyV,EACAzV,KAAAwe,GAAAxe,KAAAwe,EAEAxe,MAIAqc,IAAA,SAAArV,GAEA,MAAAhH,MAAAsV,EAAAtO,EAAAsO,EAAAtV,KAAAyV,EAAAzO,EAAAyO,EAAAzV,KAAAwe,EAAAxX,EAAAwX,GAMAsvE,SAAA,WAEA,MAAA9tF,MAAAsV,EAAAtV,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAyV,EAAAzV,KAAAwe,EAAAxe,KAAAwe,GAIAzgB,OAAA,WAEA,MAAA2G,MAAA2S,KAAArX,KAAAsV,EAAAtV,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAyV,EAAAzV,KAAAwe,EAAAxe,KAAAwe,IAIAuvE,gBAAA,WAEA,MAAArpF,MAAA2+B,IAAArjC,KAAAsV,GAAA5Q,KAAA2+B,IAAArjC,KAAAyV,GAAA/Q,KAAA2+B,IAAArjC,KAAAwe,IAIA0vC,UAAA,WAEA,MAAAluD,MAAAmjE,aAAAnjE,KAAAjC,UAAA,IAIAqpF,UAAA,SAAArpF,GAEA,MAAAiC,MAAAkuD,YAAApxC,eAAA/e,IAIAkkE,KAAA,SAAAj7D,EAAAvC,GAMA,MAJAzE,MAAAsV,IAAAtO,EAAAsO,EAAAtV,KAAAsV,GAAA7Q,EACAzE,KAAAyV,IAAAzO,EAAAyO,EAAAzV,KAAAyV,GAAAhR,EACAzE,KAAAwe,IAAAxX,EAAAwX,EAAAxe,KAAAwe,GAAA/Z,EAEAzE,MAIAkuF,YAAA,SAAA9oF,EAAAE,EAAAb,GAEA,MAAAzE,MAAAkV,WAAA5P,EAAAF,GAAA0X,eAAArY,GAAA8N,IAAAnN,IAIAs0F,MAAA,SAAA1yF,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,6FACAlU,KAAAwhE,aAAAx6D,EAAAyX,IAIAze,KAAAwhE,aAAAxhE,KAAAgH,IAIAw6D,aAAA,SAAA/zD,EAAAjI,GAEA,GAAAwkE,GAAAv8D,EAAA6H,EAAA20D,EAAAx8D,EAAAgI,EAAAkkF,EAAAlsF,EAAA+Q,EACA0rD,EAAA1kE,EAAA8P,EAAA60D,EAAA3kE,EAAAiQ,EAAAmkF,EAAAp0F,EAAAgZ,CAMA,OAJAxe,MAAAsV,EAAA20D,EAAA2vB,EAAAD,EAAAxvB,EACAnqE,KAAAyV,EAAAkkF,EAAAzvB,EAAAF,EAAA4vB,EACA55F,KAAAwe,EAAAwrD,EAAAG,EAAAF,EAAAC,EAEAlqE,MAIA65F,gBAAA,SAAAt7D,GAEA,GAAAuuD,GAAAvuD,EAAAliB,IAAArc,MAAAu+B,EAAAuvD,UAEA,OAAA9tF,MAAA4R,KAAA2sB,GAAAzhB,eAAAgwE,IAIAgN,eAAA,WAEA,GAAA10F,GAAA,GAAAwU,EAEA,iBAAAmgF,GAIA,MAFA30F,GAAAwM,KAAA5R,MAAA65F,gBAAAE,GAEA/5F,KAAA2b,IAAAvW,OAMA40F,QAAA,WAKA,GAAA50F,GAAA,GAAAwU,EAEA,iBAAAuX,GAEA,MAAAnxB,MAAA2b,IAAAvW,EAAAwM,KAAAuf,GAAArU,eAAA,EAAA9c,KAAAqc,IAAA8U,SAMA8oE,QAAA,SAAAjzF,GAEA,GAAAqM,GAAArT,KAAAqc,IAAArV,GAAAtC,KAAA2S,KAAArX,KAAA8tF,WAAA9mF,EAAA8mF,WAIA,OAAAppF,MAAAw1F,KAAAx6E,GAAA6tD,MAAAl6D,GAAA,OAIA26E,WAAA,SAAAhnF,GAEA,MAAAtC,MAAA2S,KAAArX,KAAAmc,kBAAAnV,KAIAmV,kBAAA,SAAAnV,GAEA,GAAAkQ,GAAAlX,KAAAsV,EAAAtO,EAAAsO,EAAA6B,EAAAnX,KAAAyV,EAAAzO,EAAAyO,EAAA0kF,EAAAn6F,KAAAwe,EAAAxX,EAAAwX,CAEA,OAAAtH,KAAAC,IAAAgjF,KAIAlM,oBAAA,SAAAjnF,GAEA,MAAAtC,MAAA2+B,IAAArjC,KAAAsV,EAAAtO,EAAAsO,GAAA5Q,KAAA2+B,IAAArjC,KAAAyV,EAAAzO,EAAAyO,GAAA/Q,KAAA2+B,IAAArjC,KAAAwe,EAAAxX,EAAAwX,IAIAvC,iBAAA,SAAAlV,GAEA,GAAAqzF,GAAA11F,KAAAsgE,IAAAj+D,EAAAwM,KAAAxM,EAAAgV,MAMA,OAJA/b,MAAAsV,EAAA8kF,EAAA11F,KAAAsgE,IAAAj+D,EAAAsM,OACArT,KAAAyV,EAAA/Q,KAAA2oD,IAAAtmD,EAAAwM,KAAAxM,EAAAgV,OACA/b,KAAAwe,EAAA47E,EAAA11F,KAAA2oD,IAAAtmD,EAAAsM,OAEArT,MAIAq6F,mBAAA,SAAA7zF,GAMA,MAJAxG,MAAAsV,EAAA9O,EAAAuV,OAAArX,KAAAsgE,IAAAx+D,EAAA6M,OACArT,KAAAyV,EAAAjP,EAAAiP,EACAzV,KAAAwe,EAAAhY,EAAAuV,OAAArX,KAAA2oD,IAAA7mD,EAAA6M,OAEArT,MAIA+2B,sBAAA,SAAAxxB,GAEA,GAAAjG,GAAAiG,EAAA+Y,QAMA,OAJAte,MAAAsV,EAAAhW,EAAA,IACAU,KAAAyV,EAAAnW,EAAA,IACAU,KAAAwe,EAAAlf,EAAA,IAEAU,MAIAs6F,mBAAA,SAAA/0F,GAEA,GAAAiwF,GAAAx1F,KAAA6c,oBAAAtX,EAAA,GAAAxH,SACA03F,EAAAz1F,KAAA6c,oBAAAtX,EAAA,GAAAxH,SACA23F,EAAA11F,KAAA6c,oBAAAtX,EAAA,GAAAxH,QAMA,OAJAiC,MAAAsV,EAAAkgF,EACAx1F,KAAAyV,EAAAggF,EACAz1F,KAAAwe,EAAAk3E,EAEA11F,MAIA6c,oBAAA,SAAAtX,EAAAgH,GAEA,MAAAvM,MAAA0jD,UAAAn+C,EAAA+Y,SAAA,EAAA/R,IAIA+rC,OAAA,SAAAtxC,GAEA,MAAAA,GAAAsO,IAAAtV,KAAAsV,GAAAtO,EAAAyO,IAAAzV,KAAAyV,GAAAzO,EAAAwX,IAAAxe,KAAAwe,GAIAklC,UAAA,SAAA3iD,EAAAma,GAQA,MANAzS,UAAAyS,MAAA,GAEAlb,KAAAsV,EAAAvU,EAAAma,GACAlb,KAAAyV,EAAA1U,EAAAma,EAAA,GACAlb,KAAAwe,EAAAzd,EAAAma,EAAA,GAEAlb,MAIA0iB,QAAA,SAAA3hB,EAAAma,GASA,MAPAzS,UAAA1H,UACA0H,SAAAyS,MAAA,GAEAna,EAAAma,GAAAlb,KAAAsV,EACAvU,EAAAma,EAAA,GAAAlb,KAAAyV,EACA1U,EAAAma,EAAA,GAAAlb,KAAAwe,EAEAzd,GAIAggE,oBAAA,SAAAtpC,EAAAlrB,EAAA2O,GAYA,MAVAzS,UAAAyS,GAEA5L,QAAA4E,KAAA,uEAIAlU,KAAAsV,EAAAmiB,EAAAqpC,KAAAv0D,GACAvM,KAAAyV,EAAAgiB,EAAA02D,KAAA5hF,GACAvM,KAAAwe,EAAAiZ,EAAAo8D,KAAAtnF,GAEAvM,QA+BA1B,OAAAyrF,OAAAjrE,EAAA9gB,WAEAu8F,WAAA,EAEA/lF,IAAA,SAAA85E,EAAAC,EAAAC,EAAAE,EAAAC,EAAAC,EAAAE,EAAAC,EAAAC,GAEA,GAAAM,GAAAtvF,KAAAse,QAMA,OAJAgxE,GAAA,GAAAhB,EAAiBgB,EAAA,GAAAZ,EAAeY,EAAA,GAAAR,EAChCQ,EAAA,GAAAf,EAAiBe,EAAA,GAAAX,EAAeW,EAAA,GAAAP,EAChCO,EAAA,GAAAd,EAAiBc,EAAA,GAAAV,EAAeU,EAAA,GAAAN,EAEhChvF,MAIA2tD,SAAA,WAUA,MARA3tD,MAAAwU,IAEA,MACA,MACA,OAIAxU,MAIA6M,MAAA,WAEA,UAAA7M,MAAAmK,aAAAu5C,UAAA1jD,KAAAse,WAIA1M,KAAA,SAAArM,GAEA,GAAA+pF,GAAAtvF,KAAAse,SACAixE,EAAAhqF,EAAA+Y,QAMA,OAJAgxE,GAAA,GAAAC,EAAA,GAAqBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GACxCD,EAAA,GAAAC,EAAA,GAAqBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GACxCD,EAAA,GAAAC,EAAA,GAAqBD,EAAA,GAAAC,EAAA,GAAmBD,EAAA,GAAAC,EAAA,GAExCvvF,MAIAw6F,eAAA,SAAAj1F,GAEA,GAAAgqF,GAAAhqF,EAAA+Y,QAUA,OARAte,MAAAwU,IAEA+6E,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAIAvvF,MAIA4zF,uBAAA,WAEA,GAAAxuF,GAAA,GAAAwU,EAEA,iBAAA6d,GAEA,OAAAt4B,GAAA,EAAAgQ,EAAAsoB,EAAA7uB,MAAyCzJ,EAAAgQ,EAAOhQ,IAEhDiG,EAAAkQ,EAAAmiB,EAAAqpC,KAAA3hE,GACAiG,EAAAqQ,EAAAgiB,EAAA02D,KAAAhvF,GACAiG,EAAAoZ,EAAAiZ,EAAAo8D,KAAA10F,GAEAiG,EAAAmoF,aAAAvtF,MAEAy3B,EAAAq8D,OAAA30F,EAAAiG,EAAAkQ,EAAAlQ,EAAAqQ,EAAArQ,EAAAoZ,EAIA,OAAAiZ,OAMAP,SAAA,SAAA3xB,GAEA,MAAAvF,MAAA2sB,iBAAA3sB,KAAAuF,IAIAsoD,YAAA,SAAAtoD,GAEA,MAAAvF,MAAA2sB,iBAAApnB,EAAAvF,OAIA2sB,iBAAA,SAAAlf,EAAAjI,GAEA,GAAA2qF,GAAA1iF,EAAA6Q,SACA+xE,EAAA7qF,EAAA8Y,SACAgxE,EAAAtvF,KAAAse,SAEAszE,EAAAzB,EAAA,GAAA0B,EAAA1B,EAAA,GAAA2B,EAAA3B,EAAA,GACA6B,EAAA7B,EAAA,GAAA8B,EAAA9B,EAAA,GAAA+B,EAAA/B,EAAA,GACAiC,EAAAjC,EAAA,GAAAkC,EAAAlC,EAAA,GAAAmC,EAAAnC,EAAA,GAEAyC,EAAAvC,EAAA,GAAAwC,EAAAxC,EAAA,GAAAyC,EAAAzC,EAAA,GACA2C,EAAA3C,EAAA,GAAA4C,EAAA5C,EAAA,GAAA6C,EAAA7C,EAAA,GACA+C,EAAA/C,EAAA,GAAAgD,EAAAhD,EAAA,GAAAiD,EAAAjD,EAAA,EAcA,OAZAf,GAAA,GAAAsC,EAAAgB,EAAAf,EAAAmB,EAAAlB,EAAAsB,EACA9D,EAAA,GAAAsC,EAAAiB,EAAAhB,EAAAoB,EAAAnB,EAAAuB,EACA/D,EAAA,GAAAsC,EAAAkB,EAAAjB,EAAAqB,EAAApB,EAAAwB,EAEAhE,EAAA,GAAA0C,EAAAY,EAAAX,EAAAe,EAAAd,EAAAkB,EACA9D,EAAA,GAAA0C,EAAAa,EAAAZ,EAAAgB,EAAAf,EAAAmB,EACA/D,EAAA,GAAA0C,EAAAc,EAAAb,EAAAiB,EAAAhB,EAAAoB,EAEAhE,EAAA,GAAA8C,EAAAQ,EAAAP,EAAAW,EAAAV,EAAAc,EACA9D,EAAA,GAAA8C,EAAAS,EAAAR,EAAAY,EAAAX,EAAAe,EACA/D,EAAA,GAAA8C,EAAAU,EAAAT,EAAAa,EAAAZ,EAAAgB,EAEAtzF,MAIA8c,eAAA,SAAA/V,GAEA,GAAAuoF,GAAAtvF,KAAAse,QAMA,OAJAgxE,GAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,IAAAvoF,EAC9BuoF,EAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,IAAAvoF,EAC9BuoF,EAAA,IAAAvoF,EAAgBuoF,EAAA,IAAAvoF,EAAcuoF,EAAA,IAAAvoF,EAE9B/G,MAIAkzD,YAAA,WAEA,GAAAo8B,GAAAtvF,KAAAse,SAEA7Q,EAAA6hF,EAAA,GAAA9pF,EAAA8pF,EAAA,GAAA9oF,EAAA8oF,EAAA,GACArhF,EAAAqhF,EAAA,GAAAhwF,EAAAgwF,EAAA,GAAApoF,EAAAooF,EAAA,GACA/nF,EAAA+nF,EAAA,GAAAxoF,EAAAwoF,EAAA,GAAAnwF,EAAAmwF,EAAA,EAEA,OAAA7hF,GAAAnO,EAAAH,EAAAsO,EAAAvG,EAAAJ,EAAAtB,EAAAyI,EAAA9O,EAAAqG,EAAA0B,EAAAK,EAAAf,EAAAyH,EAAAnH,EAAAN,EAAAlH,EAAAiI,GAIA08C,WAAA,SAAA7mC,EAAA82E,GAEA92E,KAAAixE,WAEA/+E,QAAAiP,MAAA,mEAIA,IAAAgxE,GAAAnyE,EAAAkB,SACAgxE,EAAAtvF,KAAAse,SAEAgwE,EAAAiB,EAAA,GAAAb,EAAAa,EAAA,GAAAT,EAAAS,EAAA,GACAhB,EAAAgB,EAAA,GAAAZ,EAAAY,EAAA,GAAAR,EAAAQ,EAAA,GACAf,EAAAe,EAAA,GAAAX,EAAAW,EAAA,GAAAP,EAAAO,EAAA,GAEA4E,EAAAnF,EAAAL,EAAAI,EAAAH,EACAwF,EAAArF,EAAAP,EAAAQ,EAAAT,EACA8F,EAAAzF,EAAAL,EAAAI,EAAAH,EAEA+F,EAAAjG,EAAA6F,EAAAzF,EAAA0F,EAAAtF,EAAAuF,CAEA,QAAAE,EAAA,CAEA,GAAAC,GAAA,oEAEA,IAAAN,KAAA,EAEA,SAAAz0F,OAAA+0F,EAQA,OAJAllF,SAAA4E,KAAAsgF,GAIAx0F,KAAA2tD,WAIA,GAAA8mC,GAAA,EAAAF,CAcA,OAZAjF,GAAA,GAAA6E,EAAAM,EACAnF,EAAA,IAAAR,EAAAF,EAAAI,EAAAN,GAAA+F,EACAnF,EAAA,IAAAP,EAAAL,EAAAI,EAAAH,GAAA8F,EAEAnF,EAAA,GAAA8E,EAAAK,EACAnF,EAAA,IAAAN,EAAAV,EAAAQ,EAAAN,GAAAiG,EACAnF,EAAA,IAAAR,EAAAP,EAAAQ,EAAAT,GAAAmG,EAEAnF,EAAA,GAAA+E,EAAAI,EACAnF,EAAA,IAAAZ,EAAAF,EAAAI,EAAAN,GAAAmG,EACAnF,EAAA,IAAAX,EAAAL,EAAAI,EAAAH,GAAAkG,EAEAz0F,MAIA+zF,UAAA,WAEA,GAAAC,GAAAzuF,EAAAvF,KAAAse,QAMA,OAJA01E,GAAAzuF,EAAA,GAAgBA,EAAA,GAAAA,EAAA,GAAiBA,EAAA,GAAAyuF,EACjCA,EAAAzuF,EAAA,GAAgBA,EAAA,GAAAA,EAAA,GAAiBA,EAAA,GAAAyuF,EACjCA,EAAAzuF,EAAA,GAAgBA,EAAA,GAAAA,EAAA,GAAiBA,EAAA,GAAAyuF,EAEjCh0F,MAIA2lD,gBAAA,SAAAiI,GAEA,MAAA5tD,MAAAw6F,eAAA5sC,GAAA3J,WAAAjkD,MAAA+zF,aAIA0G,mBAAA,SAAAnzF,GAEA,GAAA/B,GAAAvF,KAAAse,QAYA,OAVAhX,GAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GACA+B,EAAA,GAAA/B,EAAA,GAEAvF,MAIAi4D,eAAA,SAAAk9B,EAAAC,EAAAI,EAAAC,EAAAp1E,EAAA0lD,EAAAC,GAEA,GAAAx/D,GAAA9B,KAAA2oD,IAAAhtC,GACAtZ,EAAArC,KAAAsgE,IAAA3kD,EAEArgB,MAAAwU,IACAghF,EAAAhvF,EAAAgvF,EAAAzuF,GAAAyuF,GAAAhvF,EAAAu/D,EAAAh/D,EAAAi/D,GAAAD,EAAAovB,GACAM,EAAA1uF,EAAA0uF,EAAAjvF,GAAAivF,IAAA1uF,EAAAg/D,EAAAv/D,EAAAw/D,KAAAovB,EACA,QAKAzhF,MAAA,SAAA6hF,EAAAC,GAEA,GAAAnG,GAAAtvF,KAAAse,QAKA,OAHAgxE,GAAA,IAAAkG,EAAiBlG,EAAA,IAAAkG,EAAelG,EAAA,IAAAkG,EAChClG,EAAA,IAAAmG,EAAiBnG,EAAA,IAAAmG,EAAenG,EAAA,IAAAmG,EAEhCz1F,MAIA06F,OAAA,SAAArnF,GAEA,GAAA7M,GAAA9B,KAAA2oD,IAAAh6C,GACAtM,EAAArC,KAAAsgE,IAAA3xD,GAEAi8E,EAAAtvF,KAAAse,SAEAszE,EAAAtC,EAAA,GAAAuC,EAAAvC,EAAA,GAAAwC,EAAAxC,EAAA,GACA0C,EAAA1C,EAAA,GAAA2C,EAAA3C,EAAA,GAAA4C,EAAA5C,EAAA,EAUA,OARAA,GAAA,GAAA9oF,EAAAorF,EAAA7qF,EAAAirF,EACA1C,EAAA,GAAA9oF,EAAAqrF,EAAA9qF,EAAAkrF,EACA3C,EAAA,GAAA9oF,EAAAsrF,EAAA/qF,EAAAmrF,EAEA5C,EAAA,IAAAvoF,EAAA6qF,EAAAprF,EAAAwrF,EACA1C,EAAA,IAAAvoF,EAAA8qF,EAAArrF,EAAAyrF,EACA3C,EAAA,IAAAvoF,EAAA+qF,EAAAtrF,EAAA0rF,EAEAlyF,MAIAknF,UAAA,SAAAiO,EAAAC,GAEA,GAAA9F,GAAAtvF,KAAAse,QAKA,OAHAgxE,GAAA,IAAA6F,EAAA7F,EAAA,GAA2BA,EAAA,IAAA6F,EAAA7F,EAAA,GAAyBA,EAAA,IAAA6F,EAAA7F,EAAA,GACpDA,EAAA,IAAA8F,EAAA9F,EAAA,GAA2BA,EAAA,IAAA8F,EAAA9F,EAAA,GAAyBA,EAAA,IAAA8F,EAAA9F,EAAA,GAEpDtvF,MAIAs4C,OAAA,SAAAl7B,GAKA,OAHAkyE,GAAAtvF,KAAAse,SACAixE,EAAAnyE,EAAAkB,SAEAnf,EAAA,EAAmBA,EAAA,EAAOA,IAE1B,GAAAmwF,EAAAnwF,KAAAowF,EAAApwF,GAAA,QAIA,WAIAukD,UAAA,SAAA3iD,EAAAma,GAEAzS,SAAAyS,MAAA,EAEA,QAAA/b,GAAA,EAAmBA,EAAA,EAAOA,IAE1Ba,KAAAse,SAAAnf,GAAA4B,EAAA5B,EAAA+b,EAIA,OAAAlb,OAIA0iB,QAAA,SAAA3hB,EAAAma,GAEAzS,SAAA1H,UACA0H,SAAAyS,MAAA,EAEA,IAAAo0E,GAAAtvF,KAAAse,QAcA,OAZAvd,GAAAma,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GAEAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GAEAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GACAvuF,EAAAma,EAAA,GAAAo0E,EAAA,GAEAvuF,IAYA,IAAAye,IAAA,CAkDAT,GAAAa,cAAAnX,OACAsW,EAAAe,gBAAA6qE,GAEA5rE,EAAA/gB,UAAAM,OAAAyrF,OAAAzrF,OAAAmT,OAAAgM,EAAAzf,YAEAmM,YAAA4U,EAEAojB,WAAA,EAEAt1B,MAAA,WAEA,UAAA7M,MAAAmK,aAAAyH,KAAA5R,OAIA4R,KAAA,SAAAq4E,GAkCA,MAhCAjqF,MAAAlC,KAAAmsF,EAAAnsF,KAEAkC,KAAAgf,MAAAirE,EAAAjrE,MACAhf,KAAA6f,QAAAoqE,EAAApqE,QAAAq/C,MAAA,GAEAl/D,KAAAif,QAAAgrE,EAAAhrE,QAEAjf,KAAAkf,MAAA+qE,EAAA/qE,MACAlf,KAAAmf,MAAA8qE,EAAA9qE,MAEAnf,KAAAof,UAAA6qE,EAAA7qE,UACApf,KAAAqf,UAAA4qE,EAAA5qE,UAEArf,KAAAsf,WAAA2qE,EAAA3qE,WAEAtf,KAAAqE,OAAA4lF,EAAA5lF,OACArE,KAAApC,KAAAqsF,EAAArsF,KAEAoC,KAAAkb,OAAAtJ,KAAAq4E,EAAA/uE,QACAlb,KAAAogB,OAAAxO,KAAAq4E,EAAA7pE,QACApgB,KAAA2d,OAAA/L,KAAAq4E,EAAAtsE,QACA3d,KAAAqgB,SAAA4pE,EAAA5pE,SAEArgB,KAAAsgB,iBAAA2pE,EAAA3pE,iBACAtgB,KAAAod,OAAAxL,KAAAq4E,EAAA7sE,QAEApd,KAAAugB,gBAAA0pE,EAAA1pE,gBACAvgB,KAAAwgB,iBAAAypE,EAAAzpE,iBACAxgB,KAAAygB,MAAAwpE,EAAAxpE,MACAzgB,KAAA0gB,gBAAAupE,EAAAvpE,gBACA1gB,KAAAuf,SAAA0qE,EAAA1qE,SAEAvf,MAIA0uE,OAAA,SAAAisB,GAUA,QAAAC,GAAA57E,GAEA,GAAA6I,EAEA,IAAA7I,YAAA0xB,mBAEA7oB,EAAA7I,MAEK,CAEL6I,EAAAzS,SAAA0U,gBAAA,yCACAjC,EAAA9G,MAAA/B,EAAA+B,MACA8G,EAAA7G,OAAAhC,EAAAgC,MAEA,IAAA+I,GAAAlC,EAAAmC,WAAA,KAEAhL,aAAA67E,WAEA9wE,EAAA+wE,aAAA97E,EAAA,KAIA+K,EAAAumB,UAAAtxB,EAAA,IAAAA,EAAA+B,MAAA/B,EAAAgC,QAMA,MAAA6G,GAAA9G,MAAA,MAAA8G,EAAA7G,OAAA,KAEA6G,EAAAkzE,UAAA,iBAIAlzE,EAAAkzE,UAAA,aA1CA,GAAAC,GAAAvyF,SAAAkyF,GAAA,gBAAAA,EAEA,KAAAK,GAAAvyF,SAAAkyF,EAAA3yE,SAAAhoB,KAAAyf,MAEA,MAAAk7E,GAAA3yE,SAAAhoB,KAAAyf,KA4CA,IAAAuqE,IACAiR,UACAt5F,QAAA,IACA/D,KAAA,UACAs9F,UAAA,kBAGAz7E,KAAAzf,KAAAyf,KACA3hB,KAAAkC,KAAAlC,KAEAmhB,QAAAjf,KAAAif,QAEAmB,QAAApgB,KAAAogB,OAAA9K,EAAAtV,KAAAogB,OAAA3K,GACAyF,QAAAlb,KAAAkb,OAAA5F,EAAAtV,KAAAkb,OAAAzF,GACAkI,QAAA3d,KAAA2d,OAAArI,EAAAtV,KAAA2d,OAAAlI,GACA4K,SAAArgB,KAAAqgB,SAEA86E,MAAAn7F,KAAAkf,MAAAlf,KAAAmf,OAEAE,UAAArf,KAAAqf,UACAD,UAAApf,KAAAof,UACAE,WAAAtf,KAAAsf,WAEAmB,MAAAzgB,KAAAygB,MAGA,IAAAhY,SAAAzI,KAAAgf,MAAA,CAIA,GAAAA,GAAAhf,KAAAgf,KAEAvW,UAAAuW,EAAAS,OAEAT,EAAAS,KAAAC,GAAAC,gBAIAq7E,GAAAvyF,SAAAkyF,EAAA54E,OAAA/C,EAAAS,QAEAk7E,EAAA54E,OAAA/C,EAAAS,OACAA,KAAAT,EAAAS,KACApV,IAAAuwF,EAAA57E,KAKAgrE,EAAAhrE,QAAAS,KAUA,MANAu7E,KAEAL,EAAA3yE,SAAAhoB,KAAAyf,MAAAuqE,GAIAA,GAIAztE,QAAA,WAEAvc,KAAA4Y,eAAwBhb,KAAA,aAIxBw9F,YAAA,SAAApyE,GAEA,GAAAhpB,KAAAif,UAAA0rE,GAAA,CAIA,GAFA3hE,EAAAukE,aAAAvtF,KAAAod,QAEA4L,EAAA1T,EAAA,GAAA0T,EAAA1T,EAAA,EAEA,OAAAtV,KAAAkf,OAEA,IAAAunC,IAEAz9B,EAAA1T,EAAA0T,EAAA1T,EAAA5Q,KAAAyB,MAAA6iB,EAAA1T,EACA,MAEA,KAAAyK,IAEAiJ,EAAA1T,EAAA0T,EAAA1T,EAAA,KACA,MAEA,KAAAqxC,IAEA,IAAAjiD,KAAA2+B,IAAA3+B,KAAAyB,MAAA6iB,EAAA1T,GAAA,GAEA0T,EAAA1T,EAAA5Q,KAAAioF,KAAA3jE,EAAA1T,GAAA0T,EAAA1T,EAIA0T,EAAA1T,EAAA0T,EAAA1T,EAAA5Q,KAAAyB,MAAA6iB,EAAA1T,GASA,GAAA0T,EAAAvT,EAAA,GAAAuT,EAAAvT,EAAA,EAEA,OAAAzV,KAAAmf,OAEA,IAAAsnC,IAEAz9B,EAAAvT,EAAAuT,EAAAvT,EAAA/Q,KAAAyB,MAAA6iB,EAAAvT,EACA,MAEA,KAAAsK,IAEAiJ,EAAAvT,EAAAuT,EAAAvT,EAAA,KACA,MAEA,KAAAkxC,IAEA,IAAAjiD,KAAA2+B,IAAA3+B,KAAAyB,MAAA6iB,EAAAvT,GAAA,GAEAuT,EAAAvT,EAAA/Q,KAAAioF,KAAA3jE,EAAAvT,GAAAuT,EAAAvT,EAIAuT,EAAAvT,EAAAuT,EAAAvT,EAAA/Q,KAAAyB,MAAA6iB,EAAAvT,GASAzV,KAAAygB,QAEAuI,EAAAvT,EAAA,EAAAuT,EAAAvT,OAQAnX,OAAAD,eAAA0gB,EAAA/gB,UAAA,eAEAwW,IAAA,SAAAxJ,GAEAA,KAAA,GAAAhL,KAAA2B,aAuBArD,OAAAyrF,OAAAlpE,EAAA7iB,WAEAq9F,WAAA,EAEA7mF,IAAA,SAAAc,EAAAG,EAAA+I,EAAAC,GAOA,MALAze,MAAAsV,IACAtV,KAAAyV,IACAzV,KAAAwe,IACAxe,KAAAye,IAEAze,MAIA6sF,UAAA,SAAAC,GAOA,MALA9sF,MAAAsV,EAAAw3E,EACA9sF,KAAAyV,EAAAq3E,EACA9sF,KAAAwe,EAAAsuE,EACA9sF,KAAAye,EAAAquE,EAEA9sF,MAIA+sF,KAAA,SAAAz3E,GAIA,MAFAtV,MAAAsV,IAEAtV,MAIAgtF,KAAA,SAAAv3E,GAIA,MAFAzV,MAAAyV,IAEAzV,MAIAi5F,KAAA,SAAAz6E,GAIA,MAFAxe,MAAAwe,IAEAxe,MAIAs7F,KAAA,SAAA78E,GAIA,MAFAze,MAAAye,IAEAze,MAIAitF,aAAA,SAAA1gF,EAAAvB,GAEA,OAAAuB,GAEA,OAAAvM,KAAAsV,EAAAtK,CAA2B,MAC3B,QAAAhL,KAAAyV,EAAAzK,CAA2B,MAC3B,QAAAhL,KAAAwe,EAAAxT,CAA2B,MAC3B,QAAAhL,KAAAye,EAAAzT,CAA2B,MAC3B,kBAAAvL,OAAA,0BAAA8M,GAIA,MAAAvM,OAIAktF,aAAA,SAAA3gF,GAEA,OAAAA,GAEA,aAAAvM,MAAAsV,CACA,cAAAtV,MAAAyV,CACA,cAAAzV,MAAAwe,CACA,cAAAxe,MAAAye,CACA,kBAAAhf,OAAA,0BAAA8M,KAMAM,MAAA,WAEA,UAAA7M,MAAAmK,YAAAnK,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAwe,EAAAxe,KAAAye,IAIA7M,KAAA,SAAA5K,GAOA,MALAhH,MAAAsV,EAAAtO,EAAAsO,EACAtV,KAAAyV,EAAAzO,EAAAyO,EACAzV,KAAAwe,EAAAxX,EAAAwX,EACAxe,KAAAye,EAAAhW,SAAAzB,EAAAyX,EAAAzX,EAAAyX,EAAA,EAEAze,MAIAuS,IAAA,SAAAvL,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,yFACAlU,KAAA8lE,WAAA9+D,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EACAzV,KAAAwe,GAAAxX,EAAAwX,EACAxe,KAAAye,GAAAzX,EAAAyX,EAEAze,OAIAmtF,UAAA,SAAApmF,GAOA,MALA/G,MAAAsV,GAAAvO,EACA/G,KAAAyV,GAAA1O,EACA/G,KAAAwe,GAAAzX,EACA/G,KAAAye,GAAA1X,EAEA/G,MAIA8lE,WAAA,SAAAr4D,EAAAjI,GAOA,MALAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EACAzV,KAAAwe,EAAA/Q,EAAA+Q,EAAAhZ,EAAAgZ,EACAxe,KAAAye,EAAAhR,EAAAgR,EAAAjZ,EAAAiZ,EAEAze,MAIAotF,gBAAA,SAAApmF,EAAAD,GAOA,MALA/G,MAAAsV,GAAAtO,EAAAsO,EAAAvO,EACA/G,KAAAyV,GAAAzO,EAAAyO,EAAA1O,EACA/G,KAAAwe,GAAAxX,EAAAwX,EAAAzX,EACA/G,KAAAye,GAAAzX,EAAAyX,EAAA1X,EAEA/G,MAIA2b,IAAA,SAAA3U,EAAAyX,GAEA,MAAAhW,UAAAgW,GAEAnP,QAAA4E,KAAA,yFACAlU,KAAAkV,WAAAlO,EAAAyX,KAIAze,KAAAsV,GAAAtO,EAAAsO,EACAtV,KAAAyV,GAAAzO,EAAAyO,EACAzV,KAAAwe,GAAAxX,EAAAwX,EACAxe,KAAAye,GAAAzX,EAAAyX,EAEAze,OAIAqtF,UAAA,SAAAtmF,GAOA,MALA/G,MAAAsV,GAAAvO,EACA/G,KAAAyV,GAAA1O,EACA/G,KAAAwe,GAAAzX,EACA/G,KAAAye,GAAA1X,EAEA/G,MAIAkV,WAAA,SAAAzH,EAAAjI,GAOA,MALAxF,MAAAsV,EAAA7H,EAAA6H,EAAA9P,EAAA8P,EACAtV,KAAAyV,EAAAhI,EAAAgI,EAAAjQ,EAAAiQ,EACAzV,KAAAwe,EAAA/Q,EAAA+Q,EAAAhZ,EAAAgZ,EACAxe,KAAAye,EAAAhR,EAAAgR,EAAAjZ,EAAAiZ,EAEAze,MAIA8c,eAAA,SAAAgwE,GAOA,MALA9sF,MAAAsV,GAAAw3E,EACA9sF,KAAAyV,GAAAq3E,EACA9sF,KAAAwe,GAAAsuE,EACA9sF,KAAAye,GAAAquE,EAEA9sF,MAIA8jD,aAAA,SAAAv+C,GAEA,GAAA+P,GAAAtV,KAAAsV,EAAAG,EAAAzV,KAAAyV,EAAA+I,EAAAxe,KAAAwe,EAAAC,EAAAze,KAAAye,EACAnf,EAAAiG,EAAA+Y,QAOA,OALAte,MAAAsV,EAAAhW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EAAAlf,EAAA,IAAAmf,EACAze,KAAAyV,EAAAnW,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,GAAAkf,EAAAlf,EAAA,IAAAmf,EACAze,KAAAwe,EAAAlf,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,IAAAkf,EAAAlf,EAAA,IAAAmf,EACAze,KAAAye,EAAAnf,EAAA,GAAAgW,EAAAhW,EAAA,GAAAmW,EAAAnW,EAAA,IAAAkf,EAAAlf,EAAA,IAAAmf,EAEAze,MAIAmjE,aAAA,SAAA2pB,GAEA,MAAA9sF,MAAA8c,eAAA,EAAAgwE,IAIAyO,2BAAA,SAAAn0F,GAMApH,KAAAye,EAAA,EAAA/Z,KAAAw1F,KAAA9yF,EAAAqX,EAEA,IAAA1X,GAAArC,KAAA2S,KAAA,EAAAjQ,EAAAqX,EAAArX,EAAAqX,EAgBA,OAdA1X,GAAA,MAEA/G,KAAAsV,EAAA,EACAtV,KAAAyV,EAAA,EACAzV,KAAAwe,EAAA,IAIAxe,KAAAsV,EAAAlO,EAAAkO,EAAAvO,EACA/G,KAAAyV,EAAArO,EAAAqO,EAAA1O,EACA/G,KAAAwe,EAAApX,EAAAoX,EAAAzX,GAIA/G,MAIAw7F,+BAAA,SAAAj2F,GAMA,GAAA4N,GAAAmC,EAAAG,EAAA+I,EACAi9E,EAAA,IACAC,EAAA,GAEApM,EAAA/pF,EAAA+Y,SAEAg5E,EAAAhI,EAAA,GAAAiI,EAAAjI,EAAA,GAAAkI,EAAAlI,EAAA,GACAmI,EAAAnI,EAAA,GAAAoI,EAAApI,EAAA,GAAAqI,EAAArI,EAAA,GACAsI,EAAAtI,EAAA,GAAAuI,EAAAvI,EAAA,GAAAwI,EAAAxI,EAAA,GAEA,IAAA5qF,KAAA2+B,IAAAk0D,EAAAE,GAAAgE,GACA/2F,KAAA2+B,IAAAm0D,EAAAI,GAAA6D,GACA/2F,KAAA2+B,IAAAs0D,EAAAE,GAAA4D,EAAA,CAMA,GAAA/2F,KAAA2+B,IAAAk0D,EAAAE,GAAAiE,GACAh3F,KAAA2+B,IAAAm0D,EAAAI,GAAA8D,GACAh3F,KAAA2+B,IAAAs0D,EAAAE,GAAA6D,GACAh3F,KAAA2+B,IAAAi0D,EAAAI,EAAAI,EAAA,GAAA4D,EAMA,MAFA17F,MAAAwU,IAAA,SAEAxU,IAMAmT,GAAAzO,KAAAmO,EAEA,IAAAq+E,IAAAoG,EAAA,KACAjG,GAAAqG,EAAA,KACAnG,GAAAuG,EAAA,KACA3G,GAAAoG,EAAAE,GAAA,EACArG,GAAAoG,EAAAI,GAAA,EACAtG,GAAAqG,EAAAE,GAAA,CA4DA,OA1DA3G,GAAAG,GAAAH,EAAAK,EAIAL,EAAAuK,GAEAnmF,EAAA,EACAG,EAAA,WACA+I,EAAA,aAIAlJ,EAAA5Q,KAAA2S,KAAA65E,GACAz7E,EAAA07E,EAAA77E,EACAkJ,EAAA4yE,EAAA97E,GAIK+7E,EAAAE,EAILF,EAAAoK,GAEAnmF,EAAA,WACAG,EAAA,EACA+I,EAAA,aAIA/I,EAAA/Q,KAAA2S,KAAAg6E,GACA/7E,EAAA67E,EAAA17E,EACA+I,EAAA8yE,EAAA77E,GAQA87E,EAAAkK,GAEAnmF,EAAA,WACAG,EAAA,WACA+I,EAAA,IAIAA,EAAA9Z,KAAA2S,KAAAk6E,GACAj8E,EAAA87E,EAAA5yE,EACA/I,EAAA67E,EAAA9yE,GAMAxe,KAAAwU,IAAAc,EAAAG,EAAA+I,EAAArL,GAEAnT,KAMA,GAAA+G,GAAArC,KAAA2S,MAAAwgF,EAAAF,IAAAE,EAAAF,IACAH,EAAAI,IAAAJ,EAAAI,IACAH,EAAAF,IAAAE,EAAAF,GAYA,OAVA7yF,MAAA2+B,IAAAt8B,GAAA,OAAAA,EAAA,GAKA/G,KAAAsV,GAAAuiF,EAAAF,GAAA5wF,EACA/G,KAAAyV,GAAA+hF,EAAAI,GAAA7wF,EACA/G,KAAAwe,GAAAi5E,EAAAF,GAAAxwF,EACA/G,KAAAye,EAAA/Z,KAAAw1F,MAAA5C,EAAAI,EAAAI,EAAA,MAEA93F,MAIAqG,IAAA,SAAAW,GAOA,MALAhH,MAAAsV,EAAA5Q,KAAA2B,IAAArG,KAAAsV,EAAAtO,EAAAsO,GACAtV,KAAAyV,EAAA/Q,KAAA2B,IAAArG,KAAAyV,EAAAzO,EAAAyO,GACAzV,KAAAwe,EAAA9Z,KAAA2B,IAAArG,KAAAwe,EAAAxX,EAAAwX,GACAxe,KAAAye,EAAA/Z,KAAA2B,IAAArG,KAAAye,EAAAzX,EAAAyX,GAEAze,MAIAoG,IAAA,SAAAY,GAOA,MALAhH,MAAAsV,EAAA5Q,KAAA0B,IAAApG,KAAAsV,EAAAtO,EAAAsO,GACAtV,KAAAyV,EAAA/Q,KAAA0B,IAAApG,KAAAyV,EAAAzO,EAAAyO,GACAzV,KAAAwe,EAAA9Z,KAAA0B,IAAApG,KAAAwe,EAAAxX,EAAAwX,GACAxe,KAAAye,EAAA/Z,KAAA0B,IAAApG,KAAAye,EAAAzX,EAAAyX,GAEAze,MAIAutE,MAAA,SAAAlnE,EAAAD,GASA,MALApG,MAAAsV,EAAA5Q,KAAA0B,IAAAC,EAAAiP,EAAA5Q,KAAA2B,IAAAD,EAAAkP,EAAAtV,KAAAsV,IACAtV,KAAAyV,EAAA/Q,KAAA0B,IAAAC,EAAAoP,EAAA/Q,KAAA2B,IAAAD,EAAAqP,EAAAzV,KAAAyV,IACAzV,KAAAwe,EAAA9Z,KAAA0B,IAAAC,EAAAmY,EAAA9Z,KAAA2B,IAAAD,EAAAoY,EAAAxe,KAAAwe,IACAxe,KAAAye,EAAA/Z,KAAA0B,IAAAC,EAAAoY,EAAA/Z,KAAA2B,IAAAD,EAAAqY,EAAAze,KAAAye,IAEAze,MAIAwtF,YAAA,WAEA,GAAAnnF,GAAAD,CAEA,iBAAAqnF,EAAAC,GAYA,MAVAjlF,UAAApC,IAEAA,EAAA,GAAAwa,GACAza,EAAA,GAAAya,IAIAxa,EAAAmO,IAAAi5E,SACArnF,EAAAoO,IAAAk5E,SAEA1tF,KAAAutE,MAAAlnE,EAAAD,OAMAunF,YAAA,SAAAtnF,EAAAD,GAEA,GAAArI,GAAAiC,KAAAjC,QAEA,OAAAiC,MAAAmjE,aAAAplE,GAAA,GAAA+e,eAAApY,KAAA0B,IAAAC,EAAA3B,KAAA2B,IAAAD,EAAArI,MAIAoI,MAAA,WAOA,MALAnG,MAAAsV,EAAA5Q,KAAAyB,MAAAnG,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAyB,MAAAnG,KAAAyV,GACAzV,KAAAwe,EAAA9Z,KAAAyB,MAAAnG,KAAAwe,GACAxe,KAAAye,EAAA/Z,KAAAyB,MAAAnG,KAAAye,GAEAze,MAIA2sF,KAAA,WAOA,MALA3sF,MAAAsV,EAAA5Q,KAAAioF,KAAA3sF,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAioF,KAAA3sF,KAAAyV,GACAzV,KAAAwe,EAAA9Z,KAAAioF,KAAA3sF,KAAAwe,GACAxe,KAAAye,EAAA/Z,KAAAioF,KAAA3sF,KAAAye,GAEAze,MAIAkI,MAAA,WAOA,MALAlI,MAAAsV,EAAA5Q,KAAAwD,MAAAlI,KAAAsV,GACAtV,KAAAyV,EAAA/Q,KAAAwD,MAAAlI,KAAAyV,GACAzV,KAAAwe,EAAA9Z,KAAAwD,MAAAlI,KAAAwe,GACAxe,KAAAye,EAAA/Z,KAAAwD,MAAAlI,KAAAye,GAEAze,MAIA4tF,YAAA,WAOA,MALA5tF,MAAAsV,EAAAtV,KAAAsV,EAAA,EAAA5Q,KAAAioF,KAAA3sF,KAAAsV,GAAA5Q,KAAAyB,MAAAnG,KAAAsV,GACAtV,KAAAyV,EAAAzV,KAAAyV,EAAA,EAAA/Q,KAAAioF,KAAA3sF,KAAAyV,GAAA/Q,KAAAyB,MAAAnG,KAAAyV,GACAzV,KAAAwe,EAAAxe,KAAAwe,EAAA,EAAA9Z,KAAAioF,KAAA3sF,KAAAwe,GAAA9Z,KAAAyB,MAAAnG,KAAAwe,GACAxe,KAAAye,EAAAze,KAAAye,EAAA,EAAA/Z,KAAAioF,KAAA3sF,KAAAye,GAAA/Z,KAAAyB,MAAAnG,KAAAye,GAEAze,MAIA6tF,OAAA,WAOA,MALA7tF,MAAAsV,GAAAtV,KAAAsV,EACAtV,KAAAyV,GAAAzV,KAAAyV,EACAzV,KAAAwe,GAAAxe,KAAAwe,EACAxe,KAAAye,GAAAze,KAAAye,EAEAze,MAIAqc,IAAA,SAAArV,GAEA,MAAAhH,MAAAsV,EAAAtO,EAAAsO,EAAAtV,KAAAyV,EAAAzO,EAAAyO,EAAAzV,KAAAwe,EAAAxX,EAAAwX,EAAAxe,KAAAye,EAAAzX,EAAAyX,GAIAqvE,SAAA,WAEA,MAAA9tF,MAAAsV,EAAAtV,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAyV,EAAAzV,KAAAwe,EAAAxe,KAAAwe,EAAAxe,KAAAye,EAAAze,KAAAye,GAIA1gB,OAAA,WAEA,MAAA2G,MAAA2S,KAAArX,KAAAsV,EAAAtV,KAAAsV,EAAAtV,KAAAyV,EAAAzV,KAAAyV,EAAAzV,KAAAwe,EAAAxe,KAAAwe,EAAAxe,KAAAye,EAAAze,KAAAye,IAIAsvE,gBAAA,WAEA,MAAArpF,MAAA2+B,IAAArjC,KAAAsV,GAAA5Q,KAAA2+B,IAAArjC,KAAAyV,GAAA/Q,KAAA2+B,IAAArjC,KAAAwe,GAAA9Z,KAAA2+B,IAAArjC,KAAAye,IAIAyvC,UAAA,WAEA,MAAAluD,MAAAmjE,aAAAnjE,KAAAjC,UAAA,IAIAqpF,UAAA,SAAArpF,GAEA,MAAAiC,MAAAkuD,YAAApxC,eAAA/e,IAIAkkE,KAAA,SAAAj7D,EAAAvC,GAOA,MALAzE,MAAAsV,IAAAtO,EAAAsO,EAAAtV,KAAAsV,GAAA7Q,EACAzE,KAAAyV,IAAAzO,EAAAyO,EAAAzV,KAAAyV,GAAAhR,EACAzE,KAAAwe,IAAAxX,EAAAwX,EAAAxe,KAAAwe,GAAA/Z,EACAzE,KAAAye,IAAAzX,EAAAyX,EAAAze,KAAAye,GAAAha,EAEAzE,MAIAkuF,YAAA,SAAA9oF,EAAAE,EAAAb,GAEA,MAAAzE,MAAAkV,WAAA5P,EAAAF,GAAA0X,eAAArY,GAAA8N,IAAAnN,IAIAkzC,OAAA,SAAAtxC,GAEA,MAAAA,GAAAsO,IAAAtV,KAAAsV,GAAAtO,EAAAyO,IAAAzV,KAAAyV,GAAAzO,EAAAwX,IAAAxe,KAAAwe,GAAAxX,EAAAyX,IAAAze,KAAAye,GAIAilC,UAAA,SAAA3iD,EAAAma,GASA,MAPAzS,UAAAyS,MAAA,GAEAlb,KAAAsV,EAAAvU,EAAAma,GACAlb,KAAAyV,EAAA1U,EAAAma,EAAA,GACAlb,KAAAwe,EAAAzd,EAAAma,EAAA,GACAlb,KAAAye,EAAA1d,EAAAma,EAAA,GAEAlb,MAIA0iB,QAAA,SAAA3hB,EAAAma,GAUA,MARAzS,UAAA1H,UACA0H,SAAAyS,MAAA,GAEAna,EAAAma,GAAAlb,KAAAsV,EACAvU,EAAAma,EAAA,GAAAlb,KAAAyV,EACA1U,EAAAma,EAAA,GAAAlb,KAAAwe,EACAzd,EAAAma,EAAA,GAAAlb,KAAAye,EAEA1d,GAIAggE,oBAAA,SAAAtpC,EAAAlrB,EAAA2O,GAaA,MAXAzS,UAAAyS,GAEA5L,QAAA4E,KAAA,uEAIAlU,KAAAsV,EAAAmiB,EAAAqpC,KAAAv0D,GACAvM,KAAAyV,EAAAgiB,EAAA02D,KAAA5hF,GACAvM,KAAAwe,EAAAiZ,EAAAo8D,KAAAtnF,GACAvM,KAAAye,EAAAgZ,EAAAkkE,KAAApvF,GAEAvM,QAyCA8gB,EAAA9iB,UAAAM,OAAAyrF,OAAAzrF,OAAAmT,OAAAgM,EAAAzf,YAEAmM,YAAA2W,EAEA6sB,qBAAA,EAEA+sB,QAAA,SAAA35C,EAAAC,GAEAhhB,KAAA+gB,WAAA/gB,KAAAghB,aAEAhhB,KAAA+gB,QACA/gB,KAAAghB,SAEAhhB,KAAAuc,WAIAvc,KAAAmhB,SAAA3M,IAAA,IAAAuM,EAAAC,GACAhhB,KAAAihB,QAAAzM,IAAA,IAAAuM,EAAAC,IAIAnU,MAAA,WAEA,UAAA7M,MAAAmK,aAAAyH,KAAA5R,OAIA4R,KAAA,SAAAq4E,GAaA,MAXAjqF,MAAA+gB,MAAAkpE,EAAAlpE,MACA/gB,KAAAghB,OAAAipE,EAAAjpE,OAEAhhB,KAAAmhB,SAAAvP,KAAAq4E,EAAA9oE,UAEAnhB,KAAAohB,QAAA6oE,EAAA7oE,QAAAvU,QAEA7M,KAAAqhB,YAAA4oE,EAAA5oE,YACArhB,KAAAshB,cAAA2oE,EAAA3oE,cACAthB,KAAAuhB,aAAA0oE,EAAA1oE,aAEAvhB,MAIAuc,QAAA,WAEAvc,KAAA4Y,eAAwBhb,KAAA,eAmBxB4jB,EAAAxjB,UAAAM,OAAAmT,OAAAqP,EAAA9iB,WACAwjB,EAAAxjB,UAAAmM,YAAAqX,EAEAA,EAAAxjB,UAAAk0C,yBAAA,EAqBAvwB,EAAA3jB,UAAAM,OAAAmT,OAAAsN,EAAA/gB,WACA2jB,EAAA3jB,UAAAmM,YAAAwX,EAEAA,EAAA3jB,UAAAo1C,eAAA,EAiBAtxB,EAAA9jB,UAAAM,OAAAmT,OAAAsN,EAAA/gB,WACA8jB,EAAA9jB,UAAAmM,YAAA2X,EAEAA,EAAA9jB,UAAA4jC,eAAA,EAEAtjC,OAAAD,eAAAyjB,EAAA9jB,UAAA,UAEA4f,IAAA,WAEA,MAAA5d,MAAAgf,OAIAxK,IAAA,SAAAxJ,GAEAhL,KAAAgf,MAAAhU,IAuDA,IAAA0Z,IAAA,GAAA3F,GACA8F,GAAA,GAAA/C,GAeAW,MACAI,MAIAyB,GAAA,GAAAlT,cAAA,IACA+S,GAAA,GAAA/S,cAAA,EAoXAoV,GAAAxoB,UAAAsoB,SAAA,SAAArD,EAAAjY,GAOA,OAFAkX,GAAAliB,KAAAkiB,IAEA/iB,EAAA,EAAAqjB,EAAAN,EAAAnkB,OAAkCoB,IAAAqjB,IAASrjB,EAAA,CAE3C,GAAAq+B,GAAAtb,EAAA/iB,EACAq+B,GAAAlX,SAAArD,EAAAjY,EAAAwyB,EAAA9uB,MAUA,IAAAmY,IAAA,0BA0FAM,GAAAnpB,UAAAsoB,SAAA,SAAArD,EAAAnlB,EAAAkN,GAEA,GAAAwyB,GAAAx9B,KAAAmiB,IAAArkB,EAEA2K,UAAA+0B,KAAAlX,SAAArD,EAAAjY,EAAAhL,KAAA4iB,WAIAuE,EAAAnpB,UAAAy3D,YAAA,SAAAxyC,EAAA5X,EAAAvN,GAEA,GAAAkJ,GAAAqE,EAAAvN,EAEA2K,UAAAzB,GAAAhH,KAAAsmB,SAAArD,EAAAnlB,EAAAkJ,IAOAmgB,EAAAwwC,OAAA,SAAA10C,EAAAf,EAAAm0D,EAAAzzD,GAEA,OAAAzjB,GAAA,EAAAqjB,EAAAN,EAAAnkB,OAAkCoB,IAAAqjB,IAASrjB,EAAA,CAE3C,GAAAq+B,GAAAtb,EAAA/iB,GACA6H,EAAAqvE,EAAA74C,EAAA9uB,GAEA1H,GAAA8gB,eAAA,GAGA0V,EAAAlX,SAAArD,EAAAjc,EAAAgE,MAAA4X,KAQAuE,EAAAmtC,aAAA,SAAApyC,EAAAm0D,GAIA,OAFA/uE,MAEAnI,EAAA,EAAAqjB,EAAAN,EAAAnkB,OAAkCoB,IAAAqjB,IAASrjB,EAAA,CAE3C,GAAAq+B,GAAAtb,EAAA/iB,EACAq+B,GAAA9uB,KAAA2nE,IAAA/uE,EAAAjG,KAAAm8B,GAIA,MAAAl2B,GAQA,IAAAs0F,KAAsBC,UAAA,SAAAC,aAAA,SAAAC,KAAA,MAAAC,WAAA,QAAAC,MAAA,SACtBC,MAAA,SAAAC,OAAA,SAAAC,MAAA,EAAAC,eAAA,SAAAx0F,KAAA,IAAAy0F,WAAA,QACAC,MAAA,SAAAC,UAAA,SAAAC,UAAA,QAAAC,WAAA,QAAAC,UAAA,SAAAC,MAAA,SACAC,eAAA,QAAAC,SAAA,SAAAC,QAAA,SAAAC,KAAA,MAAAC,SAAA,IAAAC,SAAA,MACAC,cAAA,SAAAC,SAAA,SAAAC,UAAA,MAAAC,SAAA,SAAAC,UAAA,SAAAC,YAAA,QACAC,eAAA,QAAAC,WAAA,SAAAC,WAAA,SAAAC,QAAA,QAAAC,WAAA,SAAAC,aAAA,QACAC,cAAA,QAAAC,cAAA,QAAAC,cAAA,QAAAC,cAAA,MAAAC,WAAA,QACAC,SAAA,SAAAC,YAAA,MAAAC,QAAA;AAAAC,QAAA,QAAAC,WAAA,QAAAC,UAAA,SACAC,YAAA,SAAAC,YAAA,QAAAC,QAAA,SAAAC,UAAA,SAAAC,WAAA,SAAAC,KAAA,SACAC,UAAA,SAAAC,KAAA,QAAAr3F,MAAA,MAAAs3F,YAAA,SAAAC,KAAA,QAAAC,SAAA,SAAAC,QAAA,SACAC,UAAA,SAAAC,OAAA,QAAAC,MAAA,SAAAC,MAAA,SAAAC,SAAA,SAAAC,cAAA,SAAAC,UAAA,QACAC,aAAA,SAAAC,UAAA,SAAAC,WAAA,SAAAC,UAAA,SAAAC,qBAAA,SAAAC,UAAA,SACAC,WAAA,QAAAC,UAAA,SAAAC,UAAA,SAAAC,YAAA,SAAAC,cAAA,QAAAC,aAAA,QACAC,eAAA,QAAAC,eAAA,QAAAC,eAAA,SAAAC,YAAA,SAAAC,KAAA,MAAAC,UAAA,QACAC,MAAA,SAAAC,QAAA,SAAAC,OAAA,QAAAC,iBAAA,QAAAC,WAAA,IAAAC,aAAA,SACAC,aAAA,QAAAC,eAAA,QAAAC,gBAAA,QAAAC,kBAAA,MAAAC,gBAAA,QACAC,gBAAA,SAAAC,aAAA,QAAAC,UAAA,SAAAC,UAAA,SAAAC,SAAA,SAAAC,YAAA,SACAC,KAAA,IAAAC,QAAA,SAAAC,MAAA,QAAAC,UAAA,QAAAC,OAAA,SAAAC,UAAA,SAAAC,OAAA,SACAC,cAAA,SAAAC,UAAA,SAAAC,cAAA,SAAAC,cAAA,SAAAC,WAAA,SAAAC,UAAA,SACAC,KAAA,SAAAC,KAAA,SAAAC,KAAA,SAAAC,WAAA,SAAAC,OAAA,QAAAC,cAAA,QAAAx7F,IAAA,SAAAy7F,UAAA,SACAC,UAAA,QAAAC,YAAA,QAAAC,OAAA,SAAAC,WAAA,SAAAC,SAAA,QAAAC,SAAA,SACAC,OAAA,SAAAC,OAAA,SAAAC,QAAA,QAAAC,UAAA,QAAAC,UAAA,QAAAC,UAAA,QAAAC,KAAA,SACAC,YAAA,MAAAC,UAAA,QAAAhnF,IAAA,SAAAinF,KAAA,MAAAC,QAAA,SAAAC,OAAA,SAAAC,UAAA,QACAC,OAAA,SAAAC,MAAA,SAAAC,MAAA,SAAAC,WAAA,SAAAC,OAAA,SAAAC,YAAA,SAeAtmG,QAAAyrF,OAAAriE,EAAA1pB,WAEA48B,SAAA,EAEAtzB,EAAA,EAAAC,EAAA,EAAA/B,EAAA,EAEAgP,IAAA,SAAAxJ,GAgBA,MAdAA,MAAA4vB,QAEA56B,KAAA4R,KAAA5G,GAEI,gBAAAA,GAEJhL,KAAA6kG,OAAA75F,GAEI,gBAAAA,IAEJhL,KAAA8kG,SAAA95F,GAIAhL,MAIA6sF,UAAA,SAAAC,GAMA,MAJA9sF,MAAAsH,EAAAwlF,EACA9sF,KAAAuH,EAAAulF,EACA9sF,KAAAwF,EAAAsnF,EAEA9sF,MAIA6kG,OAAA,SAAAp+F,GAQA,MANAA,GAAA/B,KAAAyB,MAAAM,GAEAzG,KAAAsH,GAAAb,GAAA,YACAzG,KAAAuH,GAAAd,GAAA,WACAzG,KAAAwF,GAAA,IAAAiB,GAAA,IAEAzG,MAIA2nB,OAAA,SAAArgB,EAAAC,EAAA/B,GAMA,MAJAxF,MAAAsH,IACAtH,KAAAuH,IACAvH,KAAAwF,IAEAxF,MAIA+kG,OAAA,WAEA,QAAAC,GAAA79F,EAAAC,EAAAC,GAIA,MAFAA,GAAA,IAAAA,GAAA,GACAA,EAAA,IAAAA,GAAA,GACAA,EAAA,IAAAF,EAAA,GAAAC,EAAAD,GAAAE,EACAA,EAAA,GAAAD,EACAC,EAAA,IAAAF,EAAA,GAAAC,EAAAD,IAAA,IAAAE,GACAF,EAIA,gBAAAL,EAAAC,EAAAoI,GAOA,GAJArI,EAAA4Y,GAAAksE,gBAAA9kF,EAAA,GACAC,EAAA2Y,GAAA6tD,MAAAxmE,EAAA,KACAoI,EAAAuQ,GAAA6tD,MAAAp+D,EAAA,KAEA,IAAApI,EAEA/G,KAAAsH,EAAAtH,KAAAuH,EAAAvH,KAAAwF,EAAA2J,MAEK,CAEL,GAAAhI,GAAAgI,GAAA,GAAAA,GAAA,EAAApI,GAAAoI,EAAApI,EAAAoI,EAAApI,EACAK,EAAA,EAAA+H,EAAAhI,CAEAnH,MAAAsH,EAAA09F,EAAA59F,EAAAD,EAAAL,EAAA,KACA9G,KAAAuH,EAAAy9F,EAAA59F,EAAAD,EAAAL,GACA9G,KAAAwF,EAAAw/F,EAAA59F,EAAAD,EAAAL,EAAA,KAIA,MAAA9G,UAMA8kG,SAAA,SAAAlqC,GAEA,QAAAqqC,GAAA78F,GAEAK,SAAAL,GAEA+H,WAAA/H,GAAA,GAEAkH,QAAA4E,KAAA,mCAAA0mD,EAAA,qBAOA,GAAAr1D,EAEA,IAAAA,EAAA,kCAAA2K,KAAA0qD,GAAA,CAIA,GAAA/0D,GACA/H,EAAAyH,EAAA,GACAihC,EAAAjhC,EAAA,EAEA,QAAAzH,GAEA,UACA,WAEA,GAAA+H,EAAA,gEAAAqK,KAAAs2B,GASA,MANAxmC,MAAAsH,EAAA5C,KAAA2B,IAAA,IAAAX,SAAAG,EAAA,YACA7F,KAAAuH,EAAA7C,KAAA2B,IAAA,IAAAX,SAAAG,EAAA,YACA7F,KAAAwF,EAAAd,KAAA2B,IAAA,IAAAX,SAAAG,EAAA,YAEAo/F,EAAAp/F,EAAA,IAEA7F,IAIA,IAAA6F,EAAA,sEAAAqK,KAAAs2B,GASA,MANAxmC,MAAAsH,EAAA5C,KAAA2B,IAAA,IAAAX,SAAAG,EAAA,YACA7F,KAAAuH,EAAA7C,KAAA2B,IAAA,IAAAX,SAAAG,EAAA,YACA7F,KAAAwF,EAAAd,KAAA2B,IAAA,IAAAX,SAAAG,EAAA,YAEAo/F,EAAAp/F,EAAA,IAEA7F,IAIA,MAEA,WACA,WAEA,GAAA6F,EAAA,gFAAAqK,KAAAs2B,GAAA,CAGA,GAAA1/B,GAAAqJ,WAAAtK,EAAA,QACAkB,EAAArB,SAAAG,EAAA,WACAsJ,EAAAzJ,SAAAG,EAAA,UAIA,OAFAo/F,GAAAp/F,EAAA,IAEA7F,KAAA+kG,OAAAj+F,EAAAC,EAAAoI,SAQI,IAAA5J,EAAA,qBAAA2K,KAAA0qD,GAAA,CAIJ,GAAAn0D,GAAAlB,EAAA,GACAmgB,EAAAjf,EAAA1I,MAEA,QAAA2nB,EAOA,MAJA1lB,MAAAsH,EAAA5B,SAAAe,EAAAwJ,OAAA,GAAAxJ,EAAAwJ,OAAA,WACAjQ,KAAAuH,EAAA7B,SAAAe,EAAAwJ,OAAA,GAAAxJ,EAAAwJ,OAAA,WACAjQ,KAAAwF,EAAAE,SAAAe,EAAAwJ,OAAA,GAAAxJ,EAAAwJ,OAAA,WAEAjQ,IAEK,QAAA0lB,EAOL,MAJA1lB,MAAAsH,EAAA5B,SAAAe,EAAAwJ,OAAA,GAAAxJ,EAAAwJ,OAAA,WACAjQ,KAAAuH,EAAA7B,SAAAe,EAAAwJ,OAAA,GAAAxJ,EAAAwJ,OAAA,WACAjQ,KAAAwF,EAAAE,SAAAe,EAAAwJ,OAAA,GAAAxJ,EAAAwJ,OAAA,WAEAjQ,KAMA,GAAA46D,KAAA78D,OAAA,GAGA,GAAA0I,GAAAm1F,GAAAhhC,EAEAnyD,UAAAhC,EAGAzG,KAAA6kG,OAAAp+F,GAKA6I,QAAA4E,KAAA,8BAAA0mD,GAMA,MAAA56D,OAIA6M,MAAA,WAEA,UAAA7M,MAAAmK,YAAAnK,KAAAsH,EAAAtH,KAAAuH,EAAAvH,KAAAwF,IAIAoM,KAAA,SAAA/L,GAMA,MAJA7F,MAAAsH,EAAAzB,EAAAyB,EACAtH,KAAAuH,EAAA1B,EAAA0B,EACAvH,KAAAwF,EAAAK,EAAAL,EAEAxF,MAIAklG,kBAAA,SAAAr/F,EAAAokC,GAQA,MANAxhC,UAAAwhC,MAAA,GAEAjqC,KAAAsH,EAAA5C,KAAAsO,IAAAnN,EAAAyB,EAAA2iC,GACAjqC,KAAAuH,EAAA7C,KAAAsO,IAAAnN,EAAA0B,EAAA0iC,GACAjqC,KAAAwF,EAAAd,KAAAsO,IAAAnN,EAAAL,EAAAykC,GAEAjqC,MAIAmlG,kBAAA,SAAAt/F,EAAAokC,GAEAxhC,SAAAwhC,MAAA,EAEA,IAAAm7D,GAAAn7D,EAAA,IAAAA,EAAA,CAMA,OAJAjqC,MAAAsH,EAAA5C,KAAAsO,IAAAnN,EAAAyB,EAAA89F,GACAplG,KAAAuH,EAAA7C,KAAAsO,IAAAnN,EAAA0B,EAAA69F,GACAplG,KAAAwF,EAAAd,KAAAsO,IAAAnN,EAAAL,EAAA4/F,GAEAplG,MAIAqlG,qBAAA,WAEA,GAAA/9F,GAAAtH,KAAAsH,EAAAC,EAAAvH,KAAAuH,EAAA/B,EAAAxF,KAAAwF,CAMA,OAJAxF,MAAAsH,MACAtH,KAAAuH,MACAvH,KAAAwF,MAEAxF,MAIAslG,qBAAA,WAMA,MAJAtlG,MAAAsH,EAAA5C,KAAA2S,KAAArX,KAAAsH,GACAtH,KAAAuH,EAAA7C,KAAA2S,KAAArX,KAAAuH,GACAvH,KAAAwF,EAAAd,KAAA2S,KAAArX,KAAAwF,GAEAxF,MAIAulG,OAAA,WAEA,WAAAvlG,KAAAsH,GAAA,OAAAtH,KAAAuH,GAAA,MAAAvH,KAAAwF,GAAA,GAIAggG,aAAA,WAEA,gBAAAxlG,KAAAulG,SAAA7+F,SAAA,KAAAw4D,OAAA,IAIAumC,OAAA,SAAAC,GAIA,GAOAriG,GAAA2E,EAPAzD,EAAAmhG,IAAgC5+F,EAAA,EAAAC,EAAA,EAAAoI,EAAA,GAEhC7H,EAAAtH,KAAAsH,EAAAC,EAAAvH,KAAAuH,EAAA/B,EAAAxF,KAAAwF,EAEAY,EAAA1B,KAAA0B,IAAAkB,EAAAC,EAAA/B,GACAa,EAAA3B,KAAA2B,IAAAiB,EAAAC,EAAA/B,GAGAmgG,GAAAt/F,EAAAD,GAAA,CAEA,IAAAC,IAAAD,EAEA/C,EAAA,EACA2E,EAAA,MAEI,CAEJ,GAAAD,GAAA3B,EAAAC,CAIA,QAFA2B,EAAA29F,GAAA,GAAA59F,GAAA3B,EAAAC,GAAA0B,GAAA,EAAA3B,EAAAC,GAEAD,GAEA,IAAAkB,GAAAjE,GAAAkE,EAAA/B,GAAAuC,GAAAR,EAAA/B,EAAA,IAAyD,MACzD,KAAA+B,GAAAlE,GAAAmC,EAAA8B,GAAAS,EAAA,CAAyC,MACzC,KAAAvC,GAAAnC,GAAAiE,EAAAC,GAAAQ,EAAA,EAIA1E,GAAA,EAQA,MAJAkB,GAAAuC,EAAAzD,EACAkB,EAAAwC,EAAAiB,EACAzD,EAAA4K,EAAAw2F,EAEAphG,GAIAqhG,SAAA,WAEA,kBAAA5lG,KAAAsH,EAAA,YAAAtH,KAAAuH,EAAA,YAAAvH,KAAAwF,EAAA,QAIAqgG,UAAA,SAAA/+F,EAAAC,EAAAoI,GAEA,GAAA5K,GAAAvE,KAAAylG,QAMA,OAJAlhG,GAAAuC,KAAcvC,EAAAwC,KAAYxC,EAAA4K,KAE1BnP,KAAA+kG,OAAAxgG,EAAAuC,EAAAvC,EAAAwC,EAAAxC,EAAA4K,GAEAnP,MAIAuS,IAAA,SAAA1M,GAMA,MAJA7F,MAAAsH,GAAAzB,EAAAyB,EACAtH,KAAAuH,GAAA1B,EAAA0B,EACAvH,KAAAwF,GAAAK,EAAAL,EAEAxF,MAIA8lG,UAAA,SAAArhB,EAAAC,GAMA,MAJA1kF,MAAAsH,EAAAm9E,EAAAn9E,EAAAo9E,EAAAp9E,EACAtH,KAAAuH,EAAAk9E,EAAAl9E,EAAAm9E,EAAAn9E,EACAvH,KAAAwF,EAAAi/E,EAAAj/E,EAAAk/E,EAAAl/E,EAEAxF,MAIAmtF,UAAA,SAAApmF,GAMA,MAJA/G,MAAAsH,GAAAP,EACA/G,KAAAuH,GAAAR,EACA/G,KAAAwF,GAAAuB,EAEA/G,MAIA2b,IAAA,SAAA9V,GAMA,MAJA7F,MAAAsH,EAAA5C,KAAA0B,IAAA,EAAApG,KAAAsH,EAAAzB,EAAAyB,GACAtH,KAAAuH,EAAA7C,KAAA0B,IAAA,EAAApG,KAAAuH,EAAA1B,EAAA0B,GACAvH,KAAAwF,EAAAd,KAAA0B,IAAA,EAAApG,KAAAwF,EAAAK,EAAAL,GAEAxF,MAIAk3B,SAAA,SAAArxB,GAMA,MAJA7F,MAAAsH,GAAAzB,EAAAyB,EACAtH,KAAAuH,GAAA1B,EAAA0B,EACAvH,KAAAwF,GAAAK,EAAAL,EAEAxF,MAIA8c,eAAA,SAAA/V,GAMA,MAJA/G,MAAAsH,GAAAP,EACA/G,KAAAuH,GAAAR,EACA/G,KAAAwF,GAAAuB,EAEA/G,MAIAiiE,KAAA,SAAAp8D,EAAApB,GAMA,MAJAzE,MAAAsH,IAAAzB,EAAAyB,EAAAtH,KAAAsH,GAAA7C,EACAzE,KAAAuH,IAAA1B,EAAA0B,EAAAvH,KAAAuH,GAAA9C,EACAzE,KAAAwF,IAAAK,EAAAL,EAAAxF,KAAAwF,GAAAf,EAEAzE,MAIAs4C,OAAA,SAAA9xC,GAEA,MAAAA,GAAAc,IAAAtH,KAAAsH,GAAAd,EAAAe,IAAAvH,KAAAuH,GAAAf,EAAAhB,IAAAxF,KAAAwF,GAIAk+C,UAAA,SAAA3iD,EAAAma,GAQA,MANAzS,UAAAyS,MAAA,GAEAlb,KAAAsH,EAAAvG,EAAAma,GACAlb,KAAAuH,EAAAxG,EAAAma,EAAA,GACAlb,KAAAwF,EAAAzE,EAAAma,EAAA,GAEAlb,MAIA0iB,QAAA,SAAA3hB,EAAAma,GASA,MAPAzS,UAAA1H,UACA0H,SAAAyS,MAAA,GAEAna,EAAAma,GAAAlb,KAAAsH,EACAvG,EAAAma,EAAA,GAAAlb,KAAAuH,EACAxG,EAAAma,EAAA,GAAAlb,KAAAwF,EAEAzE,GAIA2tE,OAAA,WAEA,MAAA1uE,MAAAulG,WAUA,IAAAhuC,KAEAwuC,QAEAnuC,SAAa5sD,MAAA,GAAA0c,GAAA,WACb0B,SAAape,MAAA,GAEbmX,KAASnX,MAAA,MACTktD,aAAiBltD,MAAA,GAAA8T,IAEjBuR,UAAcrlB,MAAA,OAIdg7F,aAEA3mE,aAAiBr0B,MAAA,OAIjBi7F,QAEA3mE,QAAYt0B,MAAA,MACZ+sD,YAAgB/sD,OAAA,GAChBy0B,cAAkBz0B,MAAA,GAClB00B,iBAAqB10B,MAAA,MAIrBk7F,OAEA/mE,OAAWn0B,MAAA,MACXo0B,gBAAoBp0B,MAAA,IAIpBm7F,UAEAlnE,UAAcj0B,MAAA,MACdk0B,mBAAuBl0B,MAAA,IAIvBo7F,aAEA37D,aAAiBz/B,MAAA,OAIjBq7F,SAEAh/D,SAAar8B,MAAA,MACbwtD,WAAextD,MAAA,IAIfs7F,WAEAh/D,WAAet8B,MAAA,MACfytD,aAAiBztD,MAAA,GAAA0R,GAAA,OAIjB6pF,iBAEAj2E,iBAAqBtlB,MAAA,MACrBulB,mBAAuBvlB,MAAA,GACvBwlB,kBAAsBxlB,MAAA,IAItBw7F,cAEA97D,cAAkB1/B,MAAA,OAIlBy7F,cAEA97D,cAAkB3/B,MAAA,OAIlB07F,aAEAz7D,aAAiBjgC,MAAA,OAIjBohB,KAEA5C,YAAgBxe,MAAA,OAChBye,SAAaze,MAAA,GACb0e,QAAY1e,MAAA,KACZ2e,UAAc3e,MAAA,GAAA0c,GAAA,YAId8G,QAEAslC,mBAAuB9oD,UAEvB+oD,mBAAuB/oD,SAAAklC,YACvBvP,aACA96B,SAEA0wB,UACAo1B,cACAC,gBACAC,mBAGAqB,sBAA0BliD,UAC1BmiD,yBAA6BniD,UAE7BgpD,YAAgBhpD,SAAAklC,YAChBrqC,SACA8U,YACAgmB,aACAvpB,YACA00C,WACAC,eACAC,SAEAz1B,UACAo1B,cACAC,gBACAC,mBAGA0B,eAAmBviD,UACnBwiD,kBAAsBxiD,UAEtBkpD,aAAiBlpD,SAAAklC,YACjBrqC,SACA8U,YACAqxC,SACA50C,YAEAmf,UACAo1B,cACAC,gBACAC,iBACAz5B,oBACAC,qBAGA07B,gBAAoB/iD,UACpBgjD,mBAAuBhjD,UAEvBmpD,kBAAsBnpD,SAAAklC,YACtBvP,aACAsrB,YACAC,iBAIA+H,gBAAoBjpD,SAAAklC,YACpBrqC,SACA8U,YACAoG,SACAC,aAKAojB,QAEAwzB,SAAa5sD,MAAA,GAAA0c,GAAA,WACb0B,SAAape,MAAA,GACb0a,MAAU1a,MAAA,GACV2I,OAAW3I,MAAA,GACXmX,KAASnX,MAAA,MACTktD,aAAiBltD,MAAA,GAAA8T,MAUjB40C,IAEAizC,MAAA,SAAA19E,GAIA,OAFA29E,MAEAppE,EAAA,EAAmBA,EAAAvU,EAAAlrB,OAAqBy/B,IAAA,CAExC,GAAAw2D,GAAAh0F,KAAA6M,MAAAoc,EAAAuU,GAEA,QAAAr2B,KAAA6sF,GAEA4S,EAAAz/F,GAAA6sF,EAAA7sF,GAMA,MAAAy/F,IAIA/5F,MAAA,SAAAg6F,GAEA,GAAAC,KAEA,QAAAtpE,KAAAqpE,GAAA,CAEAC,EAAAtpE,KAEA,QAAAr2B,KAAA0/F,GAAArpE,GAAA,CAEA,GAAAupE,GAAAF,EAAArpE,GAAAr2B,EAEA4/F,OAAAnsE,SACAmsE,EAAAxM,WAAAwM,EAAA1Y,WACA0Y,EAAAna,WAAAma,EAAArsE,WAAAqsE,EAAA1L,WACA0L,EAAA5kE,WAEA2kE,EAAAtpE,GAAAr2B,GAAA4/F,EAAAl6F,QAEMzL,MAAAsL,QAAAq6F,GAEND,EAAAtpE,GAAAr2B,GAAA4/F,EAAA7nC,QAIA4nC,EAAAtpE,GAAAr2B,GAAA4/F,GAQA,MAAAD,KAMAE,GAAA,mFAEAC,GAAA,+DAEAC,GAAA,2EAEAC,GAAA,6aAEAC,GAAA,wFAEAC,GAAA,2CAEAC,GAAA,0CAEAC,GAAA,q7LAEAC,GAAA,65BAEAC,GAAA,2jBAEAC,GAAA,6LAEAC,GAAA,sHAEAC,GAAA,4HAEAC,GAAA,0DAEAC,GAAA,qDAEAC,GAAA,mDAEAC,GAAA,sDAEAjC,GAAA,4rEAEAkC,GAAA,qlIAEAC,GAAA,iIAEAC,GAAA,oJAEAC,GAAA,oKAEAC,GAAA,+MAEAC,GAAA,qEAEAC,GAAA,0DAEAC,GAAA,gvFAEAC,GAAA,iqDAEAC,GAAA,mnBAEAC,GAAA,iOAEAC,GAAA,ugBAEAC,GAAA,sDAEAC,GAAA,sDAEAC,GAAA,+SAEAC,GAAA,4MAEAC,GAAA,0YAEAC,GAAA,+HAEAC,GAAA,iGAEAC,GAAA,yuEAEAC,GAAA,siOAEAC,GAAA,wMAEAC,GAAA,66CAEAC,GAAA,8iBAEAC,GAAA,+uJAEAC,GAAA,wmHAEAC,GAAA,0IAEAC,GAAA,0IAEAC,GAAA,wIAEAC,GAAA,wPAEAC,GAAA,sJAEAC,GAAA,qDAEAC,GAAA,0MAEAC,GAAA,kFAEAC,GAAA,yKAEAC,GAAA,qEAEAC,GAAA,gVAEAC,GAAA,2KAEAC,GAAA,0qBAEAC,GAAA,2lBAEAC,GAAA,wrBAEAC,GAAA,qyCAEAC,GAAA,8EAEAC,GAAA,gHAEAC,GAAA,0FAEAC,GAAA,qVAEAC,GAAA,yKAEAC,GAAA,qEAEAC,GAAA,kpNAEAC,GAAA,0eAEAC,GAAA,slBAEAC,GAAA,4wCAEAC,GAAA,kOAEAC,GAAA,4gCAEAC,GAAA,iYAEAC,GAAA,8WAEAC,GAAA,0LAEAC,GAAA,mEAEAC,GAAA,+FAEAC,GAAA,g7BAEAC,GAAA,iQAEAC,GAAA,gSAEAC,GAAA,yRAEAC,GAAA,oFAEAC,GAAA,2GAEAC,GAAA,6EAEAC,GAAA,0JAEAC,GAAA,wPAEAC,GAAA,iOAEAC,GAAA,ivBAEAC,GAAA,oqBAEAC,GAAA,+rBAEAC,GAAA,otBAEAC,GAAA,oXAEAC,GAAA,+LAEAC,GAAA,qyBAEAC,GAAA,khBAEAC,GAAA,w8CAEAC,GAAA,u2BAEAC,GAAA,mlEAEAC,GAAA,4jCAEAC,GAAA,g4DAEAC,GAAA,uqCAEAC,GAAA,0mEAEAC,GAAA,+mCAEAC,GAAA,wgBAEAC,GAAA,i8BAEAC,GAAA,8yBAEAC,GAAA,4mBAEAC,GAAA,2VAEAC,GAAA,iOAEAllE;AACAu+D,qBACAC,0BACAC,sBACAC,kBACAC,uBACAC,gBACAC,sBACAC,SACAC,yBACAC,4BACAC,iCACAC,+BACAC,0BACAC,kBACAC,uBACAC,qBACAC,gBACAjC,UACAkC,+BACAC,wBACAC,+BACAC,0BACAC,wBACAC,6BACAC,sBACAC,2BACAC,mBACAC,wBACAC,sBACAC,iBACAC,cACAC,mBACAC,gBACAC,qBACAC,6BACAC,qBACAC,0BACAC,yBACAC,eACAC,yBACAC,8BACAC,4BACAC,iCACAC,mBACAC,wBACAC,6BACAC,2BACAC,sBACAC,gBACAC,qBACAC,yBACAC,8BACAC,yBACAC,8BACAC,sBACAC,2BACAC,sBACAC,mBACAC,2BACAC,WACAC,gCACAC,kBACAC,sBACAC,2BACAC,yBACAC,8BACAC,2BACAC,yBACAC,oBACAC,4BACAC,mBACAC,wBACAC,mBACAC,qBACAC,wBACAC,6BACAC,wBACAC,6BACAC,oBACAC,kBACAC,aACAC,qBACAC,mBACAC,cACAC,mBAEAC,aACAC,aACAC,cACAC,cACAC,qBACAC,qBACAC,iBACAC,iBACAC,mBACAC,mBACAC,kBACAC,kBACAC,oBACAC,oBACAC,kBACAC,kBACAC,qBACAC,qBACAC,eACAC,eACAC,eACAC,eACAC,e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","file":"component---src-pages-index-js-0bae3f85d2bfecd3485f.js","sourcesContent":["webpackJsonp([35783957827783],{\n\n/***/ 144:\n/***/ (function(module, exports) {\n\n\t/**\n\t * Copyright 2015, Yahoo! Inc.\n\t * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n\t */\n\t'use strict';\n\t\n\tvar REACT_STATICS = {\n\t    childContextTypes: true,\n\t    contextTypes: true,\n\t    defaultProps: true,\n\t    displayName: true,\n\t    getDefaultProps: true,\n\t    mixins: true,\n\t    propTypes: true,\n\t    type: true\n\t};\n\t\n\tvar KNOWN_STATICS = {\n\t  name: true,\n\t  length: true,\n\t  prototype: true,\n\t  caller: true,\n\t  callee: true,\n\t  arguments: true,\n\t  arity: true\n\t};\n\t\n\tvar defineProperty = Object.defineProperty;\n\tvar getOwnPropertyNames = Object.getOwnPropertyNames;\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\tvar getPrototypeOf = Object.getPrototypeOf;\n\tvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\t\n\tmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n\t    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\t\n\t        if (objectPrototype) {\n\t            var inheritedComponent = getPrototypeOf(sourceComponent);\n\t            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n\t                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n\t            }\n\t        }\n\t\n\t        var keys = getOwnPropertyNames(sourceComponent);\n\t\n\t        if (getOwnPropertySymbols) {\n\t            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n\t                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\t                try { // Avoid failures from read-only properties\n\t                    defineProperty(targetComponent, key, descriptor);\n\t                } catch (e) {}\n\t            }\n\t        }\n\t\n\t        return targetComponent;\n\t    }\n\t\n\t    return targetComponent;\n\t};\n\n\n/***/ }),\n\n/***/ 41:\n/***/ (function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ }),\n\n/***/ 89:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {// randomColor by David Merfield under the CC0 license\n\t// https://github.com/davidmerfield/randomColor/\n\t\n\t;(function(root, factory) {\n\t\n\t  // Support CommonJS\n\t  if (true) {\n\t    var randomColor = factory();\n\t\n\t    // Support NodeJS & Component, which allow module.exports to be a function\n\t    if (typeof module === 'object' && module && module.exports) {\n\t      exports = module.exports = randomColor;\n\t    }\n\t\n\t    // Support CommonJS 1.1.1 spec\n\t    exports.randomColor = randomColor;\n\t\n\t  // Support AMD\n\t  } else if (typeof define === 'function' && define.amd) {\n\t    define([], factory);\n\t\n\t  // Support vanilla script loading\n\t  } else {\n\t    root.randomColor = factory();\n\t  }\n\t\n\t}(this, function() {\n\t\n\t  // Seed to get repeatable colors\n\t  var seed = null;\n\t\n\t  // Shared color dictionary\n\t  var colorDictionary = {};\n\t\n\t  // Populate the color dictionary\n\t  loadColorBounds();\n\t\n\t  var randomColor = function (options) {\n\t\n\t    options = options || {};\n\t\n\t    // Check if there is a seed and ensure it's an\n\t    // integer. Otherwise, reset the seed value.\n\t    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n\t      seed = options.seed;\n\t\n\t    // A string was passed as a seed\n\t    } else if (typeof options.seed === 'string') {\n\t      seed = stringToInteger(options.seed);\n\t\n\t    // Something was passed as a seed but it wasn't an integer or string\n\t    } else if (options.seed !== undefined && options.seed !== null) {\n\t      throw new TypeError('The seed value must be an integer or string');\n\t\n\t    // No seed, reset the value outside.\n\t    } else {\n\t      seed = null;\n\t    }\n\t\n\t    var H,S,B;\n\t\n\t    // Check if we need to generate multiple colors\n\t    if (options.count !== null && options.count !== undefined) {\n\t\n\t      var totalColors = options.count,\n\t          colors = [];\n\t\n\t      options.count = null;\n\t\n\t      while (totalColors > colors.length) {\n\t\n\t        // Since we're generating multiple colors,\n\t        // incremement the seed. Otherwise we'd just\n\t        // generate the same color each time...\n\t        if (seed && options.seed) options.seed += 1;\n\t\n\t        colors.push(randomColor(options));\n\t      }\n\t\n\t      options.count = totalColors;\n\t\n\t      return colors;\n\t    }\n\t\n\t    // First we pick a hue (H)\n\t    H = pickHue(options);\n\t\n\t    // Then use H to determine saturation (S)\n\t    S = pickSaturation(H, options);\n\t\n\t    // Then use S and H to determine brightness (B).\n\t    B = pickBrightness(H, S, options);\n\t\n\t    // Then we return the HSB color in the desired format\n\t    return setFormat([H,S,B], options);\n\t  };\n\t\n\t  function pickHue (options) {\n\t\n\t    var hueRange = getHueRange(options.hue),\n\t        hue = randomWithin(hueRange);\n\t\n\t    // Instead of storing red as two seperate ranges,\n\t    // we group them, using negative numbers\n\t    if (hue < 0) {hue = 360 + hue;}\n\t\n\t    return hue;\n\t\n\t  }\n\t\n\t  function pickSaturation (hue, options) {\n\t\n\t    if (options.hue === 'monochrome') {\n\t      return 0;\n\t    }\n\t\n\t    if (options.luminosity === 'random') {\n\t      return randomWithin([0,100]);\n\t    }\n\t\n\t    var saturationRange = getSaturationRange(hue);\n\t\n\t    var sMin = saturationRange[0],\n\t        sMax = saturationRange[1];\n\t\n\t    switch (options.luminosity) {\n\t\n\t      case 'bright':\n\t        sMin = 55;\n\t        break;\n\t\n\t      case 'dark':\n\t        sMin = sMax - 10;\n\t        break;\n\t\n\t      case 'light':\n\t        sMax = 55;\n\t        break;\n\t   }\n\t\n\t    return randomWithin([sMin, sMax]);\n\t\n\t  }\n\t\n\t  function pickBrightness (H, S, options) {\n\t\n\t    var bMin = getMinimumBrightness(H, S),\n\t        bMax = 100;\n\t\n\t    switch (options.luminosity) {\n\t\n\t      case 'dark':\n\t        bMax = bMin + 20;\n\t        break;\n\t\n\t      case 'light':\n\t        bMin = (bMax + bMin)/2;\n\t        break;\n\t\n\t      case 'random':\n\t        bMin = 0;\n\t        bMax = 100;\n\t        break;\n\t    }\n\t\n\t    return randomWithin([bMin, bMax]);\n\t  }\n\t\n\t  function setFormat (hsv, options) {\n\t\n\t    switch (options.format) {\n\t\n\t      case 'hsvArray':\n\t        return hsv;\n\t\n\t      case 'hslArray':\n\t        return HSVtoHSL(hsv);\n\t\n\t      case 'hsl':\n\t        var hsl = HSVtoHSL(hsv);\n\t        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\t\n\t      case 'hsla':\n\t        var hslColor = HSVtoHSL(hsv);\n\t        var alpha = options.alpha || Math.random();\n\t        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\t\n\t      case 'rgbArray':\n\t        return HSVtoRGB(hsv);\n\t\n\t      case 'rgb':\n\t        var rgb = HSVtoRGB(hsv);\n\t        return 'rgb(' + rgb.join(', ') + ')';\n\t\n\t      case 'rgba':\n\t        var rgbColor = HSVtoRGB(hsv);\n\t        var alpha = options.alpha || Math.random();\n\t        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\t\n\t      default:\n\t        return HSVtoHex(hsv);\n\t    }\n\t\n\t  }\n\t\n\t  function getMinimumBrightness(H, S) {\n\t\n\t    var lowerBounds = getColorInfo(H).lowerBounds;\n\t\n\t    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\t\n\t      var s1 = lowerBounds[i][0],\n\t          v1 = lowerBounds[i][1];\n\t\n\t      var s2 = lowerBounds[i+1][0],\n\t          v2 = lowerBounds[i+1][1];\n\t\n\t      if (S >= s1 && S <= s2) {\n\t\n\t         var m = (v2 - v1)/(s2 - s1),\n\t             b = v1 - m*s1;\n\t\n\t         return m*S + b;\n\t      }\n\t\n\t    }\n\t\n\t    return 0;\n\t  }\n\t\n\t  function getHueRange (colorInput) {\n\t\n\t    if (typeof parseInt(colorInput) === 'number') {\n\t\n\t      var number = parseInt(colorInput);\n\t\n\t      if (number < 360 && number > 0) {\n\t        return [number, number];\n\t      }\n\t\n\t    }\n\t\n\t    if (typeof colorInput === 'string') {\n\t\n\t      if (colorDictionary[colorInput]) {\n\t        var color = colorDictionary[colorInput];\n\t        if (color.hueRange) {return color.hueRange;}\n\t      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n\t        var hue = HexToHSB(colorInput)[0];\n\t        return [ hue, hue ];\n\t      }\n\t    }\n\t\n\t    return [0,360];\n\t\n\t  }\n\t\n\t  function getSaturationRange (hue) {\n\t    return getColorInfo(hue).saturationRange;\n\t  }\n\t\n\t  function getColorInfo (hue) {\n\t\n\t    // Maps red colors to make picking hue easier\n\t    if (hue >= 334 && hue <= 360) {\n\t      hue-= 360;\n\t    }\n\t\n\t    for (var colorName in colorDictionary) {\n\t       var color = colorDictionary[colorName];\n\t       if (color.hueRange &&\n\t           hue >= color.hueRange[0] &&\n\t           hue <= color.hueRange[1]) {\n\t          return colorDictionary[colorName];\n\t       }\n\t    } return 'Color not found';\n\t  }\n\t\n\t  function randomWithin (range) {\n\t    if (seed === null) {\n\t      return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));\n\t    } else {\n\t      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n\t      var max = range[1] || 1;\n\t      var min = range[0] || 0;\n\t      seed = (seed * 9301 + 49297) % 233280;\n\t      var rnd = seed / 233280.0;\n\t      return Math.floor(min + rnd * (max - min));\n\t    }\n\t  }\n\t\n\t  function HSVtoHex (hsv){\n\t\n\t    var rgb = HSVtoRGB(hsv);\n\t\n\t    function componentToHex(c) {\n\t        var hex = c.toString(16);\n\t        return hex.length == 1 ? '0' + hex : hex;\n\t    }\n\t\n\t    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\t\n\t    return hex;\n\t\n\t  }\n\t\n\t  function defineColor (name, hueRange, lowerBounds) {\n\t\n\t    var sMin = lowerBounds[0][0],\n\t        sMax = lowerBounds[lowerBounds.length - 1][0],\n\t\n\t        bMin = lowerBounds[lowerBounds.length - 1][1],\n\t        bMax = lowerBounds[0][1];\n\t\n\t    colorDictionary[name] = {\n\t      hueRange: hueRange,\n\t      lowerBounds: lowerBounds,\n\t      saturationRange: [sMin, sMax],\n\t      brightnessRange: [bMin, bMax]\n\t    };\n\t\n\t  }\n\t\n\t  function loadColorBounds () {\n\t\n\t    defineColor(\n\t      'monochrome',\n\t      null,\n\t      [[0,0],[100,0]]\n\t    );\n\t\n\t    defineColor(\n\t      'red',\n\t      [-26,18],\n\t      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n\t    );\n\t\n\t    defineColor(\n\t      'orange',\n\t      [19,46],\n\t      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n\t    );\n\t\n\t    defineColor(\n\t      'yellow',\n\t      [47,62],\n\t      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n\t    );\n\t\n\t    defineColor(\n\t      'green',\n\t      [63,178],\n\t      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n\t    );\n\t\n\t    defineColor(\n\t      'blue',\n\t      [179, 257],\n\t      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n\t    );\n\t\n\t    defineColor(\n\t      'purple',\n\t      [258, 282],\n\t      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n\t    );\n\t\n\t    defineColor(\n\t      'pink',\n\t      [283, 334],\n\t      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n\t    );\n\t\n\t  }\n\t\n\t  function HSVtoRGB (hsv) {\n\t\n\t    // this doesn't work for the values of 0 and 360\n\t    // here's the hacky fix\n\t    var h = hsv[0];\n\t    if (h === 0) {h = 1;}\n\t    if (h === 360) {h = 359;}\n\t\n\t    // Rebase the h,s,v values\n\t    h = h/360;\n\t    var s = hsv[1]/100,\n\t        v = hsv[2]/100;\n\t\n\t    var h_i = Math.floor(h*6),\n\t      f = h * 6 - h_i,\n\t      p = v * (1 - s),\n\t      q = v * (1 - f*s),\n\t      t = v * (1 - (1 - f)*s),\n\t      r = 256,\n\t      g = 256,\n\t      b = 256;\n\t\n\t    switch(h_i) {\n\t      case 0: r = v; g = t; b = p;  break;\n\t      case 1: r = q; g = v; b = p;  break;\n\t      case 2: r = p; g = v; b = t;  break;\n\t      case 3: r = p; g = q; b = v;  break;\n\t      case 4: r = t; g = p; b = v;  break;\n\t      case 5: r = v; g = p; b = q;  break;\n\t    }\n\t\n\t    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n\t    return result;\n\t  }\n\t\n\t  function HexToHSB (hex) {\n\t    hex = hex.replace(/^#/, '');\n\t    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\t\n\t    var red = parseInt(hex.substr(0, 2), 16) / 255,\n\t          green = parseInt(hex.substr(2, 2), 16) / 255,\n\t          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\t\n\t    var cMax = Math.max(red, green, blue),\n\t          delta = cMax - Math.min(red, green, blue),\n\t          saturation = cMax ? (delta / cMax) : 0;\n\t\n\t    switch (cMax) {\n\t      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n\t      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n\t      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n\t    }\n\t  }\n\t\n\t  function HSVtoHSL (hsv) {\n\t    var h = hsv[0],\n\t      s = hsv[1]/100,\n\t      v = hsv[2]/100,\n\t      k = (2-s)*v;\n\t\n\t    return [\n\t      h,\n\t      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n\t      k/2 * 100\n\t    ];\n\t  }\n\t\n\t  function stringToInteger (string) {\n\t    var total = 0\n\t    for (var i = 0; i !== string.length; i++) {\n\t      if (total >= Number.MAX_SAFE_INTEGER) break;\n\t      total += string.charCodeAt(i)\n\t    }\n\t    return total\n\t  }\n\t\n\t  return randomColor;\n\t}));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(111)(module)))\n\n/***/ }),\n\n/***/ 413:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction defaultOnError(err) {\n\t  throw new Error(err);\n\t}\n\t\n\tmodule.exports = function (THREE) {\n\t\n\t  /**\n\t   * @author mrdoob / http://mrdoob.com/\n\t   */\n\t\n\t  THREE.OBJLoader = function (manager) {\n\t\n\t    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\n\t    this.materials = null;\n\t\n\t    this.regexp = {\n\t      // v float float float\n\t      vertex_pattern: /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t      // vn float float float\n\t      normal_pattern: /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t      // vt float float\n\t      uv_pattern: /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t      // f vertex vertex vertex\n\t      face_vertex: /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/,\n\t      // f vertex/uv vertex/uv vertex/uv\n\t      face_vertex_uv: /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/,\n\t      // f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n\t      face_vertex_uv_normal: /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/,\n\t      // f vertex//normal vertex//normal vertex//normal\n\t      face_vertex_normal: /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/,\n\t      // o object_name | g group_name\n\t      object_pattern: /^[og]\\s*(.+)?/,\n\t      // s boolean\n\t      smoothing_pattern: /^s\\s+(\\d+|on|off)/,\n\t      // mtllib file_reference\n\t      material_library_pattern: /^mtllib /,\n\t      // usemtl material_name\n\t      material_use_pattern: /^usemtl /\n\t    };\n\t  };\n\t\n\t  THREE.OBJLoader.prototype = {\n\t\n\t    constructor: THREE.OBJLoader,\n\t\n\t    load: function load(url, onLoad, onProgress, onError) {\n\t\n\t      var scope = this;\n\t      this.onError = onError || defaultOnError;\n\t\n\t      var loader = new THREE.FileLoader(scope.manager);\n\t      loader.setPath(this.path);\n\t      loader.load(url, function (text) {\n\t\n\t        onLoad(scope.parse(text));\n\t      }, onProgress, onError);\n\t    },\n\t\n\t    setPath: function setPath(value) {\n\t\n\t      this.path = value;\n\t    },\n\t\n\t    setMaterials: function setMaterials(materials) {\n\t\n\t      this.materials = materials;\n\t    },\n\t\n\t    _createParserState: function _createParserState() {\n\t\n\t      var state = {\n\t        objects: [],\n\t        object: {},\n\t\n\t        vertices: [],\n\t        normals: [],\n\t        uvs: [],\n\t\n\t        materialLibraries: [],\n\t\n\t        startObject: function startObject(name, fromDeclaration) {\n\t\n\t          // If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t          // file. We need to use it for the first parsed g/o to keep things in sync.\n\t          if (this.object && this.object.fromDeclaration === false) {\n\t\n\t            this.object.name = name;\n\t            this.object.fromDeclaration = fromDeclaration !== false;\n\t            return;\n\t          }\n\t\n\t          var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\t\n\t          if (this.object && typeof this.object._finalize === 'function') {\n\t\n\t            this.object._finalize(true);\n\t          }\n\t\n\t          this.object = {\n\t            name: name || '',\n\t            fromDeclaration: fromDeclaration !== false,\n\t\n\t            geometry: {\n\t              vertices: [],\n\t              normals: [],\n\t              uvs: []\n\t            },\n\t            materials: [],\n\t            smooth: true,\n\t\n\t            startMaterial: function startMaterial(name, libraries) {\n\t\n\t              var previous = this._finalize(false);\n\t\n\t              // New usemtl declaration overwrites an inherited material, except if faces were declared\n\t              // after the material, then it must be preserved for proper MultiMaterial continuation.\n\t              if (previous && (previous.inherited || previous.groupCount <= 0)) {\n\t\n\t                this.materials.splice(previous.index, 1);\n\t              }\n\t\n\t              var material = {\n\t                index: this.materials.length,\n\t                name: name || '',\n\t                mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n\t                smooth: previous !== undefined ? previous.smooth : this.smooth,\n\t                groupStart: previous !== undefined ? previous.groupEnd : 0,\n\t                groupEnd: -1,\n\t                groupCount: -1,\n\t                inherited: false,\n\t\n\t                clone: function clone(index) {\n\t                  var cloned = {\n\t                    index: typeof index === 'number' ? index : this.index,\n\t                    name: this.name,\n\t                    mtllib: this.mtllib,\n\t                    smooth: this.smooth,\n\t                    groupStart: 0,\n\t                    groupEnd: -1,\n\t                    groupCount: -1,\n\t                    inherited: false\n\t                  };\n\t                  cloned.clone = this.clone.bind(cloned);\n\t                  return cloned;\n\t                }\n\t              };\n\t\n\t              this.materials.push(material);\n\t\n\t              return material;\n\t            },\n\t\n\t            currentMaterial: function currentMaterial() {\n\t\n\t              if (this.materials.length > 0) {\n\t                return this.materials[this.materials.length - 1];\n\t              }\n\t\n\t              return undefined;\n\t            },\n\t\n\t            _finalize: function _finalize(end) {\n\t\n\t              var lastMultiMaterial = this.currentMaterial();\n\t              if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\t\n\t                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t                lastMultiMaterial.inherited = false;\n\t              }\n\t\n\t              // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t              if (end && this.materials.length > 1) {\n\t\n\t                for (var mi = this.materials.length - 1; mi >= 0; mi--) {\n\t                  if (this.materials[mi].groupCount <= 0) {\n\t                    this.materials.splice(mi, 1);\n\t                  }\n\t                }\n\t              }\n\t\n\t              // Guarantee at least one empty material, this makes the creation later more straight forward.\n\t              if (end && this.materials.length === 0) {\n\t\n\t                this.materials.push({\n\t                  name: '',\n\t                  smooth: this.smooth\n\t                });\n\t              }\n\t\n\t              return lastMultiMaterial;\n\t            }\n\t          };\n\t\n\t          // Inherit previous objects material.\n\t          // Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t          // If a usemtl declaration is encountered while this new object is being parsed, it will\n\t          // overwrite the inherited material. Exception being that there was already face declarations\n\t          // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\t\n\t          if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n\t\n\t            var declared = previousMaterial.clone(0);\n\t            declared.inherited = true;\n\t            this.object.materials.push(declared);\n\t          }\n\t\n\t          this.objects.push(this.object);\n\t        },\n\t\n\t        finalize: function finalize() {\n\t\n\t          if (this.object && typeof this.object._finalize === 'function') {\n\t\n\t            this.object._finalize(true);\n\t          }\n\t        },\n\t\n\t        parseVertexIndex: function parseVertexIndex(value, len) {\n\t\n\t          var index = parseInt(value, 10);\n\t          return (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t        },\n\t\n\t        parseNormalIndex: function parseNormalIndex(value, len) {\n\t\n\t          var index = parseInt(value, 10);\n\t          return (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t        },\n\t\n\t        parseUVIndex: function parseUVIndex(value, len) {\n\t\n\t          var index = parseInt(value, 10);\n\t          return (index >= 0 ? index - 1 : index + len / 2) * 2;\n\t        },\n\t\n\t        addVertex: function addVertex(a, b, c) {\n\t\n\t          var src = this.vertices;\n\t          var dst = this.object.geometry.vertices;\n\t\n\t          dst.push(src[a + 0]);\n\t          dst.push(src[a + 1]);\n\t          dst.push(src[a + 2]);\n\t          dst.push(src[b + 0]);\n\t          dst.push(src[b + 1]);\n\t          dst.push(src[b + 2]);\n\t          dst.push(src[c + 0]);\n\t          dst.push(src[c + 1]);\n\t          dst.push(src[c + 2]);\n\t        },\n\t\n\t        addVertexLine: function addVertexLine(a) {\n\t\n\t          var src = this.vertices;\n\t          var dst = this.object.geometry.vertices;\n\t\n\t          dst.push(src[a + 0]);\n\t          dst.push(src[a + 1]);\n\t          dst.push(src[a + 2]);\n\t        },\n\t\n\t        addNormal: function addNormal(a, b, c) {\n\t\n\t          var src = this.normals;\n\t          var dst = this.object.geometry.normals;\n\t\n\t          dst.push(src[a + 0]);\n\t          dst.push(src[a + 1]);\n\t          dst.push(src[a + 2]);\n\t          dst.push(src[b + 0]);\n\t          dst.push(src[b + 1]);\n\t          dst.push(src[b + 2]);\n\t          dst.push(src[c + 0]);\n\t          dst.push(src[c + 1]);\n\t          dst.push(src[c + 2]);\n\t        },\n\t\n\t        addUV: function addUV(a, b, c) {\n\t\n\t          var src = this.uvs;\n\t          var dst = this.object.geometry.uvs;\n\t\n\t          dst.push(src[a + 0]);\n\t          dst.push(src[a + 1]);\n\t          dst.push(src[b + 0]);\n\t          dst.push(src[b + 1]);\n\t          dst.push(src[c + 0]);\n\t          dst.push(src[c + 1]);\n\t        },\n\t\n\t        addUVLine: function addUVLine(a) {\n\t\n\t          var src = this.uvs;\n\t          var dst = this.object.geometry.uvs;\n\t\n\t          dst.push(src[a + 0]);\n\t          dst.push(src[a + 1]);\n\t        },\n\t\n\t        addFace: function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {\n\t\n\t          var vLen = this.vertices.length;\n\t\n\t          var ia = this.parseVertexIndex(a, vLen);\n\t          var ib = this.parseVertexIndex(b, vLen);\n\t          var ic = this.parseVertexIndex(c, vLen);\n\t          var id;\n\t\n\t          if (d === undefined) {\n\t\n\t            this.addVertex(ia, ib, ic);\n\t          } else {\n\t\n\t            id = this.parseVertexIndex(d, vLen);\n\t\n\t            this.addVertex(ia, ib, id);\n\t            this.addVertex(ib, ic, id);\n\t          }\n\t\n\t          if (ua !== undefined) {\n\t\n\t            var uvLen = this.uvs.length;\n\t\n\t            ia = this.parseUVIndex(ua, uvLen);\n\t            ib = this.parseUVIndex(ub, uvLen);\n\t            ic = this.parseUVIndex(uc, uvLen);\n\t\n\t            if (d === undefined) {\n\t\n\t              this.addUV(ia, ib, ic);\n\t            } else {\n\t\n\t              id = this.parseUVIndex(ud, uvLen);\n\t\n\t              this.addUV(ia, ib, id);\n\t              this.addUV(ib, ic, id);\n\t            }\n\t          }\n\t\n\t          if (na !== undefined) {\n\t\n\t            // Normals are many times the same. If so, skip function call and parseInt.\n\t            var nLen = this.normals.length;\n\t            ia = this.parseNormalIndex(na, nLen);\n\t\n\t            ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n\t            ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\t\n\t            if (d === undefined) {\n\t\n\t              this.addNormal(ia, ib, ic);\n\t            } else {\n\t\n\t              id = this.parseNormalIndex(nd, nLen);\n\t\n\t              this.addNormal(ia, ib, id);\n\t              this.addNormal(ib, ic, id);\n\t            }\n\t          }\n\t        },\n\t\n\t        addLineGeometry: function addLineGeometry(vertices, uvs) {\n\t\n\t          this.object.geometry.type = 'Line';\n\t\n\t          var vLen = this.vertices.length;\n\t          var uvLen = this.uvs.length;\n\t\n\t          for (var vi = 0, l = vertices.length; vi < l; vi++) {\n\t\n\t            this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n\t          }\n\t\n\t          for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\t\n\t            this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n\t          }\n\t        }\n\t\n\t      };\n\t\n\t      state.startObject('', false);\n\t\n\t      return state;\n\t    },\n\t\n\t    parse: function parse(text, debug) {\n\t      if (typeof debug === 'undefined') {\n\t        debug = true;\n\t      }\n\t\n\t      if (debug) {\n\t        console.time('OBJLoader');\n\t      }\n\t\n\t      var state = this._createParserState();\n\t\n\t      if (text.indexOf('\\r\\n') !== -1) {\n\t\n\t        // This is faster than String.split with regex that splits on both\n\t        text = text.replace(/\\r\\n/g, '\\n');\n\t      }\n\t\n\t      if (text.indexOf('\\\\\\n') !== -1) {\n\t\n\t        // join lines separated by a line continuation character (\\)\n\t        text = text.replace(/\\\\\\n/g, '');\n\t      }\n\t\n\t      var lines = text.split('\\n');\n\t      var line = '',\n\t          lineFirstChar = '',\n\t          lineSecondChar = '';\n\t      var lineLength = 0;\n\t      var result = [];\n\t\n\t      // Faster to just trim left side of the line. Use if available.\n\t      var trimLeft = typeof ''.trimLeft === 'function';\n\t\n\t      for (var i = 0, l = lines.length; i < l; i++) {\n\t\n\t        line = lines[i];\n\t\n\t        line = trimLeft ? line.trimLeft() : line.trim();\n\t\n\t        lineLength = line.length;\n\t\n\t        if (lineLength === 0) continue;\n\t\n\t        lineFirstChar = line.charAt(0);\n\t\n\t        // @todo invoke passed in handler if any\n\t        if (lineFirstChar === '#') continue;\n\t\n\t        if (lineFirstChar === 'v') {\n\t\n\t          lineSecondChar = line.charAt(1);\n\t\n\t          if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {\n\t\n\t            // 0                  1      2      3\n\t            // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\t\n\t            state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n\t          } else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {\n\t\n\t            // 0                   1      2      3\n\t            // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\t\n\t            state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n\t          } else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {\n\t\n\t            // 0               1      2\n\t            // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\t\n\t            state.uvs.push(parseFloat(result[1]), parseFloat(result[2]));\n\t          } else {\n\t\n\t            this.onError(\"Unexpected vertex/normal/uv line: '\" + line + \"'\");\n\t          }\n\t        } else if (lineFirstChar === \"f\") {\n\t\n\t          if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {\n\t\n\t            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n\t            // 0                        1    2    3    4    5    6    7    8    9   10         11         12\n\t            // [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined]\n\t\n\t            state.addFace(result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);\n\t          } else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {\n\t\n\t            // f vertex/uv vertex/uv vertex/uv\n\t            // 0                  1    2    3    4    5    6   7          8\n\t            // [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\t\n\t            state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);\n\t          } else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {\n\t\n\t            // f vertex//normal vertex//normal vertex//normal\n\t            // 0                     1    2    3    4    5    6   7          8\n\t            // [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\t\n\t            state.addFace(result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);\n\t          } else if ((result = this.regexp.face_vertex.exec(line)) !== null) {\n\t\n\t            // f vertex vertex vertex\n\t            // 0            1    2    3   4\n\t            // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\t\n\t            state.addFace(result[1], result[2], result[3], result[4]);\n\t          } else {\n\t\n\t            this.onError(\"Unexpected face line: '\" + line + \"'\");\n\t          }\n\t        } else if (lineFirstChar === \"l\") {\n\t\n\t          var lineParts = line.substring(1).trim().split(\" \");\n\t          var lineVertices = [],\n\t              lineUVs = [];\n\t\n\t          if (line.indexOf(\"/\") === -1) {\n\t\n\t            lineVertices = lineParts;\n\t          } else {\n\t\n\t            for (var li = 0, llen = lineParts.length; li < llen; li++) {\n\t\n\t              var parts = lineParts[li].split(\"/\");\n\t\n\t              if (parts[0] !== \"\") lineVertices.push(parts[0]);\n\t              if (parts[1] !== \"\") lineUVs.push(parts[1]);\n\t            }\n\t          }\n\t          state.addLineGeometry(lineVertices, lineUVs);\n\t        } else if ((result = this.regexp.object_pattern.exec(line)) !== null) {\n\t\n\t          // o object_name\n\t          // or\n\t          // g group_name\n\t\n\t          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t          // var name = result[ 0 ].substr( 1 ).trim();\n\t          var name = (\" \" + result[0].substr(1).trim()).substr(1);\n\t\n\t          state.startObject(name);\n\t        } else if (this.regexp.material_use_pattern.test(line)) {\n\t\n\t          // material\n\t\n\t          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n\t        } else if (this.regexp.material_library_pattern.test(line)) {\n\t\n\t          // mtl file\n\t\n\t          state.materialLibraries.push(line.substring(7).trim());\n\t        } else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {\n\t\n\t          // smooth shading\n\t\n\t          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t          // but does not define a usemtl for each face set.\n\t          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t          // where explicit usemtl defines geometry groups.\n\t          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\t\n\t          var value = result[1].trim().toLowerCase();\n\t          state.object.smooth = value === '1' || value === 'on';\n\t\n\t          var material = state.object.currentMaterial();\n\t          if (material) {\n\t\n\t            material.smooth = state.object.smooth;\n\t          }\n\t        } else {\n\t\n\t          // Handle null terminated files without exception\n\t          if (line === '\\0') continue;\n\t\n\t          this.onError(\"Unexpected line: '\" + line + \"'\");\n\t        }\n\t      }\n\t\n\t      state.finalize();\n\t\n\t      var container = new THREE.Group();\n\t      container.materialLibraries = [].concat(state.materialLibraries);\n\t\n\t      for (var i = 0, l = state.objects.length; i < l; i++) {\n\t\n\t        var object = state.objects[i];\n\t        var geometry = object.geometry;\n\t        var materials = object.materials;\n\t        var isLine = geometry.type === 'Line';\n\t\n\t        // Skip o/g line declarations that did not follow with any faces\n\t        if (geometry.vertices.length === 0) continue;\n\t\n\t        var buffergeometry = new THREE.BufferGeometry();\n\t\n\t        buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));\n\t\n\t        if (geometry.normals.length > 0) {\n\t\n\t          buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));\n\t        } else {\n\t\n\t          buffergeometry.computeVertexNormals();\n\t        }\n\t\n\t        if (geometry.uvs.length > 0) {\n\t\n\t          buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));\n\t        }\n\t\n\t        // Create materials\n\t\n\t        var createdMaterials = [];\n\t\n\t        for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\t\n\t          var sourceMaterial = materials[mi];\n\t          var material = undefined;\n\t\n\t          if (this.materials !== null) {\n\t\n\t            material = this.materials.create(sourceMaterial.name);\n\t\n\t            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t            if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\t\n\t              var materialLine = new THREE.LineBasicMaterial();\n\t              materialLine.copy(material);\n\t              material = materialLine;\n\t            }\n\t          }\n\t\n\t          if (!material) {\n\t\n\t            material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();\n\t            material.name = sourceMaterial.name;\n\t          }\n\t\n\t          material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;\n\t\n\t          createdMaterials.push(material);\n\t        }\n\t\n\t        // Create mesh\n\t\n\t        var mesh;\n\t\n\t        if (createdMaterials.length > 1) {\n\t\n\t          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\t\n\t            var sourceMaterial = materials[mi];\n\t            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n\t          }\n\t\n\t          var multiMaterial = new THREE.MultiMaterial(createdMaterials);\n\t          mesh = !isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.LineSegments(buffergeometry, multiMaterial);\n\t        } else {\n\t\n\t          mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n\t        }\n\t\n\t        mesh.name = object.name;\n\t\n\t        container.add(mesh);\n\t      }\n\t\n\t      if (debug) {\n\t        console.timeEnd('OBJLoader');\n\t      }\n\t\n\t      return container;\n\t    }\n\t\n\t  };\n\t};\n\n/***/ }),\n\n/***/ 414:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function( THREE ) {\n\t\t/**\n\t\t * @author qiao / https://github.com/qiao\n\t\t * @author mrdoob / http://mrdoob.com\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author erich666 / http://erichaines.com\n\t\t */\n\t\n\t// This set of controls performs orbiting, dollying (zooming), and panning.\n\t// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n\t//\n\t//    Orbit - left mouse / touch: one finger move\n\t//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n\t//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\t\n\t\tfunction OrbitControls( object, domElement ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\t\n\t\t\t// Set to false to disable this control\n\t\t\tthis.enabled = true;\n\t\n\t\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\t\tthis.target = new THREE.Vector3();\n\t\n\t\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\t\tthis.minDistance = 0;\n\t\t\tthis.maxDistance = Infinity;\n\t\n\t\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\t\tthis.minZoom = 0;\n\t\t\tthis.maxZoom = Infinity;\n\t\n\t\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t\t// Range is 0 to Math.PI radians.\n\t\t\tthis.minPolarAngle = 0; // radians\n\t\t\tthis.maxPolarAngle = Math.PI; // radians\n\t\n\t\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\t\tthis.maxAzimuthAngle = Infinity; // radians\n\t\n\t\t\t// Set to true to enable damping (inertia)\n\t\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\t\tthis.enableDamping = false;\n\t\t\tthis.dampingFactor = 0.25;\n\t\n\t\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t\t// Set to false to disable zooming\n\t\t\tthis.enableZoom = true;\n\t\t\tthis.zoomSpeed = 1.0;\n\t\n\t\t\t// Set to false to disable rotating\n\t\t\tthis.enableRotate = true;\n\t\t\tthis.rotateSpeed = 1.0;\n\t\n\t\t\t// Set to false to disable panning\n\t\t\tthis.enablePan = true;\n\t\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\n\t\t\t// Set to true to automatically rotate around the target\n\t\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\t\tthis.autoRotate = false;\n\t\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\t\n\t\t\t// Set to false to disable use of the keys\n\t\t\tthis.enableKeys = true;\n\t\n\t\t\t// The four arrow keys\n\t\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\t\n\t\t\t// Mouse buttons\n\t\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\t\n\t\t\t// for reset\n\t\t\tthis.target0 = this.target.clone();\n\t\t\tthis.position0 = this.object.position.clone();\n\t\t\tthis.zoom0 = this.object.zoom;\n\t\n\t\t\t//\n\t\t\t// public methods\n\t\t\t//\n\t\n\t\t\tthis.getPolarAngle = function () {\n\t\n\t\t\t\treturn spherical.phi;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getAzimuthalAngle = function () {\n\t\n\t\t\t\treturn spherical.theta;\n\t\n\t\t\t};\n\t\n\t\t\tthis.reset = function () {\n\t\n\t\t\t\tscope.target.copy( scope.target0 );\n\t\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\t\tscope.object.zoom = scope.zoom0;\n\t\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tscope.dispatchEvent( changeEvent );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t};\n\t\n\t\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\t\tthis.update = function() {\n\t\n\t\t\t\tvar offset = new THREE.Vector3();\n\t\n\t\t\t\t// so camera.up is the orbit axis\n\t\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\t\tvar quatInverse = quat.clone().inverse();\n\t\n\t\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\t\n\t\t\t\treturn function update () {\n\t\n\t\t\t\t\tvar position = scope.object.position;\n\t\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\n\t\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\t\toffset.applyQuaternion( quat );\n\t\n\t\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\t\tspherical.setFromVector3( offset );\n\t\n\t\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\t\n\t\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\t\n\t\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\t\n\t\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\t\n\t\t\t\t\tspherical.makeSafe();\n\t\n\t\n\t\t\t\t\tspherical.radius *= scale;\n\t\n\t\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\t\n\t\t\t\t\t// move target to panned location\n\t\t\t\t\tscope.target.add( panOffset );\n\t\n\t\t\t\t\toffset.setFromSpherical( spherical );\n\t\n\t\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\t\toffset.applyQuaternion( quatInverse );\n\t\n\t\t\t\t\tposition.copy( scope.target ).add( offset );\n\t\n\t\t\t\t\tscope.object.lookAt( scope.target );\n\t\n\t\t\t\t\tif ( scope.enableDamping === true ) {\n\t\n\t\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tscale = 1;\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\t\n\t\t\t\t\t// update condition is:\n\t\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\t\n\t\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\t\n\t\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\t\n\t\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\t\tzoomChanged = false;\n\t\n\t\t\t\t\t\treturn true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t\tthis.dispose = function() {\n\t\n\t\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\t\n\t\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\t\n\t\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\n\t\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\t\n\t\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\t\n\t\t\t};\n\t\n\t\t\t//\n\t\t\t// internals\n\t\t\t//\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar changeEvent = { type: 'change' };\n\t\t\tvar startEvent = { type: 'start' };\n\t\t\tvar endEvent = { type: 'end' };\n\t\n\t\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\t\n\t\t\tvar state = STATE.NONE;\n\t\n\t\t\tvar EPS = 0.000001;\n\t\n\t\t\t// current position in spherical coordinates\n\t\t\tvar spherical = new THREE.Spherical();\n\t\t\tvar sphericalDelta = new THREE.Spherical();\n\t\n\t\t\tvar scale = 1;\n\t\t\tvar panOffset = new THREE.Vector3();\n\t\t\tvar zoomChanged = false;\n\t\n\t\t\tvar rotateStart = new THREE.Vector2();\n\t\t\tvar rotateEnd = new THREE.Vector2();\n\t\t\tvar rotateDelta = new THREE.Vector2();\n\t\n\t\t\tvar panStart = new THREE.Vector2();\n\t\t\tvar panEnd = new THREE.Vector2();\n\t\t\tvar panDelta = new THREE.Vector2();\n\t\n\t\t\tvar dollyStart = new THREE.Vector2();\n\t\t\tvar dollyEnd = new THREE.Vector2();\n\t\t\tvar dollyDelta = new THREE.Vector2();\n\t\n\t\t\tfunction getAutoRotationAngle() {\n\t\n\t\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getZoomScale() {\n\t\n\t\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\t\n\t\t\t}\n\t\n\t\t\tfunction rotateLeft( angle ) {\n\t\n\t\t\t\tsphericalDelta.theta -= angle;\n\t\n\t\t\t}\n\t\n\t\t\tfunction rotateUp( angle ) {\n\t\n\t\t\t\tsphericalDelta.phi -= angle;\n\t\n\t\t\t}\n\t\n\t\t\tvar panLeft = function() {\n\t\n\t\t\t\tvar v = new THREE.Vector3();\n\t\n\t\t\t\treturn function panLeft( distance, objectMatrix ) {\n\t\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\t\tv.multiplyScalar( - distance );\n\t\n\t\t\t\t\tpanOffset.add( v );\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t\tvar panUp = function() {\n\t\n\t\t\t\tvar v = new THREE.Vector3();\n\t\n\t\t\t\treturn function panUp( distance, objectMatrix ) {\n\t\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\t\t\tv.multiplyScalar( distance );\n\t\n\t\t\t\t\tpanOffset.add( v );\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\t\tvar pan = function() {\n\t\n\t\t\t\tvar offset = new THREE.Vector3();\n\t\n\t\t\t\treturn function pan ( deltaX, deltaY ) {\n\t\n\t\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\t\t// perspective\n\t\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\t\tvar targetDistance = offset.length();\n\t\n\t\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\t\n\t\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\t\n\t\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\t\t// orthographic\n\t\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\t\tscope.enablePan = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t\tfunction dollyIn( dollyScale ) {\n\t\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\tscale /= dollyScale;\n\t\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\tzoomChanged = true;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\t\tscope.enableZoom = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction dollyOut( dollyScale ) {\n\t\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\tscale *= dollyScale;\n\t\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\tzoomChanged = true;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\t\tscope.enableZoom = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\t\t// event callbacks - update the object state\n\t\t\t//\n\t\n\t\t\tfunction handleMouseDownRotate( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseDownRotate' );\n\t\n\t\t\t\trotateStart.set( event.clientX, event.clientY );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseDownDolly( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseDownDolly' );\n\t\n\t\t\t\tdollyStart.set( event.clientX, event.clientY );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseDownPan( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseDownPan' );\n\t\n\t\t\t\tpanStart.set( event.clientX, event.clientY );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseMoveRotate( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseMoveRotate' );\n\t\n\t\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\t\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\t\n\t\t\t\trotateStart.copy( rotateEnd );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseMoveDolly( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseMoveDolly' );\n\t\n\t\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\t\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\t\n\t\t\t\t\tdollyIn( getZoomScale() );\n\t\n\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\t\n\t\t\t\t\tdollyOut( getZoomScale() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdollyStart.copy( dollyEnd );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseMovePan( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseMovePan' );\n\t\n\t\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\n\t\t\t\tpan( panDelta.x, panDelta.y );\n\t\n\t\t\t\tpanStart.copy( panEnd );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseUp( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseUp' );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleMouseWheel( event ) {\n\t\n\t\t\t\t//console.log( 'handleMouseWheel' );\n\t\n\t\t\t\tif ( event.deltaY < 0 ) {\n\t\n\t\t\t\t\tdollyOut( getZoomScale() );\n\t\n\t\t\t\t} else if ( event.deltaY > 0 ) {\n\t\n\t\t\t\t\tdollyIn( getZoomScale() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleKeyDown( event ) {\n\t\n\t\t\t\t//console.log( 'handleKeyDown' );\n\t\n\t\t\t\tswitch ( event.keyCode ) {\n\t\n\t\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchStartRotate( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchStartRotate' );\n\t\n\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchStartDolly( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchStartDolly' );\n\t\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\n\t\t\t\tdollyStart.set( 0, distance );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchStartPan( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchStartPan' );\n\t\n\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchMoveRotate( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchMoveRotate' );\n\t\n\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\t\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\t\n\t\t\t\trotateStart.copy( rotateEnd );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchMoveDolly( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchMoveDolly' );\n\t\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\n\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\n\t\t\t\tdollyEnd.set( 0, distance );\n\t\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\t\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\t\n\t\t\t\t\tdollyOut( getZoomScale() );\n\t\n\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\t\n\t\t\t\t\tdollyIn( getZoomScale() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdollyStart.copy( dollyEnd );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchMovePan( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchMovePan' );\n\t\n\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\n\t\t\t\tpan( panDelta.x, panDelta.y );\n\t\n\t\t\t\tpanStart.copy( panEnd );\n\t\n\t\t\t\tscope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction handleTouchEnd( event ) {\n\t\n\t\t\t\t//console.log( 'handleTouchEnd' );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\t\t// event handlers - FSM: listen for events and reset state\n\t\t\t//\n\t\n\t\t\tfunction onMouseDown( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\t\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\n\t\t\t\t\thandleMouseDownRotate( event );\n\t\n\t\t\t\t\tstate = STATE.ROTATE;\n\t\n\t\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\t\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\n\t\t\t\t\thandleMouseDownDolly( event );\n\t\n\t\t\t\t\tstate = STATE.DOLLY;\n\t\n\t\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\t\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\n\t\t\t\t\thandleMouseDownPan( event );\n\t\n\t\t\t\t\tstate = STATE.PAN;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( state !== STATE.NONE ) {\n\t\n\t\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\t\n\t\t\t\t\tscope.dispatchEvent( startEvent );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseMove( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tif ( state === STATE.ROTATE ) {\n\t\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\n\t\t\t\t\thandleMouseMoveRotate( event );\n\t\n\t\t\t\t} else if ( state === STATE.DOLLY ) {\n\t\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\n\t\t\t\t\thandleMouseMoveDolly( event );\n\t\n\t\t\t\t} else if ( state === STATE.PAN ) {\n\t\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\n\t\t\t\t\thandleMouseMovePan( event );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseUp( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\thandleMouseUp( event );\n\t\n\t\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\n\t\t\t\tscope.dispatchEvent( endEvent );\n\t\n\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseWheel( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\n\t\t\t\thandleMouseWheel( event );\n\t\n\t\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\t\t\tscope.dispatchEvent( endEvent );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onKeyDown( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\t\n\t\t\t\thandleKeyDown( event );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onTouchStart( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tswitch ( event.touches.length ) {\n\t\n\t\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\t\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\n\t\t\t\t\t\thandleTouchStartRotate( event );\n\t\n\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\t\n\t\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\n\t\t\t\t\t\thandleTouchStartDolly( event );\n\t\n\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 3: // three-fingered touch: pan\n\t\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\n\t\t\t\t\t\thandleTouchStartPan( event );\n\t\n\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( state !== STATE.NONE ) {\n\t\n\t\t\t\t\tscope.dispatchEvent( startEvent );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction onTouchMove( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\n\t\t\t\tswitch ( event.touches.length ) {\n\t\n\t\t\t\t\tcase 1: // one-fingered touch: rotate\n\t\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\t\n\t\t\t\t\t\thandleTouchMoveRotate( event );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 2: // two-fingered touch: dolly\n\t\n\t\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\t\n\t\t\t\t\t\thandleTouchMoveDolly( event );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 3: // three-fingered touch: pan\n\t\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\t\n\t\t\t\t\t\thandleTouchMovePan( event );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction onTouchEnd( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\thandleTouchEnd( event );\n\t\n\t\t\t\tscope.dispatchEvent( endEvent );\n\t\n\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t}\n\t\n\t\t\tfunction onContextMenu( event ) {\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\t\n\t\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\t\n\t\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\t\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\t\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\t\n\t\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\t\n\t\t\t// force an update at start\n\t\n\t\t\tthis.update();\n\t\n\t\t};\n\t\n\t\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\t\tOrbitControls.prototype.constructor = OrbitControls;\n\t\n\t\tObject.defineProperties( OrbitControls.prototype, {\n\t\n\t\t\tcenter: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\t\t\treturn this.target;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// backward compatibility\n\t\n\t\t\tnoZoom: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\t\treturn ! this.enableZoom;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\t\tthis.enableZoom = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tnoRotate: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\t\treturn ! this.enableRotate;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\t\tthis.enableRotate = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tnoPan: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\t\treturn ! this.enablePan;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\t\tthis.enablePan = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tnoKeys: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\t\treturn ! this.enableKeys;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\t\tthis.enableKeys = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tstaticMoving : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\t\treturn ! this.enableDamping;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\t\tthis.enableDamping = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdynamicDampingFactor : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\t\treturn this.dampingFactor;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\t\tthis.dampingFactor = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\treturn OrbitControls;\n\t};\n\n\n/***/ }),\n\n/***/ 178:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.THREE = {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\t\t// Polyfills\n\t\n\t\tif ( Number.EPSILON === undefined ) {\n\t\n\t\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\t\n\t\t}\n\t\n\t\tif ( Number.isInteger === undefined ) {\n\t\n\t\t\t// Missing in IE\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n\t\n\t\t\tNumber.isInteger = function ( value ) {\n\t\n\t\t\t\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tif ( Math.sign === undefined ) {\n\t\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\t\n\t\t\tMath.sign = function ( x ) {\n\t\n\t\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tif ( 'name' in Function.prototype === false ) {\n\t\n\t\t\t// Missing in IE\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t\n\t\t\tObject.defineProperty( Function.prototype, 'name', {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tif ( Object.assign === undefined ) {\n\t\n\t\t\t// Missing in IE\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t\n\t\t\t( function () {\n\t\n\t\t\t\tObject.assign = function ( target ) {\n\t\n\t\t\t\t\tif ( target === undefined || target === null ) {\n\t\n\t\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar output = Object( target );\n\t\n\t\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\t\n\t\t\t\t\t\tvar source = arguments[ index ];\n\t\n\t\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\t\n\t\t\t\t\t\t\tfor ( var nextKey in source ) {\n\t\n\t\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\t\n\t\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn output;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )();\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * https://github.com/mrdoob/eventdispatcher.js/\n\t\t */\n\t\n\t\tfunction EventDispatcher() {}\n\t\n\t\tObject.assign( EventDispatcher.prototype, {\n\t\n\t\t\taddEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\tif ( listeners[ type ] === undefined ) {\n\t\n\t\t\t\t\tlisteners[ type ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\t\n\t\t\t\t\tlisteners[ type ].push( listener );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\thasEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return false;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\n\t\t\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\t\n\t\t\t},\n\t\n\t\t\tremoveEventListener: function ( type, listener ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tvar index = listenerArray.indexOf( listener );\n\t\n\t\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\t\tlistenerArray.splice( index, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdispatchEvent: function ( event ) {\n\t\n\t\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\t\tvar listeners = this._listeners;\n\t\t\t\tvar listenerArray = listeners[ event.type ];\n\t\n\t\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\t\tevent.target = this;\n\t\n\t\t\t\t\tvar array = listenerArray.slice( 0 );\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ].call( this, event );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar REVISION = '90';\n\t\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\t\tvar CullFaceNone = 0;\n\t\tvar CullFaceBack = 1;\n\t\tvar CullFaceFront = 2;\n\t\tvar CullFaceFrontBack = 3;\n\t\tvar FrontFaceDirectionCW = 0;\n\t\tvar FrontFaceDirectionCCW = 1;\n\t\tvar BasicShadowMap = 0;\n\t\tvar PCFShadowMap = 1;\n\t\tvar PCFSoftShadowMap = 2;\n\t\tvar FrontSide = 0;\n\t\tvar BackSide = 1;\n\t\tvar DoubleSide = 2;\n\t\tvar FlatShading = 1;\n\t\tvar SmoothShading = 2;\n\t\tvar NoColors = 0;\n\t\tvar FaceColors = 1;\n\t\tvar VertexColors = 2;\n\t\tvar NoBlending = 0;\n\t\tvar NormalBlending = 1;\n\t\tvar AdditiveBlending = 2;\n\t\tvar SubtractiveBlending = 3;\n\t\tvar MultiplyBlending = 4;\n\t\tvar CustomBlending = 5;\n\t\tvar AddEquation = 100;\n\t\tvar SubtractEquation = 101;\n\t\tvar ReverseSubtractEquation = 102;\n\t\tvar MinEquation = 103;\n\t\tvar MaxEquation = 104;\n\t\tvar ZeroFactor = 200;\n\t\tvar OneFactor = 201;\n\t\tvar SrcColorFactor = 202;\n\t\tvar OneMinusSrcColorFactor = 203;\n\t\tvar SrcAlphaFactor = 204;\n\t\tvar OneMinusSrcAlphaFactor = 205;\n\t\tvar DstAlphaFactor = 206;\n\t\tvar OneMinusDstAlphaFactor = 207;\n\t\tvar DstColorFactor = 208;\n\t\tvar OneMinusDstColorFactor = 209;\n\t\tvar SrcAlphaSaturateFactor = 210;\n\t\tvar NeverDepth = 0;\n\t\tvar AlwaysDepth = 1;\n\t\tvar LessDepth = 2;\n\t\tvar LessEqualDepth = 3;\n\t\tvar EqualDepth = 4;\n\t\tvar GreaterEqualDepth = 5;\n\t\tvar GreaterDepth = 6;\n\t\tvar NotEqualDepth = 7;\n\t\tvar MultiplyOperation = 0;\n\t\tvar MixOperation = 1;\n\t\tvar AddOperation = 2;\n\t\tvar NoToneMapping = 0;\n\t\tvar LinearToneMapping = 1;\n\t\tvar ReinhardToneMapping = 2;\n\t\tvar Uncharted2ToneMapping = 3;\n\t\tvar CineonToneMapping = 4;\n\t\tvar UVMapping = 300;\n\t\tvar CubeReflectionMapping = 301;\n\t\tvar CubeRefractionMapping = 302;\n\t\tvar EquirectangularReflectionMapping = 303;\n\t\tvar EquirectangularRefractionMapping = 304;\n\t\tvar SphericalReflectionMapping = 305;\n\t\tvar CubeUVReflectionMapping = 306;\n\t\tvar CubeUVRefractionMapping = 307;\n\t\tvar RepeatWrapping = 1000;\n\t\tvar ClampToEdgeWrapping = 1001;\n\t\tvar MirroredRepeatWrapping = 1002;\n\t\tvar NearestFilter = 1003;\n\t\tvar NearestMipMapNearestFilter = 1004;\n\t\tvar NearestMipMapLinearFilter = 1005;\n\t\tvar LinearFilter = 1006;\n\t\tvar LinearMipMapNearestFilter = 1007;\n\t\tvar LinearMipMapLinearFilter = 1008;\n\t\tvar UnsignedByteType = 1009;\n\t\tvar ByteType = 1010;\n\t\tvar ShortType = 1011;\n\t\tvar UnsignedShortType = 1012;\n\t\tvar IntType = 1013;\n\t\tvar UnsignedIntType = 1014;\n\t\tvar FloatType = 1015;\n\t\tvar HalfFloatType = 1016;\n\t\tvar UnsignedShort4444Type = 1017;\n\t\tvar UnsignedShort5551Type = 1018;\n\t\tvar UnsignedShort565Type = 1019;\n\t\tvar UnsignedInt248Type = 1020;\n\t\tvar AlphaFormat = 1021;\n\t\tvar RGBFormat = 1022;\n\t\tvar RGBAFormat = 1023;\n\t\tvar LuminanceFormat = 1024;\n\t\tvar LuminanceAlphaFormat = 1025;\n\t\tvar RGBEFormat = RGBAFormat;\n\t\tvar DepthFormat = 1026;\n\t\tvar DepthStencilFormat = 1027;\n\t\tvar RGB_S3TC_DXT1_Format = 33776;\n\t\tvar RGBA_S3TC_DXT1_Format = 33777;\n\t\tvar RGBA_S3TC_DXT3_Format = 33778;\n\t\tvar RGBA_S3TC_DXT5_Format = 33779;\n\t\tvar RGB_PVRTC_4BPPV1_Format = 35840;\n\t\tvar RGB_PVRTC_2BPPV1_Format = 35841;\n\t\tvar RGBA_PVRTC_4BPPV1_Format = 35842;\n\t\tvar RGBA_PVRTC_2BPPV1_Format = 35843;\n\t\tvar RGB_ETC1_Format = 36196;\n\t\tvar RGBA_ASTC_4x4_Format = 37808;\n\t\tvar RGBA_ASTC_5x4_Format = 37809;\n\t\tvar RGBA_ASTC_5x5_Format = 37810;\n\t\tvar RGBA_ASTC_6x5_Format = 37811;\n\t\tvar RGBA_ASTC_6x6_Format = 37812;\n\t\tvar RGBA_ASTC_8x5_Format = 37813;\n\t\tvar RGBA_ASTC_8x6_Format = 37814;\n\t\tvar RGBA_ASTC_8x8_Format = 37815;\n\t\tvar RGBA_ASTC_10x5_Format = 37816;\n\t\tvar RGBA_ASTC_10x6_Format = 37817;\n\t\tvar RGBA_ASTC_10x8_Format = 37818;\n\t\tvar RGBA_ASTC_10x10_Format = 37819;\n\t\tvar RGBA_ASTC_12x10_Format = 37820;\n\t\tvar RGBA_ASTC_12x12_Format = 37821;\n\t\tvar LoopOnce = 2200;\n\t\tvar LoopRepeat = 2201;\n\t\tvar LoopPingPong = 2202;\n\t\tvar InterpolateDiscrete = 2300;\n\t\tvar InterpolateLinear = 2301;\n\t\tvar InterpolateSmooth = 2302;\n\t\tvar ZeroCurvatureEnding = 2400;\n\t\tvar ZeroSlopeEnding = 2401;\n\t\tvar WrapAroundEnding = 2402;\n\t\tvar TrianglesDrawMode = 0;\n\t\tvar TriangleStripDrawMode = 1;\n\t\tvar TriangleFanDrawMode = 2;\n\t\tvar LinearEncoding = 3000;\n\t\tvar sRGBEncoding = 3001;\n\t\tvar GammaEncoding = 3007;\n\t\tvar RGBEEncoding = 3002;\n\t\tvar LogLuvEncoding = 3003;\n\t\tvar RGBM7Encoding = 3004;\n\t\tvar RGBM16Encoding = 3005;\n\t\tvar RGBDEncoding = 3006;\n\t\tvar BasicDepthPacking = 3200;\n\t\tvar RGBADepthPacking = 3201;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar _Math = {\n\t\n\t\t\tDEG2RAD: Math.PI / 180,\n\t\t\tRAD2DEG: 180 / Math.PI,\n\t\n\t\t\tgenerateUUID: ( function () {\n\t\n\t\t\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\t\n\t\t\t\tvar lut = [];\n\t\n\t\t\t\tfor ( var i = 0; i < 256; i ++ ) {\n\t\n\t\t\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function generateUUID() {\n\t\n\t\t\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\treturn lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\n\t\t\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tclamp: function ( value, min, max ) {\n\t\n\t\t\t\treturn Math.max( min, Math.min( max, value ) );\n\t\n\t\t\t},\n\t\n\t\t\t// compute euclidian modulo of m % n\n\t\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\t\n\t\t\teuclideanModulo: function ( n, m ) {\n\t\n\t\t\t\treturn ( ( n % m ) + m ) % m;\n\t\n\t\t\t},\n\t\n\t\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\t\n\t\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\t\n\t\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\t\n\t\t\t},\n\t\n\t\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\t\n\t\t\tlerp: function ( x, y, t ) {\n\t\n\t\t\t\treturn ( 1 - t ) * x + t * y;\n\t\n\t\t\t},\n\t\n\t\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\t\n\t\t\tsmoothstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * ( 3 - 2 * x );\n\t\n\t\t\t},\n\t\n\t\t\tsmootherstep: function ( x, min, max ) {\n\t\n\t\t\t\tif ( x <= min ) return 0;\n\t\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\t\n\t\t\t},\n\t\n\t\t\t// Random integer from <low, high> interval\n\t\n\t\t\trandInt: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <low, high> interval\n\t\n\t\t\trandFloat: function ( low, high ) {\n\t\n\t\t\t\treturn low + Math.random() * ( high - low );\n\t\n\t\t\t},\n\t\n\t\t\t// Random float from <-range/2, range/2> interval\n\t\n\t\t\trandFloatSpread: function ( range ) {\n\t\n\t\t\t\treturn range * ( 0.5 - Math.random() );\n\t\n\t\t\t},\n\t\n\t\t\tdegToRad: function ( degrees ) {\n\t\n\t\t\t\treturn degrees * _Math.DEG2RAD;\n\t\n\t\t\t},\n\t\n\t\t\tradToDeg: function ( radians ) {\n\t\n\t\t\t\treturn radians * _Math.RAD2DEG;\n\t\n\t\t\t},\n\t\n\t\t\tisPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\t\n\t\t\t},\n\t\n\t\t\tceilPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t\t},\n\t\n\t\t\tfloorPowerOfTwo: function ( value ) {\n\t\n\t\t\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tfunction Vector2( x, y ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\n\t\t}\n\t\n\t\tObject.defineProperties( Vector2.prototype, {\n\t\n\t\t\t\"width\": {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.x;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.x = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t\"height\": {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.y;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.y = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Vector2.prototype, {\n\t\n\t\t\tisVector2: true,\n\t\n\t\t\tset: function ( x, y ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v ) {\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// assumes min < max, componentwise\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min = new Vector2();\n\t\t\t\tvar max = new Vector2();\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\t\n\t\t\t},\n\t\n\t\t\tmanhattanLength: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() || 1 );\n\t\n\t\t\t},\n\t\n\t\t\tangle: function () {\n\t\n\t\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\n\t\t\t\tvar angle = Math.atan2( this.y, this.x );\n\t\n\t\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\t\n\t\t\t\treturn angle;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\t\treturn dx * dx + dy * dy;\n\t\n\t\t\t},\n\t\n\t\t\tmanhattanDistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.normalize().multiplyScalar( length );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromBufferAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x = attribute.getX( index );\n\t\t\t\tthis.y = attribute.getY( index );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateAround: function ( center, angle ) {\n\t\n\t\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\t\n\t\t\t\tvar x = this.x - center.x;\n\t\t\t\tvar y = this.y - center.y;\n\t\n\t\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\t\tthis.y = x * s + y * c + center.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author jordi_ros / http://plattsoft.com\n\t\t * @author D1plo1d / http://github.com/D1plo1d\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author timknip / http://www.floorplanner.com/\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Matrix4() {\n\t\n\t\t\tthis.elements = [\n\t\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t];\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Matrix4.prototype, {\n\t\n\t\t\tisMatrix4: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, 0,\n\t\t\t\t\t0, 1, 0, 0,\n\t\t\t\t\t0, 0, 1, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Matrix4().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\t\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\t\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\t\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyPosition: function ( m ) {\n\t\n\t\t\t\tvar te = this.elements, me = m.elements;\n\t\n\t\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\t\tte[ 14 ] = me[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\t\tthis.set(\n\t\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\textractRotation: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function extractRotation( m ) {\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\n\t\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\n\t\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakeRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\t\n\t\t\t\tif ( euler.order === 'XYZ' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\t\tte[ 8 ] = d;\n\t\n\t\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\t\tte[ 9 ] = - b * c;\n\t\n\t\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YXZ' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\t\tte[ 8 ] = a * d;\n\t\n\t\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b;\n\t\n\t\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZXY' ) {\n\t\n\t\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\t\tte[ 8 ] = de + cf * b;\n\t\n\t\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = df - ce * b;\n\t\n\t\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\t\tte[ 6 ] = b;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'ZYX' ) {\n\t\n\t\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\t\tte[ 8 ] = ae * d + bf;\n\t\n\t\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\t\tte[ 9 ] = af * d - be;\n\t\n\t\t\t\t\tte[ 2 ] = - d;\n\t\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t\t} else if ( euler.order === 'YZX' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\t\tte[ 8 ] = bc * f + ad;\n\t\n\t\t\t\t\tte[ 1 ] = f;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = - b * e;\n\t\n\t\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\t\tte[ 10 ] = ac - bd * f;\n\t\n\t\t\t\t} else if ( euler.order === 'XZY' ) {\n\t\n\t\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\t\tte[ 4 ] = - f;\n\t\t\t\t\tte[ 8 ] = d * e;\n\t\n\t\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\t\tte[ 9 ] = ad * f - bc;\n\t\n\t\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\t\tte[ 10 ] = bd * f + ac;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar x = q._x, y = q._y, z = q._z, w = q._w;\n\t\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\t\n\t\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\t\tte[ 4 ] = xy - wz;\n\t\t\t\tte[ 8 ] = xz + wy;\n\t\n\t\t\t\tte[ 1 ] = xy + wz;\n\t\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\t\tte[ 9 ] = yz - wx;\n\t\n\t\t\t\tte[ 2 ] = xz - wy;\n\t\t\t\tte[ 6 ] = yz + wx;\n\t\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\t\n\t\t\t\t// last column\n\t\t\t\tte[ 3 ] = 0;\n\t\t\t\tte[ 7 ] = 0;\n\t\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t\t// bottom row\n\t\t\t\tte[ 12 ] = 0;\n\t\t\t\tte[ 13 ] = 0;\n\t\t\t\tte[ 14 ] = 0;\n\t\t\t\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar x = new Vector3();\n\t\t\t\tvar y = new Vector3();\n\t\t\t\tvar z = new Vector3();\n\t\n\t\t\t\treturn function lookAt( eye, target, up ) {\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tz.subVectors( eye, target );\n\t\n\t\t\t\t\tif ( z.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\t// eye and target are in the same position\n\t\n\t\t\t\t\t\tz.z = 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tz.normalize();\n\t\t\t\t\tx.crossVectors( up, z );\n\t\n\t\t\t\t\tif ( x.lengthSq() === 0 ) {\n\t\n\t\t\t\t\t\t// up and z are parallel\n\t\n\t\t\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\t\n\t\t\t\t\t\t\tz.x += 0.0001;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tz.z += 0.0001;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tz.normalize();\n\t\t\t\t\t\tx.crossVectors( up, z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tx.normalize();\n\t\t\t\t\ty.crossVectors( z, x );\n\t\n\t\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiply: function ( m, n ) {\n\t\n\t\t\t\tif ( n !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyMatrices( m, n );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( m ) {\n\t\n\t\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\t\tvar ae = a.elements;\n\t\t\t\tvar be = b.elements;\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\t\n\t\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\t\n\t\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\n\t\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\n\t\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\n\t\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToBufferAttribute: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function applyToBufferAttribute( attribute ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\t\t\tv1.z = attribute.getZ( i );\n\t\n\t\t\t\t\t\tv1.applyMatrix4( this );\n\t\n\t\t\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn attribute;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\t\n\t\t\t\t//TODO: make this more efficient\n\t\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\t\n\t\t\t\treturn (\n\t\t\t\t\tn41 * (\n\t\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t\t) +\n\t\t\t\t\tn42 * (\n\t\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn43 * (\n\t\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t\t) +\n\t\t\t\t\tn44 * (\n\t\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t\t)\n\t\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar tmp;\n\t\n\t\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\t\n\t\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPosition: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 12 ] = v.x;\n\t\t\t\tte[ 13 ] = v.y;\n\t\t\t\tte[ 14 ] = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\t\n\t\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\t\tvar te = this.elements,\n\t\t\t\t\tme = m.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\t\n\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\n\t\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\t\n\t\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tscale: function ( v ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = v.x, y = v.y, z = v.z;\n\t\n\t\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxScaleOnAxis: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\t\n\t\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\t\n\t\t\t},\n\t\n\t\t\tmakeTranslation: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, x,\n\t\t\t\t\t0, 1, 0, y,\n\t\t\t\t\t0, 0, 1, z,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationX: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0, 0,\n\t\t\t\t\t0, c, - s, 0,\n\t\t\t\t\t0, s, c, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationY: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t c, 0, s, 0,\n\t\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t\t- s, 0, c, 0,\n\t\t\t\t\t 0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationZ: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tc, - s, 0, 0,\n\t\t\t\t\ts, c, 0, 0,\n\t\t\t\t\t0, 0, 1, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeRotationAxis: function ( axis, angle ) {\n\t\n\t\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\n\t\t\t\tvar c = Math.cos( angle );\n\t\t\t\tvar s = Math.sin( angle );\n\t\t\t\tvar t = 1 - c;\n\t\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\t\tvar tx = t * x, ty = t * y;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\t return this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeScale: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tx, 0, 0, 0,\n\t\t\t\t\t0, y, 0, 0,\n\t\t\t\t\t0, 0, z, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeShear: function ( x, y, z ) {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, y, z, 0,\n\t\t\t\t\tx, 1, z, 0,\n\t\t\t\t\tx, y, 1, 0,\n\t\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcompose: function ( position, quaternion, scale ) {\n\t\n\t\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\t\tthis.scale( scale );\n\t\t\t\tthis.setPosition( position );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdecompose: function () {\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function decompose( position, quaternion, scale ) {\n\t\n\t\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\t\n\t\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\t\tvar det = this.determinant();\n\t\t\t\t\tif ( det < 0 ) sx = - sx;\n\t\n\t\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\t\tposition.z = te[ 14 ];\n\t\n\t\t\t\t\t// scale the rotation part\n\t\t\t\t\tmatrix.copy( this );\n\t\n\t\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\t\tvar invSZ = 1 / sz;\n\t\n\t\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\t\n\t\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\t\n\t\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\t\n\t\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\t\n\t\t\t\t\tscale.x = sx;\n\t\t\t\t\tscale.y = sy;\n\t\t\t\t\tscale.z = sz;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmakePerspective: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\t\tif ( far === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar x = 2 * near / ( right - left );\n\t\t\t\tvar y = 2 * near / ( top - bottom );\n\t\n\t\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\t\tvar d = - 2 * far * near / ( far - near );\n\t\n\t\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar w = 1.0 / ( right - left );\n\t\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\t\tvar p = 1.0 / ( far - near );\n\t\n\t\t\t\tvar x = ( right + left ) * w;\n\t\t\t\tvar y = ( top + bottom ) * h;\n\t\t\t\tvar z = ( far + near ) * p;\n\t\n\t\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( matrix ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = matrix.elements;\n\t\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\n\t\t\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\t\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\t\n\t\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Quaternion( x, y, z, w ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tObject.assign( Quaternion, {\n\t\n\t\t\tslerp: function ( qa, qb, qm, t ) {\n\t\n\t\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\t\n\t\t\t},\n\t\n\t\t\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\t\n\t\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\n\t\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\t\n\t\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\t\n\t\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\t\n\t\t\t\t\tvar s = 1 - t,\n\t\n\t\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\n\t\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\t\tsqrSin = 1 - cos * cos;\n\t\n\t\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\t\n\t\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar tDir = t * dir;\n\t\n\t\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\t\tw0 = w0 * s + w1 * tDir;\n\t\n\t\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\t\tif ( s === 1 - t ) {\n\t\n\t\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\t\n\t\t\t\t\t\tx0 *= f;\n\t\t\t\t\t\ty0 *= f;\n\t\t\t\t\t\tz0 *= f;\n\t\t\t\t\t\tw0 *= f;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdst[ dstOffset ] = x0;\n\t\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( Quaternion.prototype, {\n\t\n\t\t\tx: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._x;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._x = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ty: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._y;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._y = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tz: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._z;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._z = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tw: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._w;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._w = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Quaternion.prototype, {\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._w = w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( quaternion ) {\n\t\n\t\t\t\tthis._x = quaternion.x;\n\t\t\t\tthis._y = quaternion.y;\n\t\t\t\tthis._z = quaternion.z;\n\t\t\t\tthis._w = quaternion.w;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromEuler: function ( euler, update ) {\n\t\n\t\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\t\n\t\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\n\t\n\t\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t\t//\tcontent/SpinCalc.m\n\t\n\t\t\t\tvar cos = Math.cos;\n\t\t\t\tvar sin = Math.sin;\n\t\n\t\t\t\tvar c1 = cos( x / 2 );\n\t\t\t\tvar c2 = cos( y / 2 );\n\t\t\t\tvar c3 = cos( z / 2 );\n\t\n\t\t\t\tvar s1 = sin( x / 2 );\n\t\t\t\tvar s2 = sin( y / 2 );\n\t\t\t\tvar s3 = sin( z / 2 );\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\t\n\t\t\t\tthis._x = axis.x * s;\n\t\t\t\tthis._y = axis.y * s;\n\t\t\t\tthis._z = axis.z * s;\n\t\t\t\tthis._w = Math.cos( halfAngle );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\t\n\t\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\t\ts;\n\t\n\t\t\t\tif ( trace > 0 ) {\n\t\n\t\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\t\n\t\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\t\n\t\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\t\n\t\t\t\t} else if ( m22 > m33 ) {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\t\n\t\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\t\n\t\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\t\tthis._z = 0.25 * s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromUnitVectors: function () {\n\t\n\t\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar r;\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\n\t\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\n\t\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\t\n\t\t\t\t\tif ( r < EPS ) {\n\t\n\t\t\t\t\t\tr = 0;\n\t\n\t\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\t\n\t\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._x = v1.x;\n\t\t\t\t\tthis._y = v1.y;\n\t\t\t\t\tthis._z = v1.z;\n\t\t\t\t\tthis._w = r;\n\t\n\t\t\t\t\treturn this.normalize();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tinverse: function () {\n\t\n\t\t\t\t// quaternion is assumed to have unit length\n\t\n\t\t\t\treturn this.conjugate();\n\t\n\t\t\t},\n\t\n\t\t\tconjugate: function () {\n\t\n\t\t\t\tthis._x *= - 1;\n\t\t\t\tthis._y *= - 1;\n\t\t\t\tthis._z *= - 1;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tvar l = this.length();\n\t\n\t\t\t\tif ( l === 0 ) {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tl = 1 / l;\n\t\n\t\t\t\t\tthis._x = this._x * l;\n\t\t\t\t\tthis._y = this._y * l;\n\t\t\t\t\tthis._z = this._z * l;\n\t\t\t\t\tthis._w = this._w * l;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( q, p ) {\n\t\n\t\t\t\tif ( p !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyQuaternions( q, p );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.multiplyQuaternions( this, q );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( q ) {\n\t\n\t\t\t\treturn this.multiplyQuaternions( q, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyQuaternions: function ( a, b ) {\n\t\n\t\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\n\t\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\t\n\t\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tslerp: function ( qb, t ) {\n\t\n\t\t\t\tif ( t === 0 ) return this;\n\t\t\t\tif ( t === 1 ) return this.copy( qb );\n\t\n\t\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\t\n\t\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\t\n\t\t\t\tif ( cosHalfTheta < 0 ) {\n\t\n\t\t\t\t\tthis._w = - qb._w;\n\t\t\t\t\tthis._x = - qb._x;\n\t\t\t\t\tthis._y = - qb._y;\n\t\t\t\t\tthis._z = - qb._z;\n\t\n\t\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.copy( qb );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\t\n\t\t\t\t\tthis._w = w;\n\t\t\t\t\tthis._x = x;\n\t\t\t\t\tthis._y = y;\n\t\t\t\t\tthis._z = z;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\t\n\t\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\t\n\t\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\t\n\t\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( quaternion ) {\n\t\n\t\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis._x = array[ offset ];\n\t\t\t\tthis._y = array[ offset + 1 ];\n\t\t\t\tthis._z = array[ offset + 2 ];\n\t\t\t\tthis._w = array[ offset + 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author kile / http://kile.stravaganza.org/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector3( x, y, z ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\n\t\t}\n\t\n\t\tObject.assign( Vector3.prototype, {\n\t\n\t\t\tisVector3: true,\n\t\n\t\t\tset: function ( x, y, z ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.multiplyVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x *= v.x;\n\t\t\t\tthis.y *= v.y;\n\t\t\t\tthis.z *= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x * b.x;\n\t\t\t\tthis.y = a.y * b.y;\n\t\t\t\tthis.z = a.z * b.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyEuler: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function applyEuler( euler ) {\n\t\n\t\t\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyAxisAngle: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function applyAxisAngle( axis, angle ) {\n\t\n\t\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\t\n\t\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\t\n\t\t\t\t// calculate quat * vector\n\t\n\t\t\t\tvar ix = qw * x + qy * z - qz * y;\n\t\t\t\tvar iy = qw * y + qz * x - qx * z;\n\t\t\t\tvar iz = qw * z + qx * y - qy * x;\n\t\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\t\n\t\t\t\t// calculate result * inverse quat\n\t\n\t\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tproject: function () {\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function project( camera ) {\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\t\treturn this.applyMatrix4( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tunproject: function () {\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function unproject( camera ) {\n\t\n\t\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\t\treturn this.applyMatrix4( matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttransformDirection: function ( m ) {\n\t\n\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t\t// vector interpreted as a direction\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\t\n\t\t\t\treturn this.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tdivide: function ( v ) {\n\t\n\t\t\t\tthis.x /= v.x;\n\t\t\t\tthis.y /= v.y;\n\t\t\t\tthis.z /= v.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// assumes min < max, componentwise\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min = new Vector3();\n\t\t\t\tvar max = new Vector3();\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\n\t\t\t},\n\t\n\t\t\t// TODO lengthSquared?\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\t\n\t\t\t},\n\t\n\t\t\tmanhattanLength: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() || 1 );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.normalize().multiplyScalar( length );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tcross: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.crossVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.crossVectors( this, v );\n\t\n\t\t\t},\n\t\n\t\t\tcrossVectors: function ( a, b ) {\n\t\n\t\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\t\n\t\t\t\tthis.x = ay * bz - az * by;\n\t\t\t\tthis.y = az * bx - ax * bz;\n\t\t\t\tthis.z = ax * by - ay * bx;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnVector: function ( vector ) {\n\t\n\t\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t\t\t},\n\t\n\t\t\tprojectOnPlane: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function projectOnPlane( planeNormal ) {\n\t\n\t\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\t\n\t\t\t\t\treturn this.sub( v1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\treflect: function () {\n\t\n\t\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t\t// normal is assumed to have unit length\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function reflect( normal ) {\n\t\n\t\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tangleTo: function ( v ) {\n\t\n\t\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\t\n\t\t\t\t// clamp, to handle numerical problems\n\t\n\t\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\t\n\t\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\n\t\t\t},\n\t\n\t\t\tmanhattanDistanceTo: function ( v ) {\n\t\n\t\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromSpherical: function ( s ) {\n\t\n\t\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\t\n\t\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCylindrical: function ( c ) {\n\t\n\t\t\t\tthis.x = c.radius * Math.sin( c.theta );\n\t\t\t\tthis.y = c.y;\n\t\t\t\tthis.z = c.radius * Math.cos( c.theta );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixPosition: function ( m ) {\n\t\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 12 ];\n\t\t\t\tthis.y = e[ 13 ];\n\t\t\t\tthis.z = e[ 14 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixScale: function ( m ) {\n\t\n\t\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\tthis.x = sx;\n\t\t\t\tthis.y = sy;\n\t\t\t\tthis.z = sz;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrixColumn: function ( m, index ) {\n\t\n\t\t\t\treturn this.fromArray( m.elements, index * 4 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromBufferAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x = attribute.getX( index );\n\t\t\t\tthis.y = attribute.getY( index );\n\t\t\t\tthis.z = attribute.getZ( index );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Matrix3() {\n\t\n\t\t\tthis.elements = [\n\t\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\t\n\t\t\t];\n\t\n\t\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Matrix3.prototype, {\n\t\n\t\t\tisMatrix3: true,\n\t\n\t\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tidentity: function () {\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t0, 0, 1\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().fromArray( this.elements );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( m ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\t\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\t\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix4: function ( m ) {\n\t\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tthis.set(\n\t\n\t\t\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\t\n\t\t\t\t);\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyToBufferAttribute: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function applyToBufferAttribute( attribute ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\t\t\tv1.z = attribute.getZ( i );\n\t\n\t\t\t\t\t\tv1.applyMatrix3( this );\n\t\n\t\t\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn attribute;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmultiply: function ( m ) {\n\t\n\t\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t\t},\n\t\n\t\t\tpremultiply: function ( m ) {\n\t\n\t\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\t\tvar ae = a.elements;\n\t\t\t\tvar be = b.elements;\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\t\n\t\t\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\t\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\t\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\t\n\t\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\t\n\t\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\t\n\t\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdeterminant: function () {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\t\n\t\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\n\t\t\t},\n\t\n\t\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\t\n\t\t\t\tif ( matrix && matrix.isMatrix4 ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar me = matrix.elements,\n\t\t\t\t\tte = this.elements,\n\t\n\t\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\t\n\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\n\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\n\t\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\t\tvar msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\n\t\n\t\t\t\t\tif ( throwOnDegenerate === true ) {\n\t\n\t\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this.identity();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar detInv = 1 / det;\n\t\n\t\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\t\n\t\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\t\n\t\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranspose: function () {\n\t\n\t\t\t\tvar tmp, m = this.elements;\n\t\n\t\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetNormalMatrix: function ( matrix4 ) {\n\t\n\t\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\t\n\t\t\t},\n\t\n\t\t\ttransposeIntoArray: function ( r ) {\n\t\n\t\t\t\tvar m = this.elements;\n\t\n\t\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\t\tr[ 8 ] = m[ 8 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\n\t\n\t\t\t\tvar c = Math.cos( rotation );\n\t\t\t\tvar s = Math.sin( rotation );\n\t\n\t\t\t\tthis.set(\n\t\t\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t\t\t0, 0, 1\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tscale: function ( sx, sy ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\t\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotate: function ( theta ) {\n\t\n\t\t\t\tvar c = Math.cos( theta );\n\t\t\t\tvar s = Math.sin( theta );\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\t\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\t\n\t\t\t\tte[ 0 ] = c * a11 + s * a21;\n\t\t\t\tte[ 3 ] = c * a12 + s * a22;\n\t\t\t\tte[ 6 ] = c * a13 + s * a23;\n\t\n\t\t\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\t\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\t\t\tte[ 7 ] = - s * a13 + c * a23;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( tx, ty ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\t\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( matrix ) {\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = matrix.elements;\n\t\n\t\t\t\tfor ( var i = 0; i < 9; i ++ ) {\n\t\n\t\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tfor ( var i = 0; i < 9; i ++ ) {\n\t\n\t\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\n\t\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\n\t\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t */\n\t\n\t\tvar textureId = 0;\n\t\n\t\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\t\tthis.mipmaps = [];\n\t\n\t\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\t\n\t\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\t\n\t\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\t\n\t\t\tthis.offset = new Vector2( 0, 0 );\n\t\t\tthis.repeat = new Vector2( 1, 1 );\n\t\t\tthis.center = new Vector2( 0, 0 );\n\t\t\tthis.rotation = 0;\n\t\n\t\t\tthis.matrixAutoUpdate = true;\n\t\t\tthis.matrix = new Matrix3();\n\t\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\t\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\t\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\n\t\t}\n\t\n\t\tTexture.DEFAULT_IMAGE = undefined;\n\t\tTexture.DEFAULT_MAPPING = UVMapping;\n\t\n\t\tTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: Texture,\n\t\n\t\t\tisTexture: true,\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.image = source.image;\n\t\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\t\n\t\t\t\tthis.mapping = source.mapping;\n\t\n\t\t\t\tthis.wrapS = source.wrapS;\n\t\t\t\tthis.wrapT = source.wrapT;\n\t\n\t\t\t\tthis.magFilter = source.magFilter;\n\t\t\t\tthis.minFilter = source.minFilter;\n\t\n\t\t\t\tthis.anisotropy = source.anisotropy;\n\t\n\t\t\t\tthis.format = source.format;\n\t\t\t\tthis.type = source.type;\n\t\n\t\t\t\tthis.offset.copy( source.offset );\n\t\t\t\tthis.repeat.copy( source.repeat );\n\t\t\t\tthis.center.copy( source.center );\n\t\t\t\tthis.rotation = source.rotation;\n\t\n\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\t\tthis.matrix.copy( source.matrix );\n\t\n\t\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\t\tthis.flipY = source.flipY;\n\t\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\t\tthis.encoding = source.encoding;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\t\n\t\t\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\t\n\t\t\t\t\treturn meta.textures[ this.uuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getDataURL( image ) {\n\t\n\t\t\t\t\tvar canvas;\n\t\n\t\t\t\t\tif ( image instanceof HTMLCanvasElement ) {\n\t\n\t\t\t\t\t\tcanvas = image;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\t\tcanvas.height = image.height;\n\t\n\t\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\n\t\t\t\t\t\tif ( image instanceof ImageData ) {\n\t\n\t\t\t\t\t\t\tcontext.putImageData( image, 0, 0 );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar output = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t\t},\n\t\n\t\t\t\t\tuuid: this.uuid,\n\t\t\t\t\tname: this.name,\n\t\n\t\t\t\t\tmapping: this.mapping,\n\t\n\t\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\t\t\trotation: this.rotation,\n\t\n\t\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\t\n\t\t\t\t\tminFilter: this.minFilter,\n\t\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\t\tanisotropy: this.anisotropy,\n\t\n\t\t\t\t\tflipY: this.flipY\n\t\t\t\t};\n\t\n\t\t\t\tif ( this.image !== undefined ) {\n\t\n\t\t\t\t\t// TODO: Move to THREE.Image\n\t\n\t\t\t\t\tvar image = this.image;\n\t\n\t\t\t\t\tif ( image.uuid === undefined ) {\n\t\n\t\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toutput.image = image.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! isRootObject ) {\n\t\n\t\t\t\t\tmeta.textures[ this.uuid ] = output;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t},\n\t\n\t\t\ttransformUv: function ( uv ) {\n\t\n\t\t\t\tif ( this.mapping !== UVMapping ) return;\n\t\n\t\t\t\tuv.applyMatrix3( this.matrix );\n\t\n\t\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapS ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\t\n\t\t\t\t\tswitch ( this.wrapT ) {\n\t\n\t\t\t\t\t\tcase RepeatWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.flipY ) {\n\t\n\t\t\t\t\tuv.y = 1 - uv.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperty( Texture.prototype, \"needsUpdate\", {\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author philogb / http://blog.thejit.org/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author egraether / http://egraether.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Vector4( x, y, z, w ) {\n\t\n\t\t\tthis.x = x || 0;\n\t\t\tthis.y = y || 0;\n\t\t\tthis.z = z || 0;\n\t\t\tthis.w = ( w !== undefined ) ? w : 1;\n\t\n\t\t}\n\t\n\t\tObject.assign( Vector4.prototype, {\n\t\n\t\t\tisVector4: true,\n\t\n\t\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.z = z;\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x = scalar;\n\t\t\t\tthis.y = scalar;\n\t\t\t\tthis.z = scalar;\n\t\t\t\tthis.w = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( x ) {\n\t\n\t\t\t\tthis.x = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( y ) {\n\t\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( z ) {\n\t\n\t\t\t\tthis.z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( w ) {\n\t\n\t\t\t\tthis.w = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetComponent: function ( index ) {\n\t\n\t\t\t\tswitch ( index ) {\n\t\n\t\t\t\t\tcase 0: return this.x;\n\t\t\t\t\tcase 1: return this.y;\n\t\t\t\t\tcase 2: return this.z;\n\t\t\t\t\tcase 3: return this.w;\n\t\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( v ) {\n\t\n\t\t\t\tthis.x = v.x;\n\t\t\t\tthis.y = v.y;\n\t\t\t\tthis.z = v.z;\n\t\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x += v.x;\n\t\t\t\tthis.y += v.y;\n\t\t\t\tthis.z += v.z;\n\t\t\t\tthis.w += v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.x += s;\n\t\t\t\tthis.y += s;\n\t\t\t\tthis.z += s;\n\t\t\t\tthis.w += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\tthis.z = a.z + b.z;\n\t\t\t\tthis.w = a.w + b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\t\tthis.x += v.x * s;\n\t\t\t\tthis.y += v.y * s;\n\t\t\t\tthis.z += v.z * s;\n\t\t\t\tthis.w += v.w * s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( v, w ) {\n\t\n\t\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x -= v.x;\n\t\t\t\tthis.y -= v.y;\n\t\t\t\tthis.z -= v.z;\n\t\t\t\tthis.w -= v.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubScalar: function ( s ) {\n\t\n\t\t\t\tthis.x -= s;\n\t\t\t\tthis.y -= s;\n\t\t\t\tthis.z -= s;\n\t\t\t\tthis.w -= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\tthis.z = a.z - b.z;\n\t\t\t\tthis.w = a.w - b.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\t\tvar e = m.elements;\n\t\n\t\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\n\t\t\t\t// q is assumed to be normalized\n\t\n\t\t\t\tthis.w = 2 * Math.acos( q.w );\n\t\n\t\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\t\n\t\t\t\tif ( s < 0.0001 ) {\n\t\n\t\t\t\t\tthis.x = 1;\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t\tthis.z = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.x = q.x / s;\n\t\t\t\t\tthis.y = q.y / s;\n\t\t\t\t\tthis.z = q.z / s;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\t\n\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\t\n\t\t\t\t\tte = m.elements,\n\t\n\t\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\t\n\t\t\t\t\t// singularity found\n\t\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t\t// in leading diagonal and zero in other terms\n\t\n\t\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\t\n\t\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\n\t\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// otherwise this singularity is angle = 180\n\t\n\t\t\t\t\tangle = Math.PI;\n\t\n\t\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\t\n\t\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\t\n\t\t\t\t\t\t// m11 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( xx < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\t\tz = xz / x;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( yy > zz ) {\n\t\n\t\t\t\t\t\t// m22 is the largest diagonal term\n\t\n\t\t\t\t\t\tif ( yy < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\t\tz = yz / y;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\n\t\t\t\t\t\tif ( zz < epsilon ) {\n\t\n\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\tz = 0;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\t\ty = yz / z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.set( x, y, z, angle );\n\t\n\t\t\t\t\treturn this; // return 180 deg rotation\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// as we have reached here there are no singularities so we can handle normally\n\t\n\t\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\t\n\t\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\t\n\t\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t\t// caught by singularity test above, but I've left it in just in case\n\t\n\t\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmin: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\t\tthis.w = Math.min( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmax: function ( v ) {\n\t\n\t\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\t\tthis.w = Math.max( this.w, v.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclamp: function ( min, max ) {\n\t\n\t\t\t\t// assumes min < max, componentwise\n\t\n\t\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclampScalar: function () {\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\t\tmax = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\t\n\t\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclampLength: function ( min, max ) {\n\t\n\t\t\t\tvar length = this.length();\n\t\n\t\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\t\n\t\t\t},\n\t\n\t\t\tfloor: function () {\n\t\n\t\t\t\tthis.x = Math.floor( this.x );\n\t\t\t\tthis.y = Math.floor( this.y );\n\t\t\t\tthis.z = Math.floor( this.z );\n\t\t\t\tthis.w = Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tceil: function () {\n\t\n\t\t\t\tthis.x = Math.ceil( this.x );\n\t\t\t\tthis.y = Math.ceil( this.y );\n\t\t\t\tthis.z = Math.ceil( this.z );\n\t\t\t\tthis.w = Math.ceil( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tround: function () {\n\t\n\t\t\t\tthis.x = Math.round( this.x );\n\t\t\t\tthis.y = Math.round( this.y );\n\t\t\t\tthis.z = Math.round( this.z );\n\t\t\t\tthis.w = Math.round( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\troundToZero: function () {\n\t\n\t\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.x = - this.x;\n\t\t\t\tthis.y = - this.y;\n\t\t\t\tthis.z = - this.z;\n\t\t\t\tthis.w = - this.w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdot: function ( v ) {\n\t\n\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\n\t\t\t},\n\t\n\t\t\tlengthSq: function () {\n\t\n\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\n\t\t\t},\n\t\n\t\t\tlength: function () {\n\t\n\t\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\t\n\t\t\t},\n\t\n\t\t\tmanhattanLength: function () {\n\t\n\t\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\treturn this.divideScalar( this.length() || 1 );\n\t\n\t\t\t},\n\t\n\t\t\tsetLength: function ( length ) {\n\t\n\t\t\t\treturn this.normalize().multiplyScalar( length );\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( v ) {\n\t\n\t\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.x = array[ offset ];\n\t\t\t\tthis.y = array[ offset + 1 ];\n\t\t\t\tthis.z = array[ offset + 2 ];\n\t\t\t\tthis.w = array[ offset + 3 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.x;\n\t\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\t\tarray[ offset + 3 ] = this.w;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tfromBufferAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.x = attribute.getX( index );\n\t\t\t\tthis.y = attribute.getY( index );\n\t\t\t\tthis.z = attribute.getZ( index );\n\t\t\t\tthis.w = attribute.getW( index );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author Marius Kintel / https://github.com/kintel\n\t\t */\n\t\n\t\t/*\n\t\t In options, we can specify:\n\t\t * Texture parameters for an auto-generated target texture\n\t\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t\t*/\n\t\tfunction WebGLRenderTarget( width, height, options ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\n\t\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\t\tthis.scissorTest = false;\n\t\n\t\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\t\n\t\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\t\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\n\t\t}\n\t\n\t\tWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: WebGLRenderTarget,\n\t\n\t\t\tisWebGLRenderTarget: true,\n\t\n\t\t\tsetSize: function ( width, height ) {\n\t\n\t\t\t\tif ( this.width !== width || this.height !== height ) {\n\t\n\t\t\t\t\tthis.width = width;\n\t\t\t\t\tthis.height = height;\n\t\n\t\t\t\t\tthis.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\t\tthis.scissor.set( 0, 0, width, height );\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.width = source.width;\n\t\t\t\tthis.height = source.height;\n\t\n\t\t\t\tthis.viewport.copy( source.viewport );\n\t\n\t\t\t\tthis.texture = source.texture.clone();\n\t\n\t\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\t\tthis.depthTexture = source.depthTexture;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com\n\t\t */\n\t\n\t\tfunction WebGLRenderTargetCube( width, height, options ) {\n\t\n\t\t\tWebGLRenderTarget.call( this, width, height, options );\n\t\n\t\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\t\tthis.activeMipMapLevel = 0;\n\t\n\t\t}\n\t\n\t\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\t\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\t\n\t\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { data: data, width: width, height: height };\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\n\t\t}\n\t\n\t\tDataTexture.prototype = Object.create( Texture.prototype );\n\t\tDataTexture.prototype.constructor = DataTexture;\n\t\n\t\tDataTexture.prototype.isDataTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\n\t\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t}\n\t\n\t\tCubeTexture.prototype = Object.create( Texture.prototype );\n\t\tCubeTexture.prototype.constructor = CubeTexture;\n\t\n\t\tCubeTexture.prototype.isCubeTexture = true;\n\t\n\t\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\treturn this.image;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tthis.image = value;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t *\n\t\t * Uniforms of a program.\n\t\t * Those form a tree structure with a special top-level container for the root,\n\t\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t\t *\n\t\t *\n\t\t * Properties of inner nodes including the top-level container:\n\t\t *\n\t\t * .seq - array of nested uniforms\n\t\t * .map - nested uniforms by name\n\t\t *\n\t\t *\n\t\t * Methods of all nodes except the top-level container:\n\t\t *\n\t\t * .setValue( gl, value, [renderer] )\n\t\t *\n\t\t * \t\tuploads a uniform value(s)\n\t\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t\t *\n\t\t *\n\t\t * Static methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .upload( gl, seq, values, renderer )\n\t\t *\n\t\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t\t *\n\t\t * .seqWithValue( seq, values ) : filteredSeq\n\t\t *\n\t\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t\t *\n\t\t *\n\t\t * Methods of the top-level container (renderer factorizations):\n\t\t *\n\t\t * .setValue( gl, name, value )\n\t\t *\n\t\t * \t\tsets uniform with  name 'name' to 'value'\n\t\t *\n\t\t * .set( gl, obj, prop )\n\t\t *\n\t\t * \t\tsets uniform from object and property with same name than uniform\n\t\t *\n\t\t * .setOptional( gl, obj, prop )\n\t\t *\n\t\t * \t\tlike .set for an optional property of the object\n\t\t *\n\t\t */\n\t\n\t\tvar emptyTexture = new Texture();\n\t\tvar emptyCubeTexture = new CubeTexture();\n\t\n\t\t// --- Base for inner nodes (including the root) ---\n\t\n\t\tfunction UniformContainer() {\n\t\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\t\n\t\t}\n\t\n\t\t// --- Utilities ---\n\t\n\t\t// Array Caches (provide typed arrays for temporary by size)\n\t\n\t\tvar arrayCacheF32 = [];\n\t\tvar arrayCacheI32 = [];\n\t\n\t\t// Float32Array caches used for uploading Matrix uniforms\n\t\n\t\tvar mat4array = new Float32Array( 16 );\n\t\tvar mat3array = new Float32Array( 9 );\n\t\n\t\t// Flattening for arrays of vectors and matrices\n\t\n\t\tfunction flatten( array, nBlocks, blockSize ) {\n\t\n\t\t\tvar firstElem = array[ 0 ];\n\t\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\t\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tif ( nBlocks !== 0 ) {\n\t\n\t\t\t\tfirstElem.toArray( r, 0 );\n\t\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\t\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// Texture unit allocation\n\t\n\t\tfunction allocTexUnits( renderer, n ) {\n\t\n\t\t\tvar r = arrayCacheI32[ n ];\n\t\n\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\t\n\t\t\treturn r;\n\t\n\t\t}\n\t\n\t\t// --- Setters ---\n\t\n\t\t// Note: Defining these methods externally, because they come in a bunch\n\t\t// and this way their names minify.\n\t\n\t\t// Single scalar\n\t\n\t\tfunction setValue1f( gl, v ) {\n\t\n\t\t\tgl.uniform1f( this.addr, v );\n\t\n\t\t}\n\t\n\t\tfunction setValue1i( gl, v ) {\n\t\n\t\t\tgl.uniform1i( this.addr, v );\n\t\n\t\t}\n\t\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\t\n\t\tfunction setValue2fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) {\n\t\n\t\t\t\tgl.uniform2fv( this.addr, v );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValue3fv( gl, v ) {\n\t\n\t\t\tif ( v.x !== undefined ) {\n\t\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\n\t\t\t} else if ( v.r !== undefined ) {\n\t\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValue4fv( gl, v ) {\n\t\n\t\t\tif ( v.x === undefined ) {\n\t\n\t\t\t\tgl.uniform4fv( this.addr, v );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Single matrix (from flat array or MatrixN)\n\t\n\t\tfunction setValue2fm( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\t\n\t\t}\n\t\n\t\tfunction setValue3fm( gl, v ) {\n\t\n\t\t\tif ( v.elements === undefined ) {\n\t\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmat3array.set( v.elements );\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValue4fm( gl, v ) {\n\t\n\t\t\tif ( v.elements === undefined ) {\n\t\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmat4array.set( v.elements );\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Single texture (2D / Cube)\n\t\n\t\tfunction setValueT1( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\t\n\t\t}\n\t\n\t\tfunction setValueT6( gl, v, renderer ) {\n\t\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\t\n\t\t}\n\t\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\t\n\t\tfunction setValue2iv( gl, v ) {\n\t\n\t\t\tgl.uniform2iv( this.addr, v );\n\t\n\t\t}\n\t\n\t\tfunction setValue3iv( gl, v ) {\n\t\n\t\t\tgl.uniform3iv( this.addr, v );\n\t\n\t\t}\n\t\n\t\tfunction setValue4iv( gl, v ) {\n\t\n\t\t\tgl.uniform4iv( this.addr, v );\n\t\n\t\t}\n\t\n\t\t// Helper to pick the right setter for the singular case\n\t\n\t\tfunction getSingularSetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Array of scalars\n\t\n\t\tfunction setValue1fv( gl, v ) {\n\t\n\t\t\tgl.uniform1fv( this.addr, v );\n\t\n\t\t}\n\t\tfunction setValue1iv( gl, v ) {\n\t\n\t\t\tgl.uniform1iv( this.addr, v );\n\t\n\t\t}\n\t\n\t\t// Array of vectors (flat or from THREE classes)\n\t\n\t\tfunction setValueV2a( gl, v ) {\n\t\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV3a( gl, v ) {\n\t\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueV4a( gl, v ) {\n\t\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\t// Array of matrices (flat or from THREE clases)\n\t\n\t\tfunction setValueM2a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM3a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\t\n\t\t}\n\t\n\t\tfunction setValueM4a( gl, v ) {\n\t\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\t\n\t\t}\n\t\n\t\t// Array of textures (2D / Cube)\n\t\n\t\tfunction setValueT1a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setValueT6a( gl, v, renderer ) {\n\t\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\t\n\t\tfunction getPureArraySetter( type ) {\n\t\n\t\t\tswitch ( type ) {\n\t\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\t\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\t\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\t\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// --- Uniform Classes ---\n\t\n\t\tfunction SingleUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\t\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\t\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t}\n\t\n\t\tfunction StructuredUniform( id ) {\n\t\n\t\t\tthis.id = id;\n\t\n\t\t\tUniformContainer.call( this ); // mix-in\n\t\n\t\t}\n\t\n\t\tStructuredUniform.prototype.setValue = function ( gl, value ) {\n\t\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t\t// are not allowed in structured uniforms.\n\t\n\t\t\tvar seq = this.seq;\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tu.setValue( gl, value[ u.id ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// --- Top-level ---\n\t\n\t\t// Parser - builds up the property tree from the path strings\n\t\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\t\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\t\n\t\tfunction addUniform( container, uniformObject ) {\n\t\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\t\n\t\t}\n\t\n\t\tfunction parseUniform( activeInfo, addr, container ) {\n\t\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\t\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\t\n\t\t\tfor ( ; ; ) {\n\t\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\t\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\t\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\t\n\t\t\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\t\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\n\t\t\t\t\tvar map = container.map, next = map[ id ];\n\t\n\t\t\t\t\tif ( next === undefined ) {\n\t\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontainer = next;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Root Container\n\t\n\t\tfunction WebGLUniforms( gl, program, renderer ) {\n\t\n\t\t\tUniformContainer.call( this );\n\t\n\t\t\tthis.renderer = renderer;\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\t\n\t\t\tfor ( var i = 0; i < n; ++ i ) {\n\t\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\t\n\t\t\t\tparseUniform( info, addr, this );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\n\t\n\t\t\tvar v = object[ name ];\n\t\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\t\n\t\t};\n\t\n\t\n\t\t// Static interface\n\t\n\t\tWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v.needsUpdate !== false ) {\n\t\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.seqWithValue = function ( seq, values ) {\n\t\n\t\t\tvar r = [];\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tif ( u.id in values ) r.push( u );\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t\t\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t\t\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t\t\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t\t\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t\t\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t\t\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t\t\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t\t\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t\t\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t\t\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t\t\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t\t\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t\t\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t\t\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t\t\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t\t\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t\t\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t\t\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t\t\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t\t\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t\t\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t\t\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t\t\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\t\n\t\tfunction Color( r, g, b ) {\n\t\n\t\t\tif ( g === undefined && b === undefined ) {\n\t\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set( r );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.setRGB( r, g, b );\n\t\n\t\t}\n\t\n\t\tObject.assign( Color.prototype, {\n\t\n\t\t\tisColor: true,\n\t\n\t\t\tr: 1, g: 1, b: 1,\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( value && value.isColor ) {\n\t\n\t\t\t\t\tthis.copy( value );\n\t\n\t\t\t\t} else if ( typeof value === 'number' ) {\n\t\n\t\t\t\t\tthis.setHex( value );\n\t\n\t\t\t\t} else if ( typeof value === 'string' ) {\n\t\n\t\t\t\t\tthis.setStyle( value );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.r = scalar;\n\t\t\t\tthis.g = scalar;\n\t\t\t\tthis.b = scalar;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHex: function ( hex ) {\n\t\n\t\t\t\thex = Math.floor( hex );\n\t\n\t\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\t\tthis.b = ( hex & 255 ) / 255;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetRGB: function ( r, g, b ) {\n\t\n\t\t\t\tthis.r = r;\n\t\t\t\tthis.g = g;\n\t\t\t\tthis.b = b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetHSL: function () {\n\t\n\t\t\t\tfunction hue2rgb( p, q, t ) {\n\t\n\t\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\t\treturn p;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function setHSL( h, s, l ) {\n\t\n\t\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\t\n\t\t\t\t\tif ( s === 0 ) {\n\t\n\t\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\t\tvar q = ( 2 * l ) - p;\n\t\n\t\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetStyle: function ( style ) {\n\t\n\t\t\t\tfunction handleAlpha( string ) {\n\t\n\t\t\t\t\tif ( string === undefined ) return;\n\t\n\t\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tvar m;\n\t\n\t\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\t\n\t\t\t\t\t// rgb / hsl\n\t\n\t\t\t\t\tvar color;\n\t\t\t\t\tvar name = m[ 1 ];\n\t\t\t\t\tvar components = m[ 2 ];\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'rgb':\n\t\t\t\t\t\tcase 'rgba':\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'hsl':\n\t\t\t\t\t\tcase 'hsla':\n\t\n\t\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\t\n\t\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\t\n\t\t\t\t\t// hex color\n\t\n\t\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\t\tvar size = hex.length;\n\t\n\t\t\t\t\tif ( size === 3 ) {\n\t\n\t\t\t\t\t\t// #ff0\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t} else if ( size === 6 ) {\n\t\n\t\t\t\t\t\t// #ff0000\n\t\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\t\n\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( style && style.length > 0 ) {\n\t\n\t\t\t\t\t// color keywords\n\t\t\t\t\tvar hex = ColorKeywords[ style ];\n\t\n\t\t\t\t\tif ( hex !== undefined ) {\n\t\n\t\t\t\t\t\t// red\n\t\t\t\t\t\tthis.setHex( hex );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// unknown color\n\t\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( color ) {\n\t\n\t\t\t\tthis.r = color.r;\n\t\t\t\tthis.g = color.g;\n\t\t\t\tthis.b = color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\t\n\t\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\t\n\t\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertGammaToLinear: function () {\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tthis.r = r * r;\n\t\t\t\tthis.g = g * g;\n\t\t\t\tthis.b = b * b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconvertLinearToGamma: function () {\n\t\n\t\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\t\tthis.b = Math.sqrt( this.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetHex: function () {\n\t\n\t\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\t\n\t\t\t},\n\t\n\t\t\tgetHexString: function () {\n\t\n\t\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\t\n\t\t\t},\n\t\n\t\t\tgetHSL: function ( optionalTarget ) {\n\t\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\n\t\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\t\n\t\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\t\tvar max = Math.max( r, g, b );\n\t\t\t\tvar min = Math.min( r, g, b );\n\t\n\t\t\t\tvar hue, saturation;\n\t\t\t\tvar lightness = ( min + max ) / 2.0;\n\t\n\t\t\t\tif ( min === max ) {\n\t\n\t\t\t\t\thue = 0;\n\t\t\t\t\tsaturation = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar delta = max - min;\n\t\n\t\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\t\n\t\t\t\t\tswitch ( max ) {\n\t\n\t\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thue /= 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t\thsl.h = hue;\n\t\t\t\thsl.s = saturation;\n\t\t\t\thsl.l = lightness;\n\t\n\t\t\t\treturn hsl;\n\t\n\t\t\t},\n\t\n\t\t\tgetStyle: function () {\n\t\n\t\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\t\n\t\t\t},\n\t\n\t\t\toffsetHSL: function ( h, s, l ) {\n\t\n\t\t\t\tvar hsl = this.getHSL();\n\t\n\t\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\t\n\t\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tadd: function ( color ) {\n\t\n\t\t\t\tthis.r += color.r;\n\t\t\t\tthis.g += color.g;\n\t\t\t\tthis.b += color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddColors: function ( color1, color2 ) {\n\t\n\t\t\t\tthis.r = color1.r + color2.r;\n\t\t\t\tthis.g = color1.g + color2.g;\n\t\t\t\tthis.b = color1.b + color2.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddScalar: function ( s ) {\n\t\n\t\t\t\tthis.r += s;\n\t\t\t\tthis.g += s;\n\t\t\t\tthis.b += s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsub: function ( color ) {\n\t\n\t\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiply: function ( color ) {\n\t\n\t\t\t\tthis.r *= color.r;\n\t\t\t\tthis.g *= color.g;\n\t\t\t\tthis.b *= color.b;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\t\tthis.r *= s;\n\t\t\t\tthis.g *= s;\n\t\t\t\tthis.b *= s;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tlerp: function ( color, alpha ) {\n\t\n\t\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( c ) {\n\t\n\t\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.r = array[ offset ];\n\t\t\t\tthis.g = array[ offset + 1 ];\n\t\t\t\tthis.b = array[ offset + 2 ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this.r;\n\t\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\t\tarray[ offset + 2 ] = this.b;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\treturn this.getHex();\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Uniforms library for shared webgl shaders\n\t\t */\n\t\n\t\tvar UniformsLib = {\n\t\n\t\t\tcommon: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\n\t\t\t\tmap: { value: null },\n\t\t\t\tuvTransform: { value: new Matrix3() },\n\t\n\t\t\t\talphaMap: { value: null },\n\t\n\t\t\t},\n\t\n\t\t\tspecularmap: {\n\t\n\t\t\t\tspecularMap: { value: null },\n\t\n\t\t\t},\n\t\n\t\t\tenvmap: {\n\t\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tflipEnvMap: { value: - 1 },\n\t\t\t\treflectivity: { value: 1.0 },\n\t\t\t\trefractionRatio: { value: 0.98 }\n\t\n\t\t\t},\n\t\n\t\t\taomap: {\n\t\n\t\t\t\taoMap: { value: null },\n\t\t\t\taoMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tlightmap: {\n\t\n\t\t\t\tlightMap: { value: null },\n\t\t\t\tlightMapIntensity: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\temissivemap: {\n\t\n\t\t\t\temissiveMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tbumpmap: {\n\t\n\t\t\t\tbumpMap: { value: null },\n\t\t\t\tbumpScale: { value: 1 }\n\t\n\t\t\t},\n\t\n\t\t\tnormalmap: {\n\t\n\t\t\t\tnormalMap: { value: null },\n\t\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\t\n\t\t\t},\n\t\n\t\t\tdisplacementmap: {\n\t\n\t\t\t\tdisplacementMap: { value: null },\n\t\t\t\tdisplacementScale: { value: 1 },\n\t\t\t\tdisplacementBias: { value: 0 }\n\t\n\t\t\t},\n\t\n\t\t\troughnessmap: {\n\t\n\t\t\t\troughnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tmetalnessmap: {\n\t\n\t\t\t\tmetalnessMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tgradientmap: {\n\t\n\t\t\t\tgradientMap: { value: null }\n\t\n\t\t\t},\n\t\n\t\t\tfog: {\n\t\n\t\t\t\tfogDensity: { value: 0.00025 },\n\t\t\t\tfogNear: { value: 1 },\n\t\t\t\tfogFar: { value: 2000 },\n\t\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\t\n\t\t\t},\n\t\n\t\t\tlights: {\n\t\n\t\t\t\tambientLightColor: { value: [] },\n\t\n\t\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\t\tdirectionalShadowMatrix: { value: [] },\n\t\n\t\t\t\tspotLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t} },\n\t\n\t\t\t\tspotShadowMap: { value: [] },\n\t\t\t\tspotShadowMatrix: { value: [] },\n\t\n\t\t\t\tpointLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {},\n\t\n\t\t\t\t\tshadow: {},\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {},\n\t\t\t\t\tshadowCameraNear: {},\n\t\t\t\t\tshadowCameraFar: {}\n\t\t\t\t} },\n\t\n\t\t\t\tpointShadowMap: { value: [] },\n\t\t\t\tpointShadowMatrix: { value: [] },\n\t\n\t\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t} },\n\t\n\t\t\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\t\t\trectAreaLights: { value: [], properties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\twidth: {},\n\t\t\t\t\theight: {}\n\t\t\t\t} }\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\t\topacity: { value: 1.0 },\n\t\t\t\tsize: { value: 1.0 },\n\t\t\t\tscale: { value: 1.0 },\n\t\t\t\tmap: { value: null },\n\t\t\t\tuvTransform: { value: new Matrix3() }\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * Uniform Utilities\n\t\t */\n\t\n\t\tvar UniformsUtils = {\n\t\n\t\t\tmerge: function ( uniforms ) {\n\t\n\t\t\t\tvar merged = {};\n\t\n\t\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\t\n\t\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\t\n\t\t\t\t\tfor ( var p in tmp ) {\n\t\n\t\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn merged;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( uniforms_src ) {\n\t\n\t\t\t\tvar uniforms_dst = {};\n\t\n\t\t\t\tfor ( var u in uniforms_src ) {\n\t\n\t\t\t\t\tuniforms_dst[ u ] = {};\n\t\n\t\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\t\n\t\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\t\n\t\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\t\n\t\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn uniforms_dst;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\t\n\t\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\t\n\t\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\t\n\t\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\t\n\t\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\t\n\t\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\t\n\t\tvar bsdfs = \"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t}\\n\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\t\n\t\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\t\n\t\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\t\n\t\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\t\n\t\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\t\n\t\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\t\n\t\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\t\n\t\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\n\";\n\t\n\t\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\t\n\t\tvar defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n\";\n\t\n\t\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\t\n\t\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\t\n\t\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\t\n\t\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\t\n\t\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\t\n\t\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\t\n\t\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar fog_vertex = \"\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif\";\n\t\n\t\tvar fog_pars_vertex = \"#ifdef USE_FOG\\n  varying float fogDepth;\\n#endif\\n\";\n\t\n\t\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\t\n\t\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\t\n\t\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\t\n\t\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\t\n\t\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\t\n\t\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\t\n\t\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\t\n\t\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\t\n\t\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\t\n\t\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\t\n\t\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\t\n\t\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\\n\";\n\t\n\t\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\t\n\t\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\t\n\t\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\t\n\t\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\t\n\t\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\t\n\t\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\t\n\t\tvar project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\t\n\t\tvar dithering_fragment = \"#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t\tvar dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n\";\n\t\n\t\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\t\n\t\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\t\n\t\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\t\n\t\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\t\n\t\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\t\n\t\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\\n\";\n\t\n\t\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\t\n\t\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\t\n\t\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\t\n\t\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t\tvar tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\t\n\t\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\t\n\t\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\n\";\n\t\n\t\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\t\n\t\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\t\n\t\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\\n\";\n\t\n\t\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\t\n\t\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\\n\";\n\t\n\t\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\t\n\t\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t\tvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\\n\";\n\t\n\t\tvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\";\n\t\n\t\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\t\n\t\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\t\n\t\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\t\n\t\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\t\n\t\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\t\n\t\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\";\n\t\n\t\tvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\";\n\t\n\t\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\\n\";\n\t\n\t\tvar shadow_vert = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\t\n\t\tvar ShaderChunk = {\n\t\t\talphamap_fragment: alphamap_fragment,\n\t\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\t\talphatest_fragment: alphatest_fragment,\n\t\t\taomap_fragment: aomap_fragment,\n\t\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\t\tbegin_vertex: begin_vertex,\n\t\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\t\tbsdfs: bsdfs,\n\t\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\t\tcolor_fragment: color_fragment,\n\t\t\tcolor_pars_fragment: color_pars_fragment,\n\t\t\tcolor_pars_vertex: color_pars_vertex,\n\t\t\tcolor_vertex: color_vertex,\n\t\t\tcommon: common,\n\t\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\t\temissivemap_fragment: emissivemap_fragment,\n\t\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\t\tencodings_fragment: encodings_fragment,\n\t\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\t\tenvmap_fragment: envmap_fragment,\n\t\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\t\tenvmap_vertex: envmap_vertex,\n\t\t\tfog_vertex: fog_vertex,\n\t\t\tfog_pars_vertex: fog_pars_vertex,\n\t\t\tfog_fragment: fog_fragment,\n\t\t\tfog_pars_fragment: fog_pars_fragment,\n\t\t\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\t\t\tlightmap_fragment: lightmap_fragment,\n\t\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\t\tlights_pars: lights_pars,\n\t\t\tlights_phong_fragment: lights_phong_fragment,\n\t\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\t\tlights_physical_fragment: lights_physical_fragment,\n\t\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\t\tlights_template: lights_template,\n\t\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\t\tmap_fragment: map_fragment,\n\t\t\tmap_pars_fragment: map_pars_fragment,\n\t\t\tmap_particle_fragment: map_particle_fragment,\n\t\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\t\tnormal_fragment: normal_fragment,\n\t\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\t\tpacking: packing,\n\t\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\t\tproject_vertex: project_vertex,\n\t\t\tdithering_fragment: dithering_fragment,\n\t\t\tdithering_pars_fragment: dithering_pars_fragment,\n\t\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\t\tshadowmap_vertex: shadowmap_vertex,\n\t\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\t\tskinbase_vertex: skinbase_vertex,\n\t\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\t\tskinning_vertex: skinning_vertex,\n\t\t\tskinnormal_vertex: skinnormal_vertex,\n\t\t\tspecularmap_fragment: specularmap_fragment,\n\t\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\t\ttonemapping_fragment: tonemapping_fragment,\n\t\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\t\tuv_pars_fragment: uv_pars_fragment,\n\t\t\tuv_pars_vertex: uv_pars_vertex,\n\t\t\tuv_vertex: uv_vertex,\n\t\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\t\tuv2_vertex: uv2_vertex,\n\t\t\tworldpos_vertex: worldpos_vertex,\n\t\n\t\t\tcube_frag: cube_frag,\n\t\t\tcube_vert: cube_vert,\n\t\t\tdepth_frag: depth_frag,\n\t\t\tdepth_vert: depth_vert,\n\t\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\t\tequirect_frag: equirect_frag,\n\t\t\tequirect_vert: equirect_vert,\n\t\t\tlinedashed_frag: linedashed_frag,\n\t\t\tlinedashed_vert: linedashed_vert,\n\t\t\tmeshbasic_frag: meshbasic_frag,\n\t\t\tmeshbasic_vert: meshbasic_vert,\n\t\t\tmeshlambert_frag: meshlambert_frag,\n\t\t\tmeshlambert_vert: meshlambert_vert,\n\t\t\tmeshphong_frag: meshphong_frag,\n\t\t\tmeshphong_vert: meshphong_vert,\n\t\t\tmeshphysical_frag: meshphysical_frag,\n\t\t\tmeshphysical_vert: meshphysical_vert,\n\t\t\tnormal_frag: normal_frag,\n\t\t\tnormal_vert: normal_vert,\n\t\t\tpoints_frag: points_frag,\n\t\t\tpoints_vert: points_vert,\n\t\t\tshadow_frag: shadow_frag,\n\t\t\tshadow_vert: shadow_vert\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t */\n\t\n\t\tvar ShaderLib = {\n\t\n\t\t\tbasic: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.specularmap,\n\t\t\t\t\tUniformsLib.envmap,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.fog\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\n\t\t\t},\n\t\n\t\t\tlambert: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.specularmap,\n\t\t\t\t\tUniformsLib.envmap,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\t\t\t\t{\n\t\t\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\n\t\t\t},\n\t\n\t\t\tphong: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.specularmap,\n\t\t\t\t\tUniformsLib.envmap,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.gradientmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\t\t\t\t{\n\t\t\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\t\t\tspecular: { value: new Color( 0x111111 ) },\n\t\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\n\t\t\t},\n\t\n\t\t\tstandard: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.envmap,\n\t\t\t\t\tUniformsLib.aomap,\n\t\t\t\t\tUniformsLib.lightmap,\n\t\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\tUniformsLib.lights,\n\t\t\t\t\t{\n\t\t\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\t\tmetalness: { value: 0.5 },\n\t\t\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t\t},\n\t\n\t\t\tpoints: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.points,\n\t\t\t\t\tUniformsLib.fog\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\n\t\t\t},\n\t\n\t\t\tdashed: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\t{\n\t\t\t\t\t\tscale: { value: 1 },\n\t\t\t\t\t\tdashSize: { value: 1 },\n\t\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\n\t\t\t},\n\t\n\t\t\tdepth: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.displacementmap\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\n\t\t\t},\n\t\n\t\t\tnormal: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\t\tUniformsLib.normalmap,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\t{\n\t\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\n\t\t\t},\n\t\n\t\t\t/* -------------------------------------------------------------------------\n\t\t\t//\tCube map shader\n\t\t\t ------------------------------------------------------------------------- */\n\t\n\t\t\tcube: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttCube: { value: null },\n\t\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\n\t\t\t},\n\t\n\t\t\tequirect: {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: { value: null },\n\t\t\t\t},\n\t\n\t\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\n\t\t\t},\n\t\n\t\t\tdistanceRGBA: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.common,\n\t\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t\t{\n\t\t\t\t\t\treferencePosition: { value: new Vector3() },\n\t\t\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t\t\t}\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\n\t\t\t},\n\t\n\t\t\tshadow: {\n\t\n\t\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\t\tUniformsLib.lights,\n\t\t\t\t\tUniformsLib.fog,\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor: { value: new Color( 0x00000 ) },\n\t\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t\t},\n\t\t\t\t] ),\n\t\n\t\t\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\t\t\tfragmentShader: ShaderChunk.shadow_frag\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tShaderLib.physical = {\n\t\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tShaderLib.standard.uniforms,\n\t\t\t\t{\n\t\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\t\tCanvasTexture.prototype.constructor = CanvasTexture;\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {\n\t\n\t\t\tvar vertexBuffer, elementBuffer;\n\t\t\tvar program, attributes, uniforms;\n\t\n\t\t\tvar texture;\n\t\n\t\t\t// decompose matrixWorld\n\t\n\t\t\tvar spritePosition = new Vector3();\n\t\t\tvar spriteRotation = new Quaternion();\n\t\t\tvar spriteScale = new Vector3();\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t\t- 0.5, - 0.5, 0, 0,\n\t\t\t\t\t  0.5, - 0.5, 1, 0,\n\t\t\t\t\t  0.5, 0.5, 1, 1,\n\t\t\t\t\t- 0.5, 0.5, 0, 1\n\t\t\t\t] );\n\t\n\t\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t0, 2, 3\n\t\t\t\t] );\n\t\n\t\t\t\tvertexBuffer = gl.createBuffer();\n\t\t\t\telementBuffer = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t\tprogram = createProgram();\n\t\n\t\t\t\tattributes = {\n\t\t\t\t\tposition: gl.getAttribLocation( program, 'position' ),\n\t\t\t\t\tuv: gl.getAttribLocation( program, 'uv' )\n\t\t\t\t};\n\t\n\t\t\t\tuniforms = {\n\t\t\t\t\tuvOffset: gl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\t\tuvScale: gl.getUniformLocation( program, 'uvScale' ),\n\t\n\t\t\t\t\trotation: gl.getUniformLocation( program, 'rotation' ),\n\t\t\t\t\tcenter: gl.getUniformLocation( program, 'center' ),\n\t\t\t\t\tscale: gl.getUniformLocation( program, 'scale' ),\n\t\n\t\t\t\t\tcolor: gl.getUniformLocation( program, 'color' ),\n\t\t\t\t\tmap: gl.getUniformLocation( program, 'map' ),\n\t\t\t\t\topacity: gl.getUniformLocation( program, 'opacity' ),\n\t\n\t\t\t\t\tmodelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\t\tprojectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\n\t\n\t\t\t\t\tfogType: gl.getUniformLocation( program, 'fogType' ),\n\t\t\t\t\tfogDensity: gl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\t\tfogNear: gl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\t\tfogFar: gl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\t\tfogColor: gl.getUniformLocation( program, 'fogColor' ),\n\t\t\t\t\tfogDepth: gl.getUniformLocation( program, 'fogDepth' ),\n\t\n\t\t\t\t\talphaTest: gl.getUniformLocation( program, 'alphaTest' )\n\t\t\t\t};\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = 8;\n\t\t\t\tcanvas.height = 8;\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\t\n\t\t\t\ttexture = new CanvasTexture( canvas );\n\t\n\t\t\t}\n\t\n\t\t\tthis.render = function ( sprites, scene, camera ) {\n\t\n\t\t\t\tif ( sprites.length === 0 ) return;\n\t\n\t\t\t\t// setup gl\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tinit();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.useProgram( program );\n\t\n\t\t\t\tstate.initAttributes();\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\t\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tgl.uniform1i( uniforms.map, 0 );\n\t\n\t\t\t\tvar oldFogType = 0;\n\t\t\t\tvar sceneFogType = 0;\n\t\t\t\tvar fog = scene.fog;\n\t\n\t\t\t\tif ( fog ) {\n\t\n\t\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\t\n\t\t\t\t\tif ( fog.isFog ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\t\toldFogType = 1;\n\t\t\t\t\t\tsceneFogType = 1;\n\t\n\t\t\t\t\t} else if ( fog.isFogExp2 ) {\n\t\n\t\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\t\toldFogType = 2;\n\t\t\t\t\t\tsceneFogType = 2;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\t\toldFogType = 0;\n\t\t\t\t\tsceneFogType = 0;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// update positions and sort\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\n\t\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tsprites.sort( painterSortStable );\n\t\n\t\t\t\t// render all sprites\n\t\n\t\t\t\tvar scale = [];\n\t\t\t\tvar center = [];\n\t\n\t\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\t\tvar material = sprite.material;\n\t\n\t\t\t\t\tif ( material.visible === false ) continue;\n\t\n\t\t\t\t\tsprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\t\n\t\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\t\n\t\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\t\tscale[ 1 ] = spriteScale.y;\n\t\n\t\t\t\t\tcenter[ 0 ] = sprite.center.x - 0.5;\n\t\t\t\t\tcenter[ 1 ] = sprite.center.y - 0.5;\n\t\n\t\t\t\t\tvar fogType = 0;\n\t\n\t\t\t\t\tif ( scene.fog && material.fog ) {\n\t\n\t\t\t\t\t\tfogType = sceneFogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( oldFogType !== fogType ) {\n\t\n\t\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\t\toldFogType = fogType;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\t\tgl.uniform2fv( uniforms.center, center );\n\t\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\t\n\t\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\t\t\t\t\tstate.buffers.depth.setTest( material.depthTest );\n\t\t\t\t\tstate.buffers.depth.setMask( material.depthWrite );\n\t\t\t\t\tstate.buffers.color.setMask( material.colorWrite );\n\t\n\t\t\t\t\ttextures.setTexture2D( material.map || texture, 0 );\n\t\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t\tsprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore gl\n\t\n\t\t\t\tstate.enable( gl.CULL_FACE );\n\t\n\t\t\t\tstate.reset();\n\t\n\t\t\t};\n\t\n\t\t\tfunction createProgram() {\n\t\n\t\t\t\tvar program = gl.createProgram();\n\t\n\t\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\n\t\t\t\tgl.shaderSource( vertexShader, [\n\t\n\t\t\t\t\t'precision ' + capabilities.precision + ' float;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + 'SpriteMaterial',\n\t\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform float rotation;',\n\t\t\t\t\t'uniform vec2 center;',\n\t\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t\t'uniform vec2 uvScale;',\n\t\n\t\t\t\t\t'attribute vec2 position;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\t\t\t\t'varying float fogDepth;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t'\tvUV = uvOffset + uv * uvScale;',\n\t\n\t\t\t\t\t'\tvec2 alignedPosition = ( position - center ) * scale;',\n\t\n\t\t\t\t\t'\tvec2 rotatedPosition;',\n\t\t\t\t\t'\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\t\n\t\t\t\t\t'\tvec4 mvPosition;',\n\t\n\t\t\t\t\t'\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'\tmvPosition.xy += rotatedPosition;',\n\t\n\t\t\t\t\t'\tgl_Position = projectionMatrix * mvPosition;',\n\t\n\t\t\t\t\t'\tfogDepth = - mvPosition.z;',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.shaderSource( fragmentShader, [\n\t\n\t\t\t\t\t'precision ' + capabilities.precision + ' float;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + 'SpriteMaterial',\n\t\n\t\t\t\t\t'uniform vec3 color;',\n\t\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t\t'uniform float opacity;',\n\t\n\t\t\t\t\t'uniform int fogType;',\n\t\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t\t'uniform float fogNear;',\n\t\t\t\t\t'uniform float fogFar;',\n\t\t\t\t\t'uniform float alphaTest;',\n\t\n\t\t\t\t\t'varying vec2 vUV;',\n\t\t\t\t\t'varying float fogDepth;',\n\t\n\t\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t'\tvec4 texture = texture2D( map, vUV );',\n\t\n\t\t\t\t\t'\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\t\n\t\t\t\t\t'\tif ( gl_FragColor.a < alphaTest ) discard;',\n\t\n\t\t\t\t\t'\tif ( fogType > 0 ) {',\n\t\n\t\t\t\t\t'\t\tfloat fogFactor = 0.0;',\n\t\n\t\t\t\t\t'\t\tif ( fogType == 1 ) {',\n\t\n\t\t\t\t\t'\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',\n\t\n\t\t\t\t\t'\t\t} else {',\n\t\n\t\t\t\t\t'\t\t\tconst float LOG2 = 1.442695;',\n\t\t\t\t\t'\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',\n\t\t\t\t\t'\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\t\n\t\t\t\t\t'\t\t}',\n\t\n\t\t\t\t\t'\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',\n\t\n\t\t\t\t\t'\t}',\n\t\n\t\t\t\t\t'}'\n\t\n\t\t\t\t].join( '\\n' ) );\n\t\n\t\t\t\tgl.compileShader( vertexShader );\n\t\t\t\tgl.compileShader( fragmentShader );\n\t\n\t\t\t\tgl.attachShader( program, vertexShader );\n\t\t\t\tgl.attachShader( program, fragmentShader );\n\t\n\t\t\t\tgl.linkProgram( program );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn b.id - a.id;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tvar materialId = 0;\n\t\n\t\tfunction Material() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\n\t\t\tthis.fog = true;\n\t\t\tthis.lights = true;\n\t\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\t\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\n\t\t\tthis.shadowSide = null;\n\t\n\t\t\tthis.colorWrite = true;\n\t\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\t\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\n\t\t\tthis.dithering = false;\n\t\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.premultipliedAlpha = false;\n\t\n\t\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\t\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis.userData = {};\n\t\n\t\t\tthis.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: Material,\n\t\n\t\t\tisMaterial: true,\n\t\n\t\t\tonBeforeCompile: function () {},\n\t\n\t\t\tsetValues: function ( values ) {\n\t\n\t\t\t\tif ( values === undefined ) return;\n\t\n\t\t\t\tfor ( var key in values ) {\n\t\n\t\t\t\t\tvar newValue = values[ key ];\n\t\n\t\t\t\t\tif ( newValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// for backward compatability if shading is set in the constructor\n\t\t\t\t\tif ( key === 'shading' ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\t\t\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar currentValue = this[ key ];\n\t\n\t\t\t\t\tif ( currentValue === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( currentValue && currentValue.isColor ) {\n\t\n\t\t\t\t\t\tcurrentValue.set( newValue );\n\t\n\t\t\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\t\n\t\t\t\t\t\tcurrentValue.copy( newValue );\n\t\n\t\t\t\t\t} else if ( key === 'overdraw' ) {\n\t\n\t\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\t\tthis[ key ] = Number( newValue );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis[ key ] = newValue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\ttype: 'Material',\n\t\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Material serialization\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\t\n\t\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\t\n\t\t\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\t\t\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\t\n\t\t\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\t\t\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\n\t\t\t\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\n\t\n\t\t\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\t\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\t\n\t\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\n\t\t\t\t}\n\t\t\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\t\n\t\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\n\t\t\t\t}\n\t\t\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\t\n\t\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\n\t\t\t\t}\n\t\t\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\n\t\t\t\tif ( this.envMap && this.envMap.isTexture ) {\n\t\n\t\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\t\n\t\t\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\t\n\t\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\t\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\t\n\t\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\n\t\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\t\tdata.depthTest = this.depthTest;\n\t\t\t\tdata.depthWrite = this.depthWrite;\n\t\n\t\t\t\t// rotation (SpriteMaterial)\n\t\t\t\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\n\t\n\t\t\t\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\t\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\t\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\t\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\t\n\t\t\t\tif ( this.dithering === true ) data.dithering = true;\n\t\n\t\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\n\t\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\t\n\t\t\t\tif ( this.morphTargets === true ) data.morphTargets = true;\n\t\t\t\tif ( this.skinning === true ) data.skinning = true;\n\t\n\t\t\t\tif ( this.visible === false ) data.visible = false;\n\t\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\t\n\t\t\t\t// TODO: Copied from Object3D.toJSON\n\t\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRoot ) {\n\t\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) data.images = images;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.fog = source.fog;\n\t\t\t\tthis.lights = source.lights;\n\t\n\t\t\t\tthis.blending = source.blending;\n\t\t\t\tthis.side = source.side;\n\t\t\t\tthis.flatShading = source.flatShading;\n\t\t\t\tthis.vertexColors = source.vertexColors;\n\t\n\t\t\t\tthis.opacity = source.opacity;\n\t\t\t\tthis.transparent = source.transparent;\n\t\n\t\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\t\tthis.blendDst = source.blendDst;\n\t\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\n\t\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\t\tthis.depthTest = source.depthTest;\n\t\t\t\tthis.depthWrite = source.depthWrite;\n\t\n\t\t\t\tthis.colorWrite = source.colorWrite;\n\t\n\t\t\t\tthis.precision = source.precision;\n\t\n\t\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\n\t\t\t\tthis.dithering = source.dithering;\n\t\n\t\t\t\tthis.alphaTest = source.alphaTest;\n\t\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\n\t\t\t\tthis.overdraw = source.overdraw;\n\t\n\t\t\t\tthis.visible = source.visible;\n\t\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\n\t\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\t\tdstPlanes = null;\n\t\n\t\t\t\tif ( srcPlanes !== null ) {\n\t\n\t\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\t\tdstPlanes = new Array( n );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.clippingPlanes = dstPlanes;\n\t\n\t\t\t\tthis.shadowSide = source.shadowSide;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / https://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshDepthMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\t\n\t\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\t\n\t\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  referencePosition: <float>,\n\t\t *  nearDistance: <float>,\n\t\t *  farDistance: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>\n\t\t *\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshDistanceMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshDistanceMaterial';\n\t\n\t\t\tthis.referencePosition = new Vector3();\n\t\t\tthis.nearDistance = 1;\n\t\t\tthis.farDistance = 1000;\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshDistanceMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\n\t\n\t\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\t\n\t\tMeshDistanceMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.referencePosition.copy( source.referencePosition );\n\t\t\tthis.nearDistance = source.nearDistance;\n\t\t\tthis.farDistance = source.farDistance;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Box3( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tObject.assign( Box3.prototype, {\n\t\n\t\t\tisBox3: true,\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromArray: function ( array ) {\n\t\n\t\t\t\tvar minX = + Infinity;\n\t\t\t\tvar minY = + Infinity;\n\t\t\t\tvar minZ = + Infinity;\n\t\n\t\t\t\tvar maxX = - Infinity;\n\t\t\t\tvar maxY = - Infinity;\n\t\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar x = array[ i ];\n\t\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\t\tvar z = array[ i + 2 ];\n\t\n\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromBufferAttribute: function ( attribute ) {\n\t\n\t\t\t\tvar minX = + Infinity;\n\t\t\t\tvar minY = + Infinity;\n\t\t\t\tvar minZ = + Infinity;\n\t\n\t\t\t\tvar maxX = - Infinity;\n\t\t\t\tvar maxY = - Infinity;\n\t\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar x = attribute.getX( i );\n\t\t\t\t\tvar y = attribute.getY( i );\n\t\t\t\t\tvar z = attribute.getZ( i );\n\t\n\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\treturn this.expandByObject( object );\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByObject: function () {\n\t\n\t\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t\t// accounting for both the object's, and children's, world transforms\n\t\n\t\t\t\tvar scope, i, l;\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\tfunction traverse( node ) {\n\t\n\t\t\t\t\tvar geometry = node.geometry;\n\t\n\t\t\t\t\tif ( geometry !== undefined ) {\n\t\n\t\t\t\t\t\tif ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\t\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function expandByObject( object ) {\n\t\n\t\t\t\t\tscope = this;\n\t\n\t\t\t\t\tobject.updateMatrixWorld( true );\n\t\n\t\t\t\t\tobject.traverse( traverse );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: ( function () {\n\t\n\t\t\t\tvar closestPoint = new Vector3();\n\t\n\t\t\t\treturn function intersectsSphere( sphere ) {\n\t\n\t\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\t\n\t\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\n\t\t\t\tvar min, max;\n\t\n\t\t\t\tif ( plane.normal.x > 0 ) {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.y > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( plane.normal.z > 0 ) {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsTriangle: ( function () {\n\t\n\t\t\t\t// triangle centered vertices\n\t\t\t\tvar v0 = new Vector3();\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\t// triangle edge vectors\n\t\t\t\tvar f0 = new Vector3();\n\t\t\t\tvar f1 = new Vector3();\n\t\t\t\tvar f2 = new Vector3();\n\t\n\t\t\t\tvar testAxis = new Vector3();\n\t\n\t\t\t\tvar center = new Vector3();\n\t\t\t\tvar extents = new Vector3();\n\t\n\t\t\t\tvar triangleNormal = new Vector3();\n\t\n\t\t\t\tfunction satForAxes( axes ) {\n\t\n\t\t\t\t\tvar i, j;\n\t\n\t\t\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\t\n\t\t\t\t\t\ttestAxis.fromArray( axes, i );\n\t\t\t\t\t\t// project the aabb onto the seperating axis\n\t\t\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\n\t\t\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\t\t\t\t\tvar p0 = v0.dot( testAxis );\n\t\t\t\t\t\tvar p1 = v1.dot( testAxis );\n\t\t\t\t\t\tvar p2 = v2.dot( testAxis );\n\t\t\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\t\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\t\n\t\t\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function intersectsTriangle( triangle ) {\n\t\n\t\t\t\t\tif ( this.isEmpty() ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// compute box center and extents\n\t\t\t\t\tthis.getCenter( center );\n\t\t\t\t\textents.subVectors( this.max, center );\n\t\n\t\t\t\t\t// translate triangle to aabb origin\n\t\t\t\t\tv0.subVectors( triangle.a, center );\n\t\t\t\t\tv1.subVectors( triangle.b, center );\n\t\t\t\t\tv2.subVectors( triangle.c, center );\n\t\n\t\t\t\t\t// compute edge vectors for triangle\n\t\t\t\t\tf0.subVectors( v1, v0 );\n\t\t\t\t\tf1.subVectors( v2, v1 );\n\t\t\t\t\tf2.subVectors( v0, v2 );\n\t\n\t\t\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\t\t\t\tvar axes = [\n\t\t\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\n\t\t\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\n\t\t\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\n\t\t\t\t\t];\n\t\t\t\t\tif ( ! satForAxes( axes ) ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// test 3 face normals from the aabb\n\t\t\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\t\t\t\tif ( ! satForAxes( axes ) ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// finally testing the face normal of the triangle\n\t\t\t\t\t// use already existing triangle edge vectors here\n\t\t\t\t\ttriangleNormal.crossVectors( f0, f1 );\n\t\t\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\n\t\t\t\t\treturn satForAxes( axes );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetBoundingSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Sphere();\n\t\n\t\t\t\t\tthis.getCenter( result.center );\n\t\n\t\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\t\tif ( this.isEmpty() ) this.makeEmpty();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar points = [\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3(),\n\t\t\t\t\tnew Vector3()\n\t\t\t\t];\n\t\n\t\t\t\treturn function applyMatrix4( matrix ) {\n\t\n\t\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\t\tif ( this.isEmpty() ) return this;\n\t\n\t\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\t\n\t\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Sphere( center, radius ) {\n\t\n\t\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\t\n\t\t}\n\t\n\t\tObject.assign( Sphere.prototype, {\n\t\n\t\t\tset: function ( center, radius ) {\n\t\n\t\t\t\tthis.center.copy( center );\n\t\t\t\tthis.radius = radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\n\t\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\t\n\t\t\t\t\tvar center = this.center;\n\t\n\t\t\t\t\tif ( optionalCenter !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.copy( optionalCenter );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( sphere ) {\n\t\n\t\t\t\tthis.center.copy( sphere.center );\n\t\t\t\tthis.radius = sphere.radius;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tempty: function () {\n\t\n\t\t\t\treturn ( this.radius <= 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar radiusSum = this.radius + sphere.radius;\n\t\n\t\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsSphere( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tresult.copy( point );\n\t\n\t\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\t\n\t\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\tgetBoundingBox: function ( optionalTarget ) {\n\t\n\t\t\t\tvar box = optionalTarget || new Box3();\n\t\n\t\t\t\tbox.set( this.center, this.center );\n\t\t\t\tbox.expandByScalar( this.radius );\n\t\n\t\t\t\treturn box;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.center.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Plane( normal, constant ) {\n\t\n\t\t\t// normal is assumed to be normalized\n\t\n\t\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\t\n\t\t}\n\t\n\t\tObject.assign( Plane.prototype, {\n\t\n\t\t\tset: function ( normal, constant ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetComponents: function ( x, y, z, w ) {\n\t\n\t\t\t\tthis.normal.set( x, y, z );\n\t\t\t\tthis.constant = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\t\n\t\t\t\tthis.normal.copy( normal );\n\t\t\t\tthis.constant = - point.dot( this.normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCoplanarPoints: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\t\n\t\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\t\n\t\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\t\n\t\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( plane ) {\n\t\n\t\t\t\tthis.normal.copy( plane.normal );\n\t\t\t\tthis.constant = plane.constant;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\n\t\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\t\tthis.constant *= inverseNormalLength;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnegate: function () {\n\t\n\t\t\t\tthis.constant *= - 1;\n\t\t\t\tthis.normal.negate();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn this.normal.dot( point ) + this.constant;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tprojectPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\t\n\t\t\t},\n\t\n\t\t\tintersectLine: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectLine( line, optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tvar direction = line.delta( v1 );\n\t\n\t\t\t\t\tvar denominator = this.normal.dot( direction );\n\t\n\t\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\t\n\t\t\t\t\t\t\treturn result.copy( line.start );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\t\n\t\t\t\t\tif ( t < 0 || t > 1 ) {\n\t\n\t\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsLine: function ( line ) {\n\t\n\t\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\n\t\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\t\tvar endSign = this.distanceToPoint( line.end );\n\t\n\t\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn sphere.intersectsPlane( this );\n\t\n\t\t\t},\n\t\n\t\t\tcoplanarPoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar m1 = new Matrix3();\n\t\n\t\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\t\n\t\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\n\t\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\t\n\t\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.constant -= offset.dot( this.normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( plane ) {\n\t\n\t\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\tthis.planes = [\n\t\n\t\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\t\n\t\t\t];\n\t\n\t\t}\n\t\n\t\tObject.assign( Frustum.prototype, {\n\t\n\t\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\t\tplanes[ 5 ].copy( p5 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( frustum ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromMatrix: function ( m ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar me = m.elements;\n\t\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\t\n\t\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsObject: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsObject( object ) {\n\t\n\t\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSprite: function () {\n\t\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function intersectsSprite( sprite ) {\n\t\n\t\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\t\t\tvar center = sphere.center;\n\t\t\t\tvar negRadius = - sphere.radius;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\t\n\t\t\t\t\tif ( distance < negRadius ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function () {\n\t\n\t\t\t\tvar p1 = new Vector3(),\n\t\t\t\t\tp2 = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tvar plane = planes[ i ];\n\t\n\t\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\t\n\t\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\n\t\t\t\t\t\t// if both outside plane, no intersection\n\t\n\t\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\n\t\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\n\t\n\t\t\tvar _frustum = new Frustum(),\n\t\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t\t_shadowMapSize = new Vector2(),\n\t\t\t\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\n\t\n\t\t\t\t_lookTarget = new Vector3(),\n\t\t\t\t_lightPositionWorld = new Vector3(),\n\t\n\t\t\t\t_MorphingFlag = 1,\n\t\t\t\t_SkinningFlag = 2,\n\t\n\t\t\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\t\n\t\t\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\t\n\t\t\t\t_materialCache = {};\n\t\n\t\t\tvar shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\t\n\t\t\tvar cubeDirections = [\n\t\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t\t];\n\t\n\t\t\tvar cubeUps = [\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t\t];\n\t\n\t\t\tvar cube2DViewPorts = [\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t\t];\n\t\n\t\t\t// init\n\t\n\t\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\t\n\t\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\t\n\t\t\t\tvar depthMaterial = new MeshDepthMaterial( {\n\t\n\t\t\t\t\tdepthPacking: RGBADepthPacking,\n\t\n\t\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\t\tskinning: useSkinning\n\t\n\t\t\t\t} );\n\t\n\t\t\t\t_depthMaterials[ i ] = depthMaterial;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar distanceMaterial = new MeshDistanceMaterial( {\n\t\n\t\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\t\tskinning: useSkinning\n\t\n\t\t\t\t} );\n\t\n\t\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.enabled = false;\n\t\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\n\t\t\tthis.type = PCFShadowMap;\n\t\n\t\t\tthis.render = function ( lights, scene, camera ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\t\n\t\t\t\tif ( lights.length === 0 ) return;\n\t\n\t\t\t\t// TODO Clean up (needed in case of contextlost)\n\t\t\t\tvar _gl = _renderer.context;\n\t\t\t\tvar _state = _renderer.state;\n\t\n\t\t\t\t// Set GL state for depth map.\n\t\t\t\t_state.disable( _gl.BLEND );\n\t\t\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t\t\t_state.buffers.depth.setTest( true );\n\t\t\t\t_state.setScissorTest( false );\n\t\n\t\t\t\t// render depth map\n\t\n\t\t\t\tvar faceCount;\n\t\n\t\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar light = lights[ i ];\n\t\t\t\t\tvar shadow = light.shadow;\n\t\t\t\t\tvar isPointLight = light && light.isPointLight;\n\t\n\t\t\t\t\tif ( shadow === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowCamera = shadow.camera;\n\t\n\t\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\t\n\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\t\n\t\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t\t// following orientation:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t//  xzXZ\n\t\t\t\t\t\t//   y Y\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t\t// z - Negative z direction\n\t\n\t\t\t\t\t\t// positive X\n\t\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative X\n\t\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Z\n\t\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Z\n\t\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t\t// positive Y\n\t\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t\t// negative Y\n\t\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\t\n\t\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( shadow.map === null ) {\n\t\n\t\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\t\n\t\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\n\t\n\t\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( shadow.isSpotLightShadow ) {\n\t\n\t\t\t\t\t\tshadow.update( light );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\t\tvar shadowMatrix = shadow.matrix;\n\t\n\t\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\t\n\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\tfaceCount = 6;\n\t\n\t\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t\t// equal to inverse of the light's position\n\t\n\t\t\t\t\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfaceCount = 1;\n\t\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\n\t\t\t\t\t\t// compute shadow matrix\n\t\n\t\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t\t_renderer.clear();\n\t\n\t\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t\t// run a single pass if not\n\t\n\t\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\t\n\t\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\n\t\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t\t_state.viewport( vpDimensions );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t\t\t// set object matrices & frustum culling\n\t\n\t\t\t\t\t\trenderObject( scene, camera, shadowCamera, isPointLight );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.needsUpdate = false;\n\t\n\t\t\t};\n\t\n\t\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tvar result = null;\n\t\n\t\t\t\tvar materialVariants = _depthMaterials;\n\t\t\t\tvar customMaterial = object.customDepthMaterial;\n\t\n\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! customMaterial ) {\n\t\n\t\t\t\t\tvar useMorphing = false;\n\t\n\t\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\t\tif ( geometry && geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\n\t\t\t\t\t\t} else if ( geometry && geometry.isGeometry ) {\n\t\n\t\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( object.isSkinnedMesh && material.skinning === false ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\t\n\t\t\t\t\tvar variantIndex = 0;\n\t\n\t\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\t\n\t\t\t\t\tresult = materialVariants[ variantIndex ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tresult = customMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\t\n\t\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t\t// appropriate state\n\t\n\t\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\t\n\t\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\t\n\t\t\t\t\tif ( materialsForVariant === undefined ) {\n\t\n\t\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\t\n\t\t\t\t\tif ( cachedMaterial === undefined ) {\n\t\n\t\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresult = cachedMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult.visible = material.visible;\n\t\t\t\tresult.wireframe = material.wireframe;\n\t\n\t\t\t\tresult.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];\n\t\n\t\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\t\t\tresult.clipIntersection = material.clipIntersection;\n\t\n\t\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\t\tresult.linewidth = material.linewidth;\n\t\n\t\t\t\tif ( isPointLight && result.isMeshDistanceMaterial ) {\n\t\n\t\t\t\t\tresult.referencePosition.copy( lightPositionWorld );\n\t\t\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\t\t\tresult.farDistance = shadowCameraFar;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = object.layers.test( camera.layers );\n\t\n\t\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\t\n\t\t\t\t\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\t\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\t\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\t\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( material.visible ) {\n\t\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLAttributes( gl ) {\n\t\n\t\t\tvar buffers = {};\n\t\n\t\t\tfunction createBuffer( attribute, bufferType ) {\n\t\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\t\n\t\t\t\tvar buffer = gl.createBuffer();\n\t\n\t\t\t\tgl.bindBuffer( bufferType, buffer );\n\t\t\t\tgl.bufferData( bufferType, array, usage );\n\t\n\t\t\t\tattribute.onUploadCallback();\n\t\n\t\t\t\tvar type = gl.FLOAT;\n\t\n\t\t\t\tif ( array instanceof Float32Array ) {\n\t\n\t\t\t\t\ttype = gl.FLOAT;\n\t\n\t\t\t\t} else if ( array instanceof Float64Array ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\n\t\n\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\n\t\t\t\t} else if ( array instanceof Int16Array ) {\n\t\n\t\t\t\t\ttype = gl.SHORT;\n\t\n\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\n\t\t\t\t} else if ( array instanceof Int32Array ) {\n\t\n\t\t\t\t\ttype = gl.INT;\n\t\n\t\t\t\t} else if ( array instanceof Int8Array ) {\n\t\n\t\t\t\t\ttype = gl.BYTE;\n\t\n\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\t\n\t\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\t\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar updateRange = attribute.updateRange;\n\t\n\t\t\t\tgl.bindBuffer( bufferType, buffer );\n\t\n\t\t\t\tif ( attribute.dynamic === false ) {\n\t\n\t\t\t\t\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\n\t\n\t\t\t\t} else if ( updateRange.count === - 1 ) {\n\t\n\t\t\t\t\t// Not using update ranges\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, 0, array );\n\t\n\t\t\t\t} else if ( updateRange.count === 0 ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\t\n\t\t\t\t\tupdateRange.count = - 1; // reset range\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction get( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\t\n\t\t\t\treturn buffers[ attribute.uuid ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction remove( attribute ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\t\n\t\t\t\tvar data = buffers[ attribute.uuid ];\n\t\n\t\t\t\tif ( data ) {\n\t\n\t\t\t\t\tgl.deleteBuffer( data.buffer );\n\t\n\t\t\t\t\tdelete buffers[ attribute.uuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction update( attribute, bufferType ) {\n\t\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\t\n\t\t\t\tvar data = buffers[ attribute.uuid ];\n\t\n\t\t\t\tif ( data === undefined ) {\n\t\n\t\t\t\t\tbuffers[ attribute.uuid ] = createBuffer( attribute, bufferType );\n\t\n\t\t\t\t} else if ( data.version < attribute.version ) {\n\t\n\t\t\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\t\n\t\t\t\t\tdata.version = attribute.version;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: get,\n\t\t\t\tremove: remove,\n\t\t\t\tupdate: update\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Euler( x, y, z, order ) {\n\t\n\t\t\tthis._x = x || 0;\n\t\t\tthis._y = y || 0;\n\t\t\tthis._z = z || 0;\n\t\t\tthis._order = order || Euler.DefaultOrder;\n\t\n\t\t}\n\t\n\t\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\t\n\t\tEuler.DefaultOrder = 'XYZ';\n\t\n\t\tObject.defineProperties( Euler.prototype, {\n\t\n\t\t\tx: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._x;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._x = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ty: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._y;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._y = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tz: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._z;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._z = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\torder: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this._order;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis._order = value;\n\t\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Euler.prototype, {\n\t\n\t\t\tisEuler: true,\n\t\n\t\t\tset: function ( x, y, z, order ) {\n\t\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\tthis._order = order || this._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( euler ) {\n\t\n\t\t\t\tthis._x = euler._x;\n\t\t\t\tthis._y = euler._y;\n\t\t\t\tthis._z = euler._z;\n\t\t\t\tthis._order = euler._order;\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\t\n\t\t\t\tvar clamp = _Math.clamp;\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tvar te = m.elements;\n\t\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\t\torder = order || this._order;\n\t\n\t\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\t\n\t\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._y = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._order = order;\n\t\n\t\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromQuaternion: function () {\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\n\t\t\t\treturn function setFromQuaternion( q, order, update ) {\n\t\n\t\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\t\n\t\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tsetFromVector3: function ( v, order ) {\n\t\n\t\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\t\n\t\t\t},\n\t\n\t\t\treorder: function () {\n\t\n\t\t\t\t// WARNING: this discards revolution information -bhouston\n\t\n\t\t\t\tvar q = new Quaternion();\n\t\n\t\t\t\treturn function reorder( newOrder ) {\n\t\n\t\t\t\t\tq.setFromEuler( this );\n\t\n\t\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( euler ) {\n\t\n\t\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\t\n\t\t\t},\n\t\n\t\t\tfromArray: function ( array ) {\n\t\n\t\t\t\tthis._x = array[ 0 ];\n\t\t\t\tthis._y = array[ 1 ];\n\t\t\t\tthis._z = array[ 2 ];\n\t\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\t\n\t\t\t\tthis.onChangeCallback();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\t\tif ( array === undefined ) array = [];\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tarray[ offset ] = this._x;\n\t\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\t\tarray[ offset + 3 ] = this._order;\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\ttoVector3: function ( optionalResult ) {\n\t\n\t\t\t\tif ( optionalResult ) {\n\t\n\t\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tonChange: function ( callback ) {\n\t\n\t\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonChangeCallback: function () {}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Layers() {\n\t\n\t\t\tthis.mask = 1 | 0;\n\t\n\t\t}\n\t\n\t\tObject.assign( Layers.prototype, {\n\t\n\t\t\tset: function ( channel ) {\n\t\n\t\t\t\tthis.mask = 1 << channel | 0;\n\t\n\t\t\t},\n\t\n\t\t\tenable: function ( channel ) {\n\t\n\t\t\t\tthis.mask |= 1 << channel | 0;\n\t\n\t\t\t},\n\t\n\t\t\ttoggle: function ( channel ) {\n\t\n\t\t\t\tthis.mask ^= 1 << channel | 0;\n\t\n\t\t\t},\n\t\n\t\t\tdisable: function ( channel ) {\n\t\n\t\t\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\t\n\t\t\t},\n\t\n\t\t\ttest: function ( layers ) {\n\t\n\t\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author elephantatwork / www.elephantatwork.ch\n\t\t */\n\t\n\t\tvar object3DId = 0;\n\t\n\t\tfunction Object3D() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\n\t\t\tvar position = new Vector3();\n\t\t\tvar rotation = new Euler();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3( 1, 1, 1 );\n\t\n\t\t\tfunction onRotationChange() {\n\t\n\t\t\t\tquaternion.setFromEuler( rotation, false );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onQuaternionChange() {\n\t\n\t\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\t\n\t\t\t}\n\t\n\t\t\trotation.onChange( onRotationChange );\n\t\t\tquaternion.onChange( onQuaternionChange );\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tposition: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\n\t\t\tthis.userData = {};\n\t\n\t\t}\n\t\n\t\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\t\tObject3D.DefaultMatrixAutoUpdate = true;\n\t\n\t\tObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: Object3D,\n\t\n\t\t\tisObject3D: true,\n\t\n\t\t\tonBeforeRender: function () {},\n\t\t\tonAfterRender: function () {},\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\t\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t},\n\t\n\t\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\t\tthis.quaternion.premultiply( q );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t\t// assumes axis is normalized\n\t\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromEuler: function ( euler ) {\n\t\n\t\t\t\tthis.quaternion.setFromEuler( euler, true );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromMatrix: function ( m ) {\n\t\n\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\t\n\t\t\t},\n\t\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\t// assumes q is normalized\n\t\n\t\t\t\tthis.quaternion.copy( q );\n\t\n\t\t\t},\n\t\n\t\t\trotateOnAxis: function () {\n\t\n\t\t\t\t// rotate object on axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar q1 = new Quaternion();\n\t\n\t\t\t\treturn function rotateOnAxis( axis, angle ) {\n\t\n\t\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\t\tthis.quaternion.multiply( q1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateOnWorldAxis: function () {\n\t\n\t\t\t\t// rotate object on axis in world space\n\t\t\t\t// axis is assumed to be normalized\n\t\t\t\t// method assumes no rotated parent\n\t\n\t\t\t\tvar q1 = new Quaternion();\n\t\n\t\t\t\treturn function rotateOnWorldAxis( axis, angle ) {\n\t\n\t\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\t\tthis.quaternion.premultiply( q1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateOnAxis: function () {\n\t\n\t\t\t\t// translate object by distance along axis in object space\n\t\t\t\t// axis is assumed to be normalized\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function translateOnAxis( axis, distance ) {\n\t\n\t\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\t\n\t\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateX: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\t\n\t\t\t\treturn function translateX( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateY: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\t\n\t\t\t\treturn function translateY( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslateZ: function () {\n\t\n\t\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\t\n\t\t\t\treturn function translateZ( distance ) {\n\t\n\t\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlocalToWorld: function ( vector ) {\n\t\n\t\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tworldToLocal: function () {\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function worldToLocal( vector ) {\n\t\n\t\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\t// This method does not support objects with rotated and/or translated parent(s)\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\treturn function lookAt( x, y, z ) {\n\t\n\t\t\t\t\tif ( x.isVector3 ) {\n\t\n\t\t\t\t\t\tvector.copy( x );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvector.set( x, y, z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( this.isCamera ) {\n\t\n\t\t\t\t\t\tm1.lookAt( this.position, vector, this.up );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tadd: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.add( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object === this ) {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( object && object.isObject3D ) ) {\n\t\n\t\t\t\t\tif ( object.parent !== null ) {\n\t\n\t\t\t\t\t\tobject.parent.remove( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tobject.parent = this;\n\t\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\t\n\t\t\t\t\tthis.children.push( object );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( object ) {\n\t\n\t\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\t\tthis.remove( arguments[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar index = this.children.indexOf( object );\n\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\tobject.parent = null;\n\t\n\t\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\t\n\t\t\t\t\tthis.children.splice( index, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectById: function ( id ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'id', id );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByName: function ( name ) {\n\t\n\t\t\t\treturn this.getObjectByProperty( 'name', name );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectByProperty: function ( name, value ) {\n\t\n\t\t\t\tif ( this[ name ] === value ) return this;\n\t\n\t\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar child = this.children[ i ];\n\t\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\t\n\t\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\t\treturn object;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn undefined;\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldPosition: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldQuaternion: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Quaternion();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldRotation: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldRotation( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Euler();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldScale: function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldScale( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tgetWorldDirection: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\traycast: function () {},\n\t\n\t\t\ttraverse: function ( callback ) {\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverse( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseVisible: function ( callback ) {\n\t\n\t\t\t\tif ( this.visible === false ) return;\n\t\n\t\t\t\tcallback( this );\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].traverseVisible( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttraverseAncestors: function ( callback ) {\n\t\n\t\t\t\tvar parent = this.parent;\n\t\n\t\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\t\tcallback( parent );\n\t\n\t\t\t\t\tparent.traverseAncestors( callback );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrix: function () {\n\t\n\t\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\t\n\t\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\t\n\t\t\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\t\n\t\t\t\t\tif ( this.parent === null ) {\n\t\n\t\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\t\t\tforce = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update children\n\t\n\t\t\t\tvar children = this.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\t// meta is a string when called from JSON.stringify\n\t\t\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\t\n\t\t\t\tvar output = {};\n\t\n\t\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t\t// not providing it implies that this is the root object\n\t\t\t\t// being serialized.\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\t// initialize meta obj\n\t\t\t\t\tmeta = {\n\t\t\t\t\t\tgeometries: {},\n\t\t\t\t\t\tmaterials: {},\n\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\timages: {},\n\t\t\t\t\t\tshapes: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t\toutput.metadata = {\n\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\ttype: 'Object',\n\t\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// standard Object3D serialization\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tobject.uuid = this.uuid;\n\t\t\t\tobject.type = this.type;\n\t\n\t\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\t\tif ( this.visible === false ) object.visible = false;\n\t\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\n\t\t\t\tobject.matrix = this.matrix.toArray();\n\t\n\t\t\t\t//\n\t\n\t\t\t\tfunction serialize( library, element ) {\n\t\n\t\t\t\t\tif ( library[ element.uuid ] === undefined ) {\n\t\n\t\t\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn element.uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.geometry !== undefined ) {\n\t\n\t\t\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\t\n\t\t\t\t\tvar parameters = this.geometry.parameters;\n\t\n\t\t\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\t\n\t\t\t\t\t\tvar shapes = parameters.shapes;\n\t\n\t\t\t\t\t\tif ( Array.isArray( shapes ) ) {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar shape = shapes[ i ];\n\t\n\t\t\t\t\t\t\t\tserialize( meta.shapes, shape );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tserialize( meta.shapes, shapes );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.material !== undefined ) {\n\t\n\t\t\t\t\tif ( Array.isArray( this.material ) ) {\n\t\n\t\t\t\t\t\tvar uuids = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tobject.material = uuids;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.children.length > 0 ) {\n\t\n\t\t\t\t\tobject.children = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\t\tvar images = extractFromCache( meta.images );\n\t\t\t\t\tvar shapes = extractFromCache( meta.shapes );\n\t\n\t\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.object = object;\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t\t// extract data from the cache hash\n\t\t\t\t// remove metadata on each item\n\t\t\t\t// and return as array\n\t\t\t\tfunction extractFromCache( cache ) {\n\t\n\t\t\t\t\tvar values = [];\n\t\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function ( recursive ) {\n\t\n\t\t\t\treturn new this.constructor().copy( this, recursive );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tif ( recursive === undefined ) recursive = true;\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\tthis.up.copy( source.up );\n\t\n\t\t\t\tthis.position.copy( source.position );\n\t\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\t\tthis.scale.copy( source.scale );\n\t\n\t\t\t\tthis.matrix.copy( source.matrix );\n\t\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\t\n\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\n\t\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\t\tthis.visible = source.visible;\n\t\n\t\t\t\tthis.castShadow = source.castShadow;\n\t\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\n\t\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\t\tthis.renderOrder = source.renderOrder;\n\t\n\t\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\t\tthis.add( child.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t*/\n\t\n\t\tfunction Camera() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Camera';\n\t\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Camera,\n\t\n\t\t\tisCamera: true,\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\t\n\t\t\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\t\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetWorldDirection: function () {\n\t\n\t\t\t\tvar quaternion = new Quaternion();\n\t\n\t\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author arose / http://github.com/arose\n\t\t */\n\t\n\t\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'OrthographicCamera';\n\t\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: OrthographicCamera,\n\t\n\t\t\tisOrthographicCamera: true,\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source, recursive );\n\t\n\t\t\t\tthis.left = source.left;\n\t\t\t\tthis.right = source.right;\n\t\t\t\tthis.top = source.top;\n\t\t\t\tthis.bottom = source.bottom;\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\n\t\t\t\tthis.zoom = source.zoom;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tif ( this.view === null ) {\n\t\n\t\t\t\t\tthis.view = {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\toffsetY: 0,\n\t\t\t\t\t\twidth: 1,\n\t\t\t\t\t\theight: 1\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.view.enabled = true;\n\t\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\t\tthis.view.offsetX = x;\n\t\t\t\tthis.view.offsetY = y;\n\t\t\t\tthis.view.width = width;\n\t\t\t\tthis.view.height = height;\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function () {\n\t\n\t\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\t\tthis.view.enabled = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\t\n\t\t\t\tvar left = cx - dx;\n\t\t\t\tvar right = cx + dx;\n\t\t\t\tvar top = cy + dy;\n\t\t\t\tvar bottom = cy - dy;\n\t\n\t\t\t\tif ( this.view !== null && this.view.enabled ) {\n\t\n\t\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\t\n\t\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\t\t\tdata.object.left = this.left;\n\t\t\t\tdata.object.right = this.right;\n\t\t\t\tdata.object.top = this.top;\n\t\t\t\tdata.object.bottom = this.bottom;\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\t\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\n\t\t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\t\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\t\n\t\t\tthis.color = ( color && color.isColor ) ? color : new Color();\n\t\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\t\n\t\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\n\t\t}\n\t\n\t\tObject.assign( Face3.prototype, {\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.a = source.a;\n\t\t\t\tthis.b = source.b;\n\t\t\t\tthis.c = source.c;\n\t\n\t\t\t\tthis.normal.copy( source.normal );\n\t\t\t\tthis.color.copy( source.color );\n\t\n\t\t\t\tthis.materialIndex = source.materialIndex;\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author kile / http://kile.stravaganza.org/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tvar geometryId = 0; // Geometry uses even numbers as Id\n\t\n\t\tfunction Geometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Geometry';\n\t\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [[]];\n\t\n\t\t\tthis.morphTargets = [];\n\t\t\tthis.morphNormals = [];\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\tthis.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.elementsNeedUpdate = false;\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.lineDistancesNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: Geometry,\n\t\n\t\t\tisGeometry: true,\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertex.applyMatrix4( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.verticesNeedUpdate = true;\n\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj = new Object3D();\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfromBufferGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\t\tvar positions = attributes.position.array;\n\t\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\t\n\t\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\t\n\t\t\t\tvar tempNormals = [];\n\t\t\t\tvar tempUVs = [];\n\t\t\t\tvar tempUVs2 = [];\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\t\n\t\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\t\n\t\t\t\t\tif ( normals !== undefined ) {\n\t\n\t\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( colors !== undefined ) {\n\t\n\t\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\t\n\t\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\t\n\t\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\t\n\t\t\t\t\tscope.faces.push( face );\n\t\n\t\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\t\n\t\t\t\t\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tnormalize: function () {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\tvar center = this.boundingSphere.center;\n\t\t\t\tvar radius = this.boundingSphere.radius;\n\t\n\t\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\t\n\t\t\t\tvar matrix = new Matrix4();\n\t\t\t\tmatrix.set(\n\t\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t);\n\t\n\t\t\t\tthis.applyMatrix( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ f ];\n\t\n\t\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\t\tvar vC = this.vertices[ face.c ];\n\t\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\tcb.normalize();\n\t\n\t\t\t\t\tface.normal.copy( cb );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\n\t\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\t\n\t\t\t\tvar v, vl, f, fl, face, vertices;\n\t\n\t\t\t\tvertices = new Array( this.vertices.length );\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ] = new Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( areaWeighted ) {\n\t\n\t\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\t\n\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\n\t\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\t\tvertices[ face.c ].add( cb );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\t\tvertices[ v ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFlatVertexNormals: function () {\n\t\n\t\t\t\tvar f, fl, face;\n\t\n\t\t\t\tthis.computeFaceNormals();\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeMorphNormals: function () {\n\t\n\t\t\t\tvar i, il, f, fl, face;\n\t\n\t\t\t\t// save original normals\n\t\t\t\t// - create temp variables on first access\n\t\t\t\t//   otherwise just copy (for faster repeated calls)\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\t\n\t\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\t\n\t\t\t\tvar tmpGeo = new Geometry();\n\t\t\t\ttmpGeo.faces = this.faces;\n\t\n\t\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t// create on first access\n\t\n\t\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\t\n\t\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\t\n\t\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\t\n\t\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\t\n\t\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\t\n\t\t\t\t\t// set vertices to morph target\n\t\n\t\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t// compute morph normals\n\t\n\t\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\t\ttmpGeo.computeVertexNormals();\n\t\n\t\t\t\t\t// store morph normals\n\t\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\t\n\t\t\t\t\t\tfaceNormal.copy( face.normal );\n\t\n\t\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// restore original normals\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\t\n\t\t\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normalMatrix,\n\t\t\t\t\tvertexOffset = this.vertices.length,\n\t\t\t\t\tvertices1 = this.vertices,\n\t\t\t\t\tvertices2 = geometry.vertices,\n\t\t\t\t\tfaces1 = this.faces,\n\t\t\t\t\tfaces2 = geometry.faces,\n\t\t\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\t\t\tcolors1 = this.colors,\n\t\t\t\t\tcolors2 = geometry.colors;\n\t\n\t\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\t\n\t\t\t\tif ( matrix !== undefined ) {\n\t\n\t\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// vertices\n\t\n\t\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = vertices2[ i ];\n\t\n\t\t\t\t\tvar vertexCopy = vertex.clone();\n\t\n\t\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\t\n\t\t\t\t\tvertices1.push( vertexCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// colors\n\t\n\t\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// faces\n\t\n\t\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\t\t\tfaceVertexColors = face.vertexColors;\n\t\n\t\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\t\tfaceCopy.normal.copy( face.normal );\n\t\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\t\n\t\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.color.copy( face.color );\n\t\n\t\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\t\n\t\t\t\t\tfaces1.push( faceCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uvs\n\t\n\t\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\t\n\t\t\t\t\tif ( uv === undefined ) {\n\t\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvs1.push( uvCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmergeMesh: function ( mesh ) {\n\t\n\t\t\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\t\n\t\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\t\n\t\t\t},\n\t\n\t\t\t/*\n\t\t\t * Checks for duplicate vertices with hashmap.\n\t\t\t * Duplicated vertices are removed\n\t\t\t * and faces' vertices are updated.\n\t\t\t */\n\t\n\t\t\tmergeVertices: function () {\n\t\n\t\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\t\tvar unique = [], changes = [];\n\t\n\t\t\t\tvar v, key;\n\t\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\t\tvar i, il, face;\n\t\t\t\tvar indices, j, jl;\n\t\n\t\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tv = this.vertices[ i ];\n\t\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\t\n\t\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t\t// have to remove them from the geometry.\n\t\t\t\tvar faceIndicesToRemove = [];\n\t\n\t\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ i ];\n\t\n\t\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\t\tface.c = changes[ face.c ];\n\t\n\t\t\t\t\tindices = [ face.a, face.b, face.c ];\n\t\n\t\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\n\t\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\t\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\n\t\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\t\n\t\t\t\t\tthis.faces.splice( idx, 1 );\n\t\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Use unique set of vertices\n\t\n\t\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\t\tthis.vertices = unique;\n\t\t\t\treturn diff;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.vertices = [];\n\t\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar point = points[ i ];\n\t\t\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsortFacesByMaterialIndex: function () {\n\t\n\t\t\t\tvar faces = this.faces;\n\t\t\t\tvar length = faces.length;\n\t\n\t\t\t\t// tag faces\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tfaces[ i ]._id = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// sort faces\n\t\n\t\t\t\tfunction materialIndexSort( a, b ) {\n\t\n\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaces.sort( materialIndexSort );\n\t\n\t\t\t\t// sort uvs\n\t\n\t\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\t\n\t\t\t\tvar newUvs1, newUvs2;\n\t\n\t\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tvar id = faces[ i ]._id;\n\t\n\t\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard Geometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vertices = [];\n\t\n\t\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar normalsHash = {};\n\t\t\t\tvar colors = [];\n\t\t\t\tvar colorsHash = {};\n\t\t\t\tvar uvs = [];\n\t\t\t\tvar uvsHash = {};\n\t\n\t\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = this.faces[ i ];\n\t\n\t\t\t\t\tvar hasMaterial = true;\n\t\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\t\n\t\t\t\t\tvar faceType = 0;\n\t\n\t\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\t\n\t\t\t\t\tfaces.push( faceType );\n\t\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\t\tfaces.push( face.materialIndex );\n\t\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\t\tfaces.push(\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction setBit( value, position, enabled ) {\n\t\n\t\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getNormalIndex( normal ) {\n\t\n\t\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\t\n\t\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getColorIndex( color ) {\n\t\n\t\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\t\n\t\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\t\tcolors.push( color.getHex() );\n\t\n\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getUvIndex( uv ) {\n\t\n\t\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\t\n\t\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = {};\n\t\n\t\t\t\tdata.data.vertices = vertices;\n\t\t\t\tdata.data.normals = normals;\n\t\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\t\tdata.data.faces = faces;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t // Handle primitives\n\t\n\t\t\t\t var parameters = this.parameters;\n\t\n\t\t\t\t if ( parameters !== undefined ) {\n\t\n\t\t\t\t var values = [];\n\t\n\t\t\t\t for ( var key in parameters ) {\n\t\n\t\t\t\t values.push( parameters[ key ] );\n\t\n\t\t\t\t }\n\t\n\t\t\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t\t\t this.constructor.apply( geometry, values );\n\t\t\t\t return geometry;\n\t\n\t\t\t\t }\n\t\n\t\t\t\t return new this.constructor().copy( this );\n\t\t\t\t */\n\t\n\t\t\t\treturn new Geometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tvar i, il, j, jl, k, kl;\n\t\n\t\t\t\t// reset\n\t\n\t\t\t\tthis.vertices = [];\n\t\t\t\tthis.colors = [];\n\t\t\t\tthis.faces = [];\n\t\t\t\tthis.faceVertexUvs = [[]];\n\t\t\t\tthis.morphTargets = [];\n\t\t\t\tthis.morphNormals = [];\n\t\t\t\tthis.skinWeights = [];\n\t\t\t\tthis.skinIndices = [];\n\t\t\t\tthis.lineDistances = [];\n\t\t\t\tthis.boundingBox = null;\n\t\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t\t// name\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\t// vertices\n\t\n\t\t\t\tvar vertices = source.vertices;\n\t\n\t\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// colors\n\t\n\t\t\t\tvar colors = source.colors;\n\t\n\t\t\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// faces\n\t\n\t\t\t\tvar faces = source.faces;\n\t\n\t\t\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// face vertex uvs\n\t\n\t\t\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\t\n\t\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\t\n\t\t\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\tvar uv = uvs[ k ];\n\t\n\t\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphTargets = source.morphTargets;\n\t\n\t\t\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = {};\n\t\t\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\t\n\t\t\t\t\t// vertices\n\t\n\t\t\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\t\n\t\t\t\t\t\tmorphTarget.vertices = [];\n\t\n\t\t\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// normals\n\t\n\t\t\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\t\n\t\t\t\t\t\tmorphTarget.normals = [];\n\t\n\t\t\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.push( morphTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph normals\n\t\n\t\t\t\tvar morphNormals = source.morphNormals;\n\t\n\t\t\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar morphNormal = {};\n\t\n\t\t\t\t\t// vertex normals\n\t\n\t\t\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\t\n\t\t\t\t\t\tmorphNormal.vertexNormals = [];\n\t\n\t\t\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\t\t\tvar destVertexNormal = {};\n\t\n\t\t\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\t\n\t\t\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// face normals\n\t\n\t\t\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\t\n\t\t\t\t\t\tmorphNormal.faceNormals = [];\n\t\n\t\t\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphNormals.push( morphNormal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skin weights\n\t\n\t\t\t\tvar skinWeights = source.skinWeights;\n\t\n\t\t\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skin indices\n\t\n\t\t\t\tvar skinIndices = source.skinIndices;\n\t\n\t\t\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// line distances\n\t\n\t\t\t\tvar lineDistances = source.lineDistances;\n\t\n\t\t\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// bounding box\n\t\n\t\t\t\tvar boundingBox = source.boundingBox;\n\t\n\t\t\t\tif ( boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// bounding sphere\n\t\n\t\t\t\tvar boundingSphere = source.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update flags\n\t\n\t\t\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\t\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\t\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\t\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\t\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\t\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\t\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.onUploadCallback = function () {};\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( BufferAttribute.prototype, {\n\t\n\t\t\tisBufferAttribute: true,\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.itemSize = source.itemSize;\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.normalized = source.normalized;\n\t\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.itemSize;\n\t\t\t\tindex2 *= attribute.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyArray: function ( array ) {\n\t\n\t\t\t\tthis.array.set( array );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyColorsArray: function ( colors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar color = colors[ i ];\n\t\n\t\t\t\t\tif ( color === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\t\tcolor = new Color();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\t\tarray[ offset ++ ] = color.b;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyIndicesArray: function ( indices ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar index = indices[ i ];\n\t\n\t\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\t\tarray[ offset ++ ] = index.c;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector2sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector2();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector3sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector3();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyVector4sArray: function ( vectors ) {\n\t\n\t\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\t\tvector = new Vector4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\t\tarray[ offset ++ ] = vector.w;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize ];\n\t\n\t\t\t},\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex *= this.itemSize;\n\t\n\t\t\t\tthis.array[ index + 0 ] = x;\n\t\t\t\tthis.array[ index + 1 ] = y;\n\t\t\t\tthis.array[ index + 2 ] = z;\n\t\t\t\tthis.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tonUpload: function ( callback ) {\n\t\n\t\t\t\tthis.onUploadCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tfunction Int8BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\t\n\t\n\t\tfunction Uint8BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\t\n\t\n\t\tfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\t\n\t\n\t\tfunction Int16BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\t\n\t\n\t\tfunction Uint16BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\t\n\t\n\t\tfunction Int32BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\t\n\t\n\t\tfunction Uint32BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\t\n\t\n\t\tfunction Float32BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\t\n\t\n\t\tfunction Float64BufferAttribute( array, itemSize, normalized ) {\n\t\n\t\t\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\n\t\n\t\t}\n\t\n\t\tFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\t\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectGeometry() {\n\t\n\t\t\tthis.indices = [];\n\t\t\tthis.vertices = [];\n\t\t\tthis.normals = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.uvs = [];\n\t\t\tthis.uvs2 = [];\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.morphTargets = {};\n\t\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\n\t\t\t// this.lineDistances = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t// update flags\n\t\n\t\t\tthis.verticesNeedUpdate = false;\n\t\t\tthis.normalsNeedUpdate = false;\n\t\t\tthis.colorsNeedUpdate = false;\n\t\t\tthis.uvsNeedUpdate = false;\n\t\t\tthis.groupsNeedUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( DirectGeometry.prototype, {\n\t\n\t\t\tcomputeGroups: function ( geometry ) {\n\t\n\t\t\t\tvar group;\n\t\t\t\tvar groups = [];\n\t\t\t\tvar materialIndex = undefined;\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t// materials\n\t\n\t\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\t\n\t\t\t\t\t\tmaterialIndex = face.materialIndex;\n\t\n\t\t\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.groups = groups;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\t\n\t\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\tvar morphTargetsLength = morphTargets.length;\n\t\n\t\t\t\tvar morphTargetsPosition;\n\t\n\t\t\t\tif ( morphTargetsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsPosition = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\t\tvar morphNormalsLength = morphNormals.length;\n\t\n\t\t\t\tvar morphTargetsNormal;\n\t\n\t\t\t\tif ( morphNormalsLength > 0 ) {\n\t\n\t\t\t\t\tmorphTargetsNormal = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skins\n\t\n\t\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\t\tvar skinWeights = geometry.skinWeights;\n\t\n\t\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\tif ( vertexColors.length === 3 ) {\n\t\n\t\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar color = face.color;\n\t\n\t\t\t\t\t\tthis.colors.push( color, color, color );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\t\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\t\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\t\n\t\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// morphs\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\t\n\t\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\t\n\t\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\t\n\t\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// skins\n\t\n\t\t\t\t\tif ( hasSkinIndices ) {\n\t\n\t\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( hasSkinWeights ) {\n\t\n\t\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.computeGroups( geometry );\n\t\n\t\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction arrayMax( array ) {\n\t\n\t\t\tif ( array.length === 0 ) return - Infinity;\n\t\n\t\t\tvar max = array[ 0 ];\n\t\n\t\t\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\n\t\n\t\t\t\tif ( array[ i ] > max ) max = array[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn max;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\t\n\t\tfunction BufferGeometry() {\n\t\n\t\t\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\n\t\t\tthis.morphAttributes = {};\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\n\t\t\tthis.drawRange = { start: 0, count: Infinity };\n\t\n\t\t}\n\t\n\t\tBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: BufferGeometry,\n\t\n\t\t\tisBufferGeometry: true,\n\t\n\t\t\tgetIndex: function () {\n\t\n\t\t\t\treturn this.index;\n\t\n\t\t\t},\n\t\n\t\t\tsetIndex: function ( index ) {\n\t\n\t\t\t\tif ( Array.isArray( index ) ) {\n\t\n\t\t\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.index = index;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\taddAttribute: function ( name, attribute ) {\n\t\n\t\t\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\t\n\t\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( name === 'index' ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\t\tthis.setIndex( attribute );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.attributes[ name ] = attribute;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetAttribute: function ( name ) {\n\t\n\t\t\t\treturn this.attributes[ name ];\n\t\n\t\t\t},\n\t\n\t\t\tremoveAttribute: function ( name ) {\n\t\n\t\t\t\tdelete this.attributes[ name ];\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddGroup: function ( start, count, materialIndex ) {\n\t\n\t\t\t\tthis.groups.push( {\n\t\n\t\t\t\t\tstart: start,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\t\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\tclearGroups: function () {\n\t\n\t\t\t\tthis.groups = [];\n\t\n\t\t\t},\n\t\n\t\t\tsetDrawRange: function ( start, count ) {\n\t\n\t\t\t\tthis.drawRange.start = start;\n\t\t\t\tthis.drawRange.count = count;\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\t\tvar position = this.attributes.position;\n\t\n\t\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\t\tmatrix.applyToBufferAttribute( position );\n\t\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normal = this.attributes.normal;\n\t\n\t\t\t\tif ( normal !== undefined ) {\n\t\n\t\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\t\tnormalMatrix.applyToBufferAttribute( normal );\n\t\t\t\t\tnormal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trotateX: function () {\n\t\n\t\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateY: function () {\n\t\n\t\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\trotateZ: function () {\n\t\n\t\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttranslate: function () {\n\t\n\t\t\t\t// translate geometry\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tscale: function () {\n\t\n\t\t\t\t// scale geometry\n\t\n\t\t\t\tvar m1 = new Matrix4();\n\t\n\t\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tlookAt: function () {\n\t\n\t\t\t\tvar obj = new Object3D();\n\t\n\t\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcenter: function () {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\t\n\t\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\t\treturn offset;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( object.isPoints || object.isLine ) {\n\t\n\t\t\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\t\n\t\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\t\n\t\t\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\t\n\t\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object.isMesh ) {\n\t\n\t\t\t\t\tif ( geometry && geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tthis.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tvar position = [];\n\t\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar point = points[ i ];\n\t\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateFromObject: function ( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( object.isMesh ) {\n\t\n\t\t\t\t\tvar direct = geometry.__directGeometry;\n\t\n\t\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\t\n\t\t\t\t\t\tdirect = undefined;\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direct === undefined ) {\n\t\n\t\t\t\t\t\treturn this.fromGeometry( geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t\tgeometry = direct;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attribute;\n\t\n\t\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.position;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.normal;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\t\n\t\t\t\t\tattribute = this.attributes.color;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvsNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.uv;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\t\n\t\t\t\t\tattribute = this.attributes.lineDistance;\n\t\n\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.groupsNeedUpdate ) {\n\t\n\t\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\t\n\t\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\t\n\t\t\t},\n\t\n\t\t\tfromDirectGeometry: function ( geometry ) {\n\t\n\t\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\t\n\t\t\t\tif ( geometry.normals.length > 0 ) {\n\t\n\t\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.colors.length > 0 ) {\n\t\n\t\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.uvs2.length > 0 ) {\n\t\n\t\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.indices.length > 0 ) {\n\t\n\t\t\t\t\tvar TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// groups\n\t\n\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tfor ( var name in geometry.morphTargets ) {\n\t\n\t\t\t\t\tvar array = [];\n\t\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\n\t\t\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\n\t\n\t\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning\n\t\n\t\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\t\n\t\t\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\t\n\t\t\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingBox: function () {\n\t\n\t\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\t\tthis.boundingBox = new Box3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar position = this.attributes.position;\n\t\n\t\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.boundingBox.makeEmpty();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\t\tvar box = new Box3();\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\treturn function computeBoundingSphere() {\n\t\n\t\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar position = this.attributes.position;\n\t\n\t\t\t\t\tif ( position ) {\n\t\n\t\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\n\t\t\t\t\t\tbox.setFromBufferAttribute( position );\n\t\t\t\t\t\tbox.getCenter( center );\n\t\n\t\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\t\n\t\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tvector.x = position.getX( i );\n\t\t\t\t\t\t\tvector.y = position.getY( i );\n\t\t\t\t\t\t\tvector.z = position.getZ( i );\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t\t// backwards compatibility\n\t\n\t\t\t},\n\t\n\t\t\tcomputeVertexNormals: function () {\n\t\n\t\t\t\tvar index = this.index;\n\t\t\t\tvar attributes = this.attributes;\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( attributes.position ) {\n\t\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( attributes.normal === undefined ) {\n\t\n\t\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// reset existing normals to zero\n\t\n\t\t\t\t\t\tvar array = attributes.normal.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tarray[ i ] = 0;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\t\n\t\t\t\t\t// indexed elements\n\t\n\t\t\t\t\tif ( index ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar group = groups[ j ];\n\t\n\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\t\n\t\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\t\n\t\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\t\n\t\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\t\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.normalizeNormals();\n\t\n\t\t\t\t\tattributes.normal.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmerge: function ( geometry, offset ) {\n\t\n\t\t\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\t\n\t\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\t\tvar attributeArray1 = attribute1.array;\n\t\n\t\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\t\tvar attributeArray2 = attribute2.array;\n\t\n\t\t\t\t\tvar attributeSize = attribute2.itemSize;\n\t\n\t\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\t\n\t\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeNormals: function () {\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\treturn function normalizeNormals() {\n\t\n\t\t\t\t\tvar normals = this.attributes.normal;\n\t\n\t\t\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvector.x = normals.getX( i );\n\t\t\t\t\t\tvector.y = normals.getY( i );\n\t\t\t\t\t\tvector.z = normals.getZ( i );\n\t\n\t\t\t\t\t\tvector.normalize();\n\t\n\t\t\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttoNonIndexed: function () {\n\t\n\t\t\t\tif ( this.index === null ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry2 = new BufferGeometry();\n\t\n\t\t\t\tvar indices = this.index.array;\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\n\t\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\t\n\t\t\t\t\tvar index = 0, index2 = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tindex = indices[ i ] * itemSize;\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\t\n\t\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry2;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// standard BufferGeometry serialization\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.type = this.type;\n\t\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdata.data = { attributes: {} };\n\t\n\t\t\t\tvar index = this.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\t\n\t\t\t\t\tdata.data.index = {\n\t\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\t\tarray: array\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = this.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\n\t\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\t\n\t\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\t\tarray: array,\n\t\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = this.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = this.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\t/*\n\t\t\t\t // Handle primitives\n\t\n\t\t\t\t var parameters = this.parameters;\n\t\n\t\t\t\t if ( parameters !== undefined ) {\n\t\n\t\t\t\t var values = [];\n\t\n\t\t\t\t for ( var key in parameters ) {\n\t\n\t\t\t\t values.push( parameters[ key ] );\n\t\n\t\t\t\t }\n\t\n\t\t\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t\t\t this.constructor.apply( geometry, values );\n\t\t\t\t return geometry;\n\t\n\t\t\t\t }\n\t\n\t\t\t\t return new this.constructor().copy( this );\n\t\t\t\t */\n\t\n\t\t\t\treturn new BufferGeometry().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tvar name, i, l;\n\t\n\t\t\t\t// reset\n\t\n\t\t\t\tthis.index = null;\n\t\t\t\tthis.attributes = {};\n\t\t\t\tthis.morphAttributes = {};\n\t\t\t\tthis.groups = [];\n\t\t\t\tthis.boundingBox = null;\n\t\t\t\tthis.boundingSphere = null;\n\t\n\t\t\t\t// name\n\t\n\t\t\t\tthis.name = source.name;\n\t\n\t\t\t\t// index\n\t\n\t\t\t\tvar index = source.index;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// attributes\n\t\n\t\t\t\tvar attributes = source.attributes;\n\t\n\t\t\t\tfor ( name in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph attributes\n\t\n\t\t\t\tvar morphAttributes = source.morphAttributes;\n\t\n\t\t\t\tfor ( name in morphAttributes ) {\n\t\n\t\t\t\t\tvar array = [];\n\t\t\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\t\n\t\t\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tarray.push( morphAttribute[ i ].clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// groups\n\t\n\t\t\t\tvar groups = source.groups;\n\t\n\t\t\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// bounding box\n\t\n\t\t\t\tvar boundingBox = source.boundingBox;\n\t\n\t\t\t\tif ( boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// bounding sphere\n\t\n\t\t\t\tvar boundingSphere = source.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// draw range\n\t\n\t\t\t\tthis.drawRange.start = source.drawRange.start;\n\t\t\t\tthis.drawRange.count = source.drawRange.count;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdispose: function () {\n\t\n\t\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// BoxGeometry\n\t\n\t\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\t\tBoxGeometry.prototype.constructor = BoxGeometry;\n\t\n\t\t// BoxBufferGeometry\n\t\n\t\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'BoxBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\twidth = width || 1;\n\t\t\theight = height || 1;\n\t\t\tdepth = depth || 1;\n\t\n\t\t\t// segments\n\t\n\t\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar numberOfVertices = 0;\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// build each side of the box geometry\n\t\n\t\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\t\n\t\t\t\tvar segmentWidth = width / gridX;\n\t\t\t\tvar segmentHeight = height / gridY;\n\t\n\t\t\t\tvar widthHalf = width / 2;\n\t\t\t\tvar heightHalf = height / 2;\n\t\t\t\tvar depthHalf = depth / 2;\n\t\n\t\t\t\tvar gridX1 = gridX + 1;\n\t\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\t\tvar vertexCounter = 0;\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar ix, iy;\n\t\n\t\t\t\tvar vector = new Vector3();\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\t\n\t\t\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\n\t\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\t\tvector[ w ] = depthHalf;\n\t\n\t\t\t\t\t\t// now apply vector to vertex buffer\n\t\n\t\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\t\n\t\t\t\t\t\t// set values to correct vector component\n\t\n\t\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\t\n\t\t\t\t\t\t// now apply vector to normal buffer\n\t\n\t\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\t\n\t\t\t\t\t\t// uvs\n\t\n\t\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\t\n\t\t\t\t\t\t// counters\n\t\n\t\t\t\t\t\tvertexCounter += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// indices\n\t\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\t\n\t\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t\t// faces\n\t\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t\t\t// increase counter\n\t\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\n\t\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t\t// update total number of vertices\n\t\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// PlaneGeometry\n\t\n\t\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\t\n\t\t// PlaneBufferGeometry\n\t\n\t\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PlaneBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\n\t\t\twidth = width || 1;\n\t\t\theight = height || 1;\n\t\n\t\t\tvar width_half = width / 2;\n\t\t\tvar height_half = height / 2;\n\t\n\t\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\t\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\tvar segment_width = width / gridX;\n\t\t\tvar segment_height = height / gridY;\n\t\n\t\t\tvar ix, iy;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\tvar y = iy * segment_height - height_half;\n\t\n\t\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\tvar x = ix * segment_width - width_half;\n\t\n\t\t\t\t\tvertices.push( x, - y, 0 );\n\t\n\t\t\t\t\tnormals.push( 0, 0, 1 );\n\t\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// indices\n\t\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t// faces\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  depthTest: <bool>,\n\t\t *  depthWrite: <bool>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // emissive\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\t\n\t\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\t\n\t\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  defines: { \"label\" : \"value\" },\n\t\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t\t *\n\t\t *  fragmentShader: <string>,\n\t\t *  vertexShader: <string>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  lights: <bool>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction ShaderMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'ShaderMaterial';\n\t\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\n\t\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\t\n\t\t\tthis.linewidth = 1;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false; // set to use scene fog\n\t\t\tthis.lights = false; // set to use scene lights\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\t\n\t\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\t\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false, // set to use derivatives\n\t\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t\t};\n\t\n\t\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t\t'uv': [ 0, 0 ],\n\t\t\t\t'uv2': [ 0, 0 ]\n\t\t\t};\n\t\n\t\t\tthis.index0AttributeName = undefined;\n\t\t\tthis.uniformsNeedUpdate = false;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tif ( parameters.attributes !== undefined ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setValues( parameters );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tShaderMaterial.prototype = Object.create( Material.prototype );\n\t\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\t\n\t\tShaderMaterial.prototype.isShaderMaterial = true;\n\t\n\t\tShaderMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\n\t\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\t\n\t\t\tthis.defines = source.defines;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\tthis.extensions = source.extensions;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\t\n\t\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.uniforms = this.uniforms;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Ray( origin, direction ) {\n\t\n\t\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\t\n\t\t}\n\t\n\t\tObject.assign( Ray.prototype, {\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\tthis.origin.copy( origin );\n\t\t\t\tthis.direction.copy( direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( ray ) {\n\t\n\t\t\t\tthis.origin.copy( ray.origin );\n\t\t\t\tthis.direction.copy( ray.direction );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tlookAt: function ( v ) {\n\t\n\t\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\trecast: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function recast( t ) {\n\t\n\t\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tresult.subVectors( point, this.origin );\n\t\t\t\tvar directionDistance = result.dot( this.direction );\n\t\n\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\treturn result.copy( this.origin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSqToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToPoint( point ) {\n\t\n\t\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\n\t\t\t\t\t// point behind the ray\n\t\n\t\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t\t\treturn v1.distanceToSquared( point );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tdistanceSqToSegment: function () {\n\t\n\t\t\t\tvar segCenter = new Vector3();\n\t\t\t\tvar segDir = new Vector3();\n\t\t\t\tvar diff = new Vector3();\n\t\n\t\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t\t// defined by v0 and v1\n\t\t\t\t\t// It can also set two optional targets :\n\t\t\t\t\t// - The closest point on the ray\n\t\t\t\t\t// - The closest point on the segment\n\t\n\t\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\t\n\t\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\t\tvar s0, s1, sqrDist, extDet;\n\t\n\t\t\t\t\tif ( det > 0 ) {\n\t\n\t\t\t\t\t\t// The ray and segment are not parallel.\n\t\n\t\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\t\textDet = segExtent * det;\n\t\n\t\t\t\t\t\tif ( s0 >= 0 ) {\n\t\n\t\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\t\n\t\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\n\t\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t// region 1\n\t\n\t\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 5\n\t\n\t\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 4\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 3\n\t\n\t\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 2\n\t\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// Ray and segment are parallel.\n\t\n\t\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnRay ) {\n\t\n\t\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( optionalPointOnSegment ) {\n\t\n\t\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn sqrDist;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectSphere: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\t\n\t\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\t\n\t\t\t\t\tif ( d2 > radius2 ) return null;\n\t\n\t\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\t\n\t\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\t\tvar t0 = tca - thc;\n\t\n\t\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\t\tvar t1 = tca + thc;\n\t\n\t\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\t\n\t\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\t\n\t\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\t\treturn this.at( t0, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPlane: function ( plane ) {\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\t\n\t\t\t\t\t\treturn 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\t\n\t\t\t\t// Return if the ray never intersects the plane\n\t\n\t\t\t\treturn t >= 0 ? t : null;\n\t\n\t\t\t},\n\t\n\t\t\tintersectPlane: function ( plane, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.distanceToPlane( plane );\n\t\n\t\t\t\tif ( t === null ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.at( t, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t\t// check if the ray lies on the plane first\n\t\n\t\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\t\n\t\t\t\tif ( distToPoint === 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\t\tif ( denominator * distToPoint < 0 ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t},\n\t\n\t\t\tintersectBox: function ( box, optionalTarget ) {\n\t\n\t\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\n\t\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\n\t\t\t\tvar origin = this.origin;\n\t\n\t\t\t\tif ( invdirx >= 0 ) {\n\t\n\t\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( invdiry >= 0 ) {\n\t\n\t\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\t\n\t\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\n\t\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\t\n\t\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\t\n\t\t\t\tif ( invdirz >= 0 ) {\n\t\n\t\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\t\n\t\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\t\n\t\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\t\n\t\t\t\t//return point closest to the ray (positive side)\n\t\n\t\t\t\tif ( tmax < 0 ) return null;\n\t\n\t\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: ( function () {\n\t\n\t\t\t\tvar v = new Vector3();\n\t\n\t\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tintersectTriangle: function () {\n\t\n\t\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t\tvar diff = new Vector3();\n\t\t\t\tvar edge1 = new Vector3();\n\t\t\t\tvar edge2 = new Vector3();\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\t\n\t\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\n\t\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\t\n\t\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\t\tvar sign;\n\t\n\t\t\t\t\tif ( DdN > 0 ) {\n\t\n\t\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\t\tsign = 1;\n\t\n\t\t\t\t\t} else if ( DdN < 0 ) {\n\t\n\t\t\t\t\t\tsign = - 1;\n\t\t\t\t\t\tDdN = - DdN;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\t\n\t\t\t\t\t// b1 < 0, no intersection\n\t\t\t\t\tif ( DdQxE2 < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\t\n\t\t\t\t\t// b2 < 0, no intersection\n\t\t\t\t\tif ( DdE1xQ < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\t\n\t\t\t\t\t// t < 0, no intersection\n\t\t\t\t\tif ( QdN < 0 ) {\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Ray intersects triangle.\n\t\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tapplyMatrix4: function ( matrix4 ) {\n\t\n\t\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\t\tthis.direction.transformDirection( matrix4 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( ray ) {\n\t\n\t\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Line3( start, end ) {\n\t\n\t\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\t\n\t\t}\n\t\n\t\tObject.assign( Line3.prototype, {\n\t\n\t\t\tset: function ( start, end ) {\n\t\n\t\t\t\tthis.start.copy( start );\n\t\t\t\tthis.end.copy( end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( line ) {\n\t\n\t\t\t\tthis.start.copy( line.start );\n\t\t\t\tthis.end.copy( line.end );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tdelta: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.subVectors( this.end, this.start );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceSq: function () {\n\t\n\t\t\t\treturn this.start.distanceToSquared( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tdistance: function () {\n\t\n\t\t\t\treturn this.start.distanceTo( this.end );\n\t\n\t\t\t},\n\t\n\t\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPointParameter: function () {\n\t\n\t\t\t\tvar startP = new Vector3();\n\t\t\t\tvar startEnd = new Vector3();\n\t\n\t\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\t\n\t\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\t\n\t\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\t\n\t\t\t\t\tvar t = startEnd_startP / startEnd2;\n\t\n\t\t\t\t\tif ( clampToLine ) {\n\t\n\t\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn t;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t\t},\n\t\n\t\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\t\tthis.end.applyMatrix4( matrix );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( line ) {\n\t\n\t\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Triangle( a, b, c ) {\n\t\n\t\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\t\n\t\t}\n\t\n\t\tObject.assign( Triangle, {\n\t\n\t\t\tnormal: function () {\n\t\n\t\t\t\tvar v0 = new Vector3();\n\t\n\t\t\t\treturn function normal( a, b, c, optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\tresult.subVectors( c, b );\n\t\t\t\t\tv0.subVectors( a, b );\n\t\t\t\t\tresult.cross( v0 );\n\t\n\t\t\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\t\t\tif ( resultLengthSq > 0 ) {\n\t\n\t\t\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result.set( 0, 0, 0 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\t// static/instance method to calculate barycentric coordinates\n\t\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\t\t\tbarycoordFromPoint: function () {\n\t\n\t\t\t\tvar v0 = new Vector3();\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\t\n\t\t\t\t\tv0.subVectors( c, a );\n\t\t\t\t\tv1.subVectors( b, a );\n\t\t\t\t\tv2.subVectors( point, a );\n\t\n\t\t\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\t\t\tvar dot12 = v1.dot( v2 );\n\t\n\t\t\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\n\t\t\t\t\t// collinear or singular triangle\n\t\t\t\t\tif ( denom === 0 ) {\n\t\n\t\t\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar invDenom = 1 / denom;\n\t\t\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\t\t\t\t\t// barycentric coordinates must always sum to 1\n\t\t\t\t\treturn result.set( 1 - u - v, v, u );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tcontainsPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function containsPoint( point, a, b, c ) {\n\t\n\t\t\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\t\n\t\t\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}()\n\t\n\t\t} );\n\t\n\t\tObject.assign( Triangle.prototype, {\n\t\n\t\t\tset: function ( a, b, c ) {\n\t\n\t\t\t\tthis.a.copy( a );\n\t\t\t\tthis.b.copy( b );\n\t\t\t\tthis.c.copy( c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\t\n\t\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\t\tthis.c.copy( points[ i2 ] );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( triangle ) {\n\t\n\t\t\t\tthis.a.copy( triangle.a );\n\t\t\t\tthis.b.copy( triangle.b );\n\t\t\t\tthis.c.copy( triangle.c );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tarea: function () {\n\t\n\t\t\t\tvar v0 = new Vector3();\n\t\t\t\tvar v1 = new Vector3();\n\t\n\t\t\t\treturn function area() {\n\t\n\t\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\t\tv1.subVectors( this.a, this.b );\n\t\n\t\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tmidpoint: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\t\n\t\t\t},\n\t\n\t\t\tnormal: function ( optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tplane: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Plane();\n\t\n\t\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\treturn box.intersectsTriangle( this );\n\t\n\t\t\t},\n\t\n\t\t\tclosestPointToPoint: function () {\n\t\n\t\t\t\tvar plane = new Plane();\n\t\t\t\tvar edgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\tvar projectedPoint = new Vector3();\n\t\t\t\tvar closestPoint = new Vector3();\n\t\n\t\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\t\n\t\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\t\tvar minDistance = Infinity;\n\t\n\t\t\t\t\t// project the point onto the plane of the triangle\n\t\n\t\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\t\tplane.projectPoint( point, projectedPoint );\n\t\n\t\t\t\t\t// check if the projection lies within the triangle\n\t\n\t\t\t\t\tif ( this.containsPoint( projectedPoint ) === true ) {\n\t\n\t\t\t\t\t\t// if so, this is the closest point\n\t\n\t\t\t\t\t\tresult.copy( projectedPoint );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\t\n\t\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < edgeList.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\t\n\t\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\t\n\t\t\t\t\t\t\tif ( distance < minDistance ) {\n\t\n\t\t\t\t\t\t\t\tminDistance = distance;\n\t\n\t\t\t\t\t\t\t\tresult.copy( closestPoint );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn result;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tequals: function ( triangle ) {\n\t\n\t\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author jonobr1 / http://jonobr1.com/\n\t\t */\n\t\n\t\tfunction Mesh( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Mesh';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t\tthis.drawMode = TrianglesDrawMode;\n\t\n\t\t\tthis.updateMorphTargets();\n\t\n\t\t}\n\t\n\t\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Mesh,\n\t\n\t\t\tisMesh: true,\n\t\n\t\t\tsetDrawMode: function ( value ) {\n\t\n\t\t\t\tthis.drawMode = value;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.drawMode = source.drawMode;\n\t\n\t\t\t\tif ( source.morphTargetInfluences !== undefined ) {\n\t\n\t\t\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( source.morphTargetDictionary !== undefined ) {\n\t\n\t\t\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMorphTargets: function () {\n\t\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar m, ml, name;\n\t\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\t\t\t\tvar keys = Object.keys( morphAttributes );\n\t\n\t\t\t\t\tif ( keys.length > 0 ) {\n\t\n\t\t\t\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\n\t\n\t\t\t\t\t\tif ( morphAttribute !== undefined ) {\n\t\n\t\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\n\t\n\t\t\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\n\t\t\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\t\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\t\t\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\t\t\tname = morphTargets[ m ].name || String( m );\n\t\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\tvar vA = new Vector3();\n\t\t\t\tvar vB = new Vector3();\n\t\t\t\tvar vC = new Vector3();\n\t\n\t\t\t\tvar tempA = new Vector3();\n\t\t\t\tvar tempB = new Vector3();\n\t\t\t\tvar tempC = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tvar barycoord = new Vector3();\n\t\n\t\t\t\tvar intersectionPoint = new Vector3();\n\t\t\t\tvar intersectionPointWorld = new Vector3();\n\t\n\t\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\t\n\t\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\t\n\t\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\t\n\t\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\t\n\t\t\t\t\treturn uv1.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\t\n\t\t\t\t\tvar intersect;\n\t\n\t\t\t\t\tif ( material.side === BackSide ) {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( intersect === null ) return null;\n\t\n\t\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\t\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\t\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\n\t\n\t\t\t\t\tvA.fromBufferAttribute( position, a );\n\t\t\t\t\tvB.fromBufferAttribute( position, b );\n\t\t\t\t\tvC.fromBufferAttribute( position, c );\n\t\n\t\t\t\t\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\n\t\n\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\tif ( uv ) {\n\t\n\t\t\t\t\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\t\t\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\t\t\t\t\tuvC.fromBufferAttribute( uv, c );\n\t\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\t\tintersection.faceIndex = a;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn intersection;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar material = this.material;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\tif ( material === undefined ) return;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\t// Check boundingBox before continuing\n\t\n\t\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar intersection;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\tvar a, b, c;\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\t\t\tvar uv = geometry.attributes.uv;\n\t\t\t\t\t\tvar i, l;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\t// indexed buffer geometry\n\t\n\t\t\t\t\t\t\tfor ( i = 0, l = index.count; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\t\t\t\tc = index.getX( i + 2 );\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\t\t\t\t// non-indexed buffer geometry\n\t\n\t\t\t\t\t\t\tfor ( i = 0, l = position.count; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\t\tb = i + 1;\n\t\t\t\t\t\t\t\tc = i + 2;\n\t\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\n\t\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\t\tvar isMultiMaterial = Array.isArray( material );\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar uvs;\n\t\n\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\t\n\t\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\t\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\n\t\n\t\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\t\n\t\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\t\tfvC = vertices[ face.c ];\n\t\n\t\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\t\n\t\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\t\n\t\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\t\tvC.add( fvC );\n\t\n\t\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\t\tfvC = vC;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tif ( uvs && uvs[ f ] ) {\n\t\n\t\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\t\n\t\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {\n\t\n\t\t\tvar clearColor = new Color( 0x000000 );\n\t\t\tvar clearAlpha = 0;\n\t\n\t\t\tvar planeCamera, planeMesh;\n\t\t\tvar boxMesh;\n\t\n\t\t\tfunction render( renderList, scene, camera, forceClear ) {\n\t\n\t\t\t\tvar background = scene.background;\n\t\n\t\t\t\tif ( background === null ) {\n\t\n\t\t\t\t\tsetClear( clearColor, clearAlpha );\n\t\n\t\t\t\t} else if ( background && background.isColor ) {\n\t\n\t\t\t\t\tsetClear( background, 1 );\n\t\t\t\t\tforceClear = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderer.autoClear || forceClear ) {\n\t\n\t\t\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( background && background.isCubeTexture ) {\n\t\n\t\t\t\t\tif ( boxMesh === undefined ) {\n\t\n\t\t\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\t\t\tnew BoxBufferGeometry( 1, 1, 1 ),\n\t\t\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\t\t\tuniforms: ShaderLib.cube.uniforms,\n\t\t\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\t\t\tdepthTest: true,\n\t\t\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\t\t\tfog: false\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\tboxMesh.geometry.removeAttribute( 'normal' );\n\t\t\t\t\t\tboxMesh.geometry.removeAttribute( 'uv' );\n\t\n\t\t\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\t\n\t\t\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\t\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\tgeometries.update( boxMesh.geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tboxMesh.material.uniforms.tCube.value = background;\n\t\n\t\t\t\t\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\n\t\n\t\t\t\t} else if ( background && background.isTexture ) {\n\t\n\t\t\t\t\tif ( planeCamera === undefined ) {\n\t\n\t\t\t\t\t\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\n\t\t\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\t\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\tgeometries.update( planeMesh.geometry );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tplaneMesh.material.map = background;\n\t\n\t\t\t\t\t// TODO Push this to renderList\n\t\n\t\t\t\t\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setClear( color, alpha ) {\n\t\n\t\t\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetClearColor: function () {\n\t\n\t\t\t\t\treturn clearColor;\n\t\n\t\t\t\t},\n\t\t\t\tsetClearColor: function ( color, alpha ) {\n\t\n\t\t\t\t\tclearColor.set( color );\n\t\t\t\t\tclearAlpha = alpha !== undefined ? alpha : 1;\n\t\t\t\t\tsetClear( clearColor, clearAlpha );\n\t\n\t\t\t\t},\n\t\t\t\tgetClearAlpha: function () {\n\t\n\t\t\t\t\treturn clearAlpha;\n\t\n\t\t\t\t},\n\t\t\t\tsetClearAlpha: function ( alpha ) {\n\t\n\t\t\t\t\tclearAlpha = alpha;\n\t\t\t\t\tsetClear( clearColor, clearAlpha );\n\t\n\t\t\t\t},\n\t\t\t\trender: render\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction painterSortStable( a, b ) {\n\t\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t} else if ( a.program && b.program && a.program !== b.program ) {\n\t\n\t\t\t\treturn a.program.id - b.program.id;\n\t\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\t\n\t\t\t\treturn a.material.id - b.material.id;\n\t\n\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn a.z - b.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction reversePainterSortStable( a, b ) {\n\t\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t} if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction WebGLRenderList() {\n\t\n\t\t\tvar renderItems = [];\n\t\t\tvar renderItemsIndex = 0;\n\t\n\t\t\tvar opaque = [];\n\t\t\tvar transparent = [];\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\trenderItemsIndex = 0;\n\t\n\t\t\t\topaque.length = 0;\n\t\t\t\ttransparent.length = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction push( object, geometry, material, z, group ) {\n\t\n\t\t\t\tvar renderItem = renderItems[ renderItemsIndex ];\n\t\n\t\t\t\tif ( renderItem === undefined ) {\n\t\n\t\t\t\t\trenderItem = {\n\t\t\t\t\t\tid: object.id,\n\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tprogram: material.program,\n\t\t\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\t\t\tz: z,\n\t\t\t\t\t\tgroup: group\n\t\t\t\t\t};\n\t\n\t\t\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderItem.id = object.id;\n\t\t\t\t\trenderItem.object = object;\n\t\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\t\trenderItem.material = material;\n\t\t\t\t\trenderItem.program = material.program;\n\t\t\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\t\t\trenderItem.z = z;\n\t\t\t\t\trenderItem.group = group;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t( material.transparent === true ? transparent : opaque ).push( renderItem );\n\t\n\t\t\t\trenderItemsIndex ++;\n\t\n\t\t\t}\n\t\n\t\t\tfunction sort() {\n\t\n\t\t\t\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\n\t\t\t\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\topaque: opaque,\n\t\t\t\ttransparent: transparent,\n\t\n\t\t\t\tinit: init,\n\t\t\t\tpush: push,\n\t\n\t\t\t\tsort: sort\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tfunction WebGLRenderLists() {\n\t\n\t\t\tvar lists = {};\n\t\n\t\t\tfunction get( scene, camera ) {\n\t\n\t\t\t\tvar hash = scene.id + ',' + camera.id;\n\t\t\t\tvar list = lists[ hash ];\n\t\n\t\t\t\tif ( list === undefined ) {\n\t\n\t\t\t\t\t// console.log( 'THREE.WebGLRenderLists:', hash );\n\t\n\t\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\t\tlists[ hash ] = list;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn list;\n\t\n\t\t\t}\n\t\n\t\t\tfunction dispose() {\n\t\n\t\t\t\tlists = {};\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tget: get,\n\t\t\t\tdispose: dispose\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction absNumericalSort( a, b ) {\n\t\n\t\t\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\t\n\t\t}\n\t\n\t\tfunction WebGLMorphtargets( gl ) {\n\t\n\t\t\tvar influencesList = {};\n\t\t\tvar morphInfluences = new Float32Array( 8 );\n\t\n\t\t\tfunction update( object, geometry, material, program ) {\n\t\n\t\t\t\tvar objectInfluences = object.morphTargetInfluences;\n\t\n\t\t\t\tvar length = objectInfluences.length;\n\t\n\t\t\t\tvar influences = influencesList[ geometry.id ];\n\t\n\t\t\t\tif ( influences === undefined ) {\n\t\n\t\t\t\t\t// initialise list\n\t\n\t\t\t\t\tinfluences = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinfluencesList[ geometry.id ] = influences;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\t\t\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\t\n\t\t\t\t// Remove current morphAttributes\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tvar influence = influences[ i ];\n\t\n\t\t\t\t\tif ( influence[ 1 ] !== 0 ) {\n\t\n\t\t\t\t\t\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Collect influences\n\t\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tvar influence = influences[ i ];\n\t\n\t\t\t\t\tinfluence[ 0 ] = i;\n\t\t\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinfluences.sort( absNumericalSort );\n\t\n\t\t\t\t// Add morphAttributes\n\t\n\t\t\t\tfor ( var i = 0; i < 8; i ++ ) {\n\t\n\t\t\t\t\tvar influence = influences[ i ];\n\t\n\t\t\t\t\tif ( influence ) {\n\t\n\t\t\t\t\t\tvar index = influence[ 0 ];\n\t\t\t\t\t\tvar value = influence[ 1 ];\n\t\n\t\t\t\t\t\tif ( value ) {\n\t\n\t\t\t\t\t\t\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\t\t\t\t\t\t\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\t\n\t\t\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmorphInfluences[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tupdate: update\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tvar type, bytesPerElement;\n\t\n\t\t\tfunction setIndex( value ) {\n\t\n\t\t\t\ttype = value.type;\n\t\t\t\tbytesPerElement = value.bytesPerElement;\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\t\t\telse if ( mode === gl.POINTS ) infoRender.points += count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\t\t\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tthis.setMode = setMode;\n\t\t\tthis.setIndex = setIndex;\n\t\t\tthis.render = render;\n\t\t\tthis.renderInstances = renderInstances;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\t\n\t\t\tvar mode;\n\t\n\t\t\tfunction setMode( value ) {\n\t\n\t\t\t\tmode = value;\n\t\n\t\t\t}\n\t\n\t\t\tfunction render( start, count ) {\n\t\n\t\t\t\tgl.drawArrays( mode, start, count );\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\t\t\telse if ( mode === gl.POINTS ) infoRender.points += count;\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\t\tif ( position.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\tcount = position.data.count;\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\textension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinfoRender.calls ++;\n\t\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\t\n\t\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\t\t\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tthis.setMode = setMode;\n\t\t\tthis.render = render;\n\t\t\tthis.renderInstances = renderInstances;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLGeometries( gl, attributes, infoMemory ) {\n\t\n\t\t\tvar geometries = {};\n\t\t\tvar wireframeAttributes = {};\n\t\n\t\t\tfunction onGeometryDispose( event ) {\n\t\n\t\t\t\tvar geometry = event.target;\n\t\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\t\tif ( buffergeometry.index !== null ) {\n\t\n\t\t\t\t\tattributes.remove( buffergeometry.index );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var name in buffergeometry.attributes ) {\n\t\n\t\t\t\t\tattributes.remove( buffergeometry.attributes[ name ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\tdelete geometries[ geometry.id ];\n\t\n\t\t\t\t// TODO Remove duplicate code\n\t\n\t\t\t\tvar attribute = wireframeAttributes[ geometry.id ];\n\t\n\t\t\t\tif ( attribute ) {\n\t\n\t\t\t\t\tattributes.remove( attribute );\n\t\t\t\t\tdelete wireframeAttributes[ geometry.id ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tattribute = wireframeAttributes[ buffergeometry.id ];\n\t\n\t\t\t\tif ( attribute ) {\n\t\n\t\t\t\t\tattributes.remove( attribute );\n\t\t\t\t\tdelete wireframeAttributes[ buffergeometry.id ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinfoMemory.geometries --;\n\t\n\t\t\t}\n\t\n\t\t\tfunction get( object, geometry ) {\n\t\n\t\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\t\tif ( buffergeometry ) return buffergeometry;\n\t\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\tbuffergeometry = geometry;\n\t\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\t\n\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\t\n\t\t\t\tinfoMemory.geometries ++;\n\t\n\t\t\t\treturn buffergeometry;\n\t\n\t\t\t}\n\t\n\t\t\tfunction update( geometry ) {\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var name in geometryAttributes ) {\n\t\n\t\t\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morph targets\n\t\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\tfor ( var name in morphAttributes ) {\n\t\n\t\t\t\t\tvar array = morphAttributes[ name ];\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getWireframeAttribute( geometry ) {\n\t\n\t\t\t\tvar attribute = wireframeAttributes[ geometry.id ];\n\t\n\t\t\t\tif ( attribute ) return attribute;\n\t\n\t\t\t\tvar indices = [];\n\t\n\t\t\t\tvar geometryIndex = geometry.index;\n\t\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\t\t// console.time( 'wireframe' );\n\t\n\t\t\t\tif ( geometryIndex !== null ) {\n\t\n\t\t\t\t\tvar array = geometryIndex.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\t\tvar c = array[ i + 2 ];\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar array = geometryAttributes.position.array;\n\t\n\t\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\t\tvar c = i + 2;\n\t\n\t\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// console.timeEnd( 'wireframe' );\n\t\n\t\t\t\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\n\t\t\t\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t\twireframeAttributes[ geometry.id ] = attribute;\n\t\n\t\t\t\treturn attribute;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: get,\n\t\t\t\tupdate: update,\n\t\n\t\t\t\tgetWireframeAttribute: getWireframeAttribute\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLObjects( geometries, infoRender ) {\n\t\n\t\t\tvar updateList = {};\n\t\n\t\t\tfunction update( object ) {\n\t\n\t\t\t\tvar frame = infoRender.frame;\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\t\t\tvar buffergeometry = geometries.get( object, geometry );\n\t\n\t\t\t\t// Update once per frame\n\t\n\t\t\t\tif ( updateList[ buffergeometry.id ] !== frame ) {\n\t\n\t\t\t\t\tif ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tbuffergeometry.updateFromObject( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometries.update( buffergeometry );\n\t\n\t\t\t\t\tupdateList[ buffergeometry.id ] = frame;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn buffergeometry;\n\t\n\t\t\t}\n\t\n\t\t\tfunction dispose() {\n\t\n\t\t\t\tupdateList = {};\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tupdate: update,\n\t\t\t\tdispose: dispose\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction addLineNumbers( string ) {\n\t\n\t\t\tvar lines = string.split( '\\n' );\n\t\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\t\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn lines.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction WebGLShader( gl, type, string ) {\n\t\n\t\t\tvar shader = gl.createShader( type );\n\t\n\t\t\tgl.shaderSource( shader, string );\n\t\t\tgl.compileShader( shader );\n\t\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\t\n\t\t\t}\n\t\n\t\t\t// --enable-privileged-webgl-extension\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\t\n\t\t\treturn shader;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar programIdCount = 0;\n\t\n\t\tfunction getEncodingComponents( encoding ) {\n\t\n\t\t\tswitch ( encoding ) {\n\t\n\t\t\t\tcase LinearEncoding:\n\t\t\t\t\treturn [ 'Linear', '( value )' ];\n\t\t\t\tcase sRGBEncoding:\n\t\t\t\t\treturn [ 'sRGB', '( value )' ];\n\t\t\t\tcase RGBEEncoding:\n\t\t\t\t\treturn [ 'RGBE', '( value )' ];\n\t\t\t\tcase RGBM7Encoding:\n\t\t\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\n\t\t\t\tcase RGBM16Encoding:\n\t\t\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\n\t\t\t\tcase RGBDEncoding:\n\t\t\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\n\t\t\t\tcase GammaEncoding:\n\t\t\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\n\t\n\t\t}\n\t\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\t\n\t\t}\n\t\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\t\n\t\t\tvar toneMappingName;\n\t\n\t\t\tswitch ( toneMapping ) {\n\t\n\t\t\t\tcase LinearToneMapping:\n\t\t\t\t\ttoneMappingName = 'Linear';\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase ReinhardToneMapping:\n\t\t\t\t\ttoneMappingName = 'Reinhard';\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\t\ttoneMappingName = 'Uncharted2';\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase CineonToneMapping:\n\t\t\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\t\n\t\t\t}\n\t\n\t\t\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\t\n\t\t}\n\t\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\t\n\t\t\textensions = extensions || {};\n\t\n\t\t\tvar chunks = [\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t\t\t];\n\t\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction generateDefines( defines ) {\n\t\n\t\t\tvar chunks = [];\n\t\n\t\t\tfor ( var name in defines ) {\n\t\n\t\t\t\tvar value = defines[ name ];\n\t\n\t\t\t\tif ( value === false ) continue;\n\t\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\t\n\t\t\t}\n\t\n\t\t\treturn chunks.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction fetchAttributeLocations( gl, program ) {\n\t\n\t\t\tvar attributes = {};\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\t\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\n\t\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\t\tvar name = info.name;\n\t\n\t\t\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\t\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\t\n\t\t\t}\n\t\n\t\t\treturn attributes;\n\t\n\t\t}\n\t\n\t\tfunction filterEmptyLine( string ) {\n\t\n\t\t\treturn string !== '';\n\t\n\t\t}\n\t\n\t\tfunction replaceLightNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\t\n\t\t}\n\t\n\t\tfunction replaceClippingPlaneNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\t\n\t\t}\n\t\n\t\tfunction parseIncludes( string ) {\n\t\n\t\t\tvar pattern = /^[ \\t]*#include +<([\\w\\d.]+)>/gm;\n\t\n\t\t\tfunction replace( match, include ) {\n\t\n\t\t\t\tvar replace = ShaderChunk[ include ];\n\t\n\t\t\t\tif ( replace === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn parseIncludes( replace );\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction unrollLoops( string ) {\n\t\n\t\t\tvar pattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\t\n\t\t\tfunction replace( match, start, end, snippet ) {\n\t\n\t\t\t\tvar unroll = '';\n\t\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\t\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn unroll;\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction WebGLProgram( renderer, extensions, code, material, shader, parameters ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\n\t\t\tvar defines = material.defines;\n\t\n\t\t\tvar vertexShader = shader.vertexShader;\n\t\t\tvar fragmentShader = shader.fragmentShader;\n\t\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\t\n\t\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\n\t\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\n\t\t\t}\n\t\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\n\t\t\tif ( parameters.envMap ) {\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.combine ) {\n\t\n\t\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase MixOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase AddOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\t\n\t\t\t// console.log( 'building new program ' );\n\t\n\t\t\t//\n\t\n\t\t\tvar customExtensions = generateExtensions( material.extensions, parameters, extensions );\n\t\n\t\t\tvar customDefines = generateDefines( defines );\n\t\n\t\t\t//\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar prefixVertex, prefixFragment;\n\t\n\t\t\tif ( material.isRawShaderMaterial ) {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\tcustomDefines\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tif ( prefixVertex.length > 0 ) {\n\t\n\t\t\t\t\tprefixVertex += '\\n';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\t\t\t\tcustomDefines\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tif ( prefixFragment.length > 0 ) {\n\t\n\t\t\t\t\tprefixFragment += '\\n';\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + shader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\t\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t'attribute vec3 position;',\n\t\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'#ifdef USE_COLOR',\n\t\n\t\t\t\t\t'\tattribute vec3 color;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\t\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\n\t\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\t\n\t\t\t\t\t'\t#else',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\t\n\t\t\t\t\t'\t#endif',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_SKINNING',\n\t\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + shader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\t\n\t\t\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\tparameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\t\n\t\t\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\t\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\n\t\n\t\t\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t}\n\t\n\t\t\tvertexShader = parseIncludes( vertexShader );\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\t\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\t\n\t\t\tfragmentShader = parseIncludes( fragmentShader );\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\t\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\t\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\t\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\t\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\t\n\t\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\t\n\t\t\tgl.attachShader( program, glVertexShader );\n\t\t\tgl.attachShader( program, glFragmentShader );\n\t\n\t\t\t// Force a particular attribute to index 0.\n\t\n\t\t\tif ( material.index0AttributeName !== undefined ) {\n\t\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\t\n\t\t\t} else if ( parameters.morphTargets === true ) {\n\t\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\t\n\t\t\t}\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\tvar programLog = gl.getProgramInfoLog( program ).trim();\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\t\n\t\t\tvar runnable = true;\n\t\t\tvar haveDiagnostics = true;\n\t\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\t\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\t\n\t\t\t\trunnable = false;\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\t\n\t\t\t} else if ( programLog !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\t\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\t\n\t\t\t\thaveDiagnostics = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( haveDiagnostics ) {\n\t\n\t\t\t\tthis.diagnostics = {\n\t\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tmaterial: material,\n\t\n\t\t\t\t\tprogramLog: programLog,\n\t\n\t\t\t\t\tvertexShader: {\n\t\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfragmentShader: {\n\t\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// clean up\n\t\n\t\t\tgl.deleteShader( glVertexShader );\n\t\t\tgl.deleteShader( glFragmentShader );\n\t\n\t\t\t// set up caching for uniform locations\n\t\n\t\t\tvar cachedUniforms;\n\t\n\t\t\tthis.getUniforms = function () {\n\t\n\t\t\t\tif ( cachedUniforms === undefined ) {\n\t\n\t\t\t\t\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedUniforms;\n\t\n\t\t\t};\n\t\n\t\t\t// set up caching for attribute locations\n\t\n\t\t\tvar cachedAttributes;\n\t\n\t\t\tthis.getAttributes = function () {\n\t\n\t\t\t\tif ( cachedAttributes === undefined ) {\n\t\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedAttributes;\n\t\n\t\t\t};\n\t\n\t\t\t// free resource\n\t\n\t\t\tthis.destroy = function () {\n\t\n\t\t\t\tgl.deleteProgram( program );\n\t\t\t\tthis.program = undefined;\n\t\n\t\t\t};\n\t\n\t\t\t// DEPRECATED\n\t\n\t\t\tObject.defineProperties( this, {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\tget: function () {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\t\treturn this.getUniforms();\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tattributes: {\n\t\t\t\t\tget: function () {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\t\treturn this.getAttributes();\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\n\t\t\t//\n\t\n\t\t\tthis.id = programIdCount ++;\n\t\t\tthis.code = code;\n\t\t\tthis.usedTimes = 1;\n\t\t\tthis.program = program;\n\t\t\tthis.vertexShader = glVertexShader;\n\t\t\tthis.fragmentShader = glFragmentShader;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLPrograms( renderer, extensions, capabilities ) {\n\t\n\t\t\tvar programs = [];\n\t\n\t\t\tvar shaderIDs = {\n\t\t\t\tMeshDepthMaterial: 'depth',\n\t\t\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\t\t\tMeshNormalMaterial: 'normal',\n\t\t\t\tMeshBasicMaterial: 'basic',\n\t\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\t\tMeshPhongMaterial: 'phong',\n\t\t\t\tMeshToonMaterial: 'phong',\n\t\t\t\tMeshStandardMaterial: 'physical',\n\t\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\t\tLineBasicMaterial: 'basic',\n\t\t\t\tLineDashedMaterial: 'dashed',\n\t\t\t\tPointsMaterial: 'points',\n\t\t\t\tShadowMaterial: 'shadow'\n\t\t\t};\n\t\n\t\t\tvar parameterNames = [\n\t\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\t\"roughnessMap\", \"metalnessMap\", \"gradientMap\",\n\t\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\n\t\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"\n\t\t\t];\n\t\n\t\n\t\t\tfunction allocateBones( object ) {\n\t\n\t\t\t\tvar skeleton = object.skeleton;\n\t\t\t\tvar bones = skeleton.bones;\n\t\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\t\n\t\t\t\t\treturn 1024;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// default for when object is not specified\n\t\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t\t//\n\t\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t\t//    (up to 54 should be safe)\n\t\n\t\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\t\n\t\t\t\t\tvar maxBones = Math.min( nVertexMatrices, bones.length );\n\t\n\t\t\t\t\tif ( maxBones < bones.length ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\n\t\t\t\t\t\treturn 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn maxBones;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\t\n\t\t\t\tvar encoding;\n\t\n\t\t\t\tif ( ! map ) {\n\t\n\t\t\t\t\tencoding = LinearEncoding;\n\t\n\t\t\t\t} else if ( map.isTexture ) {\n\t\n\t\t\t\t\tencoding = map.encoding;\n\t\n\t\t\t\t} else if ( map.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\tencoding = map.texture.encoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\t\n\t\t\t\t\tencoding = GammaEncoding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn encoding;\n\t\n\t\t\t}\n\t\n\t\t\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\n\t\n\t\t\t\tvar shaderID = shaderIDs[ material.type ];\n\t\n\t\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t\t// (not to blow over maxLights budget)\n\t\n\t\t\t\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\n\t\t\t\tvar precision = capabilities.precision;\n\t\n\t\t\t\tif ( material.precision !== null ) {\n\t\n\t\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\t\n\t\t\t\t\tif ( precision !== material.precision ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\t\n\t\t\t\tvar parameters = {\n\t\n\t\t\t\t\tshaderID: shaderID,\n\t\n\t\t\t\t\tprecision: precision,\n\t\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\t\tmap: !! material.map,\n\t\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\t\talphaMap: !! material.alphaMap,\n\t\n\t\t\t\t\tgradientMap: !! material.gradientMap,\n\t\n\t\t\t\t\tcombine: material.combine,\n\t\n\t\t\t\t\tvertexColors: material.vertexColors,\n\t\n\t\t\t\t\tfog: !! fog,\n\t\t\t\t\tuseFog: material.fog,\n\t\t\t\t\tfogExp: ( fog && fog.isFogExp2 ),\n\t\n\t\t\t\t\tflatShading: material.flatShading,\n\t\n\t\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\t\n\t\t\t\t\tskinning: material.skinning && maxBones > 0,\n\t\t\t\t\tmaxBones: maxBones,\n\t\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures,\n\t\n\t\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\t\n\t\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\n\t\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\t\tnumClipIntersection: nClipIntersection,\n\t\n\t\t\t\t\tdithering: material.dithering,\n\t\n\t\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\n\t\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\n\t\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\n\t\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\n\t\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\t\tflipSided: material.side === BackSide,\n\t\n\t\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\t\n\t\t\t\t};\n\t\n\t\t\t\treturn parameters;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getProgramCode = function ( material, parameters ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\tarray.push( parameters.shaderID );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\t\tarray.push( material.vertexShader );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.defines !== undefined ) {\n\t\n\t\t\t\t\tfor ( var name in material.defines ) {\n\t\n\t\t\t\t\t\tarray.push( name );\n\t\t\t\t\t\tarray.push( material.defines[ name ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\t\n\t\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray.push( material.onBeforeCompile.toString() );\n\t\n\t\t\t\tarray.push( renderer.gammaOutput );\n\t\n\t\t\t\treturn array.join();\n\t\n\t\t\t};\n\t\n\t\t\tthis.acquireProgram = function ( material, shader, parameters, code ) {\n\t\n\t\t\t\tvar program;\n\t\n\t\t\t\t// Check if code has been already compiled\n\t\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tvar programInfo = programs[ p ];\n\t\n\t\t\t\t\tif ( programInfo.code === code ) {\n\t\n\t\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t\t++ program.usedTimes;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters );\n\t\t\t\t\tprograms.push( program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t};\n\t\n\t\t\tthis.releaseProgram = function ( program ) {\n\t\n\t\t\t\tif ( -- program.usedTimes === 0 ) {\n\t\n\t\t\t\t\t// Remove from unordered set\n\t\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\t\tprograms.pop();\n\t\n\t\t\t\t\t// Free WebGL resources\n\t\t\t\t\tprogram.destroy();\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tthis.programs = programs;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory, infoRender ) {\n\t\n\t\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\t\tvar _videoTextures = {};\n\t\t\tvar _canvas;\n\t\n\t\t\t//\n\t\n\t\t\tfunction clampToMaxSize( image, maxSize ) {\n\t\n\t\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\t\n\t\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t\t// premultiplied alpha.\n\t\n\t\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\t\n\t\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\t\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\t\treturn canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPowerOfTwo( image ) {\n\t\n\t\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\t\n\t\t\t}\n\t\n\t\t\tfunction makePowerOfTwo( image ) {\n\t\n\t\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\n\t\n\t\t\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\n\t\t\t\t\t_canvas.width = _Math.floorPowerOfTwo( image.width );\n\t\t\t\t\t_canvas.height = _Math.floorPowerOfTwo( image.height );\n\t\n\t\t\t\t\tvar context = _canvas.getContext( '2d' );\n\t\t\t\t\tcontext.drawImage( image, 0, 0, _canvas.width, _canvas.height );\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height, image );\n\t\n\t\t\t\t\treturn _canvas;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t}\n\t\n\t\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\t\n\t\t\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\t\n\t\t\t}\n\t\n\t\t\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\n\t\n\t\t\t\treturn texture.generateMipmaps && isPowerOfTwo &&\n\t\t\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\n\t\t\t}\n\t\n\t\t\t// Fallback filters for non-power-of-2 textures\n\t\n\t\t\tfunction filterFallback( f ) {\n\t\n\t\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\t\n\t\t\t\t\treturn _gl.NEAREST;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn _gl.LINEAR;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction onTextureDispose( event ) {\n\t\n\t\t\t\tvar texture = event.target;\n\t\n\t\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\tdeallocateTexture( texture );\n\t\n\t\t\t\tif ( texture.isVideoTexture ) {\n\t\n\t\t\t\t\tdelete _videoTextures[ texture.id ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinfoMemory.textures --;\n\t\n\t\t\t}\n\t\n\t\t\tfunction onRenderTargetDispose( event ) {\n\t\n\t\t\t\tvar renderTarget = event.target;\n\t\n\t\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\tdeallocateRenderTarget( renderTarget );\n\t\n\t\t\t\tinfoMemory.textures --;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction deallocateTexture( texture ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t// cube texture\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// 2D texture\n\t\n\t\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// remove all webgl properties\n\t\t\t\tproperties.remove( texture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction deallocateRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\tif ( ! renderTarget ) return;\n\t\n\t\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\t\n\t\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\trenderTarget.depthTexture.dispose();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tproperties.remove( renderTarget.texture );\n\t\t\t\tproperties.remove( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\n\t\n\t\t\tfunction setTexture2D( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\t\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\tvar image = texture.image;\n\t\n\t\t\t\t\tif ( image === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\t\n\t\t\t\t\t} else if ( image.complete === false ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCube( texture, slot ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\t\tif ( texture.image.length === 6 ) {\n\t\n\t\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\t\n\t\t\t\t\t\t\tinfoMemory.textures ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\n\t\t\t\t\t\tvar isCompressed = ( texture && texture.isCompressedTexture );\n\t\t\t\t\t\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\t\n\t\t\t\t\t\tvar cubeImage = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\t\t\t\t\tglType = utils.convert( texture.type );\n\t\n\t\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( ! isCompressed ) {\n\t\n\t\t\t\t\t\t\t\tif ( isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\t\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\n\t\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\n\t\n\t\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\n\t\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\t\n\t\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension ) {\n\t\n\t\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\t\n\t\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\t\n\t\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\t\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\t\n\t\t\t\t\ttextureProperties.__webglInit = true;\n\t\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t\tinfoMemory.textures ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\n\t\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\t\n\t\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\t\n\t\t\t\t\timage = makePowerOfTwo( image );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\t\t\tglType = utils.convert( texture.type );\n\t\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\t\n\t\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\t\n\t\t\t\tif ( texture.isDepthTexture ) {\n\t\n\t\t\t\t\t// populate depth texture with dummy data\n\t\n\t\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\t\n\t\t\t\t\tif ( texture.type === FloatType ) {\n\t\n\t\t\t\t\t\tif ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\n\t\t\t\t\t} else if ( _isWebGL2 ) {\n\t\n\t\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\n\t\n\t\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\t\n\t\t\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\t\t\tglType = utils.convert( texture.type );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\t\n\t\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\t\n\t\t\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\t\t\tglType = utils.convert( texture.type );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\t\n\t\t\t\t} else if ( texture.isDataTexture ) {\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( texture.isCompressedTexture ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\t\n\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// regular Texture (image, video, canvas)\n\t\n\t\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t}\n\t\n\t\t\t// Render targets\n\t\n\t\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\t\n\t\t\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\t\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\t\n\t\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\t\n\t\t\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\n\t\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\t\n\t\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\n\t\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\t\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Setup GL resources for a non-texture depth buffer\n\t\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\t\n\t\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\t\n\t\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Set up GL resources for the render target\n\t\t\tfunction setupRenderTarget( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\tinfoMemory.textures ++;\n\t\n\t\t\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\t\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t\t// Setup framebuffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup color buffer\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\t\n\t\t\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Setup depth and stencil buffers\n\t\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\t\n\t\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\t\n\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\n\t\n\t\t\t\t\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\t\n\t\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\t\tstate.bindTexture( target, null );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction updateVideoTexture( texture ) {\n\t\n\t\t\t\tvar id = texture.id;\n\t\t\t\tvar frame = infoRender.frame;\n\t\n\t\t\t\t// Check the last frame we updated the VideoTexture\n\t\n\t\t\t\tif ( _videoTextures[ id ] !== frame ) {\n\t\n\t\t\t\t\t_videoTextures[ id ] = frame;\n\t\t\t\t\ttexture.update();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.setTexture2D = setTexture2D;\n\t\t\tthis.setTextureCube = setTextureCube;\n\t\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author fordacious / fordacious.github.io\n\t\t */\n\t\n\t\tfunction WebGLProperties() {\n\t\n\t\t\tvar properties = {};\n\t\n\t\t\tfunction get( object ) {\n\t\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\t\tif ( map === undefined ) {\n\t\n\t\t\t\t\tmap = {};\n\t\t\t\t\tproperties[ uuid ] = map;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn map;\n\t\n\t\t\t}\n\t\n\t\t\tfunction remove( object ) {\n\t\n\t\t\t\tdelete properties[ object.uuid ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction update( object, key, value ) {\n\t\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\t\tmap[ key ] = value;\n\t\n\t\t\t}\n\t\n\t\t\tfunction dispose() {\n\t\n\t\t\t\tproperties = {};\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tget: get,\n\t\t\t\tremove: remove,\n\t\t\t\tupdate: update,\n\t\t\t\tdispose: dispose\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLState( gl, extensions, utils ) {\n\t\n\t\t\tfunction ColorBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar color = new Vector4();\n\t\t\t\tvar currentColorMask = null;\n\t\t\t\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetMask: function ( colorMask ) {\n\t\n\t\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tif ( premultipliedAlpha === true ) {\n\t\n\t\t\t\t\t\t\tr *= a; g *= a; b *= a;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcolor.set( r, g, b, a );\n\t\n\t\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\t\n\t\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\t\tcurrentColorClear.copy( color );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction DepthBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentDepthMask = null;\n\t\t\t\tvar currentDepthFunc = null;\n\t\t\t\tvar currentDepthClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( depthTest ) {\n\t\n\t\t\t\t\t\tif ( depthTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( depthMask ) {\n\t\n\t\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( depthFunc ) {\n\t\n\t\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\t\n\t\t\t\t\t\t\tif ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\t\n\t\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( depth ) {\n\t\n\t\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\t\n\t\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\t\tcurrentDepthClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction StencilBuffer() {\n\t\n\t\t\t\tvar locked = false;\n\t\n\t\t\t\tvar currentStencilMask = null;\n\t\t\t\tvar currentStencilFunc = null;\n\t\t\t\tvar currentStencilRef = null;\n\t\t\t\tvar currentStencilFuncMask = null;\n\t\t\t\tvar currentStencilFail = null;\n\t\t\t\tvar currentStencilZFail = null;\n\t\t\t\tvar currentStencilZPass = null;\n\t\t\t\tvar currentStencilClear = null;\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tsetTest: function ( stencilTest ) {\n\t\n\t\t\t\t\t\tif ( stencilTest ) {\n\t\n\t\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetMask: function ( stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\t\n\t\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\t\n\t\t\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\t\n\t\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\t\n\t\t\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\t\n\t\t\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetLocked: function ( lock ) {\n\t\n\t\t\t\t\t\tlocked = lock;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tsetClear: function ( stencil ) {\n\t\n\t\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\t\n\t\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\treset: function () {\n\t\n\t\t\t\t\t\tlocked = false;\n\t\n\t\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\t\tcurrentStencilClear = null;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar colorBuffer = new ColorBuffer();\n\t\t\tvar depthBuffer = new DepthBuffer();\n\t\t\tvar stencilBuffer = new StencilBuffer();\n\t\n\t\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\t\n\t\t\tvar capabilities = {};\n\t\n\t\t\tvar compressedTextureFormats = null;\n\t\n\t\t\tvar currentProgram = null;\n\t\n\t\t\tvar currentBlending = null;\n\t\t\tvar currentBlendEquation = null;\n\t\t\tvar currentBlendSrc = null;\n\t\t\tvar currentBlendDst = null;\n\t\t\tvar currentBlendEquationAlpha = null;\n\t\t\tvar currentBlendSrcAlpha = null;\n\t\t\tvar currentBlendDstAlpha = null;\n\t\t\tvar currentPremultipledAlpha = false;\n\t\n\t\t\tvar currentFlipSided = null;\n\t\t\tvar currentCullFace = null;\n\t\n\t\t\tvar currentLineWidth = null;\n\t\n\t\t\tvar currentPolygonOffsetFactor = null;\n\t\t\tvar currentPolygonOffsetUnits = null;\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\n\t\n\t\t\tvar lineWidthAvailable = false;\n\t\t\tvar version = 0;\n\t\t\tvar glVersion = gl.getParameter( gl.VERSION );\n\t\n\t\t\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\t\n\t\t\t   version = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\t\t   lineWidthAvailable = ( version >= 1.0 );\n\t\n\t\t\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\t\n\t\t\t   version = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\t\t   lineWidthAvailable = ( version >= 2.0 );\n\t\n\t\t\t}\n\t\n\t\t\tvar currentTextureSlot = null;\n\t\t\tvar currentBoundTextures = {};\n\t\n\t\t\tvar currentScissor = new Vector4();\n\t\t\tvar currentViewport = new Vector4();\n\t\n\t\t\tfunction createTexture( type, target, count ) {\n\t\n\t\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\t\tvar texture = gl.createTexture();\n\t\n\t\t\t\tgl.bindTexture( type, texture );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\n\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\t\n\t\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t\tvar emptyTextures = {};\n\t\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\t\n\t\t\t// init\n\t\n\t\t\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\t\t\tdepthBuffer.setClear( 1 );\n\t\t\tstencilBuffer.setClear( 0 );\n\t\n\t\t\tenable( gl.DEPTH_TEST );\n\t\t\tdepthBuffer.setFunc( LessEqualDepth );\n\t\n\t\t\tsetFlipSided( false );\n\t\t\tsetCullFace( CullFaceBack );\n\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\tenable( gl.BLEND );\n\t\t\tsetBlending( NormalBlending );\n\t\n\t\t\t//\n\t\n\t\t\tfunction initAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tnewAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttribute( attribute ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\t\n\t\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\t\tattributeDivisors[ attribute ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\t\n\t\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\t\n\t\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disableUnusedAttributes() {\n\t\n\t\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction enable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== true ) {\n\t\n\t\t\t\t\tgl.enable( id );\n\t\t\t\t\tcapabilities[ id ] = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction disable( id ) {\n\t\n\t\t\t\tif ( capabilities[ id ] !== false ) {\n\t\n\t\t\t\t\tgl.disable( id );\n\t\t\t\t\tcapabilities[ id ] = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction getCompressedTextureFormats() {\n\t\n\t\t\t\tif ( compressedTextureFormats === null ) {\n\t\n\t\t\t\t\tcompressedTextureFormats = [];\n\t\n\t\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||\n\t\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {\n\t\n\t\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn compressedTextureFormats;\n\t\n\t\t\t}\n\t\n\t\t\tfunction useProgram( program ) {\n\t\n\t\t\t\tif ( currentProgram !== program ) {\n\t\n\t\t\t\t\tgl.useProgram( program );\n\t\n\t\t\t\t\tcurrentProgram = program;\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\t\n\t\t\t\tif ( blending !== NoBlending ) {\n\t\n\t\t\t\t\tenable( gl.BLEND );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.BLEND );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blending !== CustomBlending ) {\n\t\n\t\t\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\t\n\t\t\t\t\t\tswitch ( blending ) {\n\t\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\n\t\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\n\t\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\n\t\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\t\n\t\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\n\t\n\t\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setMaterial( material, frontFaceCW ) {\n\t\n\t\t\t\tmaterial.side === DoubleSide\n\t\t\t\t\t? disable( gl.CULL_FACE )\n\t\t\t\t\t: enable( gl.CULL_FACE );\n\t\n\t\t\t\tvar flipSided = ( material.side === BackSide );\n\t\t\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\t\n\t\t\t\tsetFlipSided( flipSided );\n\t\n\t\t\t\tmaterial.transparent === true\n\t\t\t\t\t? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t\t: setBlending( NoBlending );\n\t\n\t\t\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\t\t\tdepthBuffer.setTest( material.depthTest );\n\t\t\t\tdepthBuffer.setMask( material.depthWrite );\n\t\t\t\tcolorBuffer.setMask( material.colorWrite );\n\t\n\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction setFlipSided( flipSided ) {\n\t\n\t\t\t\tif ( currentFlipSided !== flipSided ) {\n\t\n\t\t\t\t\tif ( flipSided ) {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CW );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.frontFace( gl.CCW );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentFlipSided = flipSided;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setCullFace( cullFace ) {\n\t\n\t\t\t\tif ( cullFace !== CullFaceNone ) {\n\t\n\t\t\t\t\tenable( gl.CULL_FACE );\n\t\n\t\t\t\t\tif ( cullFace !== currentCullFace ) {\n\t\n\t\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\t\n\t\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.CULL_FACE );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentCullFace = cullFace;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setLineWidth( width ) {\n\t\n\t\t\t\tif ( width !== currentLineWidth ) {\n\t\n\t\t\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\t\n\t\t\t\t\tcurrentLineWidth = width;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\t\n\t\t\t\tif ( polygonOffset ) {\n\t\n\t\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\t\n\t\t\t\t\t\tgl.polygonOffset( factor, units );\n\t\n\t\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setScissorTest( scissorTest ) {\n\t\n\t\t\t\tif ( scissorTest ) {\n\t\n\t\t\t\t\tenable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdisable( gl.SCISSOR_TEST );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// texture\n\t\n\t\t\tfunction activeTexture( webglSlot ) {\n\t\n\t\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\t\n\t\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\t\n\t\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction bindTexture( webglType, webglTexture ) {\n\t\n\t\t\t\tif ( currentTextureSlot === null ) {\n\t\n\t\t\t\t\tactiveTexture();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\t\n\t\t\t\tif ( boundTexture === undefined ) {\n\t\n\t\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\t\n\t\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\t\n\t\t\t\t\tboundTexture.type = webglType;\n\t\t\t\t\tboundTexture.texture = webglTexture;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction compressedTexImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction texImage2D() {\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\t\n\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction scissor( scissor ) {\n\t\n\t\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\t\n\t\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\t\tcurrentScissor.copy( scissor );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction viewport( viewport ) {\n\t\n\t\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\t\n\t\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\t\tcurrentViewport.copy( viewport );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tfunction reset() {\n\t\n\t\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\t\n\t\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\t\n\t\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcapabilities = {};\n\t\n\t\t\t\tcompressedTextureFormats = null;\n\t\n\t\t\t\tcurrentTextureSlot = null;\n\t\t\t\tcurrentBoundTextures = {};\n\t\n\t\t\t\tcurrentProgram = null;\n\t\n\t\t\t\tcurrentBlending = null;\n\t\n\t\t\t\tcurrentFlipSided = null;\n\t\t\t\tcurrentCullFace = null;\n\t\n\t\t\t\tcolorBuffer.reset();\n\t\t\t\tdepthBuffer.reset();\n\t\t\t\tstencilBuffer.reset();\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tbuffers: {\n\t\t\t\t\tcolor: colorBuffer,\n\t\t\t\t\tdepth: depthBuffer,\n\t\t\t\t\tstencil: stencilBuffer\n\t\t\t\t},\n\t\n\t\t\t\tinitAttributes: initAttributes,\n\t\t\t\tenableAttribute: enableAttribute,\n\t\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\t\tenable: enable,\n\t\t\t\tdisable: disable,\n\t\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\t\n\t\t\t\tuseProgram: useProgram,\n\t\n\t\t\t\tsetBlending: setBlending,\n\t\t\t\tsetMaterial: setMaterial,\n\t\n\t\t\t\tsetFlipSided: setFlipSided,\n\t\t\t\tsetCullFace: setCullFace,\n\t\n\t\t\t\tsetLineWidth: setLineWidth,\n\t\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\n\t\t\t\tsetScissorTest: setScissorTest,\n\t\n\t\t\t\tactiveTexture: activeTexture,\n\t\t\t\tbindTexture: bindTexture,\n\t\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\t\ttexImage2D: texImage2D,\n\t\n\t\t\t\tscissor: scissor,\n\t\t\t\tviewport: viewport,\n\t\n\t\t\t\treset: reset\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\t\n\t\t\tvar maxAnisotropy;\n\t\n\t\t\tfunction getMaxAnisotropy() {\n\t\n\t\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\t\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmaxAnisotropy = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn maxAnisotropy;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getMaxPrecision( precision ) {\n\t\n\t\t\t\tif ( precision === 'highp' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'highp';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprecision = 'mediump';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( precision === 'mediump' ) {\n\t\n\t\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\t\treturn 'mediump';\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 'lowp';\n\t\n\t\t\t}\n\t\n\t\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\t\tvar maxPrecision = getMaxPrecision( precision );\n\t\n\t\t\tif ( maxPrecision !== precision ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\t\tprecision = maxPrecision;\n\t\n\t\t\t}\n\t\n\t\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\t\n\t\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\t\n\t\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\t\n\t\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\n\t\t\treturn {\n\t\n\t\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\n\t\t\t\tprecision: precision,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\n\t\t\t\tmaxTextures: maxTextures,\n\t\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\n\t\t\t\tmaxAttributes: maxAttributes,\n\t\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\t\tmaxVaryings: maxVaryings,\n\t\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\n\t\t\t\tvertexTextures: vertexTextures,\n\t\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\t\tfloatVertexTextures: floatVertexTextures\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author greggman / http://games.greggman.com/\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\t\n\t\t\tCamera.call( this );\n\t\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\n\t\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\t\tthis.zoom = 1;\n\t\n\t\t\tthis.near = near !== undefined ? near : 0.1;\n\t\t\tthis.far = far !== undefined ? far : 2000;\n\t\t\tthis.focus = 10;\n\t\n\t\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\t\tthis.view = null;\n\t\n\t\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t}\n\t\n\t\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\t\n\t\t\tconstructor: PerspectiveCamera,\n\t\n\t\t\tisPerspectiveCamera: true,\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tCamera.prototype.copy.call( this, source, recursive );\n\t\n\t\t\t\tthis.fov = source.fov;\n\t\t\t\tthis.zoom = source.zoom;\n\t\n\t\t\t\tthis.near = source.near;\n\t\t\t\tthis.far = source.far;\n\t\t\t\tthis.focus = source.focus;\n\t\n\t\t\t\tthis.aspect = source.aspect;\n\t\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\t\tthis.filmOffset = source.filmOffset;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t\t *\n\t\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t\t * a 35mm (full frame) camera.\n\t\t\t *\n\t\t\t * Values for focal length and film gauge must have the same unit.\n\t\t\t */\n\t\t\tsetFocalLength: function ( focalLength ) {\n\t\n\t\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\n\t\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t\t */\n\t\t\tgetFocalLength: function () {\n\t\n\t\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\t\n\t\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\n\t\t\t},\n\t\n\t\t\tgetEffectiveFOV: function () {\n\t\n\t\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmWidth: function () {\n\t\n\t\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tgetFilmHeight: function () {\n\t\n\t\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t\t * multi-monitor/multi-machine setups.\n\t\t\t *\n\t\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t\t * the monitors are in grid like this\n\t\t\t *\n\t\t\t *   +---+---+---+\n\t\t\t *   | A | B | C |\n\t\t\t *   +---+---+---+\n\t\t\t *   | D | E | F |\n\t\t\t *   +---+---+---+\n\t\t\t *\n\t\t\t * then for each monitor you would call it like this\n\t\t\t *\n\t\t\t *   var w = 1920;\n\t\t\t *   var h = 1080;\n\t\t\t *   var fullWidth = w * 3;\n\t\t\t *   var fullHeight = h * 2;\n\t\t\t *\n\t\t\t *   --A--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t\t *   --B--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t\t *   --C--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t\t *   --D--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t\t *   --E--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t\t *   --F--\n\t\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t\t *\n\t\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t\t */\n\t\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\t\tthis.aspect = fullWidth / fullHeight;\n\t\n\t\t\t\tif ( this.view === null ) {\n\t\n\t\t\t\t\tthis.view = {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\t\toffsetX: 0,\n\t\t\t\t\t\toffsetY: 0,\n\t\t\t\t\t\twidth: 1,\n\t\t\t\t\t\theight: 1\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.view.enabled = true;\n\t\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\t\tthis.view.offsetX = x;\n\t\t\t\tthis.view.offsetY = y;\n\t\t\t\tthis.view.width = width;\n\t\t\t\tthis.view.height = height;\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tclearViewOffset: function () {\n\t\n\t\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\t\tthis.view.enabled = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t\t},\n\t\n\t\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\t\tvar near = this.near,\n\t\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\t\theight = 2 * top,\n\t\t\t\t\twidth = this.aspect * height,\n\t\t\t\t\tleft = - 0.5 * width,\n\t\t\t\t\tview = this.view;\n\t\n\t\t\t\tif ( this.view !== null && this.view.enabled ) {\n\t\n\t\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\n\t\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\t\theight *= view.height / fullHeight;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar skew = this.filmOffset;\n\t\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\t\n\t\t\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.fov = this.fov;\n\t\t\t\tdata.object.zoom = this.zoom;\n\t\n\t\t\t\tdata.object.near = this.near;\n\t\t\t\tdata.object.far = this.far;\n\t\t\t\tdata.object.focus = this.focus;\n\t\n\t\t\t\tdata.object.aspect = this.aspect;\n\t\n\t\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ArrayCamera( array ) {\n\t\n\t\t\tPerspectiveCamera.call( this );\n\t\n\t\t\tthis.cameras = array || [];\n\t\n\t\t}\n\t\n\t\tArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\n\t\n\t\t\tconstructor: ArrayCamera,\n\t\n\t\t\tisArrayCamera: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebVRManager( renderer ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar device = null;\n\t\t\tvar frameData = null;\n\t\n\t\t\tvar poseTarget = null;\n\t\n\t\t\tvar standingMatrix = new Matrix4();\n\t\t\tvar standingMatrixInverse = new Matrix4();\n\t\n\t\t\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\n\t\n\t\t\t\tframeData = new window.VRFrameData();\n\t\n\t\t\t}\n\t\n\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\n\t\t\tvar cameraL = new PerspectiveCamera();\n\t\t\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\n\t\t\tcameraL.layers.enable( 1 );\n\t\n\t\t\tvar cameraR = new PerspectiveCamera();\n\t\t\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\n\t\t\tcameraR.layers.enable( 2 );\n\t\n\t\t\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\n\t\t\tcameraVR.layers.enable( 1 );\n\t\t\tcameraVR.layers.enable( 2 );\n\t\n\t\t\t//\n\t\n\t\t\tvar currentSize, currentPixelRatio;\n\t\n\t\t\tfunction onVRDisplayPresentChange() {\n\t\n\t\t\t\tif ( device !== null && device.isPresenting ) {\n\t\n\t\t\t\t\tvar eyeParameters = device.getEyeParameters( 'left' );\n\t\t\t\t\tvar renderWidth = eyeParameters.renderWidth;\n\t\t\t\t\tvar renderHeight = eyeParameters.renderHeight;\n\t\n\t\t\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\t\t\tcurrentSize = renderer.getSize();\n\t\n\t\t\t\t\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\n\t\n\t\t\t\t} else if ( scope.enabled ) {\n\t\n\t\t\t\t\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( typeof window !== 'undefined' ) {\n\t\n\t\t\t\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tthis.enabled = false;\n\t\t\tthis.userHeight = 1.6;\n\t\n\t\t\tthis.getDevice = function () {\n\t\n\t\t\t\treturn device;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setDevice = function ( value ) {\n\t\n\t\t\t\tif ( value !== undefined ) device = value;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setPoseTarget = function ( object ) {\n\t\n\t\t\t\tif ( object !== undefined ) poseTarget = object;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getCamera = function ( camera ) {\n\t\n\t\t\t\tif ( device === null ) return camera;\n\t\n\t\t\t\tdevice.depthNear = camera.near;\n\t\t\t\tdevice.depthFar = camera.far;\n\t\n\t\t\t\tdevice.getFrameData( frameData );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar pose = frameData.pose;\n\t\t\t\tvar poseObject = poseTarget !== null ? poseTarget : camera;\n\t\n\t\t\t\tif ( pose.position !== null ) {\n\t\n\t\t\t\t\tposeObject.position.fromArray( pose.position );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tposeObject.position.set( 0, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( pose.orientation !== null ) {\n\t\n\t\t\t\t\tposeObject.quaternion.fromArray( pose.orientation );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar stageParameters = device.stageParameters;\n\t\n\t\t\t\tif ( stageParameters ) {\n\t\n\t\t\t\t\tstandingMatrix.fromArray( stageParameters.sittingToStandingTransform );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstandingMatrix.makeTranslation( 0, scope.userHeight, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposeObject.position.applyMatrix4( standingMatrix );\n\t\t\t\tposeObject.updateMatrixWorld();\n\t\n\t\t\t\tif ( device.isPresenting === false ) return camera;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tcameraL.near = camera.near;\n\t\t\t\tcameraR.near = camera.near;\n\t\n\t\t\t\tcameraL.far = camera.far;\n\t\t\t\tcameraR.far = camera.far;\n\t\n\t\t\t\tcameraVR.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\n\t\n\t\t\t\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\n\t\t\t\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\n\t\n\t\t\t\t// TODO (mrdoob) Double check this code\n\t\n\t\t\t\tstandingMatrixInverse.getInverse( standingMatrix );\n\t\n\t\t\t\tcameraL.matrixWorldInverse.multiply( standingMatrixInverse );\n\t\t\t\tcameraR.matrixWorldInverse.multiply( standingMatrixInverse );\n\t\n\t\t\t\tvar parent = poseObject.parent;\n\t\n\t\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\n\t\t\t\t\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\n\t\t\t\t\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// envMap and Mirror needs camera.matrixWorld\n\t\n\t\t\t\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\n\t\t\t\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\n\t\n\t\t\t\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\n\t\t\t\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\n\t\n\t\t\t\t// HACK (mrdoob)\n\t\t\t\t// https://github.com/w3c/webvr/issues/203\n\t\n\t\t\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar layers = device.getLayers();\n\t\n\t\t\t\tif ( layers.length ) {\n\t\n\t\t\t\t\tvar layer = layers[ 0 ];\n\t\n\t\t\t\t\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\n\t\n\t\t\t\t\t\tcameraL.bounds.fromArray( layer.leftBounds );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\n\t\n\t\t\t\t\t\tcameraR.bounds.fromArray( layer.rightBounds );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cameraVR;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getStandingMatrix = function () {\n\t\n\t\t\t\treturn standingMatrix;\n\t\n\t\t\t};\n\t\n\t\t\tthis.submitFrame = function () {\n\t\n\t\t\t\tif ( device && device.isPresenting ) device.submitFrame();\n\t\n\t\t\t};\n\t\n\t\t\tthis.dispose = function () {\n\t\n\t\t\t\tif ( typeof window !== 'undefined' ) {\n\t\n\t\t\t\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction WebGLExtensions( gl ) {\n\t\n\t\t\tvar extensions = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( name ) {\n\t\n\t\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn extensions[ name ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar extension;\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\textension = gl.getExtension( name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\textensions[ name ] = extension;\n\t\n\t\t\t\t\treturn extension;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLClipping() {\n\t\n\t\t\tvar scope = this,\n\t\n\t\t\t\tglobalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false,\n\t\n\t\t\t\tplane = new Plane(),\n\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\n\t\t\t\tuniform = { value: null, needsUpdate: false };\n\t\n\t\t\tthis.uniform = uniform;\n\t\t\tthis.numPlanes = 0;\n\t\t\tthis.numIntersection = 0;\n\t\n\t\t\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\t\n\t\t\t\tvar enabled =\n\t\t\t\t\tplanes.length !== 0 ||\n\t\t\t\t\tenableLocalClipping ||\n\t\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\t\tlocalClippingEnabled;\n\t\n\t\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\n\t\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\t\tnumGlobalPlanes = planes.length;\n\t\n\t\t\t\treturn enabled;\n\t\n\t\t\t};\n\t\n\t\t\tthis.beginShadows = function () {\n\t\n\t\t\t\trenderingShadows = true;\n\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t};\n\t\n\t\t\tthis.endShadows = function () {\n\t\n\t\t\t\trenderingShadows = false;\n\t\t\t\tresetGlobalState();\n\t\n\t\t\t};\n\t\n\t\t\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\t\n\t\t\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\t\n\t\t\t\t\t// there's no local clipping\n\t\n\t\t\t\t\tif ( renderingShadows ) {\n\t\n\t\t\t\t\t\t// there's no global clipping\n\t\n\t\t\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tresetGlobalState();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\tlGlobal = nGlobal * 4,\n\t\n\t\t\t\t\t\tdstArray = cache.clippingState || null;\n\t\n\t\t\t\t\tuniform.value = dstArray; // ensure unique state\n\t\n\t\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\t\n\t\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\t\n\t\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\t\tthis.numPlanes += nGlobal;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t};\n\t\n\t\t\tfunction resetGlobalState() {\n\t\n\t\t\t\tif ( uniform.value !== globalState ) {\n\t\n\t\t\t\t\tuniform.value = globalState;\n\t\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\t\tscope.numIntersection = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\t\n\t\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\t\tdstArray = null;\n\t\n\t\t\t\tif ( nPlanes !== 0 ) {\n\t\n\t\t\t\t\tdstArray = uniform.value;\n\t\n\t\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\t\n\t\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\t\n\t\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\t\n\t\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\t\n\t\t\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\t\n\t\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuniform.value = dstArray;\n\t\t\t\t\tuniform.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.numPlanes = nPlanes;\n\t\n\t\t\t\treturn dstArray;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author thespite / http://www.twitter.com/thespite\n\t\t */\n\t\n\t\tfunction WebGLUtils( gl, extensions ) {\n\t\n\t\t\tfunction convert( p ) {\n\t\n\t\t\t\tvar extension;\n\t\n\t\t\t\tif ( p === RepeatWrapping ) return gl.REPEAT;\n\t\t\t\tif ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;\n\t\t\t\tif ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;\n\t\n\t\t\t\tif ( p === NearestFilter ) return gl.NEAREST;\n\t\t\t\tif ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;\n\t\t\t\tif ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === LinearFilter ) return gl.LINEAR;\n\t\t\t\tif ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;\n\t\t\t\tif ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;\n\t\n\t\t\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\t\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tif ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;\n\t\n\t\t\t\tif ( p === ByteType ) return gl.BYTE;\n\t\t\t\tif ( p === ShortType ) return gl.SHORT;\n\t\t\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\t\t\tif ( p === IntType ) return gl.INT;\n\t\t\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\t\t\tif ( p === FloatType ) return gl.FLOAT;\n\t\n\t\t\t\tif ( p === HalfFloatType ) {\n\t\n\t\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\t\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\t\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\t\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\t\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\t\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\t\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\t\n\t\t\t\tif ( p === AddEquation ) return gl.FUNC_ADD;\n\t\t\t\tif ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;\n\t\t\t\tif ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;\n\t\n\t\t\t\tif ( p === ZeroFactor ) return gl.ZERO;\n\t\t\t\tif ( p === OneFactor ) return gl.ONE;\n\t\t\t\tif ( p === SrcColorFactor ) return gl.SRC_COLOR;\n\t\t\t\tif ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;\n\t\t\t\tif ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;\n\t\t\t\tif ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;\n\t\t\t\tif ( p === DstAlphaFactor ) return gl.DST_ALPHA;\n\t\t\t\tif ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;\n\t\n\t\t\t\tif ( p === DstColorFactor ) return gl.DST_COLOR;\n\t\t\t\tif ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;\n\t\t\t\tif ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;\n\t\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGB_ETC1_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\treturn p;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\t\n\t\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( p === UnsignedInt248Type ) {\n\t\n\t\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\t\n\t\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn { convert: convert };\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction UniformsCache() {\n\t\n\t\t\tvar lights = {};\n\t\n\t\t\treturn {\n\t\n\t\t\t\tget: function ( light ) {\n\t\n\t\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\t\n\t\t\t\t\t\treturn lights[ light.id ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uniforms;\n\t\n\t\t\t\t\tswitch ( light.type ) {\n\t\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlights[ light.id ] = uniforms;\n\t\n\t\t\t\t\treturn uniforms;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tvar count = 0;\n\t\n\t\tfunction WebGLLights() {\n\t\n\t\t\tvar cache = new UniformsCache();\n\t\n\t\t\tvar state = {\n\t\n\t\t\t\tid: count ++,\n\t\n\t\t\t\thash: '',\n\t\n\t\t\t\tambient: [ 0, 0, 0 ],\n\t\t\t\tdirectional: [],\n\t\t\t\tdirectionalShadowMap: [],\n\t\t\t\tdirectionalShadowMatrix: [],\n\t\t\t\tspot: [],\n\t\t\t\tspotShadowMap: [],\n\t\t\t\tspotShadowMatrix: [],\n\t\t\t\trectArea: [],\n\t\t\t\tpoint: [],\n\t\t\t\tpointShadowMap: [],\n\t\t\t\tpointShadowMatrix: [],\n\t\t\t\themi: []\n\t\n\t\t\t};\n\t\n\t\t\tvar vector3 = new Vector3();\n\t\t\tvar matrix4 = new Matrix4();\n\t\t\tvar matrix42 = new Matrix4();\n\t\n\t\t\tfunction setup( lights, shadows, camera ) {\n\t\n\t\t\t\tvar r = 0, g = 0, b = 0;\n\t\n\t\t\t\tvar directionalLength = 0;\n\t\t\t\tvar pointLength = 0;\n\t\t\t\tvar spotLength = 0;\n\t\t\t\tvar rectAreaLength = 0;\n\t\t\t\tvar hemiLength = 0;\n\t\n\t\t\t\tvar viewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar light = lights[ i ];\n\t\n\t\t\t\t\tvar color = light.color;\n\t\t\t\t\tvar intensity = light.intensity;\n\t\t\t\t\tvar distance = light.distance;\n\t\n\t\t\t\t\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\t\n\t\t\t\t\tif ( light.isAmbientLight ) {\n\t\n\t\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\t\tb += color.b * intensity;\n\t\n\t\t\t\t\t} else if ( light.isDirectionalLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = cache.get( light );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\t\n\t\t\t\t\t\tdirectionalLength ++;\n\t\n\t\t\t\t\t} else if ( light.isSpotLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = cache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.distance = distance;\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\t\n\t\t\t\t\t\tspotLength ++;\n\t\n\t\t\t\t\t} else if ( light.isRectAreaLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = cache.get( light );\n\t\n\t\t\t\t\t\t// (a) intensity is the total visible light emitted\n\t\t\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\t\n\t\t\t\t\t\t// (b) intensity is the brightness of the light\n\t\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\t\t\tmatrix42.identity();\n\t\t\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\t\t\tmatrix42.extractRotation( matrix4 );\n\t\n\t\t\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\t\n\t\t\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\t\n\t\t\t\t\t\t// TODO (abelnation): RectAreaLight distance?\n\t\t\t\t\t\t// uniforms.distance = distance;\n\t\n\t\t\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\t\n\t\t\t\t\t\trectAreaLength ++;\n\t\n\t\t\t\t\t} else if ( light.isPointLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = cache.get( light );\n\t\n\t\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\t\tuniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\t\t\tuniforms.shadowCameraFar = shadow.camera.far;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\t\t\t\t\t\tstate.point[ pointLength ] = uniforms;\n\t\n\t\t\t\t\t\tpointLength ++;\n\t\n\t\t\t\t\t} else if ( light.isHemisphereLight ) {\n\t\n\t\t\t\t\t\tvar uniforms = cache.get( light );\n\t\n\t\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\t\tuniforms.direction.normalize();\n\t\n\t\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\t\n\t\t\t\t\t\themiLength ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.ambient[ 0 ] = r;\n\t\t\t\tstate.ambient[ 1 ] = g;\n\t\t\t\tstate.ambient[ 2 ] = b;\n\t\n\t\t\t\tstate.directional.length = directionalLength;\n\t\t\t\tstate.spot.length = spotLength;\n\t\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\t\tstate.point.length = pointLength;\n\t\t\t\tstate.hemi.length = hemiLength;\n\t\n\t\t\t\tstate.hash = state.id + ',' + directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tsetup: setup,\n\t\t\t\tstate: state\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction WebGLRenderState() {\n\t\n\t\t\tvar lights = new WebGLLights();\n\t\n\t\t\tvar lightsArray = [];\n\t\t\tvar shadowsArray = [];\n\t\t\tvar spritesArray = [];\n\t\n\t\t\tfunction init() {\n\t\n\t\t\t\tlightsArray.length = 0;\n\t\t\t\tshadowsArray.length = 0;\n\t\t\t\tspritesArray.length = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushLight( light ) {\n\t\n\t\t\t\tlightsArray.push( light );\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushShadow( shadowLight ) {\n\t\n\t\t\t\tshadowsArray.push( shadowLight );\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushSprite( shadowLight ) {\n\t\n\t\t\t\tspritesArray.push( shadowLight );\n\t\n\t\t\t}\n\t\n\t\t\tfunction setupLights( camera ) {\n\t\n\t\t\t\tlights.setup( lightsArray, shadowsArray, camera );\n\t\n\t\t\t}\n\t\n\t\t\tvar state = {\n\t\t\t\tlightsArray: lightsArray,\n\t\t\t\tshadowsArray: shadowsArray,\n\t\t\t\tspritesArray: spritesArray,\n\t\n\t\t\t\tlights: lights\n\t\t\t};\n\t\n\t\t\treturn {\n\t\t\t\tinit: init,\n\t\t\t\tstate: state,\n\t\t\t\tsetupLights: setupLights,\n\t\n\t\t\t\tpushLight: pushLight,\n\t\t\t\tpushShadow: pushShadow,\n\t\t\t\tpushSprite: pushSprite\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tfunction WebGLRenderStates() {\n\t\n\t\t\tvar renderStates = {};\n\t\n\t\t\tfunction get( scene, camera ) {\n\t\n\t\t\t\tvar hash = scene.id + ',' + camera.id;\n\t\n\t\t\t\tvar renderState = renderStates[ hash ];\n\t\n\t\t\t\tif ( renderState === undefined ) {\n\t\n\t\t\t\t\trenderState = new WebGLRenderState();\n\t\t\t\t\trenderStates[ hash ] = renderState;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn renderState;\n\t\n\t\t\t}\n\t\n\t\t\tfunction dispose() {\n\t\n\t\t\t\trenderStates = {};\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tget: get,\n\t\t\t\tdispose: dispose\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author szimek / https://github.com/szimek/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction WebGLRenderer( parameters ) {\n\t\n\t\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\n\t\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\n\t\n\t\t\tvar currentRenderList = null;\n\t\t\tvar currentRenderState = null;\n\t\n\t\t\t// public properties\n\t\n\t\t\tthis.domElement = _canvas;\n\t\t\tthis.context = null;\n\t\n\t\t\t// clearing\n\t\n\t\t\tthis.autoClear = true;\n\t\t\tthis.autoClearColor = true;\n\t\t\tthis.autoClearDepth = true;\n\t\t\tthis.autoClearStencil = true;\n\t\n\t\t\t// scene graph\n\t\n\t\t\tthis.sortObjects = true;\n\t\n\t\t\t// user-defined clipping\n\t\n\t\t\tthis.clippingPlanes = [];\n\t\t\tthis.localClippingEnabled = false;\n\t\n\t\t\t// physically based shading\n\t\n\t\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\t\tthis.gammaInput = false;\n\t\t\tthis.gammaOutput = false;\n\t\n\t\t\t// physical lights\n\t\n\t\t\tthis.physicallyCorrectLights = false;\n\t\n\t\t\t// tone mapping\n\t\n\t\t\tthis.toneMapping = LinearToneMapping;\n\t\t\tthis.toneMappingExposure = 1.0;\n\t\t\tthis.toneMappingWhitePoint = 1.0;\n\t\n\t\t\t// morphs\n\t\n\t\t\tthis.maxMorphTargets = 8;\n\t\t\tthis.maxMorphNormals = 4;\n\t\n\t\t\t// internal properties\n\t\n\t\t\tvar _this = this,\n\t\n\t\t\t\t_isContextLost = false,\n\t\n\t\t\t\t// internal state cache\n\t\n\t\t\t\t_currentRenderTarget = null,\n\t\t\t\t_currentFramebuffer = null,\n\t\t\t\t_currentMaterialId = - 1,\n\t\t\t\t_currentGeometryProgram = '',\n\t\n\t\t\t\t_currentCamera = null,\n\t\t\t\t_currentArrayCamera = null,\n\t\n\t\t\t\t_currentViewport = new Vector4(),\n\t\t\t\t_currentScissor = new Vector4(),\n\t\t\t\t_currentScissorTest = null,\n\t\n\t\t\t\t//\n\t\n\t\t\t\t_usedTextureUnits = 0,\n\t\n\t\t\t\t//\n\t\n\t\t\t\t_width = _canvas.width,\n\t\t\t\t_height = _canvas.height,\n\t\n\t\t\t\t_pixelRatio = 1,\n\t\n\t\t\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\t\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t\t\t_scissorTest = false,\n\t\n\t\t\t\t// frustum\n\t\n\t\t\t\t_frustum = new Frustum(),\n\t\n\t\t\t\t// clipping\n\t\n\t\t\t\t_clipping = new WebGLClipping(),\n\t\t\t\t_clippingEnabled = false,\n\t\t\t\t_localClippingEnabled = false,\n\t\n\t\t\t\t// camera matrices cache\n\t\n\t\t\t\t_projScreenMatrix = new Matrix4(),\n\t\n\t\t\t\t_vector3 = new Vector3(),\n\t\n\t\t\t\t// info\n\t\n\t\t\t\t_infoMemory = {\n\t\t\t\t\tgeometries: 0,\n\t\t\t\t\ttextures: 0\n\t\t\t\t},\n\t\n\t\t\t\t_infoRender = {\n\t\n\t\t\t\t\tframe: 0,\n\t\t\t\t\tcalls: 0,\n\t\t\t\t\tvertices: 0,\n\t\t\t\t\tfaces: 0,\n\t\t\t\t\tpoints: 0\n\t\n\t\t\t\t};\n\t\n\t\t\tthis.info = {\n\t\n\t\t\t\trender: _infoRender,\n\t\t\t\tmemory: _infoMemory,\n\t\t\t\tprograms: null,\n\t\t\t\tautoReset: true,\n\t\t\t\treset: resetInfo\n\t\n\t\t\t};\n\t\n\t\t\tfunction resetInfo() {\n\t\n\t\t\t\t_infoRender.frame ++;\n\t\t\t\t_infoRender.calls = 0;\n\t\t\t\t_infoRender.vertices = 0;\n\t\t\t\t_infoRender.faces = 0;\n\t\t\t\t_infoRender.points = 0;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getTargetPixelRatio() {\n\t\n\t\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\n\t\t\t}\n\t\n\t\t\t// initialize\n\t\n\t\t\tvar _gl;\n\t\n\t\t\ttry {\n\t\n\t\t\t\tvar contextAttributes = {\n\t\t\t\t\talpha: _alpha,\n\t\t\t\t\tdepth: _depth,\n\t\t\t\t\tstencil: _stencil,\n\t\t\t\t\tantialias: _antialias,\n\t\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\t\t\tpowerPreference: _powerPreference\n\t\t\t\t};\n\t\n\t\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\n\t\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\n\t\t\t\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\n\t\n\t\t\t\tif ( _gl === null ) {\n\t\n\t\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\t\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\t\n\t\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\n\t\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\n\t\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\n\t\t\t}\n\t\n\t\t\tvar extensions, capabilities, state;\n\t\t\tvar properties, textures, attributes, geometries, objects;\n\t\t\tvar programCache, renderLists, renderStates;\n\t\n\t\t\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\t\t\tvar spriteRenderer;\n\t\n\t\t\tvar utils;\n\t\n\t\t\tfunction initGLContext() {\n\t\n\t\t\t\textensions = new WebGLExtensions( _gl );\n\t\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\t\textensions.get( 'OES_texture_float' );\n\t\t\t\textensions.get( 'OES_texture_float_linear' );\n\t\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\t\textensions.get( 'OES_element_index_uint' );\n\t\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tutils = new WebGLUtils( _gl, extensions );\n\t\n\t\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\t\n\t\t\t\tstate = new WebGLState( _gl, extensions, utils );\n\t\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t\tproperties = new WebGLProperties();\n\t\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory, _infoRender );\n\t\t\t\tattributes = new WebGLAttributes( _gl );\n\t\t\t\tgeometries = new WebGLGeometries( _gl, attributes, _infoMemory );\n\t\t\t\tobjects = new WebGLObjects( geometries, _infoRender );\n\t\t\t\tmorphtargets = new WebGLMorphtargets( _gl );\n\t\t\t\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\n\t\t\t\trenderLists = new WebGLRenderLists();\n\t\t\t\trenderStates = new WebGLRenderStates();\n\t\n\t\t\t\tbackground = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );\n\t\n\t\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\t\n\t\t\t\tspriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );\n\t\n\t\t\t\t_this.info.programs = programCache.programs;\n\t\n\t\t\t\t_this.context = _gl;\n\t\t\t\t_this.capabilities = capabilities;\n\t\t\t\t_this.extensions = extensions;\n\t\t\t\t_this.properties = properties;\n\t\t\t\t_this.renderLists = renderLists;\n\t\t\t\t_this.state = state;\n\t\n\t\t\t}\n\t\n\t\t\tinitGLContext();\n\t\n\t\t\t// vr\n\t\n\t\t\tvar vr = new WebVRManager( _this );\n\t\n\t\t\tthis.vr = vr;\n\t\n\t\t\t// shadow map\n\t\n\t\t\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\n\t\n\t\t\tthis.shadowMap = shadowMap;\n\t\n\t\t\t// API\n\t\n\t\t\tthis.getContext = function () {\n\t\n\t\t\t\treturn _gl;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getContextAttributes = function () {\n\t\n\t\t\t\treturn _gl.getContextAttributes();\n\t\n\t\t\t};\n\t\n\t\t\tthis.forceContextLoss = function () {\n\t\n\t\t\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\t\tif ( extension ) extension.loseContext();\n\t\n\t\t\t};\n\t\n\t\t\tthis.forceContextRestore = function () {\n\t\n\t\t\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\t\tif ( extension ) extension.restoreContext();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getPixelRatio = function () {\n\t\n\t\t\t\treturn _pixelRatio;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\t\tif ( value === undefined ) return;\n\t\n\t\t\t\t_pixelRatio = value;\n\t\n\t\t\t\tthis.setSize( _width, _height, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getSize = function () {\n\t\n\t\t\t\treturn {\n\t\t\t\t\twidth: _width,\n\t\t\t\t\theight: _height\n\t\t\t\t};\n\t\n\t\t\t};\n\t\n\t\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t\tvar device = vr.getDevice();\n\t\n\t\t\t\tif ( device && device.isPresenting ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_width = width;\n\t\t\t\t_height = height;\n\t\n\t\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t\t_canvas.height = height * _pixelRatio;\n\t\n\t\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getDrawingBufferSize = function () {\n\t\n\t\t\t\treturn {\n\t\t\t\t\twidth: _width * _pixelRatio,\n\t\t\t\t\theight: _height * _pixelRatio\n\t\t\t\t};\n\t\n\t\t\t};\n\t\n\t\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\t\n\t\t\t\t_width = width;\n\t\t\t\t_height = height;\n\t\n\t\t\t\t_pixelRatio = pixelRatio;\n\t\n\t\t\t\t_canvas.width = width * pixelRatio;\n\t\t\t\t_canvas.height = height * pixelRatio;\n\t\n\t\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getCurrentViewport = function () {\n\t\n\t\t\t\treturn _currentViewport;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\t\t_viewport.set( x, _height - y - height, width, height );\n\t\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissor = function ( x, y, width, height ) {\n\t\n\t\t\t\t_scissor.set( x, _height - y - height, width, height );\n\t\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t};\n\t\n\t\t\tthis.setScissorTest = function ( boolean ) {\n\t\n\t\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\t\n\t\t\t};\n\t\n\t\t\t// Clearing\n\t\n\t\t\tthis.getClearColor = function () {\n\t\n\t\t\t\treturn background.getClearColor();\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearColor = function () {\n\t\n\t\t\t\tbackground.setClearColor.apply( background, arguments );\n\t\n\t\t\t};\n\t\n\t\t\tthis.getClearAlpha = function () {\n\t\n\t\t\t\treturn background.getClearAlpha();\n\t\n\t\t\t};\n\t\n\t\t\tthis.setClearAlpha = function () {\n\t\n\t\t\t\tbackground.setClearAlpha.apply( background, arguments );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clear = function ( color, depth, stencil ) {\n\t\n\t\t\t\tvar bits = 0;\n\t\n\t\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\t\n\t\t\t\t_gl.clear( bits );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearColor = function () {\n\t\n\t\t\t\tthis.clear( true, false, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearDepth = function () {\n\t\n\t\t\t\tthis.clear( false, true, false );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearStencil = function () {\n\t\n\t\t\t\tthis.clear( false, false, true );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\t\tthis.clear( color, depth, stencil );\n\t\n\t\t\t};\n\t\n\t\t\t//\n\t\n\t\t\tthis.dispose = function () {\n\t\n\t\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\n\t\t\t\trenderLists.dispose();\n\t\t\t\trenderStates.dispose();\n\t\t\t\tproperties.dispose();\n\t\t\t\tobjects.dispose();\n\t\n\t\t\t\tvr.dispose();\n\t\n\t\t\t\tstopAnimation();\n\t\n\t\t\t};\n\t\n\t\t\t// Events\n\t\n\t\t\tfunction onContextLost( event ) {\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\t\n\t\t\t\t_isContextLost = true;\n\t\n\t\t\t}\n\t\n\t\t\tfunction onContextRestore( /* event */ ) {\n\t\n\t\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\t\n\t\t\t\t_isContextLost = false;\n\t\n\t\t\t\tinitGLContext();\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMaterialDispose( event ) {\n\t\n\t\t\t\tvar material = event.target;\n\t\n\t\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\tdeallocateMaterial( material );\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer deallocation\n\t\n\t\t\tfunction deallocateMaterial( material ) {\n\t\n\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\tproperties.remove( material );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction releaseMaterialProgramReference( material ) {\n\t\n\t\t\t\tvar programInfo = properties.get( material ).program;\n\t\n\t\t\t\tmaterial.program = undefined;\n\t\n\t\t\t\tif ( programInfo !== undefined ) {\n\t\n\t\t\t\t\tprogramCache.releaseProgram( programInfo );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Buffer rendering\n\t\n\t\t\tfunction renderObjectImmediate( object, program, material ) {\n\t\n\t\t\t\tobject.render( function ( object ) {\n\t\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\t\n\t\t\t\t} );\n\t\n\t\t\t}\n\t\n\t\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar buffers = properties.get( object );\n\t\n\t\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\t\n\t\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\t\tif ( object.hasPositions ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( programAttributes.position );\n\t\t\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasNormals ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\t\n\t\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t\t\t! material.isMeshStandardMaterial &&\n\t\t\t\t\t\t! material.isMeshNormalMaterial &&\n\t\t\t\t\t\tmaterial.flatShading === true ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\tvar array = object.normalArray;\n\t\n\t\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\t\n\t\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\t\n\t\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( programAttributes.normal );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasUvs && material.map ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( programAttributes.uv );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\t\tstate.enableAttribute( programAttributes.color );\n\t\n\t\t\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\t\n\t\t\t\tobject.count = 0;\n\t\n\t\t\t};\n\t\n\t\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\t\n\t\t\t\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\t\n\t\t\t\tstate.setMaterial( material, frontFaceCW );\n\t\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );\n\t\n\t\t\t\tvar updateBuffers = false;\n\t\n\t\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\t\n\t\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\t\n\t\t\t\t\tmorphtargets.update( object, geometry, material, program );\n\t\n\t\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\tvar rangeFactor = 1;\n\t\n\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\t\t\trangeFactor = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attribute;\n\t\t\t\tvar renderer = bufferRenderer;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tattribute = attributes.get( index );\n\t\n\t\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\t\trenderer.setIndex( attribute );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( updateBuffers ) {\n\t\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar dataCount = Infinity;\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\tdataCount = index.count;\n\t\n\t\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\t\tdataCount = position.count;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\t\n\t\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\n\t\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\t\n\t\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\t\n\t\t\t\tif ( drawCount === 0 ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( object.isMesh ) {\n\t\n\t\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tswitch ( object.drawMode ) {\n\t\n\t\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t} else if ( object.isLine ) {\n\t\n\t\t\t\t\tvar lineWidth = material.linewidth;\n\t\n\t\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\t\n\t\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\t\n\t\t\t\t\tif ( object.isLineSegments ) {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t\t} else if ( object.isLineLoop ) {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object.isPoints ) {\n\t\n\t\t\t\t\trenderer.setMode( _gl.POINTS );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\t\n\t\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.render( drawStart, drawCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\t\n\t\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\t\n\t\t\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\t\n\t\t\t\tstate.initAttributes();\n\t\n\t\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\t\n\t\t\t\tfor ( var name in programAttributes ) {\n\t\n\t\t\t\t\tvar programAttribute = programAttributes[ name ];\n\t\n\t\t\t\t\tif ( programAttribute >= 0 ) {\n\t\n\t\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\t\n\t\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\n\t\t\t\t\t\t\tvar attribute = attributes.get( geometryAttribute );\n\t\n\t\t\t\t\t\t\t// TODO Attribute may not be available on context restore\n\t\n\t\t\t\t\t\t\tif ( attribute === undefined ) continue;\n\t\n\t\t\t\t\t\t\tvar buffer = attribute.buffer;\n\t\t\t\t\t\t\tvar type = attribute.type;\n\t\t\t\t\t\t\tvar bytesPerElement = attribute.bytesPerElement;\n\t\n\t\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\t\n\t\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\t\n\t\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\t\n\t\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\t\n\t\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tswitch ( value.length ) {\n\t\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t}\n\t\n\t\t\t// Compile\n\t\n\t\t\tthis.compile = function ( scene, camera ) {\n\t\n\t\t\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\t\t\tcurrentRenderState.init();\n\t\n\t\t\t\tscene.traverse( function ( object ) {\n\t\n\t\t\t\t\tif ( object.isLight ) {\n\t\n\t\t\t\t\t\tcurrentRenderState.pushLight( object );\n\t\n\t\t\t\t\t\tif ( object.castShadow ) {\n\t\n\t\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} );\n\t\n\t\t\t\tcurrentRenderState.setupLights( camera );\n\t\n\t\t\t\tscene.traverse( function ( object ) {\n\t\n\t\t\t\t\tif ( object.material ) {\n\t\n\t\t\t\t\t\tif ( Array.isArray( object.material ) ) {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0; i < object.material.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tinitMaterial( object.material[ i ], scene.fog, object );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tinitMaterial( object.material, scene.fog, object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} );\n\t\n\t\t\t};\n\t\n\t\t\t// Animation Loop\n\t\n\t\t\tvar isAnimating = false;\n\t\t\tvar onAnimationFrame = null;\n\t\n\t\t\tfunction startAnimation() {\n\t\n\t\t\t\tif ( isAnimating ) return;\n\t\n\t\t\t\trequestAnimationLoopFrame();\n\t\n\t\t\t\tisAnimating = true;\n\t\n\t\t\t}\n\t\n\t\t\tfunction stopAnimation() {\n\t\n\t\t\t\tisAnimating = false;\n\t\n\t\t\t}\n\t\n\t\t\tfunction requestAnimationLoopFrame() {\n\t\n\t\t\t\tvar device = vr.getDevice();\n\t\n\t\t\t\tif ( device && device.isPresenting ) {\n\t\n\t\t\t\t\tdevice.requestAnimationFrame( animationLoop );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\twindow.requestAnimationFrame( animationLoop );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction animationLoop( time ) {\n\t\n\t\t\t\tif ( isAnimating === false ) return;\n\t\n\t\t\t\tonAnimationFrame( time );\n\t\n\t\t\t\trequestAnimationLoopFrame();\n\t\n\t\t\t}\n\t\n\t\t\tthis.animate = function ( callback ) {\n\t\n\t\t\t\tonAnimationFrame = callback;\n\t\t\t\tonAnimationFrame !== null ? startAnimation() : stopAnimation();\n\t\n\t\t\t};\n\t\n\t\t\t// Rendering\n\t\n\t\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\t\n\t\t\t\tif ( ! ( camera && camera.isCamera ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _isContextLost ) return;\n\t\n\t\t\t\t// reset caching for this frame\n\t\n\t\t\t\t_currentGeometryProgram = '';\n\t\t\t\t_currentMaterialId = - 1;\n\t\t\t\t_currentCamera = null;\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\n\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\t\tif ( vr.enabled ) {\n\t\n\t\t\t\t\tcamera = vr.getCamera( camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\t\t\tcurrentRenderState.init();\n\t\n\t\t\t\tscene.onBeforeRender( _this, scene, camera, renderTarget );\n\t\n\t\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\t\n\t\t\t\tcurrentRenderList = renderLists.get( scene, camera );\n\t\t\t\tcurrentRenderList.init();\n\t\n\t\t\t\tprojectObject( scene, camera, _this.sortObjects );\n\t\n\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\tcurrentRenderList.sort();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\t\n\t\t\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\t\n\t\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\t\n\t\t\t\tcurrentRenderState.setupLights( camera );\n\t\n\t\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\t\n\t\t\t\t//\n\t\n\t\t\t\tif ( this.info.autoReset ) this.info.reset();\n\t\n\t\t\t\tif ( renderTarget === undefined ) {\n\t\n\t\t\t\t\trenderTarget = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.setRenderTarget( renderTarget );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tbackground.render( currentRenderList, scene, camera, forceClear );\n\t\n\t\t\t\t// render scene\n\t\n\t\t\t\tvar opaqueObjects = currentRenderList.opaque;\n\t\t\t\tvar transparentObjects = currentRenderList.transparent;\n\t\n\t\t\t\tif ( scene.overrideMaterial ) {\n\t\n\t\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\t\n\t\t\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// opaque pass (front-to-back order)\n\t\n\t\t\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\n\t\n\t\t\t\t\t// transparent pass (back-to-front order)\n\t\n\t\t\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// custom renderers\n\t\n\t\t\t\tvar spritesArray = currentRenderState.state.spritesArray;\n\t\n\t\t\t\tspriteRenderer.render( spritesArray, scene, camera );\n\t\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\t\n\t\t\t\tstate.buffers.depth.setTest( true );\n\t\t\t\tstate.buffers.depth.setMask( true );\n\t\t\t\tstate.buffers.color.setMask( true );\n\t\n\t\t\t\tstate.setPolygonOffset( false );\n\t\n\t\t\t\tscene.onAfterRender( _this, scene, camera );\n\t\n\t\t\t\tif ( vr.enabled ) {\n\t\n\t\t\t\t\tvr.submitFrame();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// _gl.finish();\n\t\n\t\t\t\tcurrentRenderList = null;\n\t\t\t\tcurrentRenderState = null;\n\t\n\t\t\t};\n\t\n\t\t\t/*\n\t\t\t// TODO Duplicated code (Frustum)\n\t\n\t\t\tvar _sphere = new Sphere();\n\t\n\t\t\tfunction isObjectViewable( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSpriteViewable( sprite ) {\n\t\n\t\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t\t}\n\t\n\t\t\tfunction isSphereViewable( sphere ) {\n\t\n\t\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\t\n\t\t\t\tvar numPlanes = _clipping.numPlanes;\n\t\n\t\t\t\tif ( numPlanes === 0 ) return true;\n\t\n\t\t\t\tvar planes = _this.clippingPlanes,\n\t\n\t\t\t\t\tcenter = sphere.center,\n\t\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\t\ti = 0;\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\t\n\t\t\t\t} while ( ++ i !== numPlanes );\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\t\t*/\n\t\n\t\t\tfunction projectObject( object, camera, sortObjects ) {\n\t\n\t\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\t\tvar visible = object.layers.test( camera.layers );\n\t\n\t\t\t\tif ( visible ) {\n\t\n\t\t\t\t\tif ( object.isLight ) {\n\t\n\t\t\t\t\t\tcurrentRenderState.pushLight( object );\n\t\n\t\t\t\t\t\tif ( object.castShadow ) {\n\t\n\t\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( object.isSprite ) {\n\t\n\t\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\t\n\t\t\t\t\t\t\tcurrentRenderState.pushSprite( object );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\t\tif ( sortObjects ) {\n\t\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\n\t\n\t\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\t\n\t\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\t\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\t\n\t\t\t\t\t\t\tif ( sortObjects ) {\n\t\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\t\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\t\n\t\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else if ( material.visible ) {\n\t\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tprojectObject( children[ i ], camera, sortObjects );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\t\n\t\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar renderItem = renderList[ i ];\n\t\n\t\t\t\t\tvar object = renderItem.object;\n\t\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\t\tvar group = renderItem.group;\n\t\n\t\t\t\t\tif ( camera.isArrayCamera ) {\n\t\n\t\t\t\t\t\t_currentArrayCamera = camera;\n\t\n\t\t\t\t\t\tvar cameras = camera.cameras;\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar camera2 = cameras[ j ];\n\t\n\t\t\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\t\n\t\t\t\t\t\t\t\tvar bounds = camera2.bounds;\n\t\n\t\t\t\t\t\t\t\tvar x = bounds.x * _width;\n\t\t\t\t\t\t\t\tvar y = bounds.y * _height;\n\t\t\t\t\t\t\t\tvar width = bounds.z * _width;\n\t\t\t\t\t\t\t\tvar height = bounds.w * _height;\n\t\n\t\t\t\t\t\t\t\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_currentArrayCamera = null;\n\t\n\t\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\t\n\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\t\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\t\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\t\n\t\t\t\tif ( object.isImmediateRenderObject ) {\n\t\n\t\t\t\t\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\t\n\t\t\t\t\tstate.setMaterial( material, frontFaceCW );\n\t\n\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\t\n\t\t\t\t\t_currentGeometryProgram = '';\n\t\n\t\t\t\t\trenderObjectImmediate( object, program, material );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\t\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\t\n\t\t\t}\n\t\n\t\t\tfunction initMaterial( material, fog, object ) {\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\t\tvar lights = currentRenderState.state.lights;\n\t\t\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\t\n\t\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\t\n\t\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\t\n\t\t\t\tvar program = materialProperties.program;\n\t\t\t\tvar programChange = true;\n\t\n\t\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t\t// new material\n\t\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t\t} else if ( program.code !== code ) {\n\t\n\t\t\t\t\t// changed glsl or parameters\n\t\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t\t} else if ( materialProperties.lightsHash !== lights.state.hash ) {\n\t\n\t\t\t\t\tproperties.update( material, 'lightsHash', lights.state.hash );\n\t\t\t\t\tprogramChange = false;\n\t\n\t\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\t\n\t\t\t\t\t// same glsl and uniform list\n\t\t\t\t\treturn;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// only rebuild uniform list\n\t\t\t\t\tprogramChange = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( programChange ) {\n\t\n\t\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\t\n\t\t\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.onBeforeCompile( materialProperties.shader );\n\t\n\t\t\t\t\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\n\t\n\t\t\t\t\tmaterialProperties.program = program;\n\t\t\t\t\tmaterial.program = program;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\t\n\t\t\t\t\t\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.morphNormals ) {\n\t\n\t\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\t\n\t\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\t\n\t\t\t\t\t\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar uniforms = materialProperties.shader.uniforms;\n\t\n\t\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t\t\t! material.isRawShaderMaterial ||\n\t\t\t\t\tmaterial.clipping === true ) {\n\t\n\t\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterialProperties.fog = fog;\n\t\n\t\t\t\t// store the light setup it was created for\n\t\n\t\t\t\tmaterialProperties.lightsHash = lights.state.hash;\n\t\n\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t// wire up the material to this renderer's lighting state\n\t\n\t\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\t\n\t\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\t\tuniformsList =\n\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\t\n\t\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\n\t\t\t}\n\t\n\t\t\tfunction setProgram( camera, fog, material, object ) {\n\t\n\t\t\t\t_usedTextureUnits = 0;\n\t\n\t\t\t\tvar materialProperties = properties.get( material );\n\t\t\t\tvar lights = currentRenderState.state.lights;\n\t\n\t\t\t\tif ( _clippingEnabled ) {\n\t\n\t\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\t\n\t\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\t\n\t\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate === false ) {\n\t\n\t\t\t\t\tif ( materialProperties.program === undefined ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\n\t\t\t\t\t\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\n\t\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.needsUpdate ) {\n\t\n\t\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\t\tmaterial.needsUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar refreshProgram = false;\n\t\t\t\tvar refreshMaterial = false;\n\t\t\t\tvar refreshLights = false;\n\t\n\t\t\t\tvar program = materialProperties.program,\n\t\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\t\tm_uniforms = materialProperties.shader.uniforms;\n\t\n\t\t\t\tif ( state.useProgram( program.program ) ) {\n\t\n\t\t\t\t\trefreshProgram = true;\n\t\t\t\t\trefreshMaterial = true;\n\t\t\t\t\trefreshLights = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.id !== _currentMaterialId ) {\n\t\n\t\t\t\t\t_currentMaterialId = material.id;\n\t\n\t\t\t\t\trefreshMaterial = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\t\n\t\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\t\n\t\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Avoid unneeded uniform updates per ArrayCamera's sub-camera\n\t\n\t\t\t\t\tif ( _currentCamera !== ( _currentArrayCamera || camera ) ) {\n\t\n\t\t\t\t\t\t_currentCamera = ( _currentArrayCamera || camera );\n\t\n\t\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t\t// the next material that does gets activated:\n\t\n\t\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// load material specific uniforms\n\t\t\t\t\t// (shader material also gets them for the sake of genericity)\n\t\n\t\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\t\tmaterial.envMap ) {\n\t\n\t\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\t\n\t\t\t\t\t\tif ( uCamPos !== undefined ) {\n\t\n\t\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\t\t\tmaterial.skinning ) {\n\t\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t\t// not sure why, but otherwise weird things happen\n\t\n\t\t\t\tif ( material.skinning ) {\n\t\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\t\n\t\t\t\t\tvar skeleton = object.skeleton;\n\t\n\t\t\t\t\tif ( skeleton ) {\n\t\n\t\t\t\t\t\tvar bones = skeleton.bones;\n\t\n\t\t\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\t\n\t\t\t\t\t\t\tif ( skeleton.boneTexture === undefined ) {\n\t\n\t\t\t\t\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\n\t\n\t\t\t\t\t\t\t\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\t\t\t\t\tsize = _Math.ceilPowerOfTwo( size );\n\t\t\t\t\t\t\t\tsize = Math.max( size, 4 );\n\t\n\t\t\t\t\t\t\t\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\t\t\t\t\t\t\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\n\t\n\t\t\t\t\t\t\t\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\t\t\t\t\t\t\tboneTexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\t\tskeleton.boneMatrices = boneMatrices;\n\t\t\t\t\t\t\t\tskeleton.boneTexture = boneTexture;\n\t\t\t\t\t\t\t\tskeleton.boneTextureSize = size;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\n\t\t\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( refreshMaterial ) {\n\t\n\t\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\t\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\n\t\n\t\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t\t// the current material requires lighting info\n\t\n\t\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t\t// values\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t\t// the GL state when required\n\t\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// refresh uniforms common to several materials\n\t\n\t\t\t\t\tif ( fog && material.fog ) {\n\t\n\t\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( material.isMeshBasicMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t\t\tif ( material.isMeshToonMaterial ) {\n\t\n\t\t\t\t\t\t\trefreshUniformsToon( m_uniforms, material );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\t\n\t\t\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsDepth( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshDistanceMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsDistance( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\t\trefreshUniformsNormal( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isLineBasicMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\n\t\t\t\t\t\tif ( material.isLineDashedMaterial ) {\n\t\n\t\t\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( material.isPointsMaterial ) {\n\t\n\t\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\t\n\t\t\t\t\t} else if ( material.isShadowMaterial ) {\n\t\n\t\t\t\t\t\tm_uniforms.color.value = material.color;\n\t\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// RectAreaLight Texture\n\t\t\t\t\t// TODO (mrdoob): Find a nicer implementation\n\t\n\t\t\t\t\tif ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;\n\t\t\t\t\tif ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;\n\t\n\t\t\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\t\n\t\t\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// common matrices\n\t\n\t\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\t\n\t\t\t\treturn program;\n\t\n\t\t\t}\n\t\n\t\t\t// Uniforms (refresh uniforms objects)\n\t\n\t\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\t\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t\tif ( material.color ) {\n\t\n\t\t\t\t\tuniforms.diffuse.value = material.color;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissive ) {\n\t\n\t\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.alphaMap ) {\n\t\n\t\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.specularMap ) {\n\t\n\t\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\n\t\t\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\t\n\t\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.aoMap ) {\n\t\n\t\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\t\n\t\t\t\tvar uvScaleMap;\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\tuvScaleMap = material.map;\n\t\n\t\t\t\t} else if ( material.specularMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\n\t\t\t\t} else if ( material.displacementMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\n\t\t\t\t} else if ( material.normalMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\n\t\t\t\t} else if ( material.bumpMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\n\t\t\t\t} else if ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\n\t\t\t\t} else if ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\n\t\t\t\t} else if ( material.alphaMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\n\t\t\t\t} else if ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\t\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\t\n\t\t\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\t\t\t\t\tvar rotation = uvScaleMap.rotation;\n\t\t\t\t\t\tvar center = uvScaleMap.center;\n\t\n\t\t\t\t\t\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLine( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsDash( uniforms, material ) {\n\t\n\t\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\t\tuniforms.scale.value = material.scale;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\t\n\t\t\t\tuniforms.diffuse.value = material.color;\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\t\tuniforms.scale.value = _height * 0.5;\n\t\n\t\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tif ( material.map.matrixAutoUpdate === true ) {\n\t\n\t\t\t\t\t\tvar offset = material.map.offset;\n\t\t\t\t\t\tvar repeat = material.map.repeat;\n\t\t\t\t\t\tvar rotation = material.map.rotation;\n\t\t\t\t\t\tvar center = material.map.center;\n\t\n\t\t\t\t\t\tmaterial.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\t\n\t\t\t\tuniforms.fogColor.value = fog.color;\n\t\n\t\t\t\tif ( fog.isFog ) {\n\t\n\t\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\n\t\t\t\t} else if ( fog.isFogExp2 ) {\n\t\n\t\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\t\n\t\t\t\tuniforms.specular.value = material.specular;\n\t\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsToon( uniforms, material ) {\n\t\n\t\t\t\trefreshUniformsPhong( uniforms, material );\n\t\n\t\t\t\tif ( material.gradientMap ) {\n\t\n\t\t\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\t\n\t\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\t\tuniforms.metalness.value = material.metalness;\n\t\n\t\t\t\tif ( material.roughnessMap ) {\n\t\n\t\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.metalnessMap ) {\n\t\n\t\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\t\n\t\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\t\n\t\t\t\trefreshUniformsStandard( uniforms, material );\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsDepth( uniforms, material ) {\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsDistance( uniforms, material ) {\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniforms.referencePosition.value.copy( material.referencePosition );\n\t\t\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\t\t\tuniforms.farDistance.value = material.farDistance;\n\t\n\t\t\t}\n\t\n\t\t\tfunction refreshUniformsNormal( uniforms, material ) {\n\t\n\t\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\t\n\t\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\t\n\t\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\n\t\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\n\t\t\t}\n\t\n\t\t\t// Textures\n\t\n\t\t\tfunction allocTextureUnit() {\n\t\n\t\t\t\tvar textureUnit = _usedTextureUnits;\n\t\n\t\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_usedTextureUnits += 1;\n\t\n\t\t\t\treturn textureUnit;\n\t\n\t\t\t}\n\t\n\t\t\tthis.allocTextureUnit = allocTextureUnit;\n\t\n\t\t\t// this.setTexture2D = setTexture2D;\n\t\t\tthis.setTexture2D = ( function () {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\treturn function setTexture2D( texture, slot ) {\n\t\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTexture = ( function () {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTexture( texture, slot ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.setTextureCube = ( function () {\n\t\n\t\t\t\tvar warned = false;\n\t\n\t\t\t\treturn function setTextureCube( texture, slot ) {\n\t\n\t\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\t\n\t\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t\t// TODO: unify these code paths\n\t\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\t\n\t\t\t\t\t\t// CompressedTexture can have Array in image :/\n\t\n\t\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\n\t\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() );\n\t\n\t\t\tthis.getRenderTarget = function () {\n\t\n\t\t\t\treturn _currentRenderTarget;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setRenderTarget = function ( renderTarget ) {\n\t\n\t\t\t\t_currentRenderTarget = renderTarget;\n\t\n\t\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\t\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar framebuffer = null;\n\t\t\t\tvar isCube = false;\n\t\n\t\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\t\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\t\n\t\t\t\t\t\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\t\t\t\t\tisCube = true;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tframebuffer = __webglFramebuffer;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t\t_currentScissorTest = _scissorTest;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t\t_currentFramebuffer = framebuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.viewport( _currentViewport );\n\t\t\t\tstate.scissor( _currentScissor );\n\t\t\t\tstate.setScissorTest( _currentScissorTest );\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\t\n\t\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\t\tif ( framebuffer ) {\n\t\n\t\t\t\t\tvar restore = false;\n\t\n\t\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\t\t\trestore = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\t\tvar textureType = texture.type;\n\t\n\t\t\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t\t\t! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t\t\t! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\t\n\t\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\n\t\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\t\n\t\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} finally {\n\t\n\t\t\t\t\t\tif ( restore ) {\n\t\n\t\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.copyFramebufferToTexture = function ( position, texture, level ) {\n\t\n\t\t\t\tvar width = texture.image.width;\n\t\t\t\tvar height = texture.image.height;\n\t\t\t\tvar internalFormat = utils.convert( texture.format );\n\t\n\t\t\t\tthis.setTexture2D( texture, 0 );\n\t\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, internalFormat, position.x, position.y, width, height, 0 );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction FogExp2( color, density ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\t\n\t\t}\n\t\n\t\tFogExp2.prototype.isFogExp2 = true;\n\t\n\t\tFogExp2.prototype.clone = function () {\n\t\n\t\t\treturn new FogExp2( this.color.getHex(), this.density );\n\t\n\t\t};\n\t\n\t\tFogExp2.prototype.toJSON = function ( /* meta */ ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Fog( color, near, far ) {\n\t\n\t\t\tthis.name = '';\n\t\n\t\t\tthis.color = new Color( color );\n\t\n\t\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\t\n\t\t}\n\t\n\t\tFog.prototype.isFog = true;\n\t\n\t\tFog.prototype.clone = function () {\n\t\n\t\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\t\n\t\t};\n\t\n\t\tFog.prototype.toJSON = function ( /* meta */ ) {\n\t\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Scene() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Scene';\n\t\n\t\t\tthis.background = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\t\n\t\t}\n\t\n\t\tScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Scene,\n\t\n\t\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\t\n\t\t\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\t\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\t\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\t\n\t\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\t\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *\tuvOffset: new THREE.Vector2(),\n\t\t *\tuvScale: new THREE.Vector2()\n\t\t * }\n\t\t */\n\t\n\t\tfunction SpriteMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'SpriteMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.rotation = 0;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\t\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\t\tSpriteMaterial.prototype.isSpriteMaterial = true;\n\t\n\t\tSpriteMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.rotation = source.rotation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Sprite( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Sprite';\n\t\n\t\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\t\n\t\t\tthis.center = new Vector2( 0.5, 0.5 );\n\t\n\t\t}\n\t\n\t\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Sprite,\n\t\n\t\t\tisSprite: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar intersectPoint = new Vector3();\n\t\t\t\tvar worldPosition = new Vector3();\n\t\t\t\tvar worldScale = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tworldPosition.setFromMatrixPosition( this.matrixWorld );\n\t\t\t\t\traycaster.ray.closestPointToPoint( worldPosition, intersectPoint );\n\t\n\t\t\t\t\tworldScale.setFromMatrixScale( this.matrixWorld );\n\t\t\t\t\tvar guessSizeSq = worldScale.x * worldScale.y / 4;\n\t\n\t\t\t\t\tif ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.material ).copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LOD() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'LOD';\n\t\n\t\t\tObject.defineProperties( this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: LOD,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source, false );\n\t\n\t\t\t\tvar levels = source.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\taddLevel: function ( object, distance ) {\n\t\n\t\t\t\tif ( distance === undefined ) distance = 0;\n\t\n\t\t\t\tdistance = Math.abs( distance );\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ l ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\t\n\t\t\t\tthis.add( object );\n\t\n\t\t\t},\n\t\n\t\t\tgetObjectForDistance: function ( distance ) {\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tif ( distance < levels[ i ].distance ) {\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn levels[ i - 1 ].object;\n\t\n\t\t\t},\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar matrixPosition = new Vector3();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\t\n\t\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tvar v1 = new Vector3();\n\t\t\t\tvar v2 = new Vector3();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\t\tif ( levels.length > 1 ) {\n\t\n\t\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\t\n\t\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\t\n\t\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\t\n\t\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.levels = [];\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\t\tdistance: level.distance\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author michael guerrero / http://realitymeltdown.com\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Skeleton( bones, boneInverses ) {\n\t\n\t\t\t// copy the bone array\n\t\n\t\t\tbones = bones || [];\n\t\n\t\t\tthis.bones = bones.slice( 0 );\n\t\t\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\n\t\n\t\t\t// use the supplied bone inverses or calculate the inverses\n\t\n\t\t\tif ( boneInverses === undefined ) {\n\t\n\t\t\t\tthis.calculateInverses();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif ( this.bones.length === boneInverses.length ) {\n\t\n\t\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\n\t\n\t\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Skeleton.prototype, {\n\t\n\t\t\tcalculateInverses: function () {\n\t\n\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar inverse = new Matrix4();\n\t\n\t\t\t\t\tif ( this.bones[ i ] ) {\n\t\n\t\t\t\t\t\tinverse.getInverse( this.bones[ i ].matrixWorld );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.boneInverses.push( inverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tvar bone, i, il;\n\t\n\t\t\t\t// recover the bind-time world matrices\n\t\n\t\t\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ i ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// compute the local matrices, positions, rotations and scales\n\t\n\t\t\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tbone = this.bones[ i ];\n\t\n\t\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\t\n\t\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar offsetMatrix = new Matrix4();\n\t\t\t\tvar identityMatrix = new Matrix4();\n\t\n\t\t\t\treturn function update() {\n\t\n\t\t\t\t\tvar bones = this.bones;\n\t\t\t\t\tvar boneInverses = this.boneInverses;\n\t\t\t\t\tvar boneMatrices = this.boneMatrices;\n\t\t\t\t\tvar boneTexture = this.boneTexture;\n\t\n\t\t\t\t\t// flatten bone matrices to array\n\t\n\t\t\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t// compute the offset between the current and the original transform\n\t\n\t\t\t\t\t\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\n\t\n\t\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t\t\t\toffsetMatrix.toArray( boneMatrices, i * 16 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( boneTexture !== undefined ) {\n\t\n\t\t\t\t\t\tboneTexture.needsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t} )(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new Skeleton( this.bones, this.boneInverses );\n\t\n\t\t\t},\n\t\n\t\t\tgetBoneByName: function ( name ) {\n\t\n\t\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\t\t\tif ( bone.name === name ) {\n\t\n\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn undefined;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction Bone() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Bone';\n\t\n\t\t}\n\t\n\t\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Bone,\n\t\n\t\t\tisBone: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mikael emtinger / http://gomo.se/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author ikerr / http://verold.com\n\t\t */\n\t\n\t\tfunction SkinnedMesh( geometry, material ) {\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'SkinnedMesh';\n\t\n\t\t\tthis.bindMode = 'attached';\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\n\t\t\tvar bones = this.initBones();\n\t\t\tvar skeleton = new Skeleton( bones );\n\t\n\t\t\tthis.bind( skeleton, this.matrixWorld );\n\t\n\t\t\tthis.normalizeSkinWeights();\n\t\n\t\t}\n\t\n\t\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\t\n\t\t\tconstructor: SkinnedMesh,\n\t\n\t\t\tisSkinnedMesh: true,\n\t\n\t\t\tinitBones: function () {\n\t\n\t\t\t\tvar bones = [], bone, gbone;\n\t\t\t\tvar i, il;\n\t\n\t\t\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\t\n\t\t\t\t\t// first, create array of 'Bone' objects from geometry data\n\t\n\t\t\t\t\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tgbone = this.geometry.bones[ i ];\n\t\n\t\t\t\t\t\t// create new 'Bone' object\n\t\n\t\t\t\t\t\tbone = new Bone();\n\t\t\t\t\t\tbones.push( bone );\n\t\n\t\t\t\t\t\t// apply values\n\t\n\t\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// second, create bone hierarchy\n\t\n\t\t\t\t\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tgbone = this.geometry.bones[ i ];\n\t\n\t\t\t\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\n\t\n\t\t\t\t\t\t\t// subsequent bones in the hierarchy\n\t\n\t\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// topmost bone, immediate child of the skinned mesh\n\t\n\t\t\t\t\t\t\tthis.add( bones[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// now the bones are part of the scene graph and children of the skinned mesh.\n\t\t\t\t// let's update the corresponding matrices\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\treturn bones;\n\t\n\t\t\t},\n\t\n\t\t\tbind: function ( skeleton, bindMatrix ) {\n\t\n\t\t\t\tthis.skeleton = skeleton;\n\t\n\t\t\t\tif ( bindMatrix === undefined ) {\n\t\n\t\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\t\tthis.skeleton.calculateInverses();\n\t\n\t\t\t\t\tbindMatrix = this.matrixWorld;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\t\n\t\t\t},\n\t\n\t\t\tpose: function () {\n\t\n\t\t\t\tthis.skeleton.pose();\n\t\n\t\t\t},\n\t\n\t\t\tnormalizeSkinWeights: function () {\n\t\n\t\t\t\tvar scale, i;\n\t\n\t\t\t\tif ( this.geometry && this.geometry.isGeometry ) {\n\t\n\t\t\t\t\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\t\n\t\t\t\t\t\tscale = 1.0 / sw.manhattanLength();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tsw.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\tvar vec = new Vector4();\n\t\n\t\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\t\n\t\t\t\t\tfor ( i = 0; i < skinWeight.count; i ++ ) {\n\t\n\t\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\t\tvec.w = skinWeight.getW( i );\n\t\n\t\t\t\t\t\tscale = 1.0 / vec.manhattanLength();\n\t\n\t\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\t\tvec.multiplyScalar( scale );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\tif ( this.bindMode === 'attached' ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t\t} else if ( this.bindMode === 'detached' ) {\n\t\n\t\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *  linecap: \"round\",\n\t\t *  linejoin: \"round\"\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineBasicMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\t\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\t\n\t\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\t\n\t\tLineBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Line( geometry, material, mode ) {\n\t\n\t\t\tif ( mode === 1 ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\t\treturn new LineSegments( geometry, material );\n\t\n\t\t\t}\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Line';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Line,\n\t\n\t\t\tisLine: true,\n\t\n\t\t\tcomputeLineDistances: ( function () {\n\t\n\t\t\t\tvar start = new Vector3();\n\t\t\t\tvar end = new Vector3();\n\t\n\t\t\t\treturn function computeLineDistances() {\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\t// we assume non-indexed geometry\n\t\n\t\t\t\t\t\tif ( geometry.index === null ) {\n\t\n\t\t\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\t\t\tvar lineDistances = [ 0 ];\n\t\n\t\t\t\t\t\t\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i );\n\t\n\t\t\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\t\t\t\tlineDistances[ i ] += start.distanceTo( end );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new THREE.Float32BufferAttribute( lineDistances, 1 ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar lineDistances = geometry.lineDistances;\n\t\n\t\t\t\t\t\tlineDistances[ 0 ] = 0;\n\t\n\t\t\t\t\t\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\t\tvar precisionSq = precision * precision;\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar vStart = new Vector3();\n\t\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\t\tvar interRay = new Vector3();\n\t\t\t\t\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\t\n\t\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar nbVertices = vertices.length;\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LineSegments( geometry, material ) {\n\t\n\t\t\tLine.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'LineSegments';\n\t\n\t\t}\n\t\n\t\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\t\n\t\t\tconstructor: LineSegments,\n\t\n\t\t\tisLineSegments: true,\n\t\n\t\t\tcomputeLineDistances: ( function () {\n\t\n\t\t\t\tvar start = new Vector3();\n\t\t\t\tvar end = new Vector3();\n\t\n\t\t\t\treturn function computeLineDistances() {\n\t\n\t\t\t\t\tvar geometry = this.geometry;\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\t// we assume non-indexed geometry\n\t\n\t\t\t\t\t\tif ( geometry.index === null ) {\n\t\n\t\t\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\t\t\tvar lineDistances = [];\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i + 1 );\n\t\n\t\t\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new THREE.Float32BufferAttribute( lineDistances, 1 ) );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( geometry.isGeometry ) {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar lineDistances = geometry.lineDistances;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\t\t\tstart.copy( vertices[ i ] );\n\t\t\t\t\t\t\tend.copy( vertices[ i + 1 ] );\n\t\n\t\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}() )\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mgreter / http://github.com/mgreter\n\t\t */\n\t\n\t\tfunction LineLoop( geometry, material ) {\n\t\n\t\t\tLine.call( this, geometry, material );\n\t\n\t\t\tthis.type = 'LineLoop';\n\t\n\t\t}\n\t\n\t\tLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\n\t\n\t\t\tconstructor: LineLoop,\n\t\n\t\t\tisLineLoop: true,\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  size: <float>,\n\t\t *  sizeAttenuation: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction PointsMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'PointsMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff );\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tPointsMaterial.prototype = Object.create( Material.prototype );\n\t\tPointsMaterial.prototype.constructor = PointsMaterial;\n\t\n\t\tPointsMaterial.prototype.isPointsMaterial = true;\n\t\n\t\tPointsMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Points( geometry, material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Points';\n\t\n\t\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\t}\n\t\n\t\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Points,\n\t\n\t\t\tisPoints: true,\n\t\n\t\t\traycast: ( function () {\n\t\n\t\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\t\tvar ray = new Ray();\n\t\t\t\tvar sphere = new Sphere();\n\t\n\t\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\t\tvar object = this;\n\t\t\t\t\tvar geometry = this.geometry;\n\t\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\t\n\t\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\t\t\t\tsphere.radius += threshold;\n\t\n\t\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\t\tfunction testPoint( point, index ) {\n\t\n\t\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\t\n\t\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\t\n\t\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tobject: object\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, a );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\t\n\t\t\t\t\t\t\t\ttestPoint( position, i );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Group() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Group';\n\t\n\t\t}\n\t\n\t\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Group,\n\t\n\t\t\tisGroup: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t}\n\t\n\t\tVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\n\t\n\t\t\tconstructor: VideoTexture,\n\t\n\t\t\tisVideoTexture: true,\n\t\n\t\t\tupdate: function () {\n\t\n\t\t\t\tvar video = this.image;\n\t\n\t\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\t\n\t\t\t\t\tthis.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\t\tthis.mipmaps = mipmaps;\n\t\n\t\t\t// no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\t\n\t\t\tthis.flipY = false;\n\t\n\t\t\t// can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\t\n\t\t\tthis.generateMipmaps = false;\n\t\n\t\t}\n\t\n\t\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\t\tCompressedTexture.prototype.constructor = CompressedTexture;\n\t\n\t\tCompressedTexture.prototype.isCompressedTexture = true;\n\t\n\t\t/**\n\t\t * @author Matt DesLauriers / @mattdesl\n\t\t * @author atix / arthursilber.de\n\t\t */\n\t\n\t\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\t\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\t\n\t\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\t\n\t\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n\t\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\t\n\t\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\t\tthis.image = { width: width, height: height };\n\t\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps\t= false;\n\t\n\t\t}\n\t\n\t\tDepthTexture.prototype = Object.create( Texture.prototype );\n\t\tDepthTexture.prototype.constructor = DepthTexture;\n\t\tDepthTexture.prototype.isDepthTexture = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction WireframeGeometry( geometry ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'WireframeGeometry';\n\t\n\t\t\t// buffer\n\t\n\t\t\tvar vertices = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar i, j, l, o, ol;\n\t\t\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\n\t\t\tvar key, keys = [ 'a', 'b', 'c' ];\n\t\t\tvar vertex;\n\t\n\t\t\t// different logic for Geometry and BufferGeometry\n\t\n\t\t\tif ( geometry && geometry.isGeometry ) {\n\t\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\t\n\t\t\t\tvar faces = geometry.faces;\n\t\n\t\t\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\t\n\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\t\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate vertices\n\t\n\t\t\t\tfor ( key in edges ) {\n\t\n\t\t\t\t\te = edges[ key ];\n\t\n\t\t\t\t\tvertex = geometry.vertices[ e.index1 ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\tvertex = geometry.vertices[ e.index2 ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( geometry && geometry.isBufferGeometry ) {\n\t\n\t\t\t\tvar position, indices, groups;\n\t\t\t\tvar group, start, count;\n\t\t\t\tvar index1, index2;\n\t\n\t\t\t\tvertex = new Vector3();\n\t\n\t\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t\t// indexed BufferGeometry\n\t\n\t\t\t\t\tposition = geometry.attributes.position;\n\t\t\t\t\tindices = geometry.index;\n\t\t\t\t\tgroups = geometry.groups;\n\t\n\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// create a data structure that contains all eges without duplicates\n\t\n\t\t\t\t\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\n\t\n\t\t\t\t\t\tgroup = groups[ o ];\n\t\n\t\t\t\t\t\tstart = group.start;\n\t\t\t\t\t\tcount = group.count;\n\t\n\t\t\t\t\t\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tedge1 = indices.getX( i + j );\n\t\t\t\t\t\t\t\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\t\n\t\t\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// generate vertices\n\t\n\t\t\t\t\tfor ( key in edges ) {\n\t\n\t\t\t\t\t\te = edges[ key ];\n\t\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// non-indexed BufferGeometry\n\t\n\t\t\t\t\tposition = geometry.attributes.position;\n\t\n\t\t\t\t\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\t\n\t\t\t\t\t\t\tindex1 = 3 * i + j;\n\t\t\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\t\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\n\t\t}\n\t\n\t\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\t\n\t\t/**\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Parametric Surfaces Geometry\n\t\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t\t */\n\t\n\t\t// ParametricGeometry\n\t\n\t\tfunction ParametricGeometry( func, slices, stacks ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\t\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\t\n\t\t// ParametricBufferGeometry\n\t\n\t\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'ParametricBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t};\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\tvar EPS = 0.00001;\n\t\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\tvar p0 = new Vector3(), p1 = new Vector3();\n\t\t\tvar pu = new Vector3(), pv = new Vector3();\n\t\n\t\t\tvar i, j;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tvar sliceCount = slices + 1;\n\t\n\t\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\t\n\t\t\t\tvar v = i / stacks;\n\t\n\t\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\t\n\t\t\t\t\tvar u = j / slices;\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tp0 = func( u, v, p0 );\n\t\t\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\t// approximate tangent vectors via finite differences\n\t\n\t\t\t\t\tif ( u - EPS >= 0 ) {\n\t\n\t\t\t\t\t\tp1 = func( u - EPS, v, p1 );\n\t\t\t\t\t\tpu.subVectors( p0, p1 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tp1 = func( u + EPS, v, p1 );\n\t\t\t\t\t\tpu.subVectors( p1, p0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( v - EPS >= 0 ) {\n\t\n\t\t\t\t\t\tp1 = func( u, v - EPS, p1 );\n\t\t\t\t\t\tpv.subVectors( p0, p1 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tp1 = func( u, v + EPS, p1 );\n\t\t\t\t\t\tpv.subVectors( p1, p0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// cross product of tangent vectors returns surface normal\n\t\n\t\t\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuvs.push( u, v );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( i = 0; i < stacks; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\t\n\t\t\t\t\tvar a = i * sliceCount + j;\n\t\t\t\t\tvar b = i * sliceCount + j + 1;\n\t\t\t\t\tvar c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\t\tvar d = ( i + 1 ) * sliceCount + j;\n\t\n\t\t\t\t\t// faces one and two\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\t\n\t\t/**\n\t\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// PolyhedronGeometry\n\t\n\t\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\t\n\t\t// PolyhedronBufferGeometry\n\t\n\t\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'PolyhedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\tdetail = detail || 0;\n\t\n\t\t\t// default buffer data\n\t\n\t\t\tvar vertexBuffer = [];\n\t\t\tvar uvBuffer = [];\n\t\n\t\t\t// the subdivision creates the vertex buffer data\n\t\n\t\t\tsubdivide( detail );\n\t\n\t\t\t// all vertices should lie on a conceptual sphere with a given radius\n\t\n\t\t\tappplyRadius( radius );\n\t\n\t\t\t// finally, create the uv data\n\t\n\t\t\tgenerateUVs();\n\t\n\t\t\t// build non-indexed geometry\n\t\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\t\n\t\t\tif ( detail === 0 ) {\n\t\n\t\t\t\tthis.computeVertexNormals(); // flat normals\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.normalizeNormals(); // smooth normals\n\t\n\t\t\t}\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction subdivide( detail ) {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\t\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t// get the vertices of the face\n\t\n\t\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\t\n\t\t\t\t\t// perform subdivision\n\t\n\t\t\t\t\tsubdivideFace( a, b, c, detail );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction subdivideFace( a, b, c, detail ) {\n\t\n\t\t\t\tvar cols = Math.pow( 2, detail );\n\t\n\t\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\t\n\t\t\t\tvar v = [];\n\t\n\t\t\t\tvar i, j;\n\t\n\t\t\t\t// construct all of the vertices for this subdivision\n\t\n\t\t\t\tfor ( i = 0; i <= cols; i ++ ) {\n\t\n\t\t\t\t\tv[ i ] = [];\n\t\n\t\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\t\n\t\t\t\t\tvar rows = cols - i;\n\t\n\t\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\t\n\t\t\t\t\t\tif ( j === 0 && i === cols ) {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// construct all of the faces\n\t\n\t\t\t\tfor ( i = 0; i < cols; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\t\n\t\t\t\t\t\tvar k = Math.floor( j / 2 );\n\t\n\t\t\t\t\t\tif ( j % 2 === 0 ) {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction appplyRadius( radius ) {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\t\n\t\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\t\n\t\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\t\n\t\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push( u, 1 - v );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcorrectUVs();\n\t\n\t\t\t\tcorrectSeam();\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctSeam() {\n\t\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\n\t\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\t\n\t\t\t\t\t// uv data of a single face\n\t\n\t\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\t\n\t\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\t\n\t\t\t\t\t// 0.9 is somewhat arbitrary\n\t\n\t\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\t\n\t\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction pushVertex( vertex ) {\n\t\n\t\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t}\n\t\n\t\t\tfunction getVertexByIndex( index, vertex ) {\n\t\n\t\t\t\tvar stride = index * 3;\n\t\n\t\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\t\tvertex.z = vertices[ stride + 2 ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUVs() {\n\t\n\t\t\t\tvar a = new Vector3();\n\t\t\t\tvar b = new Vector3();\n\t\t\t\tvar c = new Vector3();\n\t\n\t\t\t\tvar centroid = new Vector3();\n\t\n\t\t\t\tvar uvA = new Vector2();\n\t\t\t\tvar uvB = new Vector2();\n\t\t\t\tvar uvC = new Vector2();\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\t\n\t\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\t\n\t\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\t\n\t\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\t\n\t\t\t\t\tvar azi = azimuth( centroid );\n\t\n\t\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\t\n\t\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\t\n\t\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\t\n\t\t\tfunction azimuth( vector ) {\n\t\n\t\t\t\treturn Math.atan2( vector.z, - vector.x );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Angle above the XZ plane.\n\t\n\t\t\tfunction inclination( vector ) {\n\t\n\t\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// TetrahedronGeometry\n\t\n\t\tfunction TetrahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\t\n\t\t// TetrahedronBufferGeometry\n\t\n\t\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'TetrahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// OctahedronGeometry\n\t\n\t\tfunction OctahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\t\n\t\t// OctahedronBufferGeometry\n\t\n\t\tfunction OctahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar vertices = [\n\t\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t\t1, 3, 4,\t1, 4, 2\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'OctahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author timothypratley / https://github.com/timothypratley\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// IcosahedronGeometry\n\t\n\t\tfunction IcosahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\t\n\t\t// IcosahedronBufferGeometry\n\t\n\t\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\n\t\t\tvar vertices = [\n\t\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t\t 0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\t\t t, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t 0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t\t 1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t\t 3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t\t 4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'IcosahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Abe Pazos / https://hamoid.com\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// DodecahedronGeometry\n\t\n\t\tfunction DodecahedronGeometry( radius, detail ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\t\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\t\n\t\t// DodecahedronBufferGeometry\n\t\n\t\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\t\n\t\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\t\tvar r = 1 / t;\n\t\n\t\t\tvar vertices = [\n\t\n\t\t\t\t// (1, 1, 1)\n\t\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t\t1, 1, - 1, 1, 1, 1,\n\t\n\t\t\t\t// (0, 1/, )\n\t\t\t\t 0, - r, - t, 0, - r, t,\n\t\t\t\t 0, r, - t, 0, r, t,\n\t\n\t\t\t\t// (1/, , 0)\n\t\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\t\t r, - t, 0, r, t, 0,\n\t\n\t\t\t\t// (, 0, 1/)\n\t\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t\t- t, 0, r, t, 0, r\n\t\t\t];\n\t\n\t\t\tvar indices = [\n\t\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t\t];\n\t\n\t\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\t\tthis.type = 'DodecahedronBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\t\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t\t * @author WestLangley / https://github.com/WestLangley\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author miningold / https://github.com/miningold\n\t\t * @author jonobr1 / https://github.com/jonobr1\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t */\n\t\n\t\t// TubeGeometry\n\t\n\t\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\t\n\t\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = bufferGeometry.tangents;\n\t\t\tthis.normals = bufferGeometry.normals;\n\t\t\tthis.binormals = bufferGeometry.binormals;\n\t\n\t\t\t// create geometry\n\t\n\t\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTubeGeometry.prototype.constructor = TubeGeometry;\n\t\n\t\t// TubeBufferGeometry\n\t\n\t\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TubeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\n\t\t\ttubularSegments = tubularSegments || 64;\n\t\t\tradius = radius || 1;\n\t\t\tradialSegments = radialSegments || 8;\n\t\t\tclosed = closed || false;\n\t\n\t\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\t\n\t\t\t// expose internals\n\t\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals;\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar P = new Vector3();\n\t\n\t\t\tvar i, j;\n\t\n\t\t\t// buffer\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\t\tvar indices = [];\n\t\n\t\t\t// create buffer data\n\t\n\t\t\tgenerateBufferData();\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t\t// functions\n\t\n\t\t\tfunction generateBufferData() {\n\t\n\t\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tgenerateSegment( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\t\n\t\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\t\n\t\t\t\t// uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\t\n\t\t\t\tgenerateUVs();\n\t\n\t\t\t\t// finally create faces\n\t\n\t\t\t\tgenerateIndices();\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateSegment( i ) {\n\t\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\n\t\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\t\n\t\t\t\t// retrieve corresponding normal and binormal\n\t\n\t\t\t\tvar N = frames.normals[ i ];\n\t\t\t\tvar B = frames.binormals[ i ];\n\t\n\t\t\t\t// generate normals and vertices for the current segment\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\tvar sin = Math.sin( v );\n\t\t\t\t\tvar cos = - Math.cos( v );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\t\tnormal.normalize();\n\t\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateIndices() {\n\t\n\t\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t\t// faces\n\t\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateUVs() {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\n\t\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * based on http://www.blackpawn.com/texts/pqtorus/\n\t\t */\n\t\n\t\t// TorusKnotGeometry\n\t\n\t\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\t\n\t\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\t\n\t\t// TorusKnotBufferGeometry\n\t\n\t\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusKnotBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\ttube = tube || 0.4;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\tp = p || 2;\n\t\t\tq = q || 3;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar i, j;\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\tvar P1 = new Vector3();\n\t\t\tvar P2 = new Vector3();\n\t\n\t\t\tvar B = new Vector3();\n\t\t\tvar T = new Vector3();\n\t\t\tvar N = new Vector3();\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\t\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\n\t\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\t\n\t\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\t\n\t\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\t\n\t\t\t\t// calculate orthonormal basis\n\t\n\t\t\t\tT.subVectors( P2, P1 );\n\t\t\t\tN.addVectors( P2, P1 );\n\t\t\t\tB.crossVectors( T, N );\n\t\t\t\tN.crossVectors( B, T );\n\t\n\t\t\t\t// normalize B, N. T can be ignored, we don't use it\n\t\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\t\n\t\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\t\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\t\tvar cy = tube * Math.sin( v );\n\t\n\t\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\t\n\t\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\n\t\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\t\tuvs.push( j / radialSegments );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t\t// faces\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t\t// this function calculates the current position on the torus curve\n\t\n\t\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\t\n\t\t\t\tvar cu = Math.cos( u );\n\t\t\t\tvar su = Math.sin( u );\n\t\t\t\tvar quOverP = q / p * u;\n\t\t\t\tvar cs = Math.cos( quOverP );\n\t\n\t\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\t\n\t\t/**\n\t\t * @author oosmoxiecode\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// TorusGeometry\n\t\n\t\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTorusGeometry.prototype.constructor = TorusGeometry;\n\t\n\t\t// TorusBufferGeometry\n\t\n\t\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'TorusBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\ttube = tube || 0.4;\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\t\tarc = arc || Math.PI * 2;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar center = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\t\tvertex.z = tube * Math.sin( v );\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\t\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\t\tuvs.push( j / radialSegments );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\n\t\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\t\n\t\t\t\t\t// faces\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t * Port from https://github.com/mapbox/earcut (v2.1.2)\n\t\t */\n\t\n\t\tvar Earcut = {\n\t\n\t\t\ttriangulate: function ( data, holeIndices, dim ) {\n\t\n\t\t\t\tdim = dim || 2;\n\t\n\t\t\t\tvar hasHoles = holeIndices && holeIndices.length,\n\t\t\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\n\t\t\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\n\t\t\t\t\ttriangles = [];\n\t\n\t\t\t\tif ( ! outerNode ) return triangles;\n\t\n\t\t\t\tvar minX, minY, maxX, maxY, x, y, invSize;\n\t\n\t\t\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\t\n\t\t\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\n\t\t\t\tif ( data.length > 80 * dim ) {\n\t\n\t\t\t\t\tminX = maxX = data[ 0 ];\n\t\t\t\t\tminY = maxY = data[ 1 ];\n\t\n\t\t\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\n\t\n\t\t\t\t\t\tx = data[ i ];\n\t\t\t\t\t\ty = data[ i + 1 ];\n\t\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\t\tif ( y > maxY ) maxY = y;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\n\t\t\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\n\t\n\t\t\t\treturn triangles;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// create a circular doubly linked list from polygon points in the specified winding order\n\t\n\t\tfunction linkedList( data, start, end, dim, clockwise ) {\n\t\n\t\t\tvar i, last;\n\t\n\t\t\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\t\n\t\t\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\t\n\t\t\t}\n\t\n\t\t\tif ( last && equals( last, last.next ) ) {\n\t\n\t\t\t\tremoveNode( last );\n\t\t\t\tlast = last.next;\n\t\n\t\t\t}\n\t\n\t\t\treturn last;\n\t\n\t\t}\n\t\n\t\t// eliminate colinear or duplicate points\n\t\n\t\tfunction filterPoints( start, end ) {\n\t\n\t\t\tif ( ! start ) return start;\n\t\t\tif ( ! end ) end = start;\n\t\n\t\t\tvar p = start, again;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tagain = false;\n\t\n\t\t\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\t\n\t\t\t\t\tremoveNode( p );\n\t\t\t\t\tp = end = p.prev;\n\t\t\t\t\tif ( p === p.next ) break;\n\t\t\t\t\tagain = true;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tp = p.next;\n\t\n\t\t\t\t}\n\t\n\t\t\t} while ( again || p !== end );\n\t\n\t\t\treturn end;\n\t\n\t\t}\n\t\n\t\t// main ear slicing loop which triangulates a polygon (given as a linked list)\n\t\n\t\tfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\t\n\t\t\tif ( ! ear ) return;\n\t\n\t\t\t// interlink polygon nodes in z-order\n\t\n\t\t\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\t\n\t\t\tvar stop = ear, prev, next;\n\t\n\t\t\t// iterate through ears, slicing them one by one\n\t\n\t\t\twhile ( ear.prev !== ear.next ) {\n\t\n\t\t\t\tprev = ear.prev;\n\t\t\t\tnext = ear.next;\n\t\n\t\t\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\t\n\t\t\t\t\t// cut off the triangle\n\t\t\t\t\ttriangles.push( prev.i / dim );\n\t\t\t\t\ttriangles.push( ear.i / dim );\n\t\t\t\t\ttriangles.push( next.i / dim );\n\t\n\t\t\t\t\tremoveNode( ear );\n\t\n\t\t\t\t\t// skipping the next vertice leads to less sliver triangles\n\t\t\t\t\tear = next.next;\n\t\t\t\t\tstop = next.next;\n\t\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tear = next;\n\t\n\t\t\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\n\t\t\t\tif ( ear === stop ) {\n\t\n\t\t\t\t\t// try filtering points and slicing again\n\t\n\t\t\t\t\tif ( ! pass ) {\n\t\n\t\t\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\t\n\t\t\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\t\n\t\t\t\t\t} else if ( pass === 1 ) {\n\t\n\t\t\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\n\t\t\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\t\n\t\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\t\n\t\t\t\t\t} else if ( pass === 2 ) {\n\t\n\t\t\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// check whether a polygon node forms a valid ear with adjacent nodes\n\t\n\t\tfunction isEar( ear ) {\n\t\n\t\t\tvar a = ear.prev,\n\t\t\t\tb = ear,\n\t\t\t\tc = ear.next;\n\t\n\t\t\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\t\n\t\t\t// now make sure we don't have other points inside the potential ear\n\t\t\tvar p = ear.next.next;\n\t\n\t\t\twhile ( p !== ear.prev ) {\n\t\n\t\t\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp = p.next;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t}\n\t\n\t\tfunction isEarHashed( ear, minX, minY, invSize ) {\n\t\n\t\t\tvar a = ear.prev,\n\t\t\t\tb = ear,\n\t\t\t\tc = ear.next;\n\t\n\t\t\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\t\n\t\t\t// triangle bbox; min & max are calculated like this for speed\n\t\n\t\t\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\n\t\t\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\n\t\t\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\n\t\t\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\n\t\n\t\t\t// z-order range for the current triangle bbox;\n\t\n\t\t\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\n\t\t\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\n\t\n\t\t\t// first look for points inside the triangle in increasing z-order\n\t\n\t\t\tvar p = ear.nextZ;\n\t\n\t\t\twhile ( p && p.z <= maxZ ) {\n\t\n\t\t\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\t\t\tp = p.nextZ;\n\t\n\t\t\t}\n\t\n\t\t\t// then look for points in decreasing z-order\n\t\n\t\t\tp = ear.prevZ;\n\t\n\t\t\twhile ( p && p.z >= minZ ) {\n\t\n\t\t\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\n\t\t\t\tp = p.prevZ;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t}\n\t\n\t\t// go through all polygon nodes and cure small local self-intersections\n\t\n\t\tfunction cureLocalIntersections( start, triangles, dim ) {\n\t\n\t\t\tvar p = start;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tvar a = p.prev, b = p.next.next;\n\t\n\t\t\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\t\n\t\t\t\t\ttriangles.push( a.i / dim );\n\t\t\t\t\ttriangles.push( p.i / dim );\n\t\t\t\t\ttriangles.push( b.i / dim );\n\t\n\t\t\t\t\t// remove two nodes involved\n\t\n\t\t\t\t\tremoveNode( p );\n\t\t\t\t\tremoveNode( p.next );\n\t\n\t\t\t\t\tp = start = b;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp = p.next;\n\t\n\t\t\t} while ( p !== start );\n\t\n\t\t\treturn p;\n\t\n\t\t}\n\t\n\t\t// try splitting polygon into two and triangulate them independently\n\t\n\t\tfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\t\n\t\t\t// look for a valid diagonal that divides the polygon into two\n\t\n\t\t\tvar a = start;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tvar b = a.next.next;\n\t\n\t\t\t\twhile ( b !== a.prev ) {\n\t\n\t\t\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\t\n\t\t\t\t\t\t// split the polygon in two by the diagonal\n\t\n\t\t\t\t\t\tvar c = splitPolygon( a, b );\n\t\n\t\t\t\t\t\t// filter colinear points around the cuts\n\t\n\t\t\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\t\t\tc = filterPoints( c, c.next );\n\t\n\t\t\t\t\t\t// run earcut on each half\n\t\n\t\t\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\n\t\t\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tb = b.next;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ta = a.next;\n\t\n\t\t\t} while ( a !== start );\n\t\n\t\t}\n\t\n\t\t// link every hole into the outer loop, producing a single-ring polygon without holes\n\t\n\t\tfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\t\n\t\t\tvar queue = [], i, len, start, end, list;\n\t\n\t\t\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\t\n\t\t\t\tstart = holeIndices[ i ] * dim;\n\t\t\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\t\t\tlist = linkedList( data, start, end, dim, false );\n\t\t\t\tif ( list === list.next ) list.steiner = true;\n\t\t\t\tqueue.push( getLeftmost( list ) );\n\t\n\t\t\t}\n\t\n\t\t\tqueue.sort( compareX );\n\t\n\t\t\t// process holes from left to right\n\t\n\t\t\tfor ( i = 0; i < queue.length; i ++ ) {\n\t\n\t\t\t\teliminateHole( queue[ i ], outerNode );\n\t\t\t\touterNode = filterPoints( outerNode, outerNode.next );\n\t\n\t\t\t}\n\t\n\t\t\treturn outerNode;\n\t\n\t\t}\n\t\n\t\tfunction compareX( a, b ) {\n\t\n\t\t\treturn a.x - b.x;\n\t\n\t\t}\n\t\n\t\t// find a bridge between vertices that connects hole with an outer ring and and link it\n\t\n\t\tfunction eliminateHole( hole, outerNode ) {\n\t\n\t\t\touterNode = findHoleBridge( hole, outerNode );\n\t\n\t\t\tif ( outerNode ) {\n\t\n\t\t\t\tvar b = splitPolygon( outerNode, hole );\n\t\n\t\t\t\tfilterPoints( b, b.next );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\n\t\n\t\tfunction findHoleBridge( hole, outerNode ) {\n\t\n\t\t\tvar p = outerNode,\n\t\t\t\thx = hole.x,\n\t\t\t\thy = hole.y,\n\t\t\t\tqx = - Infinity,\n\t\t\t\tm;\n\t\n\t\t\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t\t\t// segment's endpoint with lesser x will be potential connection point\n\t\n\t\t\tdo {\n\t\n\t\t\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\t\n\t\t\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\n\t\t\t\t\tif ( x <= hx && x > qx ) {\n\t\n\t\t\t\t\t\tqx = x;\n\t\n\t\t\t\t\t\tif ( x === hx ) {\n\t\n\t\t\t\t\t\t\tif ( hy === p.y ) return p;\n\t\t\t\t\t\t\tif ( hy === p.next.y ) return p.next;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp = p.next;\n\t\n\t\t\t} while ( p !== outerNode );\n\t\n\t\t\tif ( ! m ) return null;\n\t\n\t\t\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\n\t\n\t\t\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t\t\t// if there are no points found, we have a valid connection;\n\t\t\t// otherwise choose the point of the minimum angle with the ray as connection point\n\t\n\t\t\tvar stop = m,\n\t\t\t\tmx = m.x,\n\t\t\t\tmy = m.y,\n\t\t\t\ttanMin = Infinity,\n\t\t\t\ttan;\n\t\n\t\t\tp = m.next;\n\t\n\t\t\twhile ( p !== stop ) {\n\t\n\t\t\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\t\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\t\n\t\t\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\t\n\t\t\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\n\t\n\t\t\t\t\t\tm = p;\n\t\t\t\t\t\ttanMin = tan;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp = p.next;\n\t\n\t\t\t}\n\t\n\t\t\treturn m;\n\t\n\t\t}\n\t\n\t\t// interlink polygon nodes in z-order\n\t\n\t\tfunction indexCurve( start, minX, minY, invSize ) {\n\t\n\t\t\tvar p = start;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\t\t\tp.prevZ = p.prev;\n\t\t\t\tp.nextZ = p.next;\n\t\t\t\tp = p.next;\n\t\n\t\t\t} while ( p !== start );\n\t\n\t\t\tp.prevZ.nextZ = null;\n\t\t\tp.prevZ = null;\n\t\n\t\t\tsortLinked( p );\n\t\n\t\t}\n\t\n\t\t// Simon Tatham's linked list merge sort algorithm\n\t\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\t\n\t\tfunction sortLinked( list ) {\n\t\n\t\t\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tp = list;\n\t\t\t\tlist = null;\n\t\t\t\ttail = null;\n\t\t\t\tnumMerges = 0;\n\t\n\t\t\t\twhile ( p ) {\n\t\n\t\t\t\t\tnumMerges ++;\n\t\t\t\t\tq = p;\n\t\t\t\t\tpSize = 0;\n\t\n\t\t\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\t\n\t\t\t\t\t\tpSize ++;\n\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\tif ( ! q ) break;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tqSize = inSize;\n\t\n\t\t\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\t\n\t\t\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\t\n\t\t\t\t\t\t\te = p;\n\t\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\t\tpSize --;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\te = q;\n\t\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\t\tqSize --;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\t\t\telse list = e;\n\t\n\t\t\t\t\t\te.prevZ = tail;\n\t\t\t\t\t\ttail = e;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tp = q;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttail.nextZ = null;\n\t\t\t\tinSize *= 2;\n\t\n\t\t\t} while ( numMerges > 1 );\n\t\n\t\t\treturn list;\n\t\n\t\t}\n\t\n\t\t// z-order of a point given coords and inverse of the longer side of data bbox\n\t\n\t\tfunction zOrder( x, y, minX, minY, invSize ) {\n\t\n\t\t\t// coords are transformed into non-negative 15-bit integer range\n\t\n\t\t\tx = 32767 * ( x - minX ) * invSize;\n\t\t\ty = 32767 * ( y - minY ) * invSize;\n\t\n\t\t\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\t\t\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\t\t\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\t\t\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\t\n\t\t\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\t\t\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\t\t\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\t\t\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\t\n\t\t\treturn x | ( y << 1 );\n\t\n\t\t}\n\t\n\t\t// find the leftmost node of a polygon ring\n\t\n\t\tfunction getLeftmost( start ) {\n\t\n\t\t\tvar p = start, leftmost = start;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tif ( p.x < leftmost.x ) leftmost = p;\n\t\t\t\tp = p.next;\n\t\n\t\t\t} while ( p !== start );\n\t\n\t\t\treturn leftmost;\n\t\n\t\t}\n\t\n\t\t// check if a point lies within a convex triangle\n\t\n\t\tfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\t\n\t\t\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\n\t\t\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\n\t\t\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\n\t\n\t\t}\n\t\n\t\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\t\n\t\tfunction isValidDiagonal( a, b ) {\n\t\n\t\t\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\n\t\t\t\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\n\t\n\t\t}\n\t\n\t\t// signed area of a triangle\n\t\n\t\tfunction area( p, q, r ) {\n\t\n\t\t\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\t\n\t\t}\n\t\n\t\t// check if two points are equal\n\t\n\t\tfunction equals( p1, p2 ) {\n\t\n\t\t\treturn p1.x === p2.x && p1.y === p2.y;\n\t\n\t\t}\n\t\n\t\t// check if two segments intersect\n\t\n\t\tfunction intersects( p1, q1, p2, q2 ) {\n\t\n\t\t\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\n\t\t\t\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\n\t\n\t\t\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\n\t\t\t\t\t\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\n\t\n\t\t}\n\t\n\t\t// check if a polygon diagonal intersects any polygon segments\n\t\n\t\tfunction intersectsPolygon( a, b ) {\n\t\n\t\t\tvar p = a;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\t\t\t\t\t\tintersects( p, p.next, a, b ) ) {\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp = p.next;\n\t\n\t\t\t} while ( p !== a );\n\t\n\t\t\treturn false;\n\t\n\t\t}\n\t\n\t\t// check if a polygon diagonal is locally inside the polygon\n\t\n\t\tfunction locallyInside( a, b ) {\n\t\n\t\t\treturn area( a.prev, a, a.next ) < 0 ?\n\t\t\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\t\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\t\n\t\t}\n\t\n\t\t// check if the middle point of a polygon diagonal is inside the polygon\n\t\n\t\tfunction middleInside( a, b ) {\n\t\n\t\t\tvar p = a,\n\t\t\t\tinside = false,\n\t\t\t\tpx = ( a.x + b.x ) / 2,\n\t\t\t\tpy = ( a.y + b.y ) / 2;\n\t\n\t\t\tdo {\n\t\n\t\t\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t\t\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\n\t\n\t\t\t\t\tinside = ! inside;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp = p.next;\n\t\n\t\t\t} while ( p !== a );\n\t\n\t\t\treturn inside;\n\t\n\t\t}\n\t\n\t\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n\t\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\t\n\t\tfunction splitPolygon( a, b ) {\n\t\n\t\t\tvar a2 = new Node( a.i, a.x, a.y ),\n\t\t\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\t\t\tan = a.next,\n\t\t\t\tbp = b.prev;\n\t\n\t\t\ta.next = b;\n\t\t\tb.prev = a;\n\t\n\t\t\ta2.next = an;\n\t\t\tan.prev = a2;\n\t\n\t\t\tb2.next = a2;\n\t\t\ta2.prev = b2;\n\t\n\t\t\tbp.next = b2;\n\t\t\tb2.prev = bp;\n\t\n\t\t\treturn b2;\n\t\n\t\t}\n\t\n\t\t// create a node and optionally link it with previous one (in a circular doubly linked list)\n\t\n\t\tfunction insertNode( i, x, y, last ) {\n\t\n\t\t\tvar p = new Node( i, x, y );\n\t\n\t\t\tif ( ! last ) {\n\t\n\t\t\t\tp.prev = p;\n\t\t\t\tp.next = p;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tp.next = last.next;\n\t\t\t\tp.prev = last;\n\t\t\t\tlast.next.prev = p;\n\t\t\t\tlast.next = p;\n\t\n\t\t\t}\n\t\n\t\t\treturn p;\n\t\n\t\t}\n\t\n\t\tfunction removeNode( p ) {\n\t\n\t\t\tp.next.prev = p.prev;\n\t\t\tp.prev.next = p.next;\n\t\n\t\t\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\t\t\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\t\n\t\t}\n\t\n\t\tfunction Node( i, x, y ) {\n\t\n\t\t\t// vertice index in coordinates array\n\t\t\tthis.i = i;\n\t\n\t\t\t// vertex coordinates\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\n\t\t\t// previous and next vertice nodes in a polygon ring\n\t\t\tthis.prev = null;\n\t\t\tthis.next = null;\n\t\n\t\t\t// z-order curve value\n\t\t\tthis.z = null;\n\t\n\t\t\t// previous and next nodes in z-order\n\t\t\tthis.prevZ = null;\n\t\t\tthis.nextZ = null;\n\t\n\t\t\t// indicates whether this is a steiner point\n\t\t\tthis.steiner = false;\n\t\n\t\t}\n\t\n\t\tfunction signedArea( data, start, end, dim ) {\n\t\n\t\t\tvar sum = 0;\n\t\n\t\t\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\n\t\n\t\t\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\t\t\tj = i;\n\t\n\t\t\t}\n\t\n\t\t\treturn sum;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t */\n\t\n\t\tvar ShapeUtils = {\n\t\n\t\t\t// calculate area of the contour polygon\n\t\n\t\t\tarea: function ( contour ) {\n\t\n\t\t\t\tvar n = contour.length;\n\t\t\t\tvar a = 0.0;\n\t\n\t\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\t\n\t\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn a * 0.5;\n\t\n\t\t\t},\n\t\n\t\t\tisClockWise: function ( pts ) {\n\t\n\t\t\t\treturn ShapeUtils.area( pts ) < 0;\n\t\n\t\t\t},\n\t\n\t\t\ttriangulateShape: function ( contour, holes ) {\n\t\n\t\t\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\t\t\tvar holeIndices = []; // array of hole indices\n\t\t\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\t\n\t\t\t\tremoveDupEndPts( contour );\n\t\t\t\taddContour( vertices, contour );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar holeIndex = contour.length;\n\t\n\t\t\t\tholes.forEach( removeDupEndPts );\n\t\n\t\t\t\tfor ( var i = 0; i < holes.length; i ++ ) {\n\t\n\t\t\t\t\tholeIndices.push( holeIndex );\n\t\t\t\t\tholeIndex += holes[ i ].length;\n\t\t\t\t\taddContour( vertices, holes[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\n\t\n\t\t\t\t//\n\t\n\t\t\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\n\t\n\t\t\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn faces;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction removeDupEndPts( points ) {\n\t\n\t\t\tvar l = points.length;\n\t\n\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\tpoints.pop();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction addContour( vertices, contour ) {\n\t\n\t\t\tfor ( var i = 0; i < contour.length; i ++ ) {\n\t\n\t\t\t\tvertices.push( contour[ i ].x );\n\t\t\t\tvertices.push( contour[ i ].y );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t * Creates extruded geometry from a path shape.\n\t\t *\n\t\t * parameters = {\n\t\t *\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t\t *  amount: <int>, // Depth to extrude the shape\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t\t *  bevelSegments: <int>, // number of bevel layers\n\t\t *\n\t\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\n\t\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t\t *\n\t\t *  UVGenerator: <Object> // object that provides UV generator functions\n\t\t *\n\t\t * }\n\t\t */\n\t\n\t\t// ExtrudeGeometry\n\t\n\t\tfunction ExtrudeGeometry( shapes, options ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\toptions: options\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\t\n\t\t// ExtrudeBufferGeometry\n\t\n\t\tfunction ExtrudeBufferGeometry( shapes, options ) {\n\t\n\t\t\tif ( typeof ( shapes ) === \"undefined\" ) {\n\t\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'ExtrudeBufferGeometry';\n\t\n\t\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\t\n\t\t\tthis.addShapeList( shapes, options );\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t\t// can't really use automatic vertex normals\n\t\t\t// as then front and back sides get smoothed too\n\t\t\t// should do separate smoothing just for sides\n\t\n\t\t\t//this.computeVertexNormals();\n\t\n\t\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\t\n\t\t}\n\t\n\t\tExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\t\n\t\tExtrudeBufferGeometry.prototype.getArrays = function () {\n\t\n\t\t\tvar positionAttribute = this.getAttribute( \"position\" );\n\t\t\tvar verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];\n\t\n\t\t\tvar uvAttribute = this.getAttribute( \"uv\" );\n\t\t\tvar uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];\n\t\n\t\t\tvar IndexAttribute = this.index;\n\t\t\tvar indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];\n\t\n\t\t\treturn {\n\t\t\t\tposition: verticesArray,\n\t\t\t\tuv: uvArray,\n\t\t\t\tindex: indicesArray\n\t\t\t};\n\t\n\t\t};\n\t\n\t\tExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\t\tvar sl = shapes.length;\n\t\t\toptions.arrays = this.getArrays();\n\t\n\t\t\tfor ( var s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\tvar shape = shapes[ s ];\n\t\t\t\tthis.addShape( shape, options );\n\t\n\t\t\t}\n\t\n\t\t\tthis.setIndex( options.arrays.index );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );\n\t\n\t\t};\n\t\n\t\tExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\t\tvar arrays = options.arrays ? options.arrays : this.getArrays();\n\t\t\tvar verticesArray = arrays.position;\n\t\t\tvar indicesArray = arrays.index;\n\t\t\tvar uvArray = arrays.uv;\n\t\n\t\t\tvar placeholder = [];\n\t\n\t\n\t\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\t\n\t\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\n\t\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\t\n\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\n\t\t\tvar extrudePath = options.extrudePath;\n\t\t\tvar extrudePts, extrudeByPath = false;\n\t\n\t\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\t\n\t\t\tvar splineTube, binormal, normal, position2;\n\t\t\tif ( extrudePath ) {\n\t\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\t\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\n\t\t\t\t// SETUP TNB variables\n\t\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\t\n\t\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\t\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\t\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\t\n\t\t\t}\n\t\n\t\t\t// Safeguards if bevels are not enabled\n\t\n\t\t\tif ( ! bevelEnabled ) {\n\t\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\n\t\t\t}\n\t\n\t\t\t// Variables initialization\n\t\n\t\t\tvar ahole, h, hl; // looping of holes\n\t\t\tvar scope = this;\n\t\n\t\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\t\tvar vertices = shapePoints.shape;\n\t\t\tvar holes = shapePoints.holes;\n\t\n\t\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\t\n\t\t\tif ( reverse ) {\n\t\n\t\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\t\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t\t/* Vertices */\n\t\n\t\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\tvertices = vertices.concat( ahole );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\t\n\t\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\t\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\t\n\t\t\t}\n\t\n\t\t\tvar b, bs, t, z,\n\t\t\t\tvert, vlen = vertices.length,\n\t\t\t\tface, flen = faces.length;\n\t\n\t\n\t\t\t// Find directions for point movement\n\t\n\t\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\t\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\t\n\t\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\t\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\t\n\t\t\t\tvar v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tvar v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\t\n\t\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\t\n\t\t\t\t// check for collinear edges\n\t\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// not collinear\n\t\n\t\t\t\t\t// length of vectors for normalizing\n\t\n\t\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\t\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\t\n\t\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\t\n\t\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\t\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\t\n\t\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\t\t// vector from inPt to intersection point\n\t\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\t\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\t\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// handle special case of collinear edges\n\t\n\t\t\t\t\tvar direction_eq = false; // assumes: opposite\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\t\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( direction_eq ) {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar contourMovements = [];\n\t\n\t\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\t\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\t\n\t\t\t}\n\t\n\t\t\tvar holesMovements = [],\n\t\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\toneHoleMovements = [];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\t\n\t\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tbs = bevelSize;\n\t\n\t\t\t// Back facing vertices\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\t\n\t\t\tvar s;\n\t\n\t\t\tfor ( s = 1; s <= steps; s ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// Add bevel segments planes\n\t\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\t\n\t\t\t\tt = b / bevelSegments;\n\t\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\t\n\t\t\t\t// contract shape\n\t\n\t\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, amount + z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// expand holes\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y, amount + z );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t/* Faces */\n\t\n\t\t\t// Top and bottom faces\n\t\n\t\t\tbuildLidFaces();\n\t\n\t\t\t// Sides faces\n\t\n\t\t\tbuildSideFaces();\n\t\n\t\n\t\t\t/////  Internal functions\n\t\n\t\t\tfunction buildLidFaces() {\n\t\n\t\t\t\tvar start = verticesArray.length / 3;\n\t\n\t\t\t\tif ( bevelEnabled ) {\n\t\n\t\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\t\tvar offset = vlen * layer;\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Bottom faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Top faces\n\t\n\t\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );\n\t\n\t\t\t}\n\t\n\t\t\t// Create faces for the z-sides of the shape\n\t\n\t\t\tfunction buildSideFaces() {\n\t\n\t\t\t\tvar start = verticesArray.length / 3;\n\t\t\t\tvar layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\t\n\t\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\t\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );\n\t\n\t\n\t\t\t}\n\t\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\t\n\t\t\t\tvar j, k;\n\t\t\t\ti = contour.length;\n\t\n\t\t\t\twhile ( -- i >= 0 ) {\n\t\n\t\t\t\t\tj = i;\n\t\t\t\t\tk = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\t\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\t\n\t\t\t\t\tvar s = 0,\n\t\t\t\t\t\tsl = steps + bevelSegments * 2;\n\t\n\t\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\t\n\t\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\n\t\t\t\t\t\tf4( a, b, c, d );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction v( x, y, z ) {\n\t\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction f3( a, b, c ) {\n\t\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\n\t\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\t\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\n\t\t\t}\n\t\n\t\t\tfunction f4( a, b, c, d ) {\n\t\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\t\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\t\n\t\n\t\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\t\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\t\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\t\n\t\t\t}\n\t\n\t\t\tfunction addVertex( index ) {\n\t\n\t\t\t\tindicesArray.push( verticesArray.length / 3 );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction addUV( vector2 ) {\n\t\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\t\n\t\t\t}\n\t\n\t\t\tif ( ! options.arrays ) {\n\t\n\t\t\t\tthis.setIndex( indicesArray );\n\t\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tExtrudeGeometry.WorldUVGenerator = {\n\t\n\t\t\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\t\n\t\t\t\tvar a_x = vertices[ indexA * 3 ];\n\t\t\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\t\t\tvar b_x = vertices[ indexB * 3 ];\n\t\t\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\t\t\tvar c_x = vertices[ indexC * 3 ];\n\t\t\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a_x, a_y ),\n\t\t\t\t\tnew Vector2( b_x, b_y ),\n\t\t\t\t\tnew Vector2( c_x, c_y )\n\t\t\t\t];\n\t\n\t\t\t},\n\t\n\t\t\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\t\n\t\t\t\tvar a_x = vertices[ indexA * 3 ];\n\t\t\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\t\t\tvar a_z = vertices[ indexA * 3 + 2 ];\n\t\t\t\tvar b_x = vertices[ indexB * 3 ];\n\t\t\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\t\t\tvar b_z = vertices[ indexB * 3 + 2 ];\n\t\t\t\tvar c_x = vertices[ indexC * 3 ];\n\t\t\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\t\t\t\tvar c_z = vertices[ indexC * 3 + 2 ];\n\t\t\t\tvar d_x = vertices[ indexD * 3 ];\n\t\t\t\tvar d_y = vertices[ indexD * 3 + 1 ];\n\t\t\t\tvar d_z = vertices[ indexD * 3 + 2 ];\n\t\n\t\t\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t\t\t];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t\t\t];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * Text = 3D Text\n\t\t *\n\t\t * parameters = {\n\t\t *  font: <THREE.Font>, // font\n\t\t *\n\t\t *  size: <float>, // size of the text\n\t\t *  height: <float>, // thickness to extrude text\n\t\t *  curveSegments: <int>, // number of points on the curves\n\t\t *\n\t\t *  bevelEnabled: <bool>, // turn on bevel\n\t\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t\t *  bevelSize: <float> // how far from text outline is bevel\n\t\t * }\n\t\t */\n\t\n\t\t// TextGeometry\n\t\n\t\tfunction TextGeometry( text, parameters ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'TextGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\ttext: text,\n\t\t\t\tparameters: parameters\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tTextGeometry.prototype = Object.create( Geometry.prototype );\n\t\tTextGeometry.prototype.constructor = TextGeometry;\n\t\n\t\t// TextBufferGeometry\n\t\n\t\tfunction TextBufferGeometry( text, parameters ) {\n\t\n\t\t\tparameters = parameters || {};\n\t\n\t\t\tvar font = parameters.font;\n\t\n\t\t\tif ( ! ( font && font.isFont ) ) {\n\t\n\t\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\t\treturn new Geometry();\n\t\n\t\t\t}\n\t\n\t\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\t\n\t\t\t// translate parameters to ExtrudeGeometry API\n\t\n\t\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\t\n\t\t\t// defaults\n\t\n\t\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\t\n\t\t\tExtrudeBufferGeometry.call( this, shapes, parameters );\n\t\n\t\t\tthis.type = 'TextBufferGeometry';\n\t\n\t\t}\n\t\n\t\tTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\n\t\tTextBufferGeometry.prototype.constructor = TextBufferGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// SphereGeometry\n\t\n\t\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\t\tSphereGeometry.prototype.constructor = SphereGeometry;\n\t\n\t\t// SphereBufferGeometry\n\t\n\t\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'SphereBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\n\t\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\t\n\t\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\t\n\t\t\tvar thetaEnd = thetaStart + thetaLength;\n\t\n\t\t\tvar ix, iy;\n\t\n\t\t\tvar index = 0;\n\t\t\tvar grid = [];\n\t\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar normal = new Vector3();\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\n\t\n\t\t\t\tvar verticesRow = [];\n\t\n\t\t\t\tvar v = iy / heightSegments;\n\t\n\t\t\t\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\n\t\n\t\t\t\t\tvar u = ix / widthSegments;\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuvs.push( u, 1 - v );\n\t\n\t\t\t\t\tverticesRow.push( index ++ );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgrid.push( verticesRow );\n\t\n\t\t\t}\n\t\n\t\t\t// indices\n\t\n\t\t\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\n\t\n\t\t\t\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\n\t\n\t\t\t\t\tvar a = grid[ iy ][ ix + 1 ];\n\t\t\t\t\tvar b = grid[ iy ][ ix ];\n\t\t\t\t\tvar c = grid[ iy + 1 ][ ix ];\n\t\t\t\t\tvar d = grid[ iy + 1 ][ ix + 1 ];\n\t\n\t\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\t\n\t\t/**\n\t\t * @author Kaleb Murphy\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// RingGeometry\n\t\n\t\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\t\tRingGeometry.prototype.constructor = RingGeometry;\n\t\n\t\t// RingBufferGeometry\n\t\n\t\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'RingBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tinnerRadius = innerRadius || 0.5;\n\t\t\touterRadius = outerRadius || 1;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// some helper variables\n\t\n\t\t\tvar segment;\n\t\t\tvar radius = innerRadius;\n\t\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar j, i;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\t\n\t\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\t\n\t\t\t\t\t// values are generate from the inside of the ring to the outside\n\t\n\t\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormals.push( 0, 0, 1 );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// increase the radius for next row of vertices\n\t\n\t\t\t\tradius += radiusStep;\n\t\n\t\t\t}\n\t\n\t\t\t// indices\n\t\n\t\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\t\n\t\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\t\n\t\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\t\n\t\t\t\t\tsegment = i + thetaSegmentLevel;\n\t\n\t\t\t\t\tvar a = segment;\n\t\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\t\tvar d = segment + 1;\n\t\n\t\t\t\t\t// faces\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\t\n\t\t/**\n\t\t * @author astrodud / http://astrodud.isgreat.org/\n\t\t * @author zz85 / https://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// LatheGeometry\n\t\n\t\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\t\tLatheGeometry.prototype.constructor = LatheGeometry;\n\t\n\t\t// LatheBufferGeometry\n\t\n\t\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'LatheBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\n\t\t\tsegments = Math.floor( segments ) || 12;\n\t\t\tphiStart = phiStart || 0;\n\t\t\tphiLength = phiLength || Math.PI * 2;\n\t\n\t\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\n\t\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\t\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar base;\n\t\t\tvar inverseSegments = 1.0 / segments;\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\t\tvar i, j;\n\t\n\t\t\t// generate vertices and uvs\n\t\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\t\n\t\t\t\tvar sin = Math.sin( phi );\n\t\t\t\tvar cos = Math.cos( phi );\n\t\n\t\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// indices\n\t\n\t\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t\tbase = j + i * points.length;\n\t\n\t\t\t\t\tvar a = base;\n\t\t\t\t\tvar b = base + points.length;\n\t\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\t\tvar d = base + 1;\n\t\n\t\t\t\t\t// faces\n\t\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t\t// generate normals\n\t\n\t\t\tthis.computeVertexNormals();\n\t\n\t\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\t\n\t\t\tif ( phiLength === Math.PI * 2 ) {\n\t\n\t\t\t\tvar normals = this.attributes.normal.array;\n\t\t\t\tvar n1 = new Vector3();\n\t\t\t\tvar n2 = new Vector3();\n\t\t\t\tvar n = new Vector3();\n\t\n\t\t\t\t// this is the buffer offset for the last line of vertices\n\t\n\t\t\t\tbase = segments * points.length * 3;\n\t\n\t\t\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\t\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\n\t\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\t\tn1.z = normals[ j + 2 ];\n\t\n\t\t\t\t\t// select the normal of the vertex in the last line\n\t\n\t\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\t\tn2.z = normals[ base + j + 2 ];\n\t\n\t\t\t\t\t// average normals\n\t\n\t\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\t\n\t\t\t\t\t// assign the new values to both normals\n\t\n\t\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\t\n\t\t/**\n\t\t * @author jonobr1 / http://jonobr1.com\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// ShapeGeometry\n\t\n\t\tfunction ShapeGeometry( shapes, curveSegments ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'ShapeGeometry';\n\t\n\t\t\tif ( typeof curveSegments === 'object' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\n\t\n\t\t\t\tcurveSegments = curveSegments.curveSegments;\n\t\n\t\t\t}\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\tcurveSegments: curveSegments\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\t\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\t\n\t\tShapeGeometry.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Geometry.prototype.toJSON.call( this );\n\t\n\t\t\tvar shapes = this.parameters.shapes;\n\t\n\t\t\treturn toJSON( shapes, data );\n\t\n\t\t};\n\t\n\t\t// ShapeBufferGeometry\n\t\n\t\tfunction ShapeBufferGeometry( shapes, curveSegments ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'ShapeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\tcurveSegments: curveSegments\n\t\t\t};\n\t\n\t\t\tcurveSegments = curveSegments || 12;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar groupStart = 0;\n\t\t\tvar groupCount = 0;\n\t\n\t\t\t// allow single and array values for \"shapes\" parameter\n\t\n\t\t\tif ( Array.isArray( shapes ) === false ) {\n\t\n\t\t\t\taddShape( shapes );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tfor ( var i = 0; i < shapes.length; i ++ ) {\n\t\n\t\t\t\t\taddShape( shapes[ i ] );\n\t\n\t\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\t\n\t\t\t\t\tgroupStart += groupCount;\n\t\t\t\t\tgroupCount = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\n\t\t\t// helper functions\n\t\n\t\t\tfunction addShape( shape ) {\n\t\n\t\t\t\tvar i, l, shapeHole;\n\t\n\t\t\t\tvar indexOffset = vertices.length / 3;\n\t\t\t\tvar points = shape.extractPoints( curveSegments );\n\t\n\t\t\t\tvar shapeVertices = points.shape;\n\t\t\t\tvar shapeHoles = points.holes;\n\t\n\t\t\t\t// check direction of vertices\n\t\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\t\n\t\t\t\t\tshapeVertices = shapeVertices.reverse();\n\t\n\t\t\t\t\t// also check if holes are in the opposite direction\n\t\n\t\t\t\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tshapeHole = shapeHoles[ i ];\n\t\n\t\t\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\t\n\t\t\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\t\n\t\t\t\t// join vertices of inner and outer paths to a single array\n\t\n\t\t\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tshapeHole = shapeHoles[ i ];\n\t\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// vertices, normals, uvs\n\t\n\t\t\t\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar vertex = shapeVertices[ i ];\n\t\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// incides\n\t\n\t\t\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tvar a = face[ 0 ] + indexOffset;\n\t\t\t\t\tvar b = face[ 1 ] + indexOffset;\n\t\t\t\t\tvar c = face[ 2 ] + indexOffset;\n\t\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\tgroupCount += 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\t\n\t\tShapeBufferGeometry.prototype.toJSON = function () {\n\t\n\t\t\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\t\n\t\t\tvar shapes = this.parameters.shapes;\n\t\n\t\t\treturn toJSON( shapes, data );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction toJSON( shapes, data ) {\n\t\n\t\t\tdata.shapes = [];\n\t\n\t\t\tif ( Array.isArray( shapes ) ) {\n\t\n\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar shape = shapes[ i ];\n\t\n\t\t\t\t\tdata.shapes.push( shape.uuid );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tdata.shapes.push( shapes.uuid );\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'EdgesGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tthresholdAngle: thresholdAngle\n\t\t\t};\n\t\n\t\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\t\n\t\t\t// buffer\n\t\n\t\t\tvar vertices = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\t\t\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\n\t\t\tvar key, keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\t// prepare source geometry\n\t\n\t\t\tvar geometry2;\n\t\n\t\t\tif ( geometry.isBufferGeometry ) {\n\t\n\t\t\t\tgeometry2 = new Geometry();\n\t\t\t\tgeometry2.fromBufferGeometry( geometry );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgeometry2 = geometry.clone();\n\t\n\t\t\t}\n\t\n\t\t\tgeometry2.mergeVertices();\n\t\t\tgeometry2.computeFaceNormals();\n\t\n\t\t\tvar sourceVertices = geometry2.vertices;\n\t\t\tvar faces = geometry2.faces;\n\t\n\t\t\t// now create a data structure where each entry represents an edge with its adjoining faces\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 );\n\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\t\n\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\t\n\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tedges[ key ].face2 = i;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// generate vertices\n\t\n\t\t\tfor ( key in edges ) {\n\t\n\t\t\t\tvar e = edges[ key ];\n\t\n\t\t\t\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\t\n\t\t\t\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\n\t\n\t\t\t\t\tvar vertex = sourceVertices[ e.index1 ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\tvertex = sourceVertices[ e.index2 ];\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\n\t\t}\n\t\n\t\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\t// CylinderGeometry\n\t\n\t\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\t\n\t\t// CylinderBufferGeometry\n\t\n\t\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CylinderBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\n\t\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n\t\t\theight = height || 1;\n\t\n\t\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\n\t\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar index = 0;\n\t\t\tvar indexArray = [];\n\t\t\tvar halfHeight = height / 2;\n\t\t\tvar groupStart = 0;\n\t\n\t\t\t// generate geometry\n\t\n\t\t\tgenerateTorso();\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t\tfunction generateTorso() {\n\t\n\t\t\t\tvar x, y;\n\t\t\t\tvar normal = new Vector3();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\t// this will be used to calculate the normal\n\t\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\t\n\t\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\t\tvar indexRow = [];\n\t\n\t\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\t\t// calculate the radius of the current row\n\t\n\t\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\t\n\t\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t\tvar u = x / radialSegments;\n\t\n\t\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\n\t\t\t\t\t\t// vertex\n\t\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t\t// normal\n\t\n\t\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t\t// uv\n\t\n\t\t\t\t\t\tuvs.push( u, 1 - v );\n\t\n\t\t\t\t\t\t// save index of vertex in respective row\n\t\n\t\t\t\t\t\tindexRow.push( index ++ );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// now save vertices of the row in our index array\n\t\n\t\t\t\t\tindexArray.push( indexRow );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\n\t\t\t\t\t\tvar a = indexArray[ y ][ x ];\n\t\t\t\t\t\tvar b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\t\tvar c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\t\tvar d = indexArray[ y ][ x + 1 ];\n\t\n\t\t\t\t\t\t// faces\n\t\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\n\t\t\t\t\t\t// update group counter\n\t\n\t\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\n\t\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t\tfunction generateCap( top ) {\n\t\n\t\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\t\n\t\t\t\tvar uv = new Vector2();\n\t\t\t\tvar vertex = new Vector3();\n\t\n\t\t\t\tvar groupCount = 0;\n\t\n\t\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\t\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tcenterIndexStart = index;\n\t\n\t\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\t\n\t\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormals.push( 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuvs.push( 0.5, 0.5 );\n\t\n\t\t\t\t\t// increase index\n\t\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// save the index of the last center vertex\n\t\n\t\t\t\tcenterIndexEnd = index;\n\t\n\t\t\t\t// now we generate the surrounding vertices, normals and uvs\n\t\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / radialSegments;\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\n\t\t\t\t\t// vertex\n\t\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\n\t\t\t\t\tnormals.push( 0, sign, 0 );\n\t\n\t\t\t\t\t// uv\n\t\n\t\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\t\t// increase index\n\t\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// generate indices\n\t\n\t\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\t\tvar i = centerIndexEnd + x;\n\t\n\t\t\t\t\tif ( top === true ) {\n\t\n\t\t\t\t\t\t// face top\n\t\n\t\t\t\t\t\tindices.push( i, i + 1, c );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// face bottom\n\t\n\t\t\t\t\t\tindices.push( i + 1, i, c );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgroupCount += 3;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\n\t\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\t\n\t\t\t\t// calculate new start value for groups\n\t\n\t\t\t\tgroupStart += groupCount;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\t\n\t\t/**\n\t\t * @author abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\t// ConeGeometry\n\t\n\t\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\t\tConeGeometry.prototype.constructor = ConeGeometry;\n\t\n\t\t// ConeBufferGeometry\n\t\n\t\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\t\n\t\t\tthis.type = 'ConeBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\t\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t * @author hughes\n\t\t */\n\t\n\t\t// CircleGeometry\n\t\n\t\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\t\tthis.mergeVertices();\n\t\n\t\t}\n\t\n\t\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\t\tCircleGeometry.prototype.constructor = CircleGeometry;\n\t\n\t\t// CircleBufferGeometry\n\t\n\t\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'CircleBufferGeometry';\n\t\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\n\t\t\tradius = radius || 1;\n\t\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\t\n\t\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\t\t// buffers\n\t\n\t\t\tvar indices = [];\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\t\t\tvar uvs = [];\n\t\n\t\t\t// helper variables\n\t\n\t\t\tvar i, s;\n\t\t\tvar vertex = new Vector3();\n\t\t\tvar uv = new Vector2();\n\t\n\t\t\t// center point\n\t\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tnormals.push( 0, 0, 1 );\n\t\t\tuvs.push( 0.5, 0.5 );\n\t\n\t\t\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\t\n\t\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\t\n\t\t\t\t// vertex\n\t\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal\n\t\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\n\t\t\t\t// uvs\n\t\n\t\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\t\n\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t}\n\t\n\t\t\t// indices\n\t\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\tindices.push( i, i + 1, 0 );\n\t\n\t\t\t}\n\t\n\t\t\t// build geometry\n\t\n\t\t\tthis.setIndex( indices );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\n\t\t}\n\t\n\t\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\t\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\t\n\t\n\t\n\t\tvar Geometries = Object.freeze({\n\t\t\tWireframeGeometry: WireframeGeometry,\n\t\t\tParametricGeometry: ParametricGeometry,\n\t\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\t\tOctahedronGeometry: OctahedronGeometry,\n\t\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\t\tTubeGeometry: TubeGeometry,\n\t\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\t\tTorusGeometry: TorusGeometry,\n\t\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\t\tTextGeometry: TextGeometry,\n\t\t\tTextBufferGeometry: TextBufferGeometry,\n\t\t\tSphereGeometry: SphereGeometry,\n\t\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\t\tRingGeometry: RingGeometry,\n\t\t\tRingBufferGeometry: RingBufferGeometry,\n\t\t\tPlaneGeometry: PlaneGeometry,\n\t\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\t\tLatheGeometry: LatheGeometry,\n\t\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\t\tShapeGeometry: ShapeGeometry,\n\t\t\tShapeBufferGeometry: ShapeBufferGeometry,\n\t\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\t\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\n\t\t\tEdgesGeometry: EdgesGeometry,\n\t\t\tConeGeometry: ConeGeometry,\n\t\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\t\tCylinderGeometry: CylinderGeometry,\n\t\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\t\tCircleGeometry: CircleGeometry,\n\t\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\t\tBoxGeometry: BoxGeometry,\n\t\t\tBoxBufferGeometry: BoxBufferGeometry\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <THREE.Color>,\n\t\t *  opacity: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction ShadowMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'ShadowMaterial';\n\t\n\t\t\tthis.color = new Color( 0x000000 );\n\t\t\tthis.opacity = 1.0;\n\t\n\t\t\tthis.lights = true;\n\t\t\tthis.transparent = true;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tShadowMaterial.prototype = Object.create( Material.prototype );\n\t\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\t\n\t\tShadowMaterial.prototype.isShadowMaterial = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction RawShaderMaterial( parameters ) {\n\t\n\t\t\tShaderMaterial.call( this, parameters );\n\t\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\n\t\t}\n\t\n\t\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\t\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\t\n\t\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  roughness: <float>,\n\t\t *  metalness: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  envMapIntensity: <float>\n\t\t *\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshStandardMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.roughness = 0.5;\n\t\t\tthis.metalness = 0.5;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.roughnessMap = null;\n\t\n\t\t\tthis.metalnessMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\t\n\t\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\t\n\t\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  reflectivity: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhysicalMaterial( parameters ) {\n\t\n\t\t\tMeshStandardMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\t\n\t\t\tthis.clearCoat = 0.0;\n\t\t\tthis.clearCoatRoughness = 0.0;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\t\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\t\n\t\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\t\n\t\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\n\t\t\tthis.clearCoat = source.clearCoat;\n\t\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  specular: <hex>,\n\t\t *  shininess: <float>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshPhongMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\t\tthis.specular = new Color( 0x111111 );\n\t\t\tthis.shininess = 30;\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\t\n\t\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\t\n\t\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.specular.copy( source.specular );\n\t\t\tthis.shininess = source.shininess;\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author takahirox / http://github.com/takahirox\n\t\t *\n\t\t * parameters = {\n\t\t *  gradientMap: new THREE.Texture( <Image> )\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshToonMaterial( parameters ) {\n\t\n\t\t\tMeshPhongMaterial.call( this );\n\t\n\t\t\tthis.defines = { 'TOON': '' };\n\t\n\t\t\tthis.type = 'MeshToonMaterial';\n\t\n\t\t\tthis.gradientMap = null;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\n\t\tMeshToonMaterial.prototype.constructor = MeshToonMaterial;\n\t\n\t\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\t\n\t\tMeshToonMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMeshPhongMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.gradientMap = source.gradientMap;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * parameters = {\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  bumpMap: new THREE.Texture( <Image> ),\n\t\t *  bumpScale: <float>,\n\t\t *\n\t\t *  normalMap: new THREE.Texture( <Image> ),\n\t\t *  normalScale: <Vector2>,\n\t\t *\n\t\t *  displacementMap: new THREE.Texture( <Image> ),\n\t\t *  displacementScale: <float>,\n\t\t *  displacementBias: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshNormalMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalScale = new Vector2( 1, 1 );\n\t\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\n\t\t\tthis.fog = false;\n\t\t\tthis.lights = false;\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\t\n\t\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\t\n\t\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  map: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  lightMap: new THREE.Texture( <Image> ),\n\t\t *  lightMapIntensity: <float>\n\t\t *\n\t\t *  aoMap: new THREE.Texture( <Image> ),\n\t\t *  aoMapIntensity: <float>\n\t\t *\n\t\t *  emissive: <hex>,\n\t\t *  emissiveIntensity: <float>\n\t\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  specularMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  alphaMap: new THREE.Texture( <Image> ),\n\t\t *\n\t\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t\t *  combine: THREE.Multiply,\n\t\t *  reflectivity: <float>,\n\t\t *  refractionRatio: <float>,\n\t\t *\n\t\t *  wireframe: <boolean>,\n\t\t *  wireframeLinewidth: <float>,\n\t\t *\n\t\t *  skinning: <bool>,\n\t\t *  morphTargets: <bool>,\n\t\t *  morphNormals: <bool>\n\t\t * }\n\t\t */\n\t\n\t\tfunction MeshLambertMaterial( parameters ) {\n\t\n\t\t\tMaterial.call( this );\n\t\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\n\t\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\n\t\t\tthis.map = null;\n\t\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\t\tthis.emissive = new Color( 0x000000 );\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\n\t\t\tthis.specularMap = null;\n\t\n\t\t\tthis.alphaMap = null;\n\t\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\t\tthis.skinning = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\t\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\t\n\t\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\t\n\t\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.map = source.map;\n\t\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\t\tthis.emissive.copy( source.emissive );\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\t\tthis.specularMap = source.specularMap;\n\t\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\t\tthis.skinning = source.skinning;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t *\n\t\t * parameters = {\n\t\t *  color: <hex>,\n\t\t *  opacity: <float>,\n\t\t *\n\t\t *  linewidth: <float>,\n\t\t *\n\t\t *  scale: <float>,\n\t\t *  dashSize: <float>,\n\t\t *  gapSize: <float>\n\t\t * }\n\t\t */\n\t\n\t\tfunction LineDashedMaterial( parameters ) {\n\t\n\t\t\tLineBasicMaterial.call( this );\n\t\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t\tLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\n\t\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\t\n\t\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\t\n\t\tLineDashedMaterial.prototype.copy = function ( source ) {\n\t\n\t\t\tLineBasicMaterial.prototype.copy.call( this, source );\n\t\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\n\t\tvar Materials = Object.freeze({\n\t\t\tShadowMaterial: ShadowMaterial,\n\t\t\tSpriteMaterial: SpriteMaterial,\n\t\t\tRawShaderMaterial: RawShaderMaterial,\n\t\t\tShaderMaterial: ShaderMaterial,\n\t\t\tPointsMaterial: PointsMaterial,\n\t\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\t\tMeshToonMaterial: MeshToonMaterial,\n\t\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\t\tMeshDistanceMaterial: MeshDistanceMaterial,\n\t\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\t\tLineDashedMaterial: LineDashedMaterial,\n\t\t\tLineBasicMaterial: LineBasicMaterial,\n\t\t\tMaterial: Material\n\t\t});\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar Cache = {\n\t\n\t\t\tenabled: false,\n\t\n\t\t\tfiles: {},\n\t\n\t\t\tadd: function ( key, file ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\t\n\t\t\t\tthis.files[ key ] = file;\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( key ) {\n\t\n\t\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\t\n\t\t\t\treturn this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tremove: function ( key ) {\n\t\n\t\t\t\tdelete this.files[ key ];\n\t\n\t\t\t},\n\t\n\t\t\tclear: function () {\n\t\n\t\t\t\tthis.files = {};\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar isLoading = false;\n\t\t\tvar itemsLoaded = 0;\n\t\t\tvar itemsTotal = 0;\n\t\t\tvar urlModifier = undefined;\n\t\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\t\n\t\t\tthis.itemStart = function ( url ) {\n\t\n\t\t\t\titemsTotal ++;\n\t\n\t\t\t\tif ( isLoading === false ) {\n\t\n\t\t\t\t\tif ( scope.onStart !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tisLoading = true;\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemEnd = function ( url ) {\n\t\n\t\t\t\titemsLoaded ++;\n\t\n\t\t\t\tif ( scope.onProgress !== undefined ) {\n\t\n\t\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( itemsLoaded === itemsTotal ) {\n\t\n\t\t\t\t\tisLoading = false;\n\t\n\t\t\t\t\tif ( scope.onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tscope.onLoad();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.itemError = function ( url ) {\n\t\n\t\t\t\tif ( scope.onError !== undefined ) {\n\t\n\t\t\t\t\tscope.onError( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.resolveURL = function ( url ) {\n\t\n\t\t\t\tif ( urlModifier ) {\n\t\n\t\t\t\t\treturn urlModifier( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn url;\n\t\n\t\t\t};\n\t\n\t\t\tthis.setURLModifier = function ( transform ) {\n\t\n\t\t\t\turlModifier = transform;\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tvar DefaultLoadingManager = new LoadingManager();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar loading = {};\n\t\n\t\tfunction FileLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( FileLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( url === undefined ) url = '';\n\t\n\t\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\t\turl = this.manager.resolveURL( url );\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar cached = Cache.get( url );\n\t\n\t\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\treturn cached;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Check if request is duplicate\n\t\n\t\t\t\tif ( loading[ url ] !== undefined ) {\n\t\n\t\t\t\t\tloading[ url ].push( {\n\t\n\t\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\t\tonError: onError\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Check for data: URI\n\t\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\t\n\t\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\t\tif ( dataUriRegexResult ) {\n\t\n\t\t\t\t\tvar mimeType = dataUriRegexResult[ 1 ];\n\t\t\t\t\tvar isBase64 = !! dataUriRegexResult[ 2 ];\n\t\t\t\t\tvar data = dataUriRegexResult[ 3 ];\n\t\n\t\t\t\t\tdata = window.decodeURIComponent( data );\n\t\n\t\t\t\t\tif ( isBase64 ) data = window.atob( data );\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tvar response;\n\t\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\t\n\t\t\t\t\t\tswitch ( responseType ) {\n\t\n\t\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\t\tcase 'blob':\n\t\n\t\t\t\t\t\t\t\tvar view = new Uint8Array( data.length );\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\t\n\t\t\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tresponse = view.buffer;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'document':\n\t\n\t\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'json':\n\t\n\t\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault: // 'text' or other\n\t\n\t\t\t\t\t\t\t\tresponse = data;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\t\twindow.setTimeout( function () {\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\t\twindow.setTimeout( function () {\n\t\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Initialise array for duplicate requests\n\t\n\t\t\t\t\tloading[ url ] = [];\n\t\n\t\t\t\t\tloading[ url ].push( {\n\t\n\t\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\t\tonError: onError\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t\tvar request = new XMLHttpRequest();\n\t\n\t\t\t\t\trequest.open( 'GET', url, true );\n\t\n\t\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\t\n\t\t\t\t\t\tvar response = this.response;\n\t\n\t\t\t\t\t\tCache.add( url, response );\n\t\n\t\t\t\t\t\tvar callbacks = loading[ url ];\n\t\n\t\t\t\t\t\tdelete loading[ url ];\n\t\n\t\t\t\t\t\tif ( this.status === 200 ) {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else if ( this.status === 0 ) {\n\t\n\t\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\t\tvar callbacks = loading[ url ];\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\t\t\tvar callbacks = loading[ url ];\n\t\n\t\t\t\t\t\tdelete loading[ url ];\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t}, false );\n\t\n\t\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\t\n\t\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\t\n\t\t\t\t\tfor ( var header in this.requestHeader ) {\n\t\n\t\t\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\trequest.send( null );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn request;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetResponseType: function ( value ) {\n\t\n\t\t\t\tthis.responseType = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\t\tthis.withCredentials = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetMimeType: function ( value ) {\n\t\n\t\t\t\tthis.mimeType = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetRequestHeader: function ( value ) {\n\t\n\t\t\t\tthis.requestHeader = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t *\n\t\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t\t */\n\t\n\t\tfunction CompressedTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( CompressedTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar images = [];\n\t\n\t\t\t\tvar texture = new CompressedTexture();\n\t\t\t\ttexture.image = images;\n\t\n\t\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\tloaded += 1;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( Array.isArray( url ) ) {\n\t\n\t\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\t\n\t\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\n\t\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\t\tif ( texDatas.isCubemap ) {\n\t\n\t\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\t\n\t\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\t\n\t\t\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\t\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Nikos M. / https://github.com/foo123/\n\t\t *\n\t\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t\t */\n\t\n\t\tfunction DataTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\t// override in sub classes\n\t\t\tthis._parser = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( DataTextureLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texture = new DataTexture();\n\t\n\t\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar texData = scope._parser( buffer );\n\t\n\t\t\t\t\tif ( ! texData ) return;\n\t\n\t\t\t\t\tif ( undefined !== texData.image ) {\n\t\n\t\t\t\t\t\ttexture.image = texData.image;\n\t\n\t\t\t\t\t} else if ( undefined !== texData.data ) {\n\t\n\t\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\t\ttexture.image.data = texData.data;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\t\n\t\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\t\n\t\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\t\n\t\t\t\t\tif ( undefined !== texData.format ) {\n\t\n\t\t\t\t\t\ttexture.format = texData.format;\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( undefined !== texData.type ) {\n\t\n\t\t\t\t\t\ttexture.type = texData.type;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\t\n\t\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\t\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ImageLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( ImageLoader.prototype, {\n\t\n\t\t\tcrossOrigin: 'Anonymous',\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( url === undefined ) url = '';\n\t\n\t\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\t\turl = this.manager.resolveURL( url );\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar cached = Cache.get( url );\n\t\n\t\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\treturn cached;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\n\t\t\t\timage.addEventListener( 'load', function () {\n\t\n\t\t\t\t\tCache.add( url, this );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( this );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t}, false );\n\t\n\t\t\t\t/*\n\t\t\t\timage.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\tif ( onProgress ) onProgress( event );\n\t\n\t\t\t\t}, false );\n\t\t\t\t*/\n\t\n\t\t\t\timage.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t}, false );\n\t\n\t\t\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\t\n\t\t\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\timage.src = url;\n\t\n\t\t\t\treturn image;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction CubeTextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( CubeTextureLoader.prototype, {\n\t\n\t\t\tcrossOrigin: 'Anonymous',\n\t\n\t\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new CubeTexture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setPath( this.path );\n\t\n\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\t\n\t\t\t\t\t\ttexture.images[ i ] = image;\n\t\n\t\t\t\t\t\tloaded ++;\n\t\n\t\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}, undefined, onError );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\t\n\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction TextureLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( TextureLoader.prototype, {\n\t\n\t\t\tcrossOrigin: 'Anonymous',\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar texture = new Texture();\n\t\n\t\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\t\tloader.setPath( this.path );\n\t\n\t\t\t\tloader.load( url, function ( image ) {\n\t\n\t\t\t\t\ttexture.image = image;\n\t\n\t\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\t\n\t\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) {\n\t\n\t\t\t\t\t\tonLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Extensible curve object\n\t\t *\n\t\t * Some common of curve methods:\n\t\t * .getPoint( t, optionalTarget ), .getTangent( t )\n\t\t * .getPointAt( u, optionalTarget ), .getTangentAt( u )\n\t\t * .getPoints(), .getSpacedPoints()\n\t\t * .getLength()\n\t\t * .updateArcLengths()\n\t\t *\n\t\t * This following curves inherit from THREE.Curve:\n\t\t *\n\t\t * -- 2D curves --\n\t\t * THREE.ArcCurve\n\t\t * THREE.CubicBezierCurve\n\t\t * THREE.EllipseCurve\n\t\t * THREE.LineCurve\n\t\t * THREE.QuadraticBezierCurve\n\t\t * THREE.SplineCurve\n\t\t *\n\t\t * -- 3D curves --\n\t\t * THREE.CatmullRomCurve3\n\t\t * THREE.CubicBezierCurve3\n\t\t * THREE.LineCurve3\n\t\t * THREE.QuadraticBezierCurve3\n\t\t *\n\t\t * A series of curves can be represented as a THREE.CurvePath.\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tAbstract Curve base class\n\t\t **************************************************************/\n\t\n\t\tfunction Curve() {\n\t\n\t\t\tthis.type = 'Curve';\n\t\n\t\t\tthis.arcLengthDivisions = 200;\n\t\n\t\t}\n\t\n\t\tObject.assign( Curve.prototype, {\n\t\n\t\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t\t//\t- t [0 .. 1]\n\t\n\t\t\tgetPoint: function ( /* t, optionalTarget */ ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// Get point at relative position in curve according to arc length\n\t\t\t// - u [0 .. 1]\n\t\n\t\t\tgetPointAt: function ( u, optionalTarget ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getPoint( t, optionalTarget );\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPoint( t )\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( divisions === undefined ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get sequence of points using getPointAt( u )\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( divisions === undefined ) divisions = 5;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\t// Get total curve arc length\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lengths = this.getLengths();\n\t\t\t\treturn lengths[ lengths.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// Get list of cumulative segment lengths\n\t\n\t\t\tgetLengths: function ( divisions ) {\n\t\n\t\t\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\t\n\t\t\t\tif ( this.cacheArcLengths &&\n\t\t\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t\t\t! this.needsUpdate ) {\n\t\n\t\t\t\t\treturn this.cacheArcLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.needsUpdate = false;\n\t\n\t\t\t\tvar cache = [];\n\t\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\t\tvar p, sum = 0;\n\t\n\t\t\t\tcache.push( 0 );\n\t\n\t\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\t\n\t\t\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\t\tcache.push( sum );\n\t\t\t\t\tlast = current;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheArcLengths = cache;\n\t\n\t\t\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\t\n\t\t\t},\n\t\n\t\t\tupdateArcLengths: function () {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.getLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\t\n\t\t\tgetUtoTmapping: function ( u, distance ) {\n\t\n\t\t\t\tvar arcLengths = this.getLengths();\n\t\n\t\t\t\tvar i = 0, il = arcLengths.length;\n\t\n\t\t\t\tvar targetArcLength; // The targeted u distance value to get\n\t\n\t\t\t\tif ( distance ) {\n\t\n\t\t\t\t\ttargetArcLength = distance;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// binary search for the index with largest value smaller than target u distance\n\t\n\t\t\t\tvar low = 0, high = il - 1, comparison;\n\t\n\t\t\t\twhile ( low <= high ) {\n\t\n\t\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\t\n\t\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\t\n\t\t\t\t\tif ( comparison < 0 ) {\n\t\n\t\t\t\t\t\tlow = i + 1;\n\t\n\t\t\t\t\t} else if ( comparison > 0 ) {\n\t\n\t\t\t\t\t\thigh = i - 1;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\thigh = i;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t// DONE\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\ti = high;\n\t\n\t\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\t\n\t\t\t\t\treturn i / ( il - 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\t\n\t\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\t\n\t\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\t\n\t\t\t\t// determine where we are between the 'before' and 'after' points\n\t\n\t\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\t\n\t\t\t\t// add that fractional amount to t\n\t\n\t\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\t\n\t\t\t\treturn t;\n\t\n\t\t\t},\n\t\n\t\t\t// Returns a unit vector tangent at t\n\t\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t\t// which seems to give a reasonable approximation\n\t\n\t\t\tgetTangent: function ( t ) {\n\t\n\t\t\t\tvar delta = 0.0001;\n\t\t\t\tvar t1 = t - delta;\n\t\t\t\tvar t2 = t + delta;\n\t\n\t\t\t\t// Capping in case of danger\n\t\n\t\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\t\tif ( t2 > 1 ) t2 = 1;\n\t\n\t\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\t\tvar pt2 = this.getPoint( t2 );\n\t\n\t\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\t\treturn vec.normalize();\n\t\n\t\t\t},\n\t\n\t\t\tgetTangentAt: function ( u ) {\n\t\n\t\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\t\treturn this.getTangent( t );\n\t\n\t\t\t},\n\t\n\t\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\t\n\t\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\n\t\t\t\tvar normal = new Vector3();\n\t\n\t\t\t\tvar tangents = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar binormals = [];\n\t\n\t\t\t\tvar vec = new Vector3();\n\t\t\t\tvar mat = new Matrix4();\n\t\n\t\t\t\tvar i, u, theta;\n\t\n\t\t\t\t// compute the tangent vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tu = i / segments;\n\t\n\t\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\t\ttangents[ i ].normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t\t// and in the direction of the minimum tangent xyz component\n\t\n\t\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\t\tvar min = Number.MAX_VALUE;\n\t\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\t\n\t\t\t\tif ( tx <= min ) {\n\t\n\t\t\t\t\tmin = tx;\n\t\t\t\t\tnormal.set( 1, 0, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ty <= min ) {\n\t\n\t\t\t\t\tmin = ty;\n\t\t\t\t\tnormal.set( 0, 1, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tz <= min ) {\n\t\n\t\t\t\t\tnormal.set( 0, 0, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\t\n\t\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\n\t\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\t\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\t\n\t\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\t\n\t\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\t\n\t\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tvec.normalize();\n\t\n\t\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\t\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\t\n\t\t\t\tif ( closed === true ) {\n\t\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\t\ttheta /= segments;\n\t\n\t\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\t\n\t\t\t\t\t\ttheta = - theta;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\t\n\t\t\t\t\t\t// twist a little...\n\t\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn {\n\t\t\t\t\ttangents: tangents,\n\t\t\t\t\tnormals: normals,\n\t\t\t\t\tbinormals: binormals\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\ttype: 'Curve',\n\t\t\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\t\t\tdata.type = this.type;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tfromJSON: function ( json ) {\n\t\n\t\t\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'EllipseCurve';\n\t\n\t\t\tthis.aX = aX || 0;\n\t\t\tthis.aY = aY || 0;\n\t\n\t\t\tthis.xRadius = xRadius || 1;\n\t\t\tthis.yRadius = yRadius || 1;\n\t\n\t\t\tthis.aStartAngle = aStartAngle || 0;\n\t\t\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\n\t\n\t\t\tthis.aClockwise = aClockwise || false;\n\t\n\t\t\tthis.aRotation = aRotation || 0;\n\t\n\t\t}\n\t\n\t\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\t\tEllipseCurve.prototype.constructor = EllipseCurve;\n\t\n\t\tEllipseCurve.prototype.isEllipseCurve = true;\n\t\n\t\tEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector2();\n\t\n\t\t\tvar twoPi = Math.PI * 2;\n\t\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\t\n\t\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\t\n\t\t\tif ( deltaAngle < Number.EPSILON ) {\n\t\n\t\t\t\tif ( samePoints ) {\n\t\n\t\t\t\t\tdeltaAngle = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.aClockwise === true && ! samePoints ) {\n\t\n\t\t\t\tif ( deltaAngle === twoPi ) {\n\t\n\t\t\t\t\tdeltaAngle = - twoPi;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\t\n\t\t\tif ( this.aRotation !== 0 ) {\n\t\n\t\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\t\tvar sin = Math.sin( this.aRotation );\n\t\n\t\t\t\tvar tx = x - this.aX;\n\t\t\t\tvar ty = y - this.aY;\n\t\n\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\n\t\t\t}\n\t\n\t\t\treturn point.set( x, y );\n\t\n\t\t};\n\t\n\t\tEllipseCurve.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.aX = source.aX;\n\t\t\tthis.aY = source.aY;\n\t\n\t\t\tthis.xRadius = source.xRadius;\n\t\t\tthis.yRadius = source.yRadius;\n\t\n\t\t\tthis.aStartAngle = source.aStartAngle;\n\t\t\tthis.aEndAngle = source.aEndAngle;\n\t\n\t\t\tthis.aClockwise = source.aClockwise;\n\t\n\t\t\tthis.aRotation = source.aRotation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\tEllipseCurve.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.aX = this.aX;\n\t\t\tdata.aY = this.aY;\n\t\n\t\t\tdata.xRadius = this.xRadius;\n\t\t\tdata.yRadius = this.yRadius;\n\t\n\t\t\tdata.aStartAngle = this.aStartAngle;\n\t\t\tdata.aEndAngle = this.aEndAngle;\n\t\n\t\t\tdata.aClockwise = this.aClockwise;\n\t\n\t\t\tdata.aRotation = this.aRotation;\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tEllipseCurve.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.aX = json.aX;\n\t\t\tthis.aY = json.aY;\n\t\n\t\t\tthis.xRadius = json.xRadius;\n\t\t\tthis.yRadius = json.yRadius;\n\t\n\t\t\tthis.aStartAngle = json.aStartAngle;\n\t\t\tthis.aEndAngle = json.aEndAngle;\n\t\n\t\t\tthis.aClockwise = json.aClockwise;\n\t\n\t\t\tthis.aRotation = json.aRotation;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\tthis.type = 'ArcCurve';\n\t\n\t\t}\n\t\n\t\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\t\tArcCurve.prototype.constructor = ArcCurve;\n\t\n\t\tArcCurve.prototype.isArcCurve = true;\n\t\n\t\t/**\n\t\t * @author zz85 https://github.com/zz85\n\t\t *\n\t\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t\t *\n\t\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t\t * curve.tension is used for catmullrom which defaults to 0.5\n\t\t */\n\t\n\t\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\t\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\t\n\t\tfunction CubicPoly() {\n\t\n\t\t\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\t\n\t\t\t/*\n\t\t\t * Compute coefficients for a cubic polynomial\n\t\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t\t * such that\n\t\t\t *   p(0) = x0, p(1) = x1\n\t\t\t *  and\n\t\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t\t */\n\t\t\tfunction init( x0, x1, t0, t1 ) {\n\t\n\t\t\t\tc0 = x0;\n\t\t\t\tc1 = t0;\n\t\t\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\n\t\t\t}\n\t\n\t\t\treturn {\n\t\n\t\t\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\t\n\t\t\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\t\n\t\t\t\t},\n\t\n\t\t\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\t\n\t\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\t\n\t\t\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\t\t\tt1 *= dt1;\n\t\t\t\t\tt2 *= dt1;\n\t\n\t\t\t\t\tinit( x1, x2, t1, t2 );\n\t\n\t\t\t\t},\n\t\n\t\t\t\tcalc: function ( t ) {\n\t\n\t\t\t\t\tvar t2 = t * t;\n\t\t\t\t\tvar t3 = t2 * t;\n\t\t\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar tmp = new Vector3();\n\t\tvar px = new CubicPoly();\n\t\tvar py = new CubicPoly();\n\t\tvar pz = new CubicPoly();\n\t\n\t\tfunction CatmullRomCurve3( points, closed, curveType, tension ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'CatmullRomCurve3';\n\t\n\t\t\tthis.points = points || [];\n\t\t\tthis.closed = closed || false;\n\t\t\tthis.curveType = curveType || 'centripetal';\n\t\t\tthis.tension = tension || 0.5;\n\t\n\t\t}\n\t\n\t\tCatmullRomCurve3.prototype = Object.create( Curve.prototype );\n\t\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\n\t\n\t\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\t\n\t\tCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector3();\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar l = points.length;\n\t\n\t\t\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tvar intPoint = Math.floor( p );\n\t\t\tvar weight = p - intPoint;\n\t\n\t\t\tif ( this.closed ) {\n\t\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\t\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\t\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\t\n\t\t\t}\n\t\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\t\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\t\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\t\n\t\t\t}\n\t\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\t\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\t\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\t\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\t\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\t\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\t\n\t\t\t} else if ( this.curveType === 'catmullrom' ) {\n\t\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\t\n\t\t\t}\n\t\n\t\t\tpoint.set(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\tCatmullRomCurve3.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.points = [];\n\t\n\t\t\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = source.points[ i ];\n\t\n\t\t\t\tthis.points.push( point.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tthis.closed = source.closed;\n\t\t\tthis.curveType = source.curveType;\n\t\t\tthis.tension = source.tension;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tCatmullRomCurve3.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.points = [];\n\t\n\t\t\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = this.points[ i ];\n\t\t\t\tdata.points.push( point.toArray() );\n\t\n\t\t\t}\n\t\n\t\t\tdata.closed = this.closed;\n\t\t\tdata.curveType = this.curveType;\n\t\t\tdata.tension = this.tension;\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tCatmullRomCurve3.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.points = [];\n\t\n\t\t\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = json.points[ i ];\n\t\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\t\n\t\t\t}\n\t\n\t\t\tthis.closed = json.closed;\n\t\t\tthis.curveType = json.curveType;\n\t\t\tthis.tension = json.tension;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t * Bezier Curves formulas obtained from\n\t\t * http://en.wikipedia.org/wiki/Bzier_curve\n\t\t */\n\t\n\t\tfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\t\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction QuadraticBezierP0( t, p ) {\n\t\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\t\n\t\t}\n\t\n\t\tfunction QuadraticBezierP1( t, p ) {\n\t\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\t\n\t\t}\n\t\n\t\tfunction QuadraticBezierP2( t, p ) {\n\t\n\t\t\treturn t * t * p;\n\t\n\t\t}\n\t\n\t\tfunction QuadraticBezier( t, p0, p1, p2 ) {\n\t\n\t\t\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\t\t\tQuadraticBezierP2( t, p2 );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction CubicBezierP0( t, p ) {\n\t\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\t\n\t\t}\n\t\n\t\tfunction CubicBezierP1( t, p ) {\n\t\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\t\n\t\t}\n\t\n\t\tfunction CubicBezierP2( t, p ) {\n\t\n\t\t\treturn 3 * ( 1 - t ) * t * t * p;\n\t\n\t\t}\n\t\n\t\tfunction CubicBezierP3( t, p ) {\n\t\n\t\t\treturn t * t * t * p;\n\t\n\t\t}\n\t\n\t\tfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\t\n\t\t\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\t\t\tCubicBezierP3( t, p3 );\n\t\n\t\t}\n\t\n\t\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'CubicBezierCurve';\n\t\n\t\t\tthis.v0 = v0 || new Vector2();\n\t\t\tthis.v1 = v1 || new Vector2();\n\t\t\tthis.v2 = v2 || new Vector2();\n\t\t\tthis.v3 = v3 || new Vector2();\n\t\n\t\t}\n\t\n\t\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\t\n\t\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\t\n\t\tCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector2();\n\t\n\t\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\t\n\t\t\tpoint.set(\n\t\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t\t);\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.v0.copy( source.v0 );\n\t\t\tthis.v1.copy( source.v1 );\n\t\t\tthis.v2.copy( source.v2 );\n\t\t\tthis.v3.copy( source.v3 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.v0.fromArray( json.v0 );\n\t\t\tthis.v1.fromArray( json.v1 );\n\t\t\tthis.v2.fromArray( json.v2 );\n\t\t\tthis.v3.fromArray( json.v3 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'CubicBezierCurve3';\n\t\n\t\t\tthis.v0 = v0 || new Vector3();\n\t\t\tthis.v1 = v1 || new Vector3();\n\t\t\tthis.v2 = v2 || new Vector3();\n\t\t\tthis.v3 = v3 || new Vector3();\n\t\n\t\t}\n\t\n\t\tCubicBezierCurve3.prototype = Object.create( Curve.prototype );\n\t\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\n\t\n\t\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\t\n\t\tCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector3();\n\t\n\t\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\t\n\t\t\tpoint.set(\n\t\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t\t);\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve3.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.v0.copy( source.v0 );\n\t\t\tthis.v1.copy( source.v1 );\n\t\t\tthis.v2.copy( source.v2 );\n\t\t\tthis.v3.copy( source.v3 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve3.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tCubicBezierCurve3.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.v0.fromArray( json.v0 );\n\t\t\tthis.v1.fromArray( json.v1 );\n\t\t\tthis.v2.fromArray( json.v2 );\n\t\t\tthis.v3.fromArray( json.v3 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction LineCurve( v1, v2 ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'LineCurve';\n\t\n\t\t\tthis.v1 = v1 || new Vector2();\n\t\t\tthis.v2 = v2 || new Vector2();\n\t\n\t\t}\n\t\n\t\tLineCurve.prototype = Object.create( Curve.prototype );\n\t\tLineCurve.prototype.constructor = LineCurve;\n\t\n\t\tLineCurve.prototype.isLineCurve = true;\n\t\n\t\tLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector2();\n\t\n\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\tpoint.copy( this.v2 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\t\t}\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\t\tLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\n\t\n\t\t\treturn this.getPoint( u, optionalTarget );\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.getTangent = function ( /* t */ ) {\n\t\n\t\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\t\n\t\t\treturn tangent.normalize();\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.v1.copy( source.v1 );\n\t\t\tthis.v2.copy( source.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tLineCurve.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.v1.fromArray( json.v1 );\n\t\t\tthis.v2.fromArray( json.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction LineCurve3( v1, v2 ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'LineCurve3';\n\t\n\t\t\tthis.v1 = v1 || new Vector3();\n\t\t\tthis.v2 = v2 || new Vector3();\n\t\n\t\t}\n\t\n\t\tLineCurve3.prototype = Object.create( Curve.prototype );\n\t\tLineCurve3.prototype.constructor = LineCurve3;\n\t\n\t\tLineCurve3.prototype.isLineCurve3 = true;\n\t\n\t\tLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector3();\n\t\n\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\tpoint.copy( this.v2 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\t\t}\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\t\tLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\n\t\n\t\t\treturn this.getPoint( u, optionalTarget );\n\t\n\t\t};\n\t\n\t\tLineCurve3.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.v1.copy( source.v1 );\n\t\t\tthis.v2.copy( source.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tLineCurve3.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tLineCurve3.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.v1.fromArray( json.v1 );\n\t\t\tthis.v2.fromArray( json.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'QuadraticBezierCurve';\n\t\n\t\t\tthis.v0 = v0 || new Vector2();\n\t\t\tthis.v1 = v1 || new Vector2();\n\t\t\tthis.v2 = v2 || new Vector2();\n\t\n\t\t}\n\t\n\t\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\t\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\t\n\t\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\t\n\t\tQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector2();\n\t\n\t\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\t\n\t\t\tpoint.set(\n\t\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t\t);\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\tQuadraticBezierCurve.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.v0.copy( source.v0 );\n\t\t\tthis.v1.copy( source.v1 );\n\t\t\tthis.v2.copy( source.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tQuadraticBezierCurve.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.v0.fromArray( json.v0 );\n\t\t\tthis.v1.fromArray( json.v1 );\n\t\t\tthis.v2.fromArray( json.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction QuadraticBezierCurve3( v0, v1, v2 ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'QuadraticBezierCurve3';\n\t\n\t\t\tthis.v0 = v0 || new Vector3();\n\t\t\tthis.v1 = v1 || new Vector3();\n\t\t\tthis.v2 = v2 || new Vector3();\n\t\n\t\t}\n\t\n\t\tQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\n\t\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\n\t\n\t\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\t\n\t\tQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector3();\n\t\n\t\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\t\n\t\t\tpoint.set(\n\t\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t\t);\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\tQuadraticBezierCurve3.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.v0.copy( source.v0 );\n\t\t\tthis.v1.copy( source.v1 );\n\t\t\tthis.v2.copy( source.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tQuadraticBezierCurve3.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.v0.fromArray( json.v0 );\n\t\t\tthis.v1.fromArray( json.v1 );\n\t\t\tthis.v2.fromArray( json.v2 );\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'SplineCurve';\n\t\n\t\t\tthis.points = points || [];\n\t\n\t\t}\n\t\n\t\tSplineCurve.prototype = Object.create( Curve.prototype );\n\t\tSplineCurve.prototype.constructor = SplineCurve;\n\t\n\t\tSplineCurve.prototype.isSplineCurve = true;\n\t\n\t\tSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\t\n\t\t\tvar point = optionalTarget || new Vector2();\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar p = ( points.length - 1 ) * t;\n\t\n\t\t\tvar intPoint = Math.floor( p );\n\t\t\tvar weight = p - intPoint;\n\t\n\t\t\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar p1 = points[ intPoint ];\n\t\t\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\tpoint.set(\n\t\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t\t);\n\t\n\t\t\treturn point;\n\t\n\t\t};\n\t\n\t\tSplineCurve.prototype.copy = function ( source ) {\n\t\n\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\tthis.points = [];\n\t\n\t\t\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = source.points[ i ];\n\t\n\t\t\t\tthis.points.push( point.clone() );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tSplineCurve.prototype.toJSON = function () {\n\t\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\tdata.points = [];\n\t\n\t\t\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = this.points[ i ];\n\t\t\t\tdata.points.push( point.toArray() );\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t};\n\t\n\t\tSplineCurve.prototype.fromJSON = function ( json ) {\n\t\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\tthis.points = [];\n\t\n\t\t\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = json.points[ i ];\n\t\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\n\t\tvar Curves = Object.freeze({\n\t\t\tArcCurve: ArcCurve,\n\t\t\tCatmullRomCurve3: CatmullRomCurve3,\n\t\t\tCubicBezierCurve: CubicBezierCurve,\n\t\t\tCubicBezierCurve3: CubicBezierCurve3,\n\t\t\tEllipseCurve: EllipseCurve,\n\t\t\tLineCurve: LineCurve,\n\t\t\tLineCurve3: LineCurve3,\n\t\t\tQuadraticBezierCurve: QuadraticBezierCurve,\n\t\t\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\t\t\tSplineCurve: SplineCurve\n\t\t});\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t **/\n\t\n\t\t/**************************************************************\n\t\t *\tCurved Path - a curve path is simply a array of connected\n\t\t *  curves, but retains the api of a curve\n\t\t **************************************************************/\n\t\n\t\tfunction CurvePath() {\n\t\n\t\t\tCurve.call( this );\n\t\n\t\t\tthis.type = 'CurvePath';\n\t\n\t\t\tthis.curves = [];\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\n\t\t}\n\t\n\t\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\t\n\t\t\tconstructor: CurvePath,\n\t\n\t\t\tadd: function ( curve ) {\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t},\n\t\n\t\t\tclosePath: function () {\n\t\n\t\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\t\n\t\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\t\n\t\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// To get accurate point with reference to\n\t\t\t// entire path distance at time t,\n\t\t\t// following has to be done:\n\t\n\t\t\t// 1. Length of each sub path have to be known\n\t\t\t// 2. Locate and identify type of curve\n\t\t\t// 3. Get t for the curve\n\t\t\t// 4. Return curve.getPointAt(t')\n\t\n\t\t\tgetPoint: function ( t ) {\n\t\n\t\t\t\tvar d = t * this.getLength();\n\t\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\t\tvar i = 0;\n\t\n\t\t\t\t// To think about boundaries points.\n\t\n\t\t\t\twhile ( i < curveLengths.length ) {\n\t\n\t\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\t\n\t\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\t\tvar curve = this.curves[ i ];\n\t\n\t\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\n\t\t\t\t\t\treturn curve.getPointAt( u );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ti ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\n\t\t\t},\n\t\n\t\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t\t// getPoint() depends on getLength\n\t\n\t\t\tgetLength: function () {\n\t\n\t\t\t\tvar lens = this.getCurveLengths();\n\t\t\t\treturn lens[ lens.length - 1 ];\n\t\n\t\t\t},\n\t\n\t\t\t// cacheLengths must be recalculated.\n\t\t\tupdateArcLengths: function () {\n\t\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\tthis.cacheLengths = null;\n\t\t\t\tthis.getCurveLengths();\n\t\n\t\t\t},\n\t\n\t\t\t// Compute lengths and cache them\n\t\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\n\t\t\tgetCurveLengths: function () {\n\t\n\t\t\t\t// We use cache values if curves and cache array are same length\n\t\n\t\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\t\n\t\t\t\t\treturn this.cacheLengths;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Get length of sub-curve\n\t\t\t\t// Push sums into cached array\n\t\n\t\t\t\tvar lengths = [], sums = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\t\tlengths.push( sums );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cacheLengths = lengths;\n\t\n\t\t\t\treturn lengths;\n\t\n\t\t\t},\n\t\n\t\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\t\tif ( divisions === undefined ) divisions = 40;\n\t\n\t\t\t\tvar points = [];\n\t\n\t\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\t\n\t\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\t\tdivisions = divisions || 12;\n\t\n\t\t\t\tvar points = [], last;\n\t\n\t\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\t\n\t\t\t\t\tvar curve = curves[ i ];\n\t\t\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t\t\t: ( curve && curve.isLineCurve ) ? 1\n\t\t\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t\t\t: divisions;\n\t\n\t\t\t\t\tvar pts = curve.getPoints( resolution );\n\t\n\t\t\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\n\t\n\t\t\t\t\t\tvar point = pts[ j ];\n\t\n\t\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\t\n\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\tlast = point;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn points;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCurve.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.curves = [];\n\t\n\t\t\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar curve = source.curves[ i ];\n\t\n\t\t\t\t\tthis.curves.push( curve.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.autoClose = source.autoClose;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\t\n\t\t\t\tdata.autoClose = this.autoClose;\n\t\t\t\tdata.curves = [];\n\t\n\t\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar curve = this.curves[ i ];\n\t\t\t\t\tdata.curves.push( curve.toJSON() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tfromJSON: function ( json ) {\n\t\n\t\t\t\tCurve.prototype.fromJSON.call( this, json );\n\t\n\t\t\t\tthis.autoClose = json.autoClose;\n\t\t\t\tthis.curves = [];\n\t\n\t\t\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar curve = json.curves[ i ];\n\t\t\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Creates free form 2d path using series of points, lines or curves.\n\t\t **/\n\t\n\t\tfunction Path( points ) {\n\t\n\t\t\tCurvePath.call( this );\n\t\n\t\t\tthis.type = 'Path';\n\t\n\t\t\tthis.currentPoint = new Vector2();\n\t\n\t\t\tif ( points ) {\n\t\n\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\n\t\n\t\t\tconstructor: Path,\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\t\n\t\t\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\t\n\t\t\t},\n\t\n\t\t\tlineTo: function ( x, y ) {\n\t\n\t\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( x, y );\n\t\n\t\t\t},\n\t\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\t\tnew Vector2( aX, aY )\n\t\t\t\t);\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\t\n\t\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\t\n\t\t\t\tvar curve = new SplineCurve( npts );\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\t\n\t\t\t},\n\t\n\t\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t\t},\n\t\n\t\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t},\n\t\n\t\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\t\tif ( this.curves.length > 0 ) {\n\t\n\t\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\t\n\t\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\t\n\t\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.curves.push( curve );\n\t\n\t\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\t\tthis.currentPoint.copy( lastPoint );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tCurvePath.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.currentPoint.copy( source.currentPoint );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = CurvePath.prototype.toJSON.call( this );\n\t\n\t\t\t\tdata.currentPoint = this.currentPoint.toArray();\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tfromJSON: function ( json ) {\n\t\n\t\t\t\tCurvePath.prototype.fromJSON.call( this, json );\n\t\n\t\t\t\tthis.currentPoint.fromArray( json.currentPoint );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * Defines a 2d shape plane using paths.\n\t\t **/\n\t\n\t\t// STEP 1 Create a path.\n\t\t// STEP 2 Turn path into shape.\n\t\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t\t// STEP 3a - Extract points from each shape, turn to vertices\n\t\t// STEP 3b - Triangulate each shape, add faces.\n\t\n\t\tfunction Shape( points ) {\n\t\n\t\t\tPath.call( this, points );\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.type = 'Shape';\n\t\n\t\t\tthis.holes = [];\n\t\n\t\t}\n\t\n\t\tShape.prototype = Object.assign( Object.create( Path.prototype ), {\n\t\n\t\t\tconstructor: Shape,\n\t\n\t\t\tgetPointsHoles: function ( divisions ) {\n\t\n\t\t\t\tvar holesPts = [];\n\t\n\t\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn holesPts;\n\t\n\t\t\t},\n\t\n\t\t\t// get points of shape and holes (keypoints based on segments parameter)\n\t\n\t\t\textractPoints: function ( divisions ) {\n\t\n\t\t\t\treturn {\n\t\n\t\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\t\tholes: this.getPointsHoles( divisions )\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tPath.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.holes = [];\n\t\n\t\t\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar hole = source.holes[ i ];\n\t\n\t\t\t\t\tthis.holes.push( hole.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar data = Path.prototype.toJSON.call( this );\n\t\n\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\tdata.holes = [];\n\t\n\t\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar hole = this.holes[ i ];\n\t\t\t\t\tdata.holes.push( hole.toJSON() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t},\n\t\n\t\t\tfromJSON: function ( json ) {\n\t\n\t\t\t\tPath.prototype.fromJSON.call( this, json );\n\t\n\t\t\t\tthis.uuid = json.uuid;\n\t\t\t\tthis.holes = [];\n\t\n\t\t\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar hole = json.holes[ i ];\n\t\t\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Light( color, intensity ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Light';\n\t\n\t\t\tthis.color = new Color( color );\n\t\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\t\n\t\t\tthis.receiveShadow = undefined;\n\t\n\t\t}\n\t\n\t\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Light,\n\t\n\t\t\tisLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tObject3D.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.color.copy( source.color );\n\t\t\t\tthis.intensity = source.intensity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.color = this.color.getHex();\n\t\t\t\tdata.object.intensity = this.intensity;\n\t\n\t\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\t\n\t\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\t\n\t\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\t\n\t\t\tLight.call( this, skyColor, intensity );\n\t\n\t\t\tthis.type = 'HemisphereLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.groundColor = new Color( groundColor );\n\t\n\t\t}\n\t\n\t\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: HemisphereLight,\n\t\n\t\t\tisHemisphereLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.groundColor.copy( source.groundColor );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction LightShadow( camera ) {\n\t\n\t\t\tthis.camera = camera;\n\t\n\t\t\tthis.bias = 0;\n\t\t\tthis.radius = 1;\n\t\n\t\t\tthis.mapSize = new Vector2( 512, 512 );\n\t\n\t\t\tthis.map = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\n\t\t}\n\t\n\t\tObject.assign( LightShadow.prototype, {\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.camera = source.camera.clone();\n\t\n\t\t\t\tthis.bias = source.bias;\n\t\t\t\tthis.radius = source.radius;\n\t\n\t\t\t\tthis.mapSize.copy( source.mapSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function () {\n\t\n\t\t\t\tvar object = {};\n\t\n\t\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\t\n\t\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\t\tdelete object.camera.matrix;\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction SpotLightShadow() {\n\t\n\t\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: SpotLightShadow,\n\t\n\t\t\tisSpotLightShadow: true,\n\t\n\t\t\tupdate: function ( light ) {\n\t\n\t\t\t\tvar camera = this.camera;\n\t\n\t\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\t\tvar far = light.distance || camera.far;\n\t\n\t\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\t\n\t\t\t\t\tcamera.fov = fov;\n\t\t\t\t\tcamera.aspect = aspect;\n\t\t\t\t\tcamera.far = far;\n\t\t\t\t\tcamera.updateProjectionMatrix();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'SpotLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\t\treturn this.intensity * Math.PI;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\t\tthis.intensity = power / Math.PI;\n\t\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\n\t\t}\n\t\n\t\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: SpotLight,\n\t\n\t\t\tisSpotLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.angle = source.angle;\n\t\t\t\tthis.penumbra = source.penumbra;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\n\t\tfunction PointLight( color, intensity, distance, decay ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'PointLight';\n\t\n\t\t\tObject.defineProperty( this, 'power', {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\t\treturn this.intensity * 4 * Math.PI;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( power ) {\n\t\n\t\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: PointLight,\n\t\n\t\t\tisPointLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.distance = source.distance;\n\t\t\t\tthis.decay = source.decay;\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction DirectionalLightShadow( ) {\n\t\n\t\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\t\n\t\t}\n\t\n\t\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLightShadow\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction DirectionalLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'DirectionalLight';\n\t\n\t\t\tthis.position.copy( Object3D.DefaultUp );\n\t\t\tthis.updateMatrix();\n\t\n\t\t\tthis.target = new Object3D();\n\t\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\n\t\t}\n\t\n\t\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: DirectionalLight,\n\t\n\t\t\tisDirectionalLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.target = source.target.clone();\n\t\n\t\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AmbientLight( color, intensity ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'AmbientLight';\n\t\n\t\t\tthis.castShadow = undefined;\n\t\n\t\t}\n\t\n\t\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: AmbientLight,\n\t\n\t\t\tisAmbientLight: true\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author abelnation / http://github.com/abelnation\n\t\t */\n\t\n\t\tfunction RectAreaLight( color, intensity, width, height ) {\n\t\n\t\t\tLight.call( this, color, intensity );\n\t\n\t\t\tthis.type = 'RectAreaLight';\n\t\n\t\t\tthis.width = ( width !== undefined ) ? width : 10;\n\t\t\tthis.height = ( height !== undefined ) ? height : 10;\n\t\n\t\t}\n\t\n\t\tRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\t\n\t\t\tconstructor: RectAreaLight,\n\t\n\t\t\tisRectAreaLight: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tLight.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.width = source.width;\n\t\t\t\tthis.height = source.height;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t\tvar data = Light.prototype.toJSON.call( this, meta );\n\t\n\t\t\t\tdata.object.width = this.width;\n\t\t\t\tdata.object.height = this.height;\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track that interpolates Strings\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\t\n\t\t\tconstructor: StringKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'string',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of Boolean keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction BooleanKeyframeTrack( name, times, values ) {\n\t\n\t\t\tKeyframeTrack.call( this, name, times, values );\n\t\n\t\t}\n\t\n\t\tBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\t\n\t\t\tconstructor: BooleanKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'bool',\n\t\t\tValueBufferType: Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateDiscrete,\n\t\n\t\t\tInterpolantFactoryMethodLinear: undefined,\n\t\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t\t// Note: Actually this track could have a optimized / compressed\n\t\t\t// representation of a single value and a custom interpolant that\n\t\t\t// computes \"firstValue ^ isOdd( index )\".\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Abstract base class of interpolants over parametric samples.\n\t\t *\n\t\t * The parameter domain is one dimensional, typically the time or a path\n\t\t * along a curve defined by the data.\n\t\t *\n\t\t * The sample values can have any dimensionality and derived classes may\n\t\t * apply special interpretations to the data.\n\t\t *\n\t\t * This class provides the interval seek in a Template Method, deferring\n\t\t * the actual interpolation to derived classes.\n\t\t *\n\t\t * Time complexity is O(1) for linear access crossing at most two points\n\t\t * and O(log N) for random access, where N is the number of positions.\n\t\t *\n\t\t * References:\n\t\t *\n\t\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\n\t\t}\n\t\n\t\tObject.assign( Interpolant.prototype, {\n\t\n\t\t\tevaluate: function ( t ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\ti1 = this._cachedIndex,\n\t\n\t\t\t\t\tt1 = pp[ i1 ],\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\tvalidate_interval: {\n\t\n\t\t\t\t\tseek: {\n\t\n\t\t\t\t\t\tvar right;\n\t\n\t\t\t\t\t\tlinear_scan: {\n\t\n\t\t\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t\t//-\n\t\t\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ; ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\t\n\t\t\t\t\t\t\t\t\t\t// after end\n\t\n\t\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\t\n\t\t\t\t\t\t\t\t// looping?\n\t\n\t\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t < t1global ) {\n\t\n\t\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\t\tt0 = t1global;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// linear reverse scan\n\t\n\t\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ; ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// before start\n\t\n\t\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\t\n\t\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\t\n\t\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// the interval is valid\n\t\n\t\t\t\t\t\t\tbreak validate_interval;\n\t\n\t\t\t\t\t\t} // linear scan\n\t\n\t\t\t\t\t\t// binary search\n\t\n\t\t\t\t\t\twhile ( i1 < right ) {\n\t\n\t\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\t\n\t\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\t\n\t\t\t\t\t\t\t\tright = mid;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\ti1 = mid + 1;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\t\t\t// check boundary cases, again\n\t\n\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} // seek\n\t\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\n\t\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\t\n\t\t\t\t} // validate_interval\n\t\n\t\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\t\n\t\t\t},\n\t\n\t\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t\t// Note: The indirection allows central control of many interpolants.\n\t\n\t\t\t// --- Protected interface\n\t\n\t\t\tDefaultSettings_: {},\n\t\n\t\t\tgetSettings_: function () {\n\t\n\t\t\t\treturn this.settings || this.DefaultSettings_;\n\t\n\t\t\t},\n\t\n\t\t\tcopySampleValue_: function ( index ) {\n\t\n\t\t\t\t// copies a sample value to the result buffer\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = index * stride;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] = values[ offset + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// Template methods for derived classes:\n\t\n\t\t\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\t\n\t\t\t\tthrow new Error( 'call to abstract method' );\n\t\t\t\t// implementations shall return this.resultBuffer\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\t\n\t\t\t\t// empty\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//!\\ DECLARE ALIAS AFTER assign prototype !\n\t\tObject.assign( Interpolant.prototype, {\n\t\n\t\t\t//( 0, t, t0 ), returns this.resultBuffer\n\t\t\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\t\n\t\t\t//( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Spherical linear unit quaternion interpolant.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: QuaternionLinearInterpolant,\n\t\n\t\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset = i1 * stride,\n\t\n\t\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\t\n\t\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\t\n\t\t\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of quaternion keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\t\n\t\t\tconstructor: QuaternionKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'quaternion',\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodLinear: function ( result ) {\n\t\n\t\t\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of keyframe values that represent color.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\t\n\t\t\tconstructor: ColorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'color'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t\t// Note: Very basic implementation and nothing special yet.\n\t\t\t// However, this is the place for color space parameterization.\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of numeric keyframe values.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\t\n\t\t\tconstructor: NumberKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'number'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Fast and simple cubic spline interpolant.\n\t\t *\n\t\t * It was derived from a Hermitian construction setting the first derivative\n\t\t * at each sample position to the linear slope between neighboring positions\n\t\t * over their parameter interval.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t\tthis._weightPrev = - 0;\n\t\t\tthis._offsetPrev = - 0;\n\t\t\tthis._weightNext = - 0;\n\t\t\tthis._offsetNext = - 0;\n\t\n\t\t}\n\t\n\t\tCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: CubicInterpolant,\n\t\n\t\t\tDefaultSettings_: {\n\t\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\n\t\t\t},\n\t\n\t\t\tintervalChanged_: function ( i1, t0, t1 ) {\n\t\n\t\t\t\tvar pp = this.parameterPositions,\n\t\t\t\t\tiPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\n\t\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\t\ttNext = pp[ iNext ];\n\t\n\t\t\t\tif ( tPrev === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\t\ttPrev = t1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tNext === undefined ) {\n\t\n\t\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\t\n\t\t\t\t\t\tcase ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase WrapAroundEnding:\n\t\n\t\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\t\ttNext = t0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\t\tstride = this.valueSize;\n\t\n\t\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\t\tthis._offsetNext = iNext * stride;\n\t\n\t\t\t},\n\t\n\t\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\t\n\t\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tpp = p * p,\n\t\t\t\t\tppp = pp * p;\n\t\n\t\t\t\t// evaluate polynomials\n\t\n\t\t\t\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\t\t\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\t\t\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\t\t\tvar sN = wN * ppp - wN * pp;\n\t\n\t\t\t\t// combine data linearly\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\t\tsN * values[ oN + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: LinearInterpolant,\n\t\n\t\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\t\n\t\t\t\tvar result = this.resultBuffer,\n\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\toffset0 = offset1 - stride,\n\t\n\t\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\t\tweight0 = 1 - weight1;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tresult[ i ] =\n\t\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Interpolant that evaluates to the sample value at the position preceeding\n\t\t * the parameter.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\t}\n\t\n\t\tDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\t\n\t\t\tconstructor: DiscreteInterpolant,\n\t\n\t\t\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\n\t\n\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author tschw\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tvar AnimationUtils = {\n\t\n\t\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\t\tarraySlice: function ( array, from, to ) {\n\t\n\t\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\t\n\t\t\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array.slice( from, to );\n\t\n\t\t\t},\n\t\n\t\t\t// converts an array to a specific type\n\t\t\tconvertArray: function ( array, type, forceClone ) {\n\t\n\t\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\t\n\t\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\t\n\t\t\t\t\treturn new type( array ); // create typed array\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\t\n\t\t\t},\n\t\n\t\t\tisTypedArray: function ( object ) {\n\t\n\t\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t\t! ( object instanceof DataView );\n\t\n\t\t\t},\n\t\n\t\t\t// returns an array by which times and values can be sorted\n\t\t\tgetKeyframeOrder: function ( times ) {\n\t\n\t\t\t\tfunction compareTime( i, j ) {\n\t\n\t\t\t\t\treturn times[ i ] - times[ j ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar n = times.length;\n\t\t\t\tvar result = new Array( n );\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\t\n\t\t\t\tresult.sort( compareTime );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\t\tsortedArray: function ( values, stride, order ) {\n\t\n\t\t\t\tvar nValues = values.length;\n\t\t\t\tvar result = new values.constructor( nValues );\n\t\n\t\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\t\n\t\t\t\t\tvar srcOffset = order[ i ] * stride;\n\t\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t},\n\t\n\t\t\t// function for parsing AOS keyframe formats\n\t\t\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\t\n\t\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\t\n\t\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( key === undefined ) return; // no data\n\t\n\t\t\t\tvar value = key[ valuePropertyName ];\n\t\t\t\tif ( value === undefined ) return; // no data\n\t\n\t\t\t\tif ( Array.isArray( value ) ) {\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else if ( value.toArray !== undefined ) {\n\t\n\t\t\t\t\t// ...assume THREE.Math-ish\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalue.toArray( values, values.length );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// otherwise push as-is\n\t\n\t\t\t\t\tdo {\n\t\n\t\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\t\tvalues.push( value );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t *\n\t\t * A timed sequence of keyframes for a specific property.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\t\n\t\t\tthis.name = name;\n\t\n\t\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\t\n\t\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\t\n\t\t\tthis.validate();\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\t// Static methods:\n\t\n\t\tObject.assign( KeyframeTrack, {\n\t\n\t\t\t// Serialization (in static context, because of constructor invocation\n\t\t\t// and automatic invocation of .toJSON):\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tif ( json.type === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\t\n\t\t\t\tif ( json.times === undefined ) {\n\t\n\t\t\t\t\tvar times = [], values = [];\n\t\n\t\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\t\n\t\t\t\t\tjson.times = times;\n\t\t\t\t\tjson.values = values;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// derived classes can define a static parse method\n\t\t\t\tif ( trackType.parse !== undefined ) {\n\t\n\t\t\t\t\treturn trackType.parse( json );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we assume a constructor compatible with the base\n\t\t\t\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( track ) {\n\t\n\t\t\t\tvar trackType = track.constructor;\n\t\n\t\t\t\tvar json;\n\t\n\t\t\t\t// derived classes can define a static toJSON method\n\t\t\t\tif ( trackType.toJSON !== undefined ) {\n\t\n\t\t\t\t\tjson = trackType.toJSON( track );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\t\tjson = {\n\t\n\t\t\t\t\t\t'name': track.name,\n\t\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar interpolation = track.getInterpolation();\n\t\n\t\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\tjson.interpolation = interpolation;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tjson.type = track.ValueTypeName; // mandatory\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\t\t_getTrackTypeForValueTypeName: function ( typeName ) {\n\t\n\t\t\t\tswitch ( typeName.toLowerCase() ) {\n\t\n\t\t\t\t\tcase 'scalar':\n\t\t\t\t\tcase 'double':\n\t\t\t\t\tcase 'float':\n\t\t\t\t\tcase 'number':\n\t\t\t\t\tcase 'integer':\n\t\n\t\t\t\t\t\treturn NumberKeyframeTrack;\n\t\n\t\t\t\t\tcase 'vector':\n\t\t\t\t\tcase 'vector2':\n\t\t\t\t\tcase 'vector3':\n\t\t\t\t\tcase 'vector4':\n\t\n\t\t\t\t\t\treturn VectorKeyframeTrack;\n\t\n\t\t\t\t\tcase 'color':\n\t\n\t\t\t\t\t\treturn ColorKeyframeTrack;\n\t\n\t\t\t\t\tcase 'quaternion':\n\t\n\t\t\t\t\t\treturn QuaternionKeyframeTrack;\n\t\n\t\t\t\t\tcase 'bool':\n\t\t\t\t\tcase 'boolean':\n\t\n\t\t\t\t\t\treturn BooleanKeyframeTrack;\n\t\n\t\t\t\t\tcase 'string':\n\t\n\t\t\t\t\t\treturn StringKeyframeTrack;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( KeyframeTrack.prototype, {\n\t\n\t\t\tconstructor: KeyframeTrack,\n\t\n\t\t\tTimeBufferType: Float32Array,\n\t\n\t\t\tValueBufferType: Float32Array,\n\t\n\t\t\tDefaultInterpolation: InterpolateLinear,\n\t\n\t\t\tInterpolantFactoryMethodDiscrete: function ( result ) {\n\t\n\t\t\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodLinear: function ( result ) {\n\t\n\t\t\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tInterpolantFactoryMethodSmooth: function ( result ) {\n\t\n\t\t\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\t\n\t\t\t},\n\t\n\t\t\tsetInterpolation: function ( interpolation ) {\n\t\n\t\t\t\tvar factoryMethod;\n\t\n\t\t\t\tswitch ( interpolation ) {\n\t\n\t\t\t\t\tcase InterpolateDiscrete:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateLinear:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase InterpolateSmooth:\n\t\n\t\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( factoryMethod === undefined ) {\n\t\n\t\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\t\n\t\t\t\t\tif ( this.createInterpolant === undefined ) {\n\t\n\t\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.createInterpolant = factoryMethod;\n\t\n\t\t\t},\n\t\n\t\t\tgetInterpolation: function () {\n\t\n\t\t\t\tswitch ( this.createInterpolant ) {\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\n\t\t\t\t\t\treturn InterpolateDiscrete;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\n\t\t\t\t\t\treturn InterpolateLinear;\n\t\n\t\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\n\t\t\t\t\t\treturn InterpolateSmooth;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetValueSize: function () {\n\t\n\t\t\t\treturn this.values.length / this.times.length;\n\t\n\t\t\t},\n\t\n\t\t\t// move all keyframes either forwards or backwards in time\n\t\t\tshift: function ( timeOffset ) {\n\t\n\t\t\t\tif ( timeOffset !== 0.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] += timeOffset;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\t\tscale: function ( timeScale ) {\n\t\n\t\t\t\tif ( timeScale !== 1.0 ) {\n\t\n\t\t\t\t\tvar times = this.times;\n\t\n\t\t\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\ttimes[ i ] *= timeScale;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\t\ttrim: function ( startTime, endTime ) {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tnKeys = times.length,\n\t\t\t\t\tfrom = 0,\n\t\t\t\t\tto = nKeys - 1;\n\t\n\t\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\t\n\t\t\t\t\t++ from;\n\t\n\t\t\t\t}\n\t\n\t\t\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\t\n\t\t\t\t\t-- to;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t++ to; // inclusive -> exclusive bound\n\t\n\t\t\t\tif ( from !== 0 || to !== nKeys ) {\n\t\n\t\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\t\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\n\t\n\t\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\t\tvalidate: function () {\n\t\n\t\t\t\tvar valid = true;\n\t\n\t\t\t\tvar valueSize = this.getValueSize();\n\t\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\n\t\t\t\t\tnKeys = times.length;\n\t\n\t\t\t\tif ( nKeys === 0 ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\t\t\tvalid = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar prevTime = null;\n\t\n\t\t\t\tfor ( var i = 0; i !== nKeys; i ++ ) {\n\t\n\t\t\t\t\tvar currTime = times[ i ];\n\t\n\t\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tprevTime = currTime;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( values !== undefined ) {\n\t\n\t\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tvar value = values[ i ];\n\t\n\t\t\t\t\t\t\tif ( isNaN( value ) ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn valid;\n\t\n\t\t\t},\n\t\n\t\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\t\toptimize: function () {\n\t\n\t\t\t\tvar times = this.times,\n\t\t\t\t\tvalues = this.values,\n\t\t\t\t\tstride = this.getValueSize(),\n\t\n\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\n\t\t\t\t\twriteIndex = 1,\n\t\t\t\t\tlastIndex = times.length - 1;\n\t\n\t\t\t\tfor ( var i = 1; i < lastIndex; ++ i ) {\n\t\n\t\t\t\t\tvar keep = false;\n\t\n\t\t\t\t\tvar time = times[ i ];\n\t\t\t\t\tvar timeNext = times[ i + 1 ];\n\t\n\t\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\t\n\t\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\t\n\t\t\t\t\t\tif ( ! smoothInterpolation ) {\n\t\n\t\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\n\t\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\t\n\t\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\t\n\t\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tkeep = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// in-place compaction\n\t\n\t\t\t\t\tif ( keep ) {\n\t\n\t\t\t\t\t\tif ( i !== writeIndex ) {\n\t\n\t\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\t\n\t\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// flush last keyframe (compaction looks ahead)\n\t\n\t\t\t\tif ( lastIndex > 0 ) {\n\t\n\t\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\t\n\t\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( writeIndex !== times.length ) {\n\t\n\t\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A Track of vectored keyframe values.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\t\n\t\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t\t}\n\t\n\t\tVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\t\n\t\t\tconstructor: VectorKeyframeTrack,\n\t\n\t\t\tValueTypeName: 'vector'\n\t\n\t\t\t// ValueBufferType is inherited\n\t\n\t\t\t// DefaultInterpolation is inherited\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Reusable set of Tracks that represent an animation.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t */\n\t\n\t\tfunction AnimationClip( name, duration, tracks ) {\n\t\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// this means it should figure out its duration by scanning the tracks\n\t\t\tif ( this.duration < 0 ) {\n\t\n\t\t\t\tthis.resetDuration();\n\t\n\t\t\t}\n\t\n\t\t\tthis.optimize();\n\t\n\t\t}\n\t\n\t\tObject.assign( AnimationClip, {\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\t\n\t\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\t\n\t\t\t},\n\t\n\t\t\ttoJSON: function ( clip ) {\n\t\n\t\t\t\tvar tracks = [],\n\t\t\t\t\tclipTracks = clip.tracks;\n\t\n\t\t\t\tvar json = {\n\t\n\t\t\t\t\t'name': clip.name,\n\t\t\t\t\t'duration': clip.duration,\n\t\t\t\t\t'tracks': tracks\n\t\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn json;\n\t\n\t\t\t},\n\t\n\t\t\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\t\n\t\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\t\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\t\n\t\t\t\t\tvalues.push( 0, 1, 0 );\n\t\n\t\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\t\n\t\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\t\n\t\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\t\tvalues.push( values[ 0 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn new AnimationClip( name, - 1, tracks );\n\t\n\t\t\t},\n\t\n\t\t\tfindByName: function ( objectOrClipArray, name ) {\n\t\n\t\t\t\tvar clipArray = objectOrClipArray;\n\t\n\t\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\t\n\t\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\t\n\t\t\t\t\tif ( clipArray[ i ].name === name ) {\n\t\n\t\t\t\t\t\treturn clipArray[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\t\n\t\t\t\tvar animationToMorphTargets = {};\n\t\n\t\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\t\n\t\t\t\t// sort morph target names into animation groups based\n\t\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\t\n\t\t\t\t\tif ( parts && parts.length > 1 ) {\n\t\n\t\t\t\t\t\tvar name = parts[ 1 ];\n\t\n\t\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\t\tif ( ! animationMorphTargets ) {\n\t\n\t\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clips = [];\n\t\n\t\t\t\tfor ( var name in animationToMorphTargets ) {\n\t\n\t\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn clips;\n\t\n\t\t\t},\n\t\n\t\t\t// parse the animation.hierarchy format\n\t\t\tparseAnimation: function ( animation, bones ) {\n\t\n\t\t\t\tif ( ! animation ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\t\n\t\t\t\t\t// only return track if there are actually keys.\n\t\t\t\t\tif ( animationKeys.length !== 0 ) {\n\t\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\t\n\t\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\t\tif ( times.length !== 0 ) {\n\t\n\t\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar tracks = [];\n\t\n\t\t\t\tvar clipName = animation.name || 'default';\n\t\t\t\t// automatic length determination in AnimationClip.\n\t\t\t\tvar duration = animation.length || - 1;\n\t\t\t\tvar fps = animation.fps || 30;\n\t\n\t\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\t\n\t\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\t\n\t\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\t\n\t\t\t\t\t// skip empty tracks\n\t\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\t\n\t\t\t\t\t// process morph targets\n\t\t\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\t\n\t\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\t\tvar morphTargetNames = {};\n\t\n\t\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\t\n\t\t\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\t\n\t\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\t\n\t\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\t\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\t\n\t\t\t\t\t\t\t\tvar animationKey = animationKeys[ k ];\n\t\n\t\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// ...assume skeletal animation\n\t\n\t\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\t\n\t\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( tracks.length === 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\t\n\t\t\t\treturn clip;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( AnimationClip.prototype, {\n\t\n\t\t\tresetDuration: function () {\n\t\n\t\t\t\tvar tracks = this.tracks, duration = 0;\n\t\n\t\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar track = this.tracks[ i ];\n\t\n\t\t\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.duration = duration;\n\t\n\t\t\t},\n\t\n\t\t\ttrim: function () {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\toptimize: function () {\n\t\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\t\tthis.tracks[ i ].optimize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction MaterialLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.textures = {};\n\t\n\t\t}\n\t\n\t\tObject.assign( MaterialLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new FileLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTextures: function ( value ) {\n\t\n\t\t\t\tthis.textures = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar textures = this.textures;\n\t\n\t\t\t\tfunction getTexture( name ) {\n\t\n\t\t\t\t\tif ( textures[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn textures[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar material = new Materials[ json.type ]();\n\t\n\t\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\t\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\n\t\t\t\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\n\t\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\n\t\t\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\t\n\t\t\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\t\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\t\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\t\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\t\n\t\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\t\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\t\n\t\t\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\t\t\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\t\n\t\t\t\t// Deprecated\n\t\n\t\t\t\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\n\t\n\t\t\t\t// for PointsMaterial\n\t\n\t\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\t\n\t\t\t\t// maps\n\t\n\t\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\n\t\t\t\tif ( json.alphaMap !== undefined ) {\n\t\n\t\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\t\tmaterial.transparent = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\t\n\t\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\t\tif ( json.normalScale !== undefined ) {\n\t\n\t\t\t\t\tvar normalScale = json.normalScale;\n\t\n\t\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\t\n\t\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\n\t\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\t\n\t\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\t\n\t\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\t\n\t\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\n\t\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\n\t\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\n\t\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\t\n\t\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\t\n\t\t\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\t\n\t\t\t\treturn material;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction BufferGeometryLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( BufferGeometryLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new FileLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\t\tvar index = json.data.index;\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar attributes = json.data.attributes;\n\t\n\t\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\n\t\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\t\n\t\t\t\tif ( groups !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingSphere = json.data.boundingSphere;\n\t\n\t\t\t\tif ( boundingSphere !== undefined ) {\n\t\n\t\t\t\t\tvar center = new Vector3();\n\t\n\t\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\t\n\t\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar TYPED_ARRAYS = {\n\t\t\tInt8Array: Int8Array,\n\t\t\tUint8Array: Uint8Array,\n\t\t\t// Workaround for IE11 pre KB2929437. See #11440\n\t\t\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\n\t\t\tInt16Array: Int16Array,\n\t\t\tUint16Array: Uint16Array,\n\t\t\tInt32Array: Int32Array,\n\t\t\tUint32Array: Uint32Array,\n\t\t\tFloat32Array: Float32Array,\n\t\t\tFloat64Array: Float64Array\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Loader() {\n\t\n\t\t\tthis.onLoadStart = function () {};\n\t\t\tthis.onLoadProgress = function () {};\n\t\t\tthis.onLoadComplete = function () {};\n\t\n\t\t}\n\t\n\t\tLoader.Handlers = {\n\t\n\t\t\thandlers: [],\n\t\n\t\t\tadd: function ( regex, loader ) {\n\t\n\t\t\t\tthis.handlers.push( regex, loader );\n\t\n\t\t\t},\n\t\n\t\t\tget: function ( file ) {\n\t\n\t\t\t\tvar handlers = this.handlers;\n\t\n\t\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\t\n\t\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\t\tvar loader = handlers[ i + 1 ];\n\t\n\t\t\t\t\tif ( regex.test( file ) ) {\n\t\n\t\t\t\t\t\treturn loader;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tObject.assign( Loader.prototype, {\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\n\t\t\t\tvar array = [];\n\t\n\t\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\t\n\t\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t},\n\t\n\t\t\tcreateMaterial: ( function () {\n\t\n\t\t\t\tvar BlendingMode = {\n\t\t\t\t\tNoBlending: NoBlending,\n\t\t\t\t\tNormalBlending: NormalBlending,\n\t\t\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\t\t\tCustomBlending: CustomBlending\n\t\t\t\t};\n\t\n\t\t\t\tvar color = new Color();\n\t\t\t\tvar textureLoader = new TextureLoader();\n\t\t\t\tvar materialLoader = new MaterialLoader();\n\t\n\t\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\t\n\t\t\t\t\t// convert from old material format\n\t\n\t\t\t\t\tvar textures = {};\n\t\n\t\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\t\n\t\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\t\n\t\t\t\t\t\tvar texture;\n\t\n\t\t\t\t\t\tif ( loader !== null ) {\n\t\n\t\t\t\t\t\t\ttexture = loader.load( fullPath );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( repeat !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\t\n\t\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( anisotropy !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar uuid = _Math.generateUUID();\n\t\n\t\t\t\t\t\ttextures[ uuid ] = texture;\n\t\n\t\t\t\t\t\treturn uuid;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//\n\t\n\t\t\t\t\tvar json = {\n\t\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t\t};\n\t\n\t\t\t\t\tfor ( var name in m ) {\n\t\n\t\t\t\t\t\tvar value = m[ name ];\n\t\n\t\t\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\t\n\t\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\t\n\t\t\t\t\tmaterialLoader.setTextures( textures );\n\t\n\t\t\t\t\treturn materialLoader.parse( json );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Don McCurdy / https://www.donmccurdy.com\n\t\t */\n\t\n\t\tvar LoaderUtils = {\n\t\n\t\t\tdecodeText: function ( array ) {\n\t\n\t\t\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\t\n\t\t\t\t\treturn new TextDecoder().decode( array );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\t\n\t\t\t\tvar s = '';\n\t\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t// Implicitly assumes little-endian.\n\t\t\t\t\ts += String.fromCharCode( array[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Merges multi-byte utf-8 characters.\n\t\t\t\treturn decodeURIComponent( escape( s ) );\n\t\n\t\t\t},\n\t\n\t\t\textractUrlBase: function ( url ) {\n\t\n\t\t\t\tvar parts = url.split( '/' );\n\t\n\t\t\t\tif ( parts.length === 1 ) return './';\n\t\n\t\t\t\tparts.pop();\n\t\n\t\t\t\treturn parts.join( '/' ) + '/';\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction JSONLoader( manager ) {\n\t\n\t\t\tif ( typeof manager === 'boolean' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\t\tmanager = undefined;\n\t\n\t\t\t}\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t\tthis.withCredentials = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( JSONLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\n\t\n\t\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\t\tif ( metadata !== undefined ) {\n\t\n\t\t\t\t\t\tvar type = metadata.type;\n\t\n\t\t\t\t\t\tif ( type !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\t\tonLoad( object.geometry, object.materials );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: ( function () {\n\t\n\t\t\t\tfunction parseModel( json, geometry ) {\n\t\n\t\t\t\t\tfunction isBitSet( value, position ) {\n\t\n\t\t\t\t\t\treturn value & ( 1 << position );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar i, j, fi,\n\t\n\t\t\t\t\t\toffset, zLength,\n\t\n\t\t\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\t\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tisQuad,\n\t\t\t\t\t\thasMaterial,\n\t\t\t\t\t\thasFaceVertexUv,\n\t\t\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\t\t\thasFaceColor, hasFaceVertexColor,\n\t\n\t\t\t\t\t\tvertex, face, faceA, faceB, hex, normal,\n\t\n\t\t\t\t\t\tuvLayer, uv, u, v,\n\t\n\t\t\t\t\t\tfaces = json.faces,\n\t\t\t\t\t\tvertices = json.vertices,\n\t\t\t\t\t\tnormals = json.normals,\n\t\t\t\t\t\tcolors = json.colors,\n\t\n\t\t\t\t\t\tscale = json.scale,\n\t\n\t\t\t\t\t\tnUvLayers = 0;\n\t\n\t\n\t\t\t\t\tif ( json.uvs !== undefined ) {\n\t\n\t\t\t\t\t\t// disregard empty arrays\n\t\n\t\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = vertices.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\tvertex = new Vector3();\n\t\n\t\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\t\n\t\t\t\t\t\tgeometry.vertices.push( vertex );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tzLength = faces.length;\n\t\n\t\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\t\ttype = faces[ offset ++ ];\n\t\n\t\t\t\t\t\tisQuad = isBitSet( type, 0 );\n\t\t\t\t\t\thasMaterial = isBitSet( type, 1 );\n\t\t\t\t\t\thasFaceVertexUv = isBitSet( type, 3 );\n\t\t\t\t\t\thasFaceNormal = isBitSet( type, 4 );\n\t\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\t\thasFaceColor = isBitSet( type, 6 );\n\t\t\t\t\t\thasFaceVertexColor = isBitSet( type, 7 );\n\t\n\t\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\t\n\t\t\t\t\t\tif ( isQuad ) {\n\t\n\t\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\t\toffset += 4;\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\t\tgeometry.faces.push( faceB );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\n\t\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tgeometry.faces.push( face );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseSkin( json, geometry ) {\n\t\n\t\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\t\n\t\t\t\t\tif ( json.skinWeights ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar x = json.skinWeights[ i ];\n\t\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.skinIndices ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\t\tvar a = json.skinIndices[ i ];\n\t\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.bones = json.bones;\n\t\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseMorphing( json, geometry ) {\n\t\n\t\t\t\t\tvar scale = json.scale;\n\t\n\t\t\t\t\tif ( json.morphTargets !== undefined ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\t\n\t\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\t\n\t\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\t\n\t\t\t\t\t\t\t\tdstVertices.push( vertex );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\t\n\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction parseAnimations( json, geometry ) {\n\t\n\t\t\t\t\tvar outputAnimations = [];\n\t\n\t\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\t\tvar animations = [];\n\t\n\t\t\t\t\tif ( json.animation !== undefined ) {\n\t\n\t\t\t\t\t\tanimations.push( json.animation );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.animations !== undefined ) {\n\t\n\t\t\t\t\t\tif ( json.animations.length ) {\n\t\n\t\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tanimations.push( json.animations );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// parse implicit morph animations\n\t\t\t\t\tif ( geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn function parse( json, texturePath ) {\n\t\n\t\t\t\t\tif ( json.data !== undefined ) {\n\t\n\t\t\t\t\t\t// Geometry 4.0 spec\n\t\t\t\t\t\tjson = json.data;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( json.scale !== undefined ) {\n\t\n\t\t\t\t\t\tjson.scale = 1.0 / json.scale;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tjson.scale = 1.0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar geometry = new Geometry();\n\t\n\t\t\t\t\tparseModel( json, geometry );\n\t\t\t\t\tparseSkin( json, geometry );\n\t\t\t\t\tparseMorphing( json, geometry );\n\t\t\t\t\tparseAnimations( json, geometry );\n\t\n\t\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\t\n\t\t\t\t\t\treturn { geometry: geometry };\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\t\n\t\t\t\t\t\treturn { geometry: geometry, materials: materials };\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction ObjectLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\t\tthis.texturePath = '';\n\t\n\t\t}\n\t\n\t\tObject.assign( ObjectLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( this.texturePath === '' ) {\n\t\n\t\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new FileLoader( scope.manager );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json = null;\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t\t} catch ( error ) {\n\t\n\t\t\t\t\t\tif ( onError !== undefined ) onError( error );\n\t\n\t\t\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\t\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tscope.parse( json, onLoad );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\t\tthis.texturePath = value;\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\t\tthis.crossOrigin = value;\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json, onLoad ) {\n\t\n\t\t\t\tvar shapes = this.parseShape( json.shapes );\n\t\t\t\tvar geometries = this.parseGeometries( json.geometries, shapes );\n\t\n\t\t\t\tvar images = this.parseImages( json.images, function () {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t} );\n\t\n\t\t\t\tvar textures = this.parseTextures( json.textures, images );\n\t\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\t\n\t\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\t\n\t\t\t\tif ( json.animations ) {\n\t\n\t\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\t\n\t\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t},\n\t\n\t\t\tparseShape: function ( json ) {\n\t\n\t\t\t\tvar shapes = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar shape = new Shape().fromJSON( json[ i ] );\n\t\n\t\t\t\t\t\tshapes[ shape.uuid ] = shape;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t},\n\t\n\t\t\tparseGeometries: function ( json, shapes ) {\n\t\n\t\t\t\tvar geometries = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar geometry;\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tdata.vertices,\n\t\t\t\t\t\t\t\t\tdata.indices,\n\t\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\t\tdata.details\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\t\t\tcase 'ShapeBufferGeometry':\n\t\n\t\t\t\t\t\t\t\tvar geometryShapes = [];\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = data.shapes.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ i ] ];\n\t\n\t\t\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\t\t\tdata.curveSegments\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'BufferGeometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'Geometry':\n\t\n\t\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data, this.texturePath ).geometry;\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\t\n\t\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\n\t\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometries;\n\t\n\t\t\t},\n\t\n\t\t\tparseMaterials: function ( json, textures ) {\n\t\n\t\t\t\tvar materials = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\t\tloader.setTextures( textures );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tif ( data.type === 'MultiMaterial' ) {\n\t\n\t\t\t\t\t\t\t// Deprecated\n\t\n\t\t\t\t\t\t\tvar array = [];\n\t\n\t\t\t\t\t\t\tfor ( var j = 0; j < data.materials.length; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tarray.push( loader.parse( data.materials[ j ] ) );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tmaterials[ data.uuid ] = array;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn materials;\n\t\n\t\t\t},\n\t\n\t\t\tparseAnimations: function ( json ) {\n\t\n\t\t\t\tvar animations = [];\n\t\n\t\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\t\n\t\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\t\n\t\t\t\t\tanimations.push( clip );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn animations;\n\t\n\t\t\t},\n\t\n\t\t\tparseImages: function ( json, onLoad ) {\n\t\n\t\t\t\tvar scope = this;\n\t\t\t\tvar images = {};\n\t\n\t\t\t\tfunction loadImage( url ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\treturn loader.load( url, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, undefined, function () {\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json !== undefined && json.length > 0 ) {\n\t\n\t\t\t\t\tvar manager = new LoadingManager( onLoad );\n\t\n\t\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\t\n\t\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn images;\n\t\n\t\t\t},\n\t\n\t\t\tparseTextures: function ( json, images ) {\n\t\n\t\t\t\tfunction parseConstant( value, type ) {\n\t\n\t\t\t\t\tif ( typeof value === 'number' ) return value;\n\t\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\t\n\t\t\t\t\treturn type[ value ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar textures = {};\n\t\n\t\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\t\tif ( data.image === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\ttexture.uuid = data.uuid;\n\t\n\t\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\n\t\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\n\t\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\t\n\t\t\t\t\t\tif ( data.wrap !== undefined ) {\n\t\n\t\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\n\t\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\t\n\t\t\t\t\t\ttextures[ data.uuid ] = texture;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn textures;\n\t\n\t\t\t},\n\t\n\t\t\tparseObject: function ( data, geometries, materials ) {\n\t\n\t\t\t\tvar object;\n\t\n\t\t\t\tfunction getGeometry( name ) {\n\t\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn geometries[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getMaterial( name ) {\n\t\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\t\n\t\t\t\t\tif ( Array.isArray( name ) ) {\n\t\n\t\t\t\t\t\tvar array = [];\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar uuid = name[ i ];\n\t\n\t\t\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tarray.push( materials[ uuid ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn array;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn materials[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\tcase 'Scene':\n\t\n\t\t\t\t\t\tobject = new Scene();\n\t\n\t\t\t\t\t\tif ( data.background !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\t\n\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\t\n\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\t\n\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\t\n\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\t\n\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PerspectiveCamera':\n\t\n\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\t\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'OrthographicCamera':\n\t\n\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'AmbientLight':\n\t\n\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'DirectionalLight':\n\t\n\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PointLight':\n\t\n\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'RectAreaLight':\n\t\n\t\t\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'SpotLight':\n\t\n\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'HemisphereLight':\n\t\n\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'SkinnedMesh':\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\n\t\n\t\t\t\t\tcase 'Mesh':\n\t\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\t\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\t\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'LOD':\n\t\n\t\t\t\t\t\tobject = new LOD();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Line':\n\t\n\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'LineLoop':\n\t\n\t\t\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'LineSegments':\n\t\n\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\t\n\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Sprite':\n\t\n\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Group':\n\t\n\t\t\t\t\t\tobject = new Group();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tobject = new Object3D();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.uuid = data.uuid;\n\t\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\t\n\t\t\t\t\tobject.matrix.fromArray( data.matrix );\n\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\t\n\t\t\t\tif ( data.shadow ) {\n\t\n\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\n\t\t\t\tif ( data.children !== undefined ) {\n\t\n\t\t\t\t\tvar children = data.children;\n\t\n\t\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.type === 'LOD' ) {\n\t\n\t\t\t\t\tvar levels = data.levels;\n\t\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\t\n\t\t\t\t\t\tif ( child !== undefined ) {\n\t\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tvar TEXTURE_MAPPING = {\n\t\t\tUVMapping: UVMapping,\n\t\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t\t};\n\t\n\t\tvar TEXTURE_WRAPPING = {\n\t\t\tRepeatWrapping: RepeatWrapping,\n\t\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t\t};\n\t\n\t\tvar TEXTURE_FILTER = {\n\t\t\tNearestFilter: NearestFilter,\n\t\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\t\tLinearFilter: LinearFilter,\n\t\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t\t};\n\t\n\t\t/**\n\t\t * @author thespite / http://clicktorelease.com/\n\t\t */\n\t\n\t\tfunction ImageBitmapLoader( manager ) {\n\t\n\t\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( typeof fetch === 'undefined' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\t\t\tthis.options = undefined;\n\t\n\t\t}\n\t\n\t\tImageBitmapLoader.prototype = {\n\t\n\t\t\tconstructor: ImageBitmapLoader,\n\t\n\t\t\tsetOptions: function setOptions( options ) {\n\t\n\t\t\t\tthis.options = options;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tload: function load( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tif ( url === undefined ) url = '';\n\t\n\t\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar cached = Cache.get( url );\n\t\n\t\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t\t}, 0 );\n\t\n\t\t\t\t\treturn cached;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfetch( url ).then( function ( res ) {\n\t\n\t\t\t\t\treturn res.blob();\n\t\n\t\t\t\t} ).then( function ( blob ) {\n\t\n\t\t\t\t\treturn createImageBitmap( blob, scope.options );\n\t\n\t\t\t\t} ).then( function ( imageBitmap ) {\n\t\n\t\t\t\t\tCache.add( url, imageBitmap );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} ).catch( function ( e ) {\n\t\n\t\t\t\t\tif ( onError ) onError( e );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t} );\n\t\n\t\t\t},\n\t\n\t\t\tsetCrossOrigin: function ( /* value */ ) {\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\t\t **/\n\t\n\t\tfunction ShapePath() {\n\t\n\t\t\tthis.type = 'ShapePath';\n\t\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\n\t\t}\n\t\n\t\tObject.assign( ShapePath.prototype, {\n\t\n\t\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\t\tthis.currentPath = new Path();\n\t\t\t\tthis.subPaths.push( this.currentPath );\n\t\t\t\tthis.currentPath.moveTo( x, y );\n\t\n\t\t\t},\n\t\n\t\t\tlineTo: function ( x, y ) {\n\t\n\t\t\t\tthis.currentPath.lineTo( x, y );\n\t\n\t\t\t},\n\t\n\t\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\n\t\t\t},\n\t\n\t\t\tsplineThru: function ( pts ) {\n\t\n\t\t\t\tthis.currentPath.splineThru( pts );\n\t\n\t\t\t},\n\t\n\t\t\ttoShapes: function ( isCCW, noHoles ) {\n\t\n\t\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\t\n\t\t\t\t\tvar shapes = [];\n\t\n\t\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\t\n\t\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tshapes.push( tmpShape );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\t\n\t\t\t\t\tvar polyLen = inPolygon.length;\n\t\n\t\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\t\tvar inside = false;\n\t\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\t\n\t\t\t\t\t\tvar edgeLowPt = inPolygon[ p ];\n\t\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\t\n\t\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\t\n\t\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\t\n\t\t\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\t\n\t\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\t\n\t\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t\t// continue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\tinside;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\t\n\t\t\t\tvar subPaths = this.subPaths;\n\t\t\t\tif ( subPaths.length === 0 ) return [];\n\t\n\t\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\t\n\t\t\t\tif ( subPaths.length === 1 ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\t\ttmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\treturn shapes;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\t\n\t\t\t\t// console.log(\"Holes first\", holesFirst);\n\t\n\t\t\t\tvar betterShapeHoles = [];\n\t\t\t\tvar newShapes = [];\n\t\t\t\tvar newShapeHoles = [];\n\t\t\t\tvar mainIdx = 0;\n\t\t\t\tvar tmpPoints;\n\t\n\t\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\t\tsolid = isCCW ? ! solid : solid;\n\t\n\t\t\t\t\tif ( solid ) {\n\t\n\t\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\t\n\t\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\t\n\t\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\t\t\t//console.log('cw', i);\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\t\n\t\t\t\t\t\t//console.log('ccw', i);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\t\tif ( newShapes.length > 1 ) {\n\t\n\t\t\t\t\tvar ambiguous = false;\n\t\t\t\t\tvar toChange = [];\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\t\n\t\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\t\tvar hole_unassigned = true;\n\t\n\t\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\t\tif ( toChange.length > 0 ) {\n\t\n\t\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar tmpHoles;\n\t\n\t\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\t\n\t\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\t\tshapes.push( tmpShape );\n\t\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Font( data ) {\n\t\n\t\t\tthis.type = 'Font';\n\t\n\t\t\tthis.data = data;\n\t\n\t\t}\n\t\n\t\tObject.assign( Font.prototype, {\n\t\n\t\t\tisFont: true,\n\t\n\t\t\tgenerateShapes: function ( text, size, divisions ) {\n\t\n\t\t\t\tif ( size === undefined ) size = 100;\n\t\t\t\tif ( divisions === undefined ) divisions = 4;\n\t\n\t\t\t\tvar shapes = [];\n\t\t\t\tvar paths = createPaths( text, size, divisions, this.data );\n\t\n\t\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\t\n\t\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tfunction createPaths( text, size, divisions, data ) {\n\t\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\t\n\t\t\tvar paths = [];\n\t\n\t\t\tvar offsetX = 0, offsetY = 0;\n\t\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\t\n\t\t\t\tvar char = chars[ i ];\n\t\n\t\t\t\tif ( char === '\\n' ) {\n\t\n\t\t\t\t\toffsetX = 0;\n\t\t\t\t\toffsetY -= line_height;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar ret = createPath( char, divisions, scale, offsetX, offsetY, data );\n\t\t\t\t\toffsetX += ret.offsetX;\n\t\t\t\t\tpaths.push( ret.path );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn paths;\n\t\n\t\t}\n\t\n\t\tfunction createPath( char, divisions, scale, offsetX, offsetY, data ) {\n\t\n\t\t\tvar glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\t\n\t\t\tif ( ! glyph ) return;\n\t\n\t\t\tvar path = new ShapePath();\n\t\n\t\t\tvar x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\t\n\t\t\tif ( glyph.o ) {\n\t\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\t\n\t\t\t\t\tvar action = outline[ i ++ ];\n\t\n\t\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\t\t\tcase 'm': // moveTo\n\t\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\t\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'l': // lineTo\n\t\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\t\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\t\n\t\t\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\t\n\t\t\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\t\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn { offsetX: glyph.ha * scale, path: path };\n\t\n\t\t}\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction FontLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( FontLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\t\tvar json;\n\t\n\t\t\t\t\ttry {\n\t\n\t\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar font = scope.parse( json );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( font );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t},\n\t\n\t\t\tparse: function ( json ) {\n\t\n\t\t\t\treturn new Font( json );\n\t\n\t\t\t},\n\t\n\t\t\tsetPath: function ( value ) {\n\t\n\t\t\t\tthis.path = value;\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tvar context;\n\t\n\t\tvar AudioContext = {\n\t\n\t\t\tgetContext: function () {\n\t\n\t\t\t\tif ( context === undefined ) {\n\t\n\t\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn context;\n\t\n\t\t\t},\n\t\n\t\t\tsetContext: function ( value ) {\n\t\n\t\t\t\tcontext = value;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction AudioLoader( manager ) {\n\t\n\t\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioLoader.prototype, {\n\t\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar context = AudioContext.getContext();\n\t\n\t\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\t\n\t\t\t\t\t\tonLoad( audioBuffer );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction StereoCamera() {\n\t\n\t\t\tthis.type = 'StereoCamera';\n\t\n\t\t\tthis.aspect = 1;\n\t\n\t\t\tthis.eyeSep = 0.064;\n\t\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable( 1 );\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable( 2 );\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( StereoCamera.prototype, {\n\t\n\t\t\tupdate: ( function () {\n\t\n\t\t\t\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\n\t\n\t\t\t\tvar eyeRight = new Matrix4();\n\t\t\t\tvar eyeLeft = new Matrix4();\n\t\n\t\t\t\treturn function update( camera ) {\n\t\n\t\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\n\t\n\t\t\t\t\tif ( needsUpdate ) {\n\t\n\t\t\t\t\t\tinstance = this;\n\t\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\t\tnear = camera.near;\n\t\t\t\t\t\tfar = camera.far;\n\t\t\t\t\t\tzoom = camera.zoom;\n\t\n\t\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\t\n\t\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\t\teyeSep = this.eyeSep / 2;\n\t\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\t\tvar xmin, xmax;\n\t\n\t\t\t\t\t\t// translate xOffset\n\t\n\t\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\t\n\t\t\t\t\t\t// for left eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t\t// for right eye\n\t\n\t\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\t\n\t\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * Camera for rendering cube maps\n\t\t *\t- renders scene into axis-aligned cube\n\t\t *\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction CubeCamera( near, far, cubeResolution ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'CubeCamera';\n\t\n\t\t\tvar fov = 90, aspect = 1;\n\t\n\t\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\t\tthis.add( cameraPX );\n\t\n\t\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\t\tthis.add( cameraNX );\n\t\n\t\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\t\tthis.add( cameraPY );\n\t\n\t\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\t\tthis.add( cameraNY );\n\t\n\t\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\t\tthis.add( cameraPZ );\n\t\n\t\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\t\tthis.add( cameraNZ );\n\t\n\t\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\t\n\t\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\t\tthis.renderTarget.texture.name = \"CubeCamera\";\n\t\n\t\t\tthis.update = function ( renderer, scene ) {\n\t\n\t\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\t\n\t\t\t\tvar renderTarget = this.renderTarget;\n\t\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\t\n\t\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\t\n\t\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\n\t\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\t\n\t\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t\t};\n\t\n\t\t\tthis.clear = function ( renderer, color, depth, stencil ) {\n\t\n\t\t\t\tvar renderTarget = this.renderTarget;\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\trenderTarget.activeCubeFace = i;\n\t\t\t\t\trenderer.setRenderTarget( renderTarget );\n\t\n\t\t\t\t\trenderer.clear( color, depth, stencil );\n\t\n\t\t\t\t}\n\t\n\t\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\t\tCubeCamera.prototype.constructor = CubeCamera;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioListener() {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'AudioListener';\n\t\n\t\t\tthis.context = AudioContext.getContext();\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( this.context.destination );\n\t\n\t\t\tthis.filter = null;\n\t\n\t\t}\n\t\n\t\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: AudioListener,\n\t\n\t\t\tgetInput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tremoveFilter: function ( ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\t\tthis.filter = null;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.filter;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( value ) {\n\t\n\t\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.gain.disconnect( this.context.destination );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filter = value;\n\t\t\t\tthis.gain.connect( this.filter );\n\t\t\t\tthis.filter.connect( this.context.destination );\n\t\n\t\t\t},\n\t\n\t\t\tgetMasterVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\t\tsetMasterVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\t\t\tvar quaternion = new Quaternion();\n\t\t\t\tvar scale = new Vector3();\n\t\n\t\t\t\tvar orientation = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tvar listener = this.context.listener;\n\t\t\t\t\tvar up = this.up;\n\t\n\t\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\t\tif ( listener.positionX ) {\n\t\n\t\t\t\t\t\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\n\t\t\t\t\t\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\n\t\t\t\t\t\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\n\t\t\t\t\t\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\n\t\t\t\t\t\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\n\t\t\t\t\t\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\n\t\t\t\t\t\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\n\t\t\t\t\t\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\n\t\t\t\t\t\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t\t */\n\t\n\t\tfunction Audio( listener ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.type = 'Audio';\n\t\n\t\t\tthis.context = listener.context;\n\t\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect( listener.getInput() );\n\t\n\t\t\tthis.autoplay = false;\n\t\n\t\t\tthis.buffer = null;\n\t\t\tthis.loop = false;\n\t\t\tthis.startTime = 0;\n\t\t\tthis.offset = 0;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.sourceType = 'empty';\n\t\n\t\t\tthis.filters = [];\n\t\n\t\t}\n\t\n\t\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\t\n\t\t\tconstructor: Audio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.gain;\n\t\n\t\t\t},\n\t\n\t\t\tsetNodeSource: function ( audioNode ) {\n\t\n\t\t\t\tthis.hasPlaybackControl = false;\n\t\t\t\tthis.sourceType = 'audioNode';\n\t\t\t\tthis.source = audioNode;\n\t\t\t\tthis.connect();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetBuffer: function ( audioBuffer ) {\n\t\n\t\t\t\tthis.buffer = audioBuffer;\n\t\t\t\tthis.sourceType = 'buffer';\n\t\n\t\t\t\tif ( this.autoplay ) this.play();\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tplay: function () {\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar source = this.context.createBufferSource();\n\t\n\t\t\t\tsource.buffer = this.buffer;\n\t\t\t\tsource.loop = this.loop;\n\t\t\t\tsource.onended = this.onEnded.bind( this );\n\t\t\t\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\n\t\t\t\tthis.startTime = this.context.currentTime;\n\t\t\t\tsource.start( this.startTime, this.offset );\n\t\n\t\t\t\tthis.isPlaying = true;\n\t\n\t\t\t\tthis.source = source;\n\t\n\t\t\t\treturn this.connect();\n\t\n\t\t\t},\n\t\n\t\t\tpause: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.source.stop();\n\t\t\t\t\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\n\t\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.offset = 0;\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.connect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tdisconnect: function () {\n\t\n\t\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\t\n\t\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.source.disconnect( this.getOutput() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilters: function () {\n\t\n\t\t\t\treturn this.filters;\n\t\n\t\t\t},\n\t\n\t\t\tsetFilters: function ( value ) {\n\t\n\t\t\t\tif ( ! value ) value = [];\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.disconnect();\n\t\t\t\t\tthis.filters = value;\n\t\t\t\t\tthis.connect();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.filters = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetFilter: function () {\n\t\n\t\t\t\treturn this.getFilters()[ 0 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetFilter: function ( filter ) {\n\t\n\t\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\t\n\t\t\t},\n\t\n\t\t\tsetPlaybackRate: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.playbackRate = value;\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetPlaybackRate: function () {\n\t\n\t\t\t\treturn this.playbackRate;\n\t\n\t\t\t},\n\t\n\t\t\tonEnded: function () {\n\t\n\t\t\t\tthis.isPlaying = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetLoop: function () {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.loop;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function ( value ) {\n\t\n\t\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.loop = value;\n\t\n\t\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\t\tthis.source.loop = this.loop;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetVolume: function () {\n\t\n\t\t\t\treturn this.gain.gain.value;\n\t\n\t\t\t},\n\t\n\t\t\tsetVolume: function ( value ) {\n\t\n\t\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PositionalAudio( listener ) {\n\t\n\t\t\tAudio.call( this, listener );\n\t\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.connect( this.gain );\n\t\n\t\t}\n\t\n\t\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\t\n\t\t\tconstructor: PositionalAudio,\n\t\n\t\t\tgetOutput: function () {\n\t\n\t\t\t\treturn this.panner;\n\t\n\t\t\t},\n\t\n\t\t\tgetRefDistance: function () {\n\t\n\t\t\t\treturn this.panner.refDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetRefDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.refDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetRolloffFactor: function () {\n\t\n\t\t\t\treturn this.panner.rolloffFactor;\n\t\n\t\t\t},\n\t\n\t\t\tsetRolloffFactor: function ( value ) {\n\t\n\t\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetDistanceModel: function () {\n\t\n\t\t\t\treturn this.panner.distanceModel;\n\t\n\t\t\t},\n\t\n\t\t\tsetDistanceModel: function ( value ) {\n\t\n\t\t\t\tthis.panner.distanceModel = value;\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxDistance: function () {\n\t\n\t\t\t\treturn this.panner.maxDistance;\n\t\n\t\t\t},\n\t\n\t\t\tsetMaxDistance: function ( value ) {\n\t\n\t\t\t\tthis.panner.maxDistance = value;\n\t\n\t\t\t},\n\t\n\t\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\t\tvar position = new Vector3();\n\t\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t\t};\n\t\n\t\t\t} )()\n\t\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AudioAnalyser( audio, fftSize ) {\n\t\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\t\n\t\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\t\n\t\t\taudio.getOutput().connect( this.analyser );\n\t\n\t\t}\n\t\n\t\tObject.assign( AudioAnalyser.prototype, {\n\t\n\t\t\tgetFrequencyData: function () {\n\t\n\t\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\t\n\t\t\t\treturn this.data;\n\t\n\t\t\t},\n\t\n\t\t\tgetAverageFrequency: function () {\n\t\n\t\t\t\tvar value = 0, data = this.getFrequencyData();\n\t\n\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\t\tvalue += data[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn value / data.length;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Buffered scene graph property that allows weighted accumulation.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\t\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\n\t\t\tvar bufferType = Float64Array,\n\t\t\t\tmixFunction;\n\t\n\t\t\tswitch ( typeName ) {\n\t\n\t\t\t\tcase 'quaternion':\n\t\t\t\t\tmixFunction = this._slerp;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\t\t\t\tbufferType = Array;\n\t\t\t\t\tmixFunction = this._select;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tmixFunction = this._lerp;\n\t\n\t\t\t}\n\t\n\t\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\n\t\t}\n\t\n\t\tObject.assign( PropertyMixer.prototype, {\n\t\n\t\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\t\taccumulate: function ( accuIndex, weight ) {\n\t\n\t\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t\t// the weight and shouldn't have made the call in the first place\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\t\n\t\t\t\tif ( currentWeight === 0 ) {\n\t\n\t\t\t\t\t// accuN := incoming * weight\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcurrentWeight = weight;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// accuN := accuN + incoming * weight\n\t\n\t\t\t\t\tcurrentWeight += weight;\n\t\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = currentWeight;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\t\tapply: function ( accuIndex ) {\n\t\n\t\t\t\tvar stride = this.valueSize,\n\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\t\tweight = this.cumulativeWeight,\n\t\n\t\t\t\t\tbinding = this.binding;\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t\tif ( weight < 1 ) {\n\t\n\t\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\n\t\t\t\t\tvar originalValueOffset = stride * 3;\n\t\n\t\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\t\n\t\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\t\n\t\t\t\t\t\t// value has changed -> update scene graph\n\t\n\t\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remember the state of the bound property and copy it to both accus\n\t\t\tsaveOriginalState: function () {\n\t\n\t\t\t\tvar binding = this.binding;\n\t\n\t\t\t\tvar buffer = this.buffer,\n\t\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\t\toriginalValueOffset = stride * 3;\n\t\n\t\t\t\tbinding.getValue( buffer, originalValueOffset );\n\t\n\t\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\t},\n\t\n\t\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\t\trestoreOriginalState: function () {\n\t\n\t\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// mix functions\n\t\n\t\t\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tif ( t >= 0.5 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\t\n\t\t\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\t\n\t\t\t},\n\t\n\t\t\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\t\tvar s = 1 - t;\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tvar j = dstOffset + i;\n\t\n\t\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A reference to a real property in the scene graph.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\t// Characters [].:/ are reserved for track binding syntax.\n\t\tvar RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\t\n\t\tfunction Composite( targetGroup, path, optionalParsedPath ) {\n\t\n\t\t\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\t\n\t\t}\n\t\n\t\tObject.assign( Composite.prototype, {\n\t\n\t\t\tgetValue: function ( array, offset ) {\n\t\n\t\t\t\tthis.bind(); // bind all binding\n\t\n\t\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\t\n\t\t\t\t// and only call .getValue on the first\n\t\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function ( array, offset ) {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].setValue( array, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tbind: function () {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].bind();\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function () {\n\t\n\t\t\t\tvar bindings = this._bindings;\n\t\n\t\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].unbind();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\n\t\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\t\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\t\n\t\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\t\n\t\t\tthis.rootNode = rootNode;\n\t\n\t\t}\n\t\n\t\tObject.assign( PropertyBinding, {\n\t\n\t\t\tComposite: Composite,\n\t\n\t\t\tcreate: function ( root, path, parsedPath ) {\n\t\n\t\t\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\t\n\t\t\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Replaces spaces with underscores and removes unsupported characters from\n\t\t\t * node names, to ensure compatibility with parseTrackName().\n\t\t\t *\n\t\t\t * @param  {string} name Node name to be sanitized.\n\t\t\t * @return {string}\n\t\t\t */\n\t\t\tsanitizeNodeName: ( function () {\n\t\n\t\t\t\tvar reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );\n\t\n\t\t\t\treturn function sanitizeNodeName( name ) {\n\t\n\t\t\t\t\treturn name.replace( /\\s/g, '_' ).replace( reservedRe, '' );\n\t\n\t\t\t\t};\n\t\n\t\t\t}() ),\n\t\n\t\t\tparseTrackName: function () {\n\t\n\t\t\t\t// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t\t\t\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t\t\t\t// instead, we exclude reserved characters and match everything else.\n\t\t\t\tvar wordChar = '[^' + RESERVED_CHARS_RE + ']';\n\t\t\t\tvar wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\t\n\t\t\t\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t\t\t\t// be matched to parse the rest of the track name.\n\t\t\t\tvar directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar );\n\t\n\t\t\t\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\t\t\t\tvar nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );\n\t\n\t\t\t\t// Object on target node, and accessor. May not contain reserved\n\t\t\t\t// characters. Accessor may contain any character except closing bracket.\n\t\t\t\tvar objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar );\n\t\n\t\t\t\t// Property and accessor. May not contain reserved characters. Accessor may\n\t\t\t\t// contain any non-bracket characters.\n\t\t\t\tvar propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar );\n\t\n\t\t\t\tvar trackRe = new RegExp( ''\n\t\t\t\t\t+ '^'\n\t\t\t\t\t+ directoryRe\n\t\t\t\t\t+ nodeRe\n\t\t\t\t\t+ objectRe\n\t\t\t\t\t+ propertyRe\n\t\t\t\t\t+ '$'\n\t\t\t\t);\n\t\n\t\t\t\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\t\n\t\t\t\treturn function parseTrackName( trackName ) {\n\t\n\t\t\t\t\tvar matches = trackRe.exec( trackName );\n\t\n\t\t\t\t\tif ( ! matches ) {\n\t\n\t\t\t\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar results = {\n\t\t\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\t\t\tnodeName: matches[ 2 ],\n\t\t\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\t\t\t\tpropertyIndex: matches[ 6 ]\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\t\n\t\t\t\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\t\n\t\t\t\t\t\tvar objectName = results.nodeName.substring( lastDot + 1 );\n\t\n\t\t\t\t\t\t// Object names must be checked against a whitelist. Otherwise, there\n\t\t\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t\t\t// include '.' characters).\n\t\t\t\t\t\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\t\n\t\t\t\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\t\t\t\tresults.objectName = objectName;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\t\n\t\t\t\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn results;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tfindNode: function ( root, nodeName ) {\n\t\n\t\t\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\t\n\t\t\t\t\treturn root;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// search into skeleton bones.\n\t\t\t\tif ( root.skeleton ) {\n\t\n\t\t\t\t\tvar bone = root.skeleton.getBoneByName( nodeName );\n\t\n\t\t\t\t\tif ( bone !== undefined ) {\n\t\n\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// search into node subtree.\n\t\t\t\tif ( root.children ) {\n\t\n\t\t\t\t\tvar searchNodeSubtree = function ( children ) {\n\t\n\t\t\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar childNode = children[ i ];\n\t\n\t\t\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\t\n\t\t\t\t\t\t\t\treturn childNode;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\t\n\t\t\t\t\t\t\tif ( result ) return result;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn null;\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\t\n\t\t\t\t\tif ( subTreeNode ) {\n\t\n\t\t\t\t\t\treturn subTreeNode;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\t\n\t\t\t// these are used to \"bind\" a nonexistent property\n\t\t\t_getValue_unavailable: function () {},\n\t\t\t_setValue_unavailable: function () {},\n\t\n\t\t\tBindingType: {\n\t\t\t\tDirect: 0,\n\t\t\t\tEntireArray: 1,\n\t\t\t\tArrayElement: 2,\n\t\t\t\tHasFromToArray: 3\n\t\t\t},\n\t\n\t\t\tVersioning: {\n\t\t\t\tNone: 0,\n\t\t\t\tNeedsUpdate: 1,\n\t\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t\t},\n\t\n\t\t\tGetterByBindingType: [\n\t\n\t\t\t\tfunction getValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_array( buffer, offset ) {\n\t\n\t\t\t\t\tvar source = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction getValue_toArray( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t],\n\t\n\t\t\tSetterByBindingTypeAndVersioning: [\n\t\n\t\t\t\t[\n\t\t\t\t\t// Direct\n\t\n\t\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// EntireArray\n\t\n\t\t\t\t\tfunction setValue_array( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// ArrayElement\n\t\n\t\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t], [\n\t\n\t\t\t\t\t// HasToFromArray\n\t\n\t\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t]\n\t\n\t\t\t],\n\t\n\t\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.getValue( targetArray, offset );\n\t\n\t\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t\t// prototype version of these methods with one that represents\n\t\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t\t// become no-ops.\n\t\n\t\t\t},\n\t\n\t\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\t\n\t\t\t\tthis.bind();\n\t\t\t\tthis.setValue( sourceArray, offset );\n\t\n\t\t\t},\n\t\n\t\t\t// create getter / setter pair for a property in the scene graph\n\t\t\tbind: function () {\n\t\n\t\t\t\tvar targetObject = this.node,\n\t\t\t\t\tparsedPath = this.parsedPath,\n\t\n\t\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\t\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\t\n\t\t\t\t\tthis.node = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// set fail state so we can just 'return' on error\n\t\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\t\tthis.setValue = this._setValue_unavailable;\n\t\n\t\t\t\t// ensure there is a value node\n\t\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( objectName ) {\n\t\n\t\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\t\n\t\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\t\tswitch ( objectName ) {\n\t\n\t\t\t\t\t\tcase 'materials':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'bones':\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t\t// and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\t\n\t\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\t\n\t\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\t\n\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\tif ( objectIndex !== undefined ) {\n\t\n\t\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// resolve property\n\t\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\t\n\t\t\t\tif ( nodeProperty === undefined ) {\n\t\n\t\t\t\t\tvar nodeName = parsedPath.nodeName;\n\t\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine versioning scheme\n\t\t\t\tvar versioning = this.Versioning.None;\n\t\n\t\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\t\n\t\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\t\n\t\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// determine how the property gets bound\n\t\t\t\tvar bindingType = this.BindingType.Direct;\n\t\n\t\t\t\tif ( propertyIndex !== undefined ) {\n\t\n\t\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\n\t\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\n\t\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tif ( ! targetObject.geometry ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\t\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\n\t\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\n\t\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\n\t\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\n\t\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\t\n\t\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\n\t\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.propertyName = propertyName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// select getter / setter\n\t\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\t\n\t\t\t},\n\t\n\t\t\tunbind: function () {\n\t\n\t\t\t\tthis.node = null;\n\t\n\t\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\t\tthis.setValue = this._setValue_unbound;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//!\\ DECLARE ALIAS AFTER assign prototype !\n\t\tObject.assign( PropertyBinding.prototype, {\n\t\n\t\t\t// initial state of these methods that calls 'bind'\n\t\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * A group of objects that receives a shared animation state.\n\t\t *\n\t\t * Usage:\n\t\t *\n\t\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t\t *\n\t\t * \t-\tInstead pass this object as 'root'.\n\t\t *\n\t\t * \t-\tYou can also add and remove objects later when the mixer\n\t\t * \t\tis running.\n\t\t *\n\t\t * Note:\n\t\t *\n\t\t *  \tObjects of this class appear as one object to the mixer,\n\t\t *  \tso cache control of the individual objects must be done\n\t\t *  \ton the group.\n\t\t *\n\t\t * Limitation:\n\t\t *\n\t\t * \t- \tThe animated properties must be compatible among the\n\t\t * \t\tall objects in the group.\n\t\t *\n\t\t *  -\tA single property can either be controlled through a\n\t\t *  \ttarget group or directly, but not both.\n\t\t *\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationObjectGroup() {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\t// cached objects followed by the active ones\n\t\t\tthis._objects = Array.prototype.slice.call( arguments );\n\t\n\t\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\t\n\t\t\tvar indices = {};\n\t\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tindices[ arguments[ i ].uuid ] = i;\n\t\n\t\t\t}\n\t\n\t\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.stats = {\n\t\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() {\n\t\n\t\t\t\t\t\treturn scope._objects.length;\n\t\n\t\t\t\t\t},\n\t\t\t\t\tget inUse() {\n\t\n\t\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tget bindingsPerObject() {\n\t\n\t\t\t\t\treturn scope._bindings.length;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\tObject.assign( AnimationObjectGroup.prototype, {\n\t\n\t\t\tisAnimationObjectGroup: true,\n\t\n\t\t\tadd: function () {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length,\n\t\t\t\t\tknownObject = undefined;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index === undefined ) {\n\t\n\t\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\n\t\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\t\tobjects.push( object );\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\tknownObject = objects[ index ];\n\t\n\t\t\t\t\t\t// move existing object to the ACTIVE region\n\t\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\n\t\t\t\t\t\t\tif ( binding === undefined ) {\n\t\n\t\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t\t// or may not exist\n\t\n\t\t\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\t\n\t\t\t\t\t} // else the object is already where we want it to be\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\tremove: function () {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\t\n\t\t\t\t\t\t// move existing object into the CACHED region\n\t\n\t\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\t\n\t\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// remove & forget\n\t\t\tuncache: function () {\n\t\n\t\t\t\tvar objects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\t\n\t\t\t\t\t\tif ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\n\t\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\n\t\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\t\n\t\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} // cached or active\n\t\n\t\t\t\t\t} // if object is known\n\t\n\t\t\t\t} // for arguments\n\t\n\t\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t\t},\n\t\n\t\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\t\n\t\t\tsubscribe_: function ( path, parsedPath ) {\n\t\n\t\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t\t// according to the contained objects in the group\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( index !== undefined ) return bindings[ index ];\n\t\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tbindingsForPath = new Array( nObjects );\n\t\n\t\t\t\tindex = bindings.length;\n\t\n\t\t\t\tindicesByPath[ path ] = index;\n\t\n\t\t\t\tpaths.push( path );\n\t\t\t\tparsedPaths.push( parsedPath );\n\t\t\t\tbindings.push( bindingsForPath );\n\t\n\t\t\t\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar object = objects[ i ];\n\t\t\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn bindingsForPath;\n\t\n\t\t\t},\n\t\n\t\t\tunsubscribe_: function ( path ) {\n\t\n\t\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t\t// update the array previously obtained with 'subscribe_'\n\t\n\t\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\tindex = indicesByPath[ path ];\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tvar paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\t\n\t\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\t\n\t\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\t\tbindings.pop();\n\t\n\t\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\t\tparsedPaths.pop();\n\t\n\t\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\t\tpaths.pop();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t\t * objects.\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t *\n\t\t */\n\t\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\t\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot || null;\n\t\n\t\t\tvar tracks = clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tinterpolants = new Array( nTracks );\n\t\n\t\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\t\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\t\tinterpolants[ i ] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\n\t\t\t}\n\t\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\n\t\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\t\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\t\t\tthis._propertyBindings = new Array( nTracks );\n\t\n\t\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\t\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = - 1;\n\t\n\t\t\t// global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\t\t\tthis._startTime = null;\n\t\n\t\t\t// scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\n\t\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\t\n\t\t\tthis.paused = false;\t\t\t\t// true -> zero effective time scale\n\t\t\tthis.enabled = true;\t\t\t\t// false -> zero effective weight\n\t\n\t\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\t\n\t\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\t\n\t\t}\n\t\n\t\tObject.assign( AnimationAction.prototype, {\n\t\n\t\t\t// State & Scheduling\n\t\n\t\t\tplay: function () {\n\t\n\t\t\t\tthis._mixer._activateAction( this );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tthis._mixer._deactivateAction( this );\n\t\n\t\t\t\treturn this.reset();\n\t\n\t\t\t},\n\t\n\t\t\treset: function () {\n\t\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.enabled = true;\n\t\n\t\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\t\tthis._loopCount = - 1;\t// forget previous loops\n\t\t\t\tthis._startTime = null;\t// forget scheduling\n\t\n\t\t\t\treturn this.stopFading().stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tisRunning: function () {\n\t\n\t\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\t// return true when play has been called\n\t\t\tisScheduled: function () {\n\t\n\t\t\t\treturn this._mixer._isActiveAction( this );\n\t\n\t\t\t},\n\t\n\t\t\tstartAt: function ( time ) {\n\t\n\t\t\t\tthis._startTime = time;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetLoop: function ( mode, repetitions ) {\n\t\n\t\t\t\tthis.loop = mode;\n\t\t\t\tthis.repetitions = repetitions;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Weight\n\t\n\t\t\t// set the weight stopping any scheduled fading\n\t\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t\t// method does *not* change .enabled, because it would be confusing\n\t\t\tsetEffectiveWeight: function ( weight ) {\n\t\n\t\t\t\tthis.weight = weight;\n\t\n\t\t\t\t// note: same logic as when updated at runtime\n\t\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\n\t\t\t\treturn this.stopFading();\n\t\n\t\t\t},\n\t\n\t\t\t// return the weight considering fading and .enabled\n\t\t\tgetEffectiveWeight: function () {\n\t\n\t\t\t\treturn this._effectiveWeight;\n\t\n\t\t\t},\n\t\n\t\t\tfadeIn: function ( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\t\n\t\t\t},\n\t\n\t\t\tfadeOut: function ( duration ) {\n\t\n\t\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\n\t\n\t\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\t\tthis.fadeIn( duration );\n\t\n\t\t\t\tif ( warp ) {\n\t\n\t\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\n\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\n\t\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\n\t\n\t\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\t\n\t\t\t},\n\t\n\t\t\tstopFading: function () {\n\t\n\t\t\t\tvar weightInterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( weightInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Time Scale Control\n\t\n\t\t\t// set the time scale stopping any scheduled warping\n\t\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t\t// method does *not* change .paused, because it would be confusing\n\t\t\tsetEffectiveTimeScale: function ( timeScale ) {\n\t\n\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\t// return the time scale considering warping and .paused\n\t\t\tgetEffectiveTimeScale: function () {\n\t\n\t\t\t\treturn this._effectiveTimeScale;\n\t\n\t\t\t},\n\t\n\t\t\tsetDuration: function ( duration ) {\n\t\n\t\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\tsyncWith: function ( action ) {\n\t\n\t\t\t\tthis.time = action.time;\n\t\t\t\tthis.timeScale = action.timeScale;\n\t\n\t\t\t\treturn this.stopWarping();\n\t\n\t\t\t},\n\t\n\t\t\thalt: function ( duration ) {\n\t\n\t\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\t\n\t\t\t},\n\t\n\t\t\twarp: function ( startTimeScale, endTimeScale, duration ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now;\n\t\t\t\ttimes[ 1 ] = now + duration;\n\t\n\t\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tstopWarping: function () {\n\t\n\t\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\tif ( timeScaleInterpolant !== null ) {\n\t\n\t\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// Object Accessors\n\t\n\t\t\tgetMixer: function () {\n\t\n\t\t\t\treturn this._mixer;\n\t\n\t\t\t},\n\t\n\t\t\tgetClip: function () {\n\t\n\t\t\t\treturn this._clip;\n\t\n\t\t\t},\n\t\n\t\t\tgetRoot: function () {\n\t\n\t\t\t\treturn this._localRoot || this._mixer._root;\n\t\n\t\t\t},\n\t\n\t\t\t// Interna\n\t\n\t\t\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\n\t\n\t\t\t\t// called by the mixer\n\t\n\t\t\t\tif ( ! this.enabled ) {\n\t\n\t\t\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\t\n\t\t\t\t\tthis._updateWeight( time );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar startTime = this._startTime;\n\t\n\t\t\t\tif ( startTime !== null ) {\n\t\n\t\t\t\t\t// check for scheduled start of action\n\t\n\t\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\t\n\t\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// start\n\t\n\t\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// apply time scale and advance time\n\t\n\t\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\t\tvar clipTime = this._updateTime( deltaTime );\n\t\n\t\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t\t// an effective weight of 0\n\t\n\t\t\t\tvar weight = this._updateWeight( time );\n\t\n\t\t\t\tif ( weight > 0 ) {\n\t\n\t\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\t\tvar propertyMixers = this._propertyBindings;\n\t\n\t\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_updateWeight: function ( time ) {\n\t\n\t\t\t\tvar weight = 0;\n\t\n\t\t\t\tif ( this.enabled ) {\n\t\n\t\t\t\t\tweight = this.weight;\n\t\t\t\t\tvar interpolant = this._weightInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\tweight *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopFading();\n\t\n\t\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\t\tthis.enabled = false;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveWeight = weight;\n\t\t\t\treturn weight;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTimeScale: function ( time ) {\n\t\n\t\t\t\tvar timeScale = 0;\n\t\n\t\t\t\tif ( ! this.paused ) {\n\t\n\t\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\t\ttimeScale *= interpolantValue;\n\t\n\t\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\t\tthis.stopWarping();\n\t\n\t\t\t\t\t\t\tif ( timeScale === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\t\tthis.paused = true;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\t\treturn timeScale;\n\t\n\t\t\t},\n\t\n\t\t\t_updateTime: function ( deltaTime ) {\n\t\n\t\t\t\tvar time = this.time + deltaTime;\n\t\n\t\t\t\tif ( deltaTime === 0 ) return time;\n\t\n\t\t\t\tvar duration = this._clip.duration,\n\t\n\t\t\t\t\tloop = this.loop,\n\t\t\t\t\tloopCount = this._loopCount;\n\t\n\t\t\t\tif ( loop === LoopOnce ) {\n\t\n\t\t\t\t\tif ( loopCount === - 1 ) {\n\t\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tthis._loopCount = 0;\n\t\t\t\t\t\tthis._setEndings( true, true, false );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\thandle_stop: {\n\t\n\t\t\t\t\t\tif ( time >= duration ) {\n\t\n\t\t\t\t\t\t\ttime = duration;\n\t\n\t\t\t\t\t\t} else if ( time < 0 ) {\n\t\n\t\t\t\t\t\t\ttime = 0;\n\t\n\t\t\t\t\t\t} else break handle_stop;\n\t\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else { // repetitive Repeat or PingPong\n\t\n\t\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\t\n\t\t\t\t\tif ( loopCount === - 1 ) {\n\t\n\t\t\t\t\t\t// just started\n\t\n\t\t\t\t\t\tif ( deltaTime >= 0 ) {\n\t\n\t\t\t\t\t\t\tloopCount = 0;\n\t\n\t\t\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t\t// so leave loopCount at -1\n\t\n\t\t\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\n\t\t\t\t\t\t// wrap around\n\t\n\t\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\t\ttime -= duration * loopDelta;\n\t\n\t\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\t\n\t\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\t\n\t\t\t\t\t\tif ( pending < 0 ) {\n\t\n\t\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\n\t\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// keep running\n\t\n\t\t\t\t\t\t\tif ( pending === 0 ) {\n\t\n\t\t\t\t\t\t\t\t// entering the last round\n\t\n\t\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\n\t\t\t\t\t\t// invert time for the \"pong round\"\n\t\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\treturn duration - time;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.time = time;\n\t\t\t\treturn time;\n\t\n\t\t\t},\n\t\n\t\t\t_setEndings: function ( atStart, atEnd, pingPong ) {\n\t\n\t\t\t\tvar settings = this._interpolantSettings;\n\t\n\t\t\t\tif ( pingPong ) {\n\t\n\t\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\n\t\t\t\t\tif ( atStart ) {\n\t\n\t\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( atEnd ) {\n\t\n\t\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_scheduleFading: function ( duration, weightNow, weightThen ) {\n\t\n\t\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\t\tinterpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\t\tthis._weightInterpolant = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t *\n\t\t * Player for AnimationClips.\n\t\t *\n\t\t *\n\t\t * @author Ben Houston / http://clara.io/\n\t\t * @author David Sarno / http://lighthaus.us/\n\t\t * @author tschw\n\t\t */\n\t\n\t\tfunction AnimationMixer( root ) {\n\t\n\t\t\tthis._root = root;\n\t\t\tthis._initMemoryManager();\n\t\t\tthis._accuIndex = 0;\n\t\n\t\t\tthis.time = 0;\n\t\n\t\t\tthis.timeScale = 1.0;\n\t\n\t\t}\n\t\n\t\tAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\t\n\t\t\tconstructor: AnimationMixer,\n\t\n\t\t\t_bindAction: function ( action, prototypeAction ) {\n\t\n\t\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingsByName === undefined ) {\n\t\n\t\t\t\t\tbindingsByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\t\n\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbinding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\n\t\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\t\n\t\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\t\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_activateAction: function ( action ) {\n\t\n\t\t\t\tif ( ! this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tif ( action._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t\t// appears to be still using it -> rebind\n\t\n\t\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\t\n\t\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// increment reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\t\n\t\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\t\tbinding.saveOriginalState();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._lendAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_deactivateAction: function ( action ) {\n\t\n\t\t\t\tif ( this._isActiveAction( action ) ) {\n\t\n\t\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\t\n\t\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\t\tthis._takeBackBinding( binding );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis._takeBackAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// Memory manager\n\t\n\t\t\t_initMemoryManager: function () {\n\t\n\t\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\t\tthis._nActiveActions = 0;\n\t\n\t\t\t\tthis._actionsByClip = {};\n\t\t\t\t// inside:\n\t\t\t\t// {\n\t\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t\t// }\n\t\n\t\n\t\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\t\n\t\n\t\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\t\tthis._nActiveControlInterpolants = 0;\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tthis.stats = {\n\t\n\t\t\t\t\tactions: {\n\t\t\t\t\t\tget total() {\n\t\n\t\t\t\t\t\t\treturn scope._actions.length;\n\t\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget inUse() {\n\t\n\t\t\t\t\t\t\treturn scope._nActiveActions;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbindings: {\n\t\t\t\t\t\tget total() {\n\t\n\t\t\t\t\t\t\treturn scope._bindings.length;\n\t\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget inUse() {\n\t\n\t\t\t\t\t\t\treturn scope._nActiveBindings;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\t\tget total() {\n\t\n\t\t\t\t\t\t\treturn scope._controlInterpolants.length;\n\t\n\t\t\t\t\t\t},\n\t\t\t\t\t\tget inUse() {\n\t\n\t\t\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for AnimationAction objects\n\t\n\t\t\t_isActiveAction: function ( action ) {\n\t\n\t\t\t\tvar index = action._cacheIndex;\n\t\t\t\treturn index !== null && index < this._nActiveActions;\n\t\n\t\t\t},\n\t\n\t\t\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip === undefined ) {\n\t\n\t\t\t\t\tactionsForClip = {\n\t\n\t\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\t\tactionByRoot: {}\n\t\n\t\t\t\t\t};\n\t\n\t\t\t\t\taction._byClipCacheIndex = 0;\n\t\n\t\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\t\n\t\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\t\tknownActions.push( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t\taction._cacheIndex = actions.length;\n\t\t\t\tactions.push( action );\n\t\n\t\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveAction: function ( action ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\t\n\t\t\t\taction._cacheIndex = null;\n\t\n\t\n\t\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\n\t\t\t\t\tlastKnownAction =\n\t\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\t\n\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\n\t\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\t\tknownActionsForClip.pop();\n\t\n\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\n\t\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\t\n\t\t\t\tdelete actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( knownActionsForClip.length === 0 ) {\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBindingsForAction: function ( action ) {\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\t\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendAction: function ( action ) {\n\t\n\t\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t\t// [  active actions >| inactive actions ]\n\t\t\t\t//                 s        a\n\t\t\t\t//                  <-swap->\n\t\t\t\t//                 a        s\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\t\n\t\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\t\tactions[ lastActiveIndex ] = action;\n\t\n\t\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackAction: function ( action ) {\n\t\n\t\t\t\t// [  active actions  | inactive actions ]\n\t\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t\t//        a        s\n\t\t\t\t//         <-swap->\n\t\t\t\t//        s        a\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\t\n\t\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\t\n\t\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\t\tactions[ firstInactiveIndex ] = action;\n\t\n\t\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\t\tactions[ prevIndex ] = lastActiveAction;\n\t\n\t\t\t},\n\t\n\t\t\t// Memory management for PropertyMixer objects\n\t\n\t\t\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tbindings = this._bindings;\n\t\n\t\t\t\tif ( bindingByName === undefined ) {\n\t\n\t\t\t\t\tbindingByName = {};\n\t\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbindingByName[ trackName ] = binding;\n\t\n\t\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\t\tbindings.push( binding );\n\t\n\t\t\t},\n\t\n\t\t\t_removeInactiveBinding: function ( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\n\t\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\t\tbindings.pop();\n\t\n\t\t\t\tdelete bindingByName[ trackName ];\n\t\n\t\t\t\tremove_empty_map: {\n\t\n\t\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\n\t\n\t\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t_lendBinding: function ( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\t\n\t\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\t\tbindings[ lastActiveIndex ] = binding;\n\t\n\t\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackBinding: function ( binding ) {\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\t\n\t\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\t\n\t\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\t\tbindings[ firstInactiveIndex ] = binding;\n\t\n\t\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// Memory management of Interpolants for weight and time scale\n\t\n\t\t\t_lendControlInterpolant: function () {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\t\n\t\t\t\tif ( interpolant === undefined ) {\n\t\n\t\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\t\n\t\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn interpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_takeBackControlInterpolant: function ( interpolant ) {\n\t\n\t\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\n\t\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\t\n\t\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\t\n\t\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\t\n\t\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\t\n\t\t\t},\n\t\n\t\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\t\n\t\t\t// return an action for a clip optionally using a custom root target\n\t\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t\t// previously unknown clip/root combination is specified)\n\t\t\tclipAction: function ( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\t\tprototypeAction = null;\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\tvar existingAction =\n\t\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( existingAction !== undefined ) {\n\t\n\t\t\t\t\t\treturn existingAction;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t\t// the bindings again but can just copy\n\t\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\t\n\t\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\t\tif ( clipObject === null )\n\t\t\t\t\t\tclipObject = prototypeAction._clip;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// clip must be known when specified via string\n\t\t\t\tif ( clipObject === null ) return null;\n\t\n\t\t\t\t// allocate all resources required to run it\n\t\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\t\n\t\t\t\tthis._bindAction( newAction, prototypeAction );\n\t\n\t\t\t\t// and make the action known to the memory manager\n\t\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\t\n\t\t\t\treturn newAction;\n\t\n\t\t\t},\n\t\n\t\t\t// get an existing action\n\t\t\texistingAction: function ( clip, optionalRoot ) {\n\t\n\t\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t},\n\t\n\t\t\t// deactivates all previously scheduled actions\n\t\t\tstopAllAction: function () {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tthis._nActiveActions = 0;\n\t\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tactions[ i ].reset();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].useCount = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// advance the time and update apply the animation\n\t\t\tupdate: function ( deltaTime ) {\n\t\n\t\t\t\tdeltaTime *= this.timeScale;\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tnActions = this._nActiveActions,\n\t\n\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\t\n\t\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t\t\t\t// run active actions\n\t\n\t\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\t\tvar action = actions[ i ];\n\t\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update scene graph\n\t\n\t\t\t\tvar bindings = this._bindings,\n\t\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\t\tbindings[ i ].apply( accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// return this mixer's root target object\n\t\t\tgetRoot: function () {\n\t\n\t\t\t\treturn this._root;\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular clip\n\t\t\tuncacheClip: function ( clip ) {\n\t\n\t\t\t\tvar actions = this._actions,\n\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t\t// just throw away\n\t\n\t\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\t\n\t\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar action = actionsToRemove[ i ];\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\n\t\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\t\n\t\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\t\tactions.pop();\n\t\n\t\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// free all resources specific to a particular root target object\n\t\t\tuncacheRoot: function ( root ) {\n\t\n\t\t\t\tvar rootUuid = root.uuid,\n\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\n\t\t\t\tfor ( var clipUuid in actionsByClip ) {\n\t\n\t\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\t\n\t\t\t\t\tif ( action !== undefined ) {\n\t\n\t\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( bindingByName !== undefined ) {\n\t\n\t\t\t\t\tfor ( var trackName in bindingByName ) {\n\t\n\t\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// remove a targeted clip from the cache\n\t\t\tuncacheAction: function ( clip, optionalRoot ) {\n\t\n\t\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\t\n\t\t\t\tif ( action !== null ) {\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Uniform( value ) {\n\t\n\t\t\tif ( typeof value === 'string' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\t\tvalue = arguments[ 1 ];\n\t\n\t\t\t}\n\t\n\t\t\tthis.value = value;\n\t\n\t\t}\n\t\n\t\tUniform.prototype.clone = function () {\n\t\n\t\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferGeometry() {\n\t\n\t\t\tBufferGeometry.call( this );\n\t\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.maxInstancedCount = undefined;\n\t\n\t\t}\n\t\n\t\tInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\n\t\n\t\t\tconstructor: InstancedBufferGeometry,\n\t\n\t\t\tisInstancedBufferGeometry: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tBufferGeometry.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.maxInstancedCount = source.maxInstancedCount;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\n\t\t\tthis.normalized = normalized === true;\n\t\n\t\t}\n\t\n\t\tObject.defineProperties( InterleavedBufferAttribute.prototype, {\n\t\n\t\t\tcount: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.data.count;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tarray: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.data.array;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( InterleavedBufferAttribute.prototype, {\n\t\n\t\t\tisInterleavedBufferAttribute: true,\n\t\n\t\t\tsetX: function ( index, x ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetY: function ( index, y ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetZ: function ( index, z ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetW: function ( index, w ) {\n\t\n\t\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tgetX: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\t\n\t\t\t},\n\t\n\t\t\tgetY: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetZ: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\t\n\t\t\t},\n\t\n\t\t\tgetW: function ( index ) {\n\t\n\t\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\t\n\t\t\t},\n\t\n\t\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\t\tthis.data.array[ index + 3 ] = w;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InterleavedBuffer( array, stride ) {\n\t\n\t\t\tthis.uuid = _Math.generateUUID();\n\t\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\n\t\t\tthis.dynamic = false;\n\t\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\t\tthis.onUploadCallback = function () {};\n\t\n\t\t\tthis.version = 0;\n\t\n\t\t}\n\t\n\t\tObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\n\t\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( InterleavedBuffer.prototype, {\n\t\n\t\t\tisInterleavedBuffer: true,\n\t\n\t\t\tsetArray: function ( array ) {\n\t\n\t\t\t\tif ( Array.isArray( array ) ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\t\tthis.array = array;\n\t\n\t\t\t},\n\t\n\t\t\tsetDynamic: function ( value ) {\n\t\n\t\t\t\tthis.dynamic = value;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\t\tthis.count = source.count;\n\t\t\t\tthis.stride = source.stride;\n\t\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\t\tindex1 *= this.stride;\n\t\t\t\tindex2 *= attribute.stride;\n\t\n\t\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tset: function ( value, offset ) {\n\t\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\t\tthis.array.set( value, offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tonUpload: function ( callback ) {\n\t\n\t\t\t\tthis.onUploadCallback = callback;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\t\n\t\t\tInterleavedBuffer.call( this, array, stride );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\n\t\n\t\t\tconstructor: InstancedInterleavedBuffer,\n\t\n\t\t\tisInstancedInterleavedBuffer: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author benaadams / https://twitter.com/ben_a_adams\n\t\t */\n\t\n\t\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\t\n\t\t\tBufferAttribute.call( this, array, itemSize );\n\t\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t\t}\n\t\n\t\tInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\n\t\n\t\t\tconstructor: InstancedBufferAttribute,\n\t\n\t\t\tisInstancedBufferAttribute: true,\n\t\n\t\t\tcopy: function ( source ) {\n\t\n\t\t\t\tBufferAttribute.prototype.copy.call( this, source );\n\t\n\t\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author bhouston / http://clara.io/\n\t\t * @author stephomi / http://stephaneginier.com/\n\t\t */\n\t\n\t\tfunction Raycaster( origin, direction, near, far ) {\n\t\n\t\t\tthis.ray = new Ray( origin, direction );\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\tthis.near = near || 0;\n\t\t\tthis.far = far || Infinity;\n\t\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: { threshold: 1 },\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\n\t\t\tObject.defineProperties( this.params, {\n\t\t\t\tPointCloud: {\n\t\t\t\t\tget: function () {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\t\treturn this.Points;\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t}\n\t\n\t\tfunction ascSort( a, b ) {\n\t\n\t\t\treturn a.distance - b.distance;\n\t\n\t\t}\n\t\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tobject.raycast( raycaster, intersects );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tObject.assign( Raycaster.prototype, {\n\t\n\t\t\tlinePrecision: 1,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\t\tthis.ray.set( origin, direction );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCamera: function ( coords, camera ) {\n\t\n\t\t\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\n\t\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\n\t\t\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\n\t\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tintersectObject: function ( object, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tintersectObject( object, this, intersects, recursive );\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t},\n\t\n\t\t\tintersectObjects: function ( objects, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\t\treturn intersects;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction Clock( autoStart ) {\n\t\n\t\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\t\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\n\t\t\tthis.running = false;\n\t\n\t\t}\n\t\n\t\tObject.assign( Clock.prototype, {\n\t\n\t\t\tstart: function () {\n\t\n\t\t\t\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\t\n\t\t\t\tthis.oldTime = this.startTime;\n\t\t\t\tthis.elapsedTime = 0;\n\t\t\t\tthis.running = true;\n\t\n\t\t\t},\n\t\n\t\t\tstop: function () {\n\t\n\t\t\t\tthis.getElapsedTime();\n\t\t\t\tthis.running = false;\n\t\t\t\tthis.autoStart = false;\n\t\n\t\t\t},\n\t\n\t\t\tgetElapsedTime: function () {\n\t\n\t\t\t\tthis.getDelta();\n\t\t\t\treturn this.elapsedTime;\n\t\n\t\t\t},\n\t\n\t\t\tgetDelta: function () {\n\t\n\t\t\t\tvar diff = 0;\n\t\n\t\t\t\tif ( this.autoStart && ! this.running ) {\n\t\n\t\t\t\t\tthis.start();\n\t\t\t\t\treturn 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.running ) {\n\t\n\t\t\t\t\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\n\t\n\t\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\t\tthis.oldTime = newTime;\n\t\n\t\t\t\t\tthis.elapsedTime += diff;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn diff;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t *\n\t\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t\t *\n\t\t * The poles (phi) are at the positive and negative y axis.\n\t\t * The equator starts at positive z.\n\t\t */\n\t\n\t\tfunction Spherical( radius, phi, theta ) {\n\t\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\tObject.assign( Spherical.prototype, {\n\t\n\t\t\tset: function ( radius, phi, theta ) {\n\t\n\t\t\t\tthis.radius = radius;\n\t\t\t\tthis.phi = phi;\n\t\t\t\tthis.theta = theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( other ) {\n\t\n\t\t\t\tthis.radius = other.radius;\n\t\t\t\tthis.phi = other.phi;\n\t\t\t\tthis.theta = other.theta;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\tmakeSafe: function () {\n\t\n\t\t\t\tvar EPS = 0.000001;\n\t\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromVector3: function ( vec3 ) {\n\t\n\t\t\t\tthis.radius = vec3.length();\n\t\n\t\t\t\tif ( this.radius === 0 ) {\n\t\n\t\t\t\t\tthis.theta = 0;\n\t\t\t\t\tthis.phi = 0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n\t\t *\n\t\t */\n\t\n\t\tfunction Cylindrical( radius, theta, y ) {\n\t\n\t\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\n\t\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\t\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t\tObject.assign( Cylindrical.prototype, {\n\t\n\t\t\tset: function ( radius, theta, y ) {\n\t\n\t\t\t\tthis.radius = radius;\n\t\t\t\tthis.theta = theta;\n\t\t\t\tthis.y = y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( other ) {\n\t\n\t\t\t\tthis.radius = other.radius;\n\t\t\t\tthis.theta = other.theta;\n\t\t\t\tthis.y = other.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromVector3: function ( vec3 ) {\n\t\n\t\t\t\tthis.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z );\n\t\t\t\tthis.y = vec3.y;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author bhouston / http://clara.io\n\t\t */\n\t\n\t\tfunction Box2( min, max ) {\n\t\n\t\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\t\n\t\t}\n\t\n\t\tObject.assign( Box2.prototype, {\n\t\n\t\t\tset: function ( min, max ) {\n\t\n\t\t\t\tthis.min.copy( min );\n\t\t\t\tthis.max.copy( max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tclone: function () {\n\t\n\t\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t\t},\n\t\n\t\t\tcopy: function ( box ) {\n\t\n\t\t\t\tthis.min.copy( box.min );\n\t\t\t\tthis.max.copy( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tmakeEmpty: function () {\n\t\n\t\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\t\tthis.max.x = this.max.y = - Infinity;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tisEmpty: function () {\n\t\n\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\t\n\t\t\t},\n\t\n\t\t\tgetCenter: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t\t},\n\t\n\t\t\tgetSize: function ( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\t\n\t\t\t},\n\t\n\t\t\texpandByPoint: function ( point ) {\n\t\n\t\t\t\tthis.min.min( point );\n\t\t\t\tthis.max.max( point );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByVector: function ( vector ) {\n\t\n\t\t\t\tthis.min.sub( vector );\n\t\t\t\tthis.max.add( vector );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\t\tthis.min.addScalar( - scalar );\n\t\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\t\n\t\t\t},\n\t\n\t\t\tcontainsBox: function ( box ) {\n\t\n\t\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\t\n\t\t\t},\n\t\n\t\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t// has a size dimension of 0.\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\n\t\t\t\treturn result.set(\n\t\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t\t);\n\t\n\t\t\t},\n\t\n\t\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t\t// using 4 splitting planes to rule out intersections\n\t\n\t\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\t\n\t\t\t},\n\t\n\t\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t\t},\n\t\n\t\t\tdistanceToPoint: function () {\n\t\n\t\t\t\tvar v1 = new Vector2();\n\t\n\t\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\n\t\t\tintersect: function ( box ) {\n\t\n\t\t\t\tthis.min.max( box.min );\n\t\t\t\tthis.max.min( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tunion: function ( box ) {\n\t\n\t\t\t\tthis.min.min( box.min );\n\t\t\t\tthis.max.max( box.max );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\ttranslate: function ( offset ) {\n\t\n\t\t\t\tthis.min.add( offset );\n\t\t\t\tthis.max.add( offset );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t},\n\t\n\t\t\tequals: function ( box ) {\n\t\n\t\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t */\n\t\n\t\tfunction ImmediateRenderObject( material ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.material = material;\n\t\t\tthis.render = function ( /* renderCallback */ ) {};\n\t\n\t\t}\n\t\n\t\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\t\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\t\n\t\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length * 3;\n\t\n\t\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\t\n\t\t\t\tnNormals = objGeometry.attributes.normal.count;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\t\n\t\tVertexNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\t\n\t\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\t\n\t\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\t\n\t\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\t\n\t\t\t\t\tvar objPos = objGeometry.attributes.position;\n\t\n\t\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\t\n\t\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\t\n\t\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\t\n\t\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction SpotLightHelper( light, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.color = color;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = [\n\t\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t\t];\n\t\n\t\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\t\n\t\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\t\n\t\t\t\tpositions.push(\n\t\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t\t);\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.cone = new LineSegments( geometry, material );\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\t\n\t\tSpotLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\n\t\t};\n\t\n\t\tSpotLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar vector2 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\t\n\t\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\t\n\t\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\n\t\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\t\n\t\t\t\tif ( this.color !== undefined ) {\n\t\n\t\t\t\t\tthis.cone.material.color.set( this.color );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.cone.material.color.copy( this.light.color );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author Sean Griffin / http://twitter.com/sgrif\n\t\t * @author Michael Guerrero / http://realitymeltdown.com\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author ikerr / http://verold.com\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction getBoneList( object ) {\n\t\n\t\t\tvar boneList = [];\n\t\n\t\t\tif ( object && object.isBone ) {\n\t\n\t\t\t\tboneList.push( object );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\t\n\t\t\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn boneList;\n\t\n\t\t}\n\t\n\t\tfunction SkeletonHelper( object ) {\n\t\n\t\t\tvar bones = getBoneList( object );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar colors = [];\n\t\n\t\t\tvar color1 = new Color( 0, 0, 1 );\n\t\t\tvar color2 = new Color( 0, 1, 0 );\n\t\n\t\t\tfor ( var i = 0; i < bones.length; i ++ ) {\n\t\n\t\t\t\tvar bone = bones[ i ];\n\t\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\t\n\t\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.root = object;\n\t\t\tthis.bones = bones;\n\t\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t}\n\t\n\t\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\t\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\t\n\t\tSkeletonHelper.prototype.updateMatrixWorld = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\n\t\t\tvar boneMatrix = new Matrix4();\n\t\t\tvar matrixWorldInv = new Matrix4();\n\t\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\tvar bones = this.bones;\n\t\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\t\n\t\t\t\tmatrixWorldInv.getInverse( this.root.matrixWorld );\n\t\n\t\t\t\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\n\t\n\t\t\t\t\tvar bone = bones[ i ];\n\t\n\t\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\t\n\t\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\t\t\tposition.setXYZ( j, vector.x, vector.y, vector.z );\n\t\n\t\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\t\t\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\n\t\n\t\t\t\t\t\tj += 2;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\t\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction PointLightHelper( light, sphereSize, color ) {\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.color = color;\n\t\n\t\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\n\t\t\tMesh.call( this, geometry, material );\n\t\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\n\t\t\t/*\n\t\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\n\t\t\tvar d = light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\n\t\t}\n\t\n\t\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\t\tPointLightHelper.prototype.constructor = PointLightHelper;\n\t\n\t\tPointLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\n\t\t};\n\t\n\t\tPointLightHelper.prototype.update = function () {\n\t\n\t\t\tif ( this.color !== undefined ) {\n\t\n\t\t\t\tthis.material.color.set( this.color );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.material.color.copy( this.light.color );\n\t\n\t\t\t}\n\t\n\t\t\t/*\n\t\t\tvar d = this.light.distance;\n\t\n\t\t\tif ( d === 0.0 ) {\n\t\n\t\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t\t}\n\t\t\t*/\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author abelnation / http://github.com/abelnation\n\t\t * @author Mugen87 / http://github.com/Mugen87\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction RectAreaLightHelper( light, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.color = color;\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\n\t\n\t\t\tthis.line = new Line( geometry, material );\n\t\t\tthis.add( this.line );\n\t\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\n\t\n\t\tRectAreaLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.children[ 0 ].geometry.dispose();\n\t\t\tthis.children[ 0 ].material.dispose();\n\t\n\t\t};\n\t\n\t\tRectAreaLightHelper.prototype.update = function () {\n\t\n\t\t\t// calculate new dimensions of the helper\n\t\n\t\t\tvar hx = this.light.width * 0.5;\n\t\t\tvar hy = this.light.height * 0.5;\n\t\n\t\t\tvar position = this.line.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\t\n\t\t\t// update vertices\n\t\n\t\t\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\n\t\t\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\n\t\t\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\n\t\t\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\n\t\t\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\tif ( this.color !== undefined ) {\n\t\n\t\t\t\tthis.line.material.color.set( this.color );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.line.material.color.copy( this.light.color );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction HemisphereLightHelper( light, size, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.color = color;\n\t\n\t\t\tvar geometry = new OctahedronBufferGeometry( size );\n\t\t\tgeometry.rotateY( Math.PI * 0.5 );\n\t\n\t\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\t\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\n\t\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\t\t\tvar colors = new Float32Array( position.count * 3 );\n\t\n\t\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\n\t\t\tthis.add( new Mesh( geometry, this.material ) );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\t\n\t\tHemisphereLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.children[ 0 ].geometry.dispose();\n\t\t\tthis.children[ 0 ].material.dispose();\n\t\n\t\t};\n\t\n\t\tHemisphereLightHelper.prototype.update = function () {\n\t\n\t\t\tvar vector = new Vector3();\n\t\n\t\t\tvar color1 = new Color();\n\t\t\tvar color2 = new Color();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tvar mesh = this.children[ 0 ];\n\t\n\t\t\t\tif ( this.color !== undefined ) {\n\t\n\t\t\t\t\tthis.material.color.set( this.color );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar colors = mesh.geometry.getAttribute( 'color' );\n\t\n\t\t\t\t\tcolor1.copy( this.light.color );\n\t\t\t\t\tcolor2.copy( this.light.groundColor );\n\t\n\t\t\t\t\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\n\t\n\t\t\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcolors.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction GridHelper( size, divisions, color1, color2 ) {\n\t\n\t\t\tsize = size || 10;\n\t\t\tdivisions = divisions || 10;\n\t\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\t\tvar center = divisions / 2;\n\t\t\tvar step = size / divisions;\n\t\t\tvar halfSize = size / 2;\n\t\n\t\t\tvar vertices = [], colors = [];\n\t\n\t\t\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\t\n\t\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\t\n\t\t\t\tvar color = i === center ? color1 : color2;\n\t\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\t\tGridHelper.prototype.constructor = GridHelper;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / http://github.com/Mugen87\n\t\t * @author Hectate / http://www.github.com/Hectate\n\t\t */\n\t\n\t\tfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\n\t\n\t\t\tradius = radius || 10;\n\t\t\tradials = radials || 16;\n\t\t\tcircles = circles || 8;\n\t\t\tdivisions = divisions || 64;\n\t\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar colors = [];\n\t\n\t\t\tvar x, z;\n\t\t\tvar v, i, j, r, color;\n\t\n\t\t\t// create the radials\n\t\n\t\t\tfor ( i = 0; i <= radials; i ++ ) {\n\t\n\t\t\t\tv = ( i / radials ) * ( Math.PI * 2 );\n\t\n\t\t\t\tx = Math.sin( v ) * radius;\n\t\t\t\tz = Math.cos( v ) * radius;\n\t\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\t\n\t\t\t\tcolor = ( i & 1 ) ? color1 : color2;\n\t\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\n\t\t\t}\n\t\n\t\t\t// create the circles\n\t\n\t\t\tfor ( i = 0; i <= circles; i ++ ) {\n\t\n\t\t\t\tcolor = ( i & 1 ) ? color1 : color2;\n\t\n\t\t\t\tr = radius - ( radius / circles * i );\n\t\n\t\t\t\tfor ( j = 0; j < divisions; j ++ ) {\n\t\n\t\t\t\t\t// first vertex\n\t\n\t\t\t\t\tv = ( j / divisions ) * ( Math.PI * 2 );\n\t\n\t\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\t\tz = Math.cos( v ) * r;\n\t\n\t\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\n\t\t\t\t\t// second vertex\n\t\n\t\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\t\n\t\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\t\tz = Math.cos( v ) * r;\n\t\n\t\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tPolarGridHelper.prototype = Object.create( LineSegments.prototype );\n\t\tPolarGridHelper.prototype.constructor = PolarGridHelper;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\t\n\t\t\t// FaceNormalsHelper only supports THREE.Geometry\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t\t//\n\t\n\t\t\tvar nNormals = 0;\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\t\n\t\t\t\tnNormals = objGeometry.faces.length;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\t\n\t\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t\t//\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\t\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\t\n\t\tFaceNormalsHelper.prototype.update = ( function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar normalMatrix = new Matrix3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t\t.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction DirectionalLightHelper( light, size, color ) {\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.color = color;\n\t\n\t\t\tif ( size === undefined ) size = 1;\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t\t- size, size, 0,\n\t\t\t\tsize, size, 0,\n\t\t\t\tsize, - size, 0,\n\t\t\t\t- size, - size, 0,\n\t\t\t\t- size, size, 0\n\t\t\t], 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { fog: false } );\n\t\n\t\t\tthis.lightPlane = new Line( geometry, material );\n\t\t\tthis.add( this.lightPlane );\n\t\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\t\n\t\t\tthis.targetLine = new Line( geometry, material );\n\t\t\tthis.add( this.targetLine );\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\t\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\t\n\t\tDirectionalLightHelper.prototype.dispose = function () {\n\t\n\t\t\tthis.lightPlane.geometry.dispose();\n\t\t\tthis.lightPlane.material.dispose();\n\t\t\tthis.targetLine.geometry.dispose();\n\t\t\tthis.targetLine.material.dispose();\n\t\n\t\t};\n\t\n\t\tDirectionalLightHelper.prototype.update = function () {\n\t\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\t\t\tvar v3 = new Vector3();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\t\tv3.subVectors( v2, v1 );\n\t\n\t\t\t\tthis.lightPlane.lookAt( v3 );\n\t\n\t\t\t\tif ( this.color !== undefined ) {\n\t\n\t\t\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\t\t\tthis.targetLine.material.color.set( this.color );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.targetLine.lookAt( v3 );\n\t\t\t\tthis.targetLine.scale.z = v3.length();\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author Mugen87 / https://github.com/Mugen87\n\t\t *\n\t\t *\t- shows frustum, line of sight and up of the camera\n\t\t *\t- suitable for fast updates\n\t\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t\t */\n\t\n\t\tfunction CameraHelper( camera ) {\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\t\n\t\t\tvar vertices = [];\n\t\t\tvar colors = [];\n\t\n\t\t\tvar pointMap = {};\n\t\n\t\t\t// colors\n\t\n\t\t\tvar colorFrustum = new Color( 0xffaa00 );\n\t\t\tvar colorCone = new Color( 0xff0000 );\n\t\t\tvar colorUp = new Color( 0x00aaff );\n\t\t\tvar colorTarget = new Color( 0xffffff );\n\t\t\tvar colorCross = new Color( 0x333333 );\n\t\n\t\t\t// near\n\t\n\t\t\taddLine( 'n1', 'n2', colorFrustum );\n\t\t\taddLine( 'n2', 'n4', colorFrustum );\n\t\t\taddLine( 'n4', 'n3', colorFrustum );\n\t\t\taddLine( 'n3', 'n1', colorFrustum );\n\t\n\t\t\t// far\n\t\n\t\t\taddLine( 'f1', 'f2', colorFrustum );\n\t\t\taddLine( 'f2', 'f4', colorFrustum );\n\t\t\taddLine( 'f4', 'f3', colorFrustum );\n\t\t\taddLine( 'f3', 'f1', colorFrustum );\n\t\n\t\t\t// sides\n\t\n\t\t\taddLine( 'n1', 'f1', colorFrustum );\n\t\t\taddLine( 'n2', 'f2', colorFrustum );\n\t\t\taddLine( 'n3', 'f3', colorFrustum );\n\t\t\taddLine( 'n4', 'f4', colorFrustum );\n\t\n\t\t\t// cone\n\t\n\t\t\taddLine( 'p', 'n1', colorCone );\n\t\t\taddLine( 'p', 'n2', colorCone );\n\t\t\taddLine( 'p', 'n3', colorCone );\n\t\t\taddLine( 'p', 'n4', colorCone );\n\t\n\t\t\t// up\n\t\n\t\t\taddLine( 'u1', 'u2', colorUp );\n\t\t\taddLine( 'u2', 'u3', colorUp );\n\t\t\taddLine( 'u3', 'u1', colorUp );\n\t\n\t\t\t// target\n\t\n\t\t\taddLine( 'c', 't', colorTarget );\n\t\t\taddLine( 'p', 'c', colorCross );\n\t\n\t\t\t// cross\n\t\n\t\t\taddLine( 'cn1', 'cn2', colorCross );\n\t\t\taddLine( 'cn3', 'cn4', colorCross );\n\t\n\t\t\taddLine( 'cf1', 'cf2', colorCross );\n\t\t\taddLine( 'cf3', 'cf4', colorCross );\n\t\n\t\t\tfunction addLine( a, b, color ) {\n\t\n\t\t\t\taddPoint( a, color );\n\t\t\t\taddPoint( b, color );\n\t\n\t\t\t}\n\t\n\t\t\tfunction addPoint( id, color ) {\n\t\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\n\t\t\t\tif ( pointMap[ id ] === undefined ) {\n\t\n\t\t\t\t\tpointMap[ id ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t\tthis.camera = camera;\n\t\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\t\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.pointMap = pointMap;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\t\tCameraHelper.prototype.constructor = CameraHelper;\n\t\n\t\tCameraHelper.prototype.update = function () {\n\t\n\t\t\tvar geometry, pointMap;\n\t\n\t\t\tvar vector = new Vector3();\n\t\t\tvar camera = new Camera();\n\t\n\t\t\tfunction setPoint( point, x, y, z ) {\n\t\n\t\t\t\tvector.set( x, y, z ).unproject( camera );\n\t\n\t\t\t\tvar points = pointMap[ point ];\n\t\n\t\t\t\tif ( points !== undefined ) {\n\t\n\t\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\t\n\t\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\tgeometry = this.geometry;\n\t\t\t\tpointMap = this.pointMap;\n\t\n\t\t\t\tvar w = 1, h = 1;\n\t\n\t\t\t\t// we need just camera projection matrix\n\t\t\t\t// world matrix must be identity\n\t\n\t\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\n\t\t\t\t// center / target\n\t\n\t\t\t\tsetPoint( 'c', 0, 0, - 1 );\n\t\t\t\tsetPoint( 't', 0, 0, 1 );\n\t\n\t\t\t\t// near\n\t\n\t\t\t\tsetPoint( 'n1', - w, - h, - 1 );\n\t\t\t\tsetPoint( 'n2', w, - h, - 1 );\n\t\t\t\tsetPoint( 'n3', - w, h, - 1 );\n\t\t\t\tsetPoint( 'n4', w, h, - 1 );\n\t\n\t\t\t\t// far\n\t\n\t\t\t\tsetPoint( 'f1', - w, - h, 1 );\n\t\t\t\tsetPoint( 'f2', w, - h, 1 );\n\t\t\t\tsetPoint( 'f3', - w, h, 1 );\n\t\t\t\tsetPoint( 'f4', w, h, 1 );\n\t\n\t\t\t\t// up\n\t\n\t\t\t\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\n\t\t\t\tsetPoint( 'u3', 0, h * 2, - 1 );\n\t\n\t\t\t\t// cross\n\t\n\t\t\t\tsetPoint( 'cf1', - w, 0, 1 );\n\t\t\t\tsetPoint( 'cf2', w, 0, 1 );\n\t\t\t\tsetPoint( 'cf3', 0, - h, 1 );\n\t\t\t\tsetPoint( 'cf4', 0, h, 1 );\n\t\n\t\t\t\tsetPoint( 'cn1', - w, 0, - 1 );\n\t\t\t\tsetPoint( 'cn2', w, 0, - 1 );\n\t\t\t\tsetPoint( 'cn3', 0, - h, - 1 );\n\t\t\t\tsetPoint( 'cn4', 0, h, - 1 );\n\t\n\t\t\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\t\n\t\t\t};\n\t\n\t\t}();\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t * @author Mugen87 / http://github.com/Mugen87\n\t\t */\n\t\n\t\tfunction BoxHelper( object, color ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\n\t\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\t\tvar positions = new Float32Array( 8 * 3 );\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\t\n\t\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t\tthis.update();\n\t\n\t\t}\n\t\n\t\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\t\tBoxHelper.prototype.constructor = BoxHelper;\n\t\n\t\tBoxHelper.prototype.update = ( function () {\n\t\n\t\t\tvar box = new Box3();\n\t\n\t\t\treturn function update( object ) {\n\t\n\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.object !== undefined ) {\n\t\n\t\t\t\t\tbox.setFromObject( this.object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\t\tvar min = box.min;\n\t\t\t\tvar max = box.max;\n\t\n\t\t\t\t/*\n\t\t\t\t  5____4\n\t\t\t\t1/___0/|\n\t\t\t\t| 6__|_7\n\t\t\t\t2/___3/\n\t\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t\t1: min.x, max.y, max.z\n\t\t\t\t2: min.x, min.y, max.z\n\t\t\t\t3: max.x, min.y, max.z\n\t\t\t\t4: max.x, max.y, min.z\n\t\t\t\t5: min.x, max.y, min.z\n\t\t\t\t6: min.x, min.y, min.z\n\t\t\t\t7: max.x, min.y, min.z\n\t\t\t\t*/\n\t\n\t\t\t\tvar position = this.geometry.attributes.position;\n\t\t\t\tvar array = position.array;\n\t\n\t\t\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\t\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\t\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\t\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\t\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t\t};\n\t\n\t\t} )();\n\t\n\t\tBoxHelper.prototype.setFromObject = function ( object ) {\n\t\n\t\t\tthis.object = object;\n\t\t\tthis.update();\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction Box3Helper( box, hex ) {\n\t\n\t\t\tthis.type = 'Box3Helper';\n\t\n\t\t\tthis.box = box;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\n\t\t\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\n\t\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\t\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t}\n\t\n\t\tBox3Helper.prototype = Object.create( LineSegments.prototype );\n\t\tBox3Helper.prototype.constructor = Box3Helper;\n\t\n\t\tBox3Helper.prototype.updateMatrixWorld = function ( force ) {\n\t\n\t\t\tvar box = this.box;\n\t\n\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\tbox.getCenter( this.position );\n\t\n\t\t\tbox.getSize( this.scale );\n\t\n\t\t\tthis.scale.multiplyScalar( 0.5 );\n\t\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t */\n\t\n\t\tfunction PlaneHelper( plane, size, hex ) {\n\t\n\t\t\tthis.type = 'PlaneHelper';\n\t\n\t\t\tthis.plane = plane;\n\t\n\t\t\tthis.size = ( size === undefined ) ? 1 : size;\n\t\n\t\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\t\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\t\n\t\t\t//\n\t\n\t\t\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\n\t\n\t\t\tvar geometry2 = new BufferGeometry();\n\t\t\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\t\tgeometry2.computeBoundingSphere();\n\t\n\t\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\n\t\n\t\t}\n\t\n\t\tPlaneHelper.prototype = Object.create( Line.prototype );\n\t\tPlaneHelper.prototype.constructor = PlaneHelper;\n\t\n\t\tPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\n\t\n\t\t\tvar scale = - this.plane.constant;\n\t\n\t\t\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\n\t\n\t\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\n\t\n\t\t\tthis.lookAt( this.plane.normal );\n\t\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author zz85 / http://github.com/zz85\n\t\t * @author bhouston / http://clara.io\n\t\t *\n\t\t * Creates an arrow for visualizing directions\n\t\t *\n\t\t * Parameters:\n\t\t *  dir - Vector3\n\t\t *  origin - Vector3\n\t\t *  length - Number\n\t\t *  color - color in hex value\n\t\t *  headLength - Number\n\t\t *  headWidth - Number\n\t\t */\n\t\n\t\tvar lineGeometry;\n\t\tvar coneGeometry;\n\t\n\t\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tObject3D.call( this );\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\t\tif ( length === undefined ) length = 1;\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tif ( lineGeometry === undefined ) {\n\t\n\t\t\t\tlineGeometry = new BufferGeometry();\n\t\t\t\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\t\n\t\t\t\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tthis.position.copy( origin );\n\t\n\t\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add( this.line );\n\t\n\t\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.setDirection( dir );\n\t\t\tthis.setLength( length, headLength, headWidth );\n\t\n\t\t}\n\t\n\t\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\t\tArrowHelper.prototype.constructor = ArrowHelper;\n\t\n\t\tArrowHelper.prototype.setDirection = ( function () {\n\t\n\t\t\tvar axis = new Vector3();\n\t\t\tvar radians;\n\t\n\t\t\treturn function setDirection( dir ) {\n\t\n\t\t\t\t// dir is assumed to be normalized\n\t\n\t\t\t\tif ( dir.y > 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\t\n\t\t\t\t} else if ( dir.y < - 0.99999 ) {\n\t\n\t\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\t\n\t\t\t\t\tradians = Math.acos( dir.y );\n\t\n\t\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\t\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\t\tthis.line.updateMatrix();\n\t\n\t\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\n\t\t};\n\t\n\t\tArrowHelper.prototype.setColor = function ( color ) {\n\t\n\t\t\tthis.line.material.color.copy( color );\n\t\t\tthis.cone.material.color.copy( color );\n\t\n\t\t};\n\t\n\t\t/**\n\t\t * @author sroucheray / http://sroucheray.org/\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction AxesHelper( size ) {\n\t\n\t\t\tsize = size || 1;\n\t\n\t\t\tvar vertices = [\n\t\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t\t0, 0, 0,\t0, 0, size\n\t\t\t];\n\t\n\t\t\tvar colors = [\n\t\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t\t];\n\t\n\t\t\tvar geometry = new BufferGeometry();\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\t\n\t\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\t\n\t\t\tLineSegments.call( this, geometry, material );\n\t\n\t\t}\n\t\n\t\tAxesHelper.prototype = Object.create( LineSegments.prototype );\n\t\tAxesHelper.prototype.constructor = AxesHelper;\n\t\n\t\t/**\n\t\t * @author mrdoob / http://mrdoob.com/\n\t\t */\n\t\n\t\tfunction Face4( a, b, c, d, normal, color, materialIndex ) {\n\t\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t\n\t\t}\n\t\n\t\tvar LineStrip = 0;\n\t\n\t\tvar LinePieces = 1;\n\t\n\t\tfunction MeshFaceMaterial( materials ) {\n\t\n\t\t\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\n\t\t\treturn materials;\n\t\n\t\t}\n\t\n\t\tfunction MultiMaterial( materials ) {\n\t\n\t\t\tif ( materials === undefined ) materials = [];\n\t\n\t\t\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\n\t\t\tmaterials.isMultiMaterial = true;\n\t\t\tmaterials.materials = materials;\n\t\t\tmaterials.clone = function () {\n\t\n\t\t\t\treturn materials.slice();\n\t\n\t\t\t};\n\t\t\treturn materials;\n\t\n\t\t}\n\t\n\t\tfunction PointCloud( geometry, material ) {\n\t\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\n\t\t}\n\t\n\t\tfunction Particle( material ) {\n\t\n\t\t\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n\t\t\treturn new Sprite( material );\n\t\n\t\t}\n\t\n\t\tfunction ParticleSystem( geometry, material ) {\n\t\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\t\treturn new Points( geometry, material );\n\t\n\t\t}\n\t\n\t\tfunction PointCloudMaterial( parameters ) {\n\t\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\n\t\t}\n\t\n\t\tfunction ParticleBasicMaterial( parameters ) {\n\t\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\n\t\t}\n\t\n\t\tfunction ParticleSystemMaterial( parameters ) {\n\t\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new PointsMaterial( parameters );\n\t\n\t\t}\n\t\n\t\tfunction Vertex( x, y, z ) {\n\t\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\t\treturn new Vector3( x, y, z );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction DynamicBufferAttribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\t\n\t\t}\n\t\n\t\tfunction Int8Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n\t\t\treturn new Int8BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n\t\t\treturn new Uint8BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n\t\t\treturn new Uint8ClampedBufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int16Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n\t\t\treturn new Int16BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint16Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n\t\t\treturn new Uint16BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Int32Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n\t\t\treturn new Int32BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Uint32Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n\t\t\treturn new Uint32BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float32Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n\t\t\treturn new Float32BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\tfunction Float64Attribute( array, itemSize ) {\n\t\n\t\t\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n\t\t\treturn new Float64BufferAttribute( array, itemSize );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tCurve.create = function ( construct, getPoint ) {\n\t\n\t\t\tconsole.log( 'THREE.Curve.create() has been deprecated' );\n\t\n\t\t\tconstruct.prototype = Object.create( Curve.prototype );\n\t\t\tconstruct.prototype.constructor = construct;\n\t\t\tconstruct.prototype.getPoint = getPoint;\n\t\n\t\t\treturn construct;\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tObject.assign( CurvePath.prototype, {\n\t\n\t\t\tcreatePointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\t\n\t\t\t\t// generate geometry from path points (for Line or Points objects)\n\t\n\t\t\t\tvar pts = this.getPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\t\n\t\t\t\t// generate geometry from equidistant sampling along the path\n\t\n\t\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\t\treturn this.createGeometry( pts );\n\t\n\t\t\t},\n\t\n\t\t\tcreateGeometry: function ( points ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\t\n\t\t\t\tvar geometry = new Geometry();\n\t\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar point = points[ i ];\n\t\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Path.prototype, {\n\t\n\t\t\tfromPoints: function ( points ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\n\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tfunction ClosedSplineCurve3( points ) {\n\t\n\t\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\t\n\t\t\tCatmullRomCurve3.call( this, points );\n\t\t\tthis.type = 'catmullrom';\n\t\t\tthis.closed = true;\n\t\n\t\t}\n\t\n\t\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\t\n\t\t//\n\t\n\t\tfunction SplineCurve3( points ) {\n\t\n\t\t\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\t\n\t\t\tCatmullRomCurve3.call( this, points );\n\t\t\tthis.type = 'catmullrom';\n\t\n\t\t}\n\t\n\t\tSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\t\n\t\t//\n\t\n\t\tfunction Spline( points ) {\n\t\n\t\t\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\n\t\n\t\t\tCatmullRomCurve3.call( this, points );\n\t\t\tthis.type = 'catmullrom';\n\t\n\t\t}\n\t\n\t\tSpline.prototype = Object.create( CatmullRomCurve3.prototype );\n\t\n\t\tObject.assign( Spline.prototype, {\n\t\n\t\t\tinitFromArray: function ( /* a */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\n\t\n\t\t\t},\n\t\t\tgetControlPointsArray: function ( /* optionalTarget */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\n\t\n\t\t\t},\n\t\t\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tfunction AxisHelper( size ) {\n\t\n\t\t\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\n\t\t\treturn new AxesHelper( size );\n\t\n\t\t}\n\t\n\t\tfunction BoundingBoxHelper( object, color ) {\n\t\n\t\t\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n\t\t\treturn new BoxHelper( object, color );\n\t\n\t\t}\n\t\n\t\tfunction EdgesHelper( object, hex ) {\n\t\n\t\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\n\t\t}\n\t\n\t\tGridHelper.prototype.setColors = function () {\n\t\n\t\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\t\n\t\t};\n\t\n\t\tSkeletonHelper.prototype.update = function () {\n\t\n\t\t\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\n\t\n\t\t};\n\t\n\t\tfunction WireframeHelper( object, hex ) {\n\t\n\t\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tObject.assign( Loader.prototype, {\n\t\n\t\t\textractUrlBase: function ( url ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\n\t\t\t\treturn LoaderUtils.extractUrlBase( url );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tfunction XHRLoader( manager ) {\n\t\n\t\t\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n\t\t\treturn new FileLoader( manager );\n\t\n\t\t}\n\t\n\t\tfunction BinaryTextureLoader( manager ) {\n\t\n\t\t\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n\t\t\treturn new DataTextureLoader( manager );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tObject.assign( Box2.prototype, {\n\t\n\t\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\n\t\t\t},\n\t\t\tempty: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.assign( Box3.prototype, {\n\t\n\t\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\t\treturn this.getCenter( optionalTarget );\n\t\n\t\t\t},\n\t\t\tempty: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\t\treturn this.isEmpty();\n\t\n\t\t\t},\n\t\t\tisIntersectionBox: function ( box ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t},\n\t\t\tsize: function ( optionalTarget ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\t\treturn this.getSize( optionalTarget );\n\t\n\t\t\t}\n\t\t} );\n\t\n\t\tLine3.prototype.center = function ( optionalTarget ) {\n\t\n\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\n\t\t};\n\t\n\t\tObject.assign( _Math, {\n\t\n\t\t\trandom16: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\n\t\t\t\treturn Math.random();\n\t\n\t\t\t},\n\t\n\t\t\tnearestPowerOfTwo: function ( value ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\n\t\t\t\treturn _Math.floorPowerOfTwo( value );\n\t\n\t\t\t},\n\t\n\t\t\tnextPowerOfTwo: function ( value ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\n\t\t\t\treturn _Math.ceilPowerOfTwo( value );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Matrix3.prototype, {\n\t\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix3( this );\n\t\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( /* a */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\n\t\n\t\t\t},\n\t\t\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\t\t\treturn this.applyToBufferAttribute( buffer );\n\t\n\t\t\t},\n\t\t\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Matrix4.prototype, {\n\t\n\t\t\textractPosition: function ( m ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\t\treturn this.copyPosition( m );\n\t\n\t\t\t},\n\t\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\t\t\treturn this.toArray( array, offset );\n\t\n\t\t\t},\n\t\t\tgetPosition: function () {\n\t\n\t\t\t\tvar v1;\n\t\n\t\t\t\treturn function getPosition() {\n\t\n\t\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\t\n\t\t\t\t};\n\t\n\t\t\t}(),\n\t\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\n\t\t\t},\n\t\t\tmultiplyToArray: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\n\t\n\t\t\t},\n\t\t\tmultiplyVector3: function ( vector ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\n\t\t\t},\n\t\t\tmultiplyVector4: function ( vector ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\n\t\t\t},\n\t\t\tmultiplyVector3Array: function ( /* a */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\n\t\n\t\t\t},\n\t\t\trotateAxis: function ( v ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\t\tv.transformDirection( this );\n\t\n\t\t\t},\n\t\t\tcrossVector: function ( vector ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\t\treturn vector.applyMatrix4( this );\n\t\n\t\t\t},\n\t\t\ttranslate: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\n\t\t\t},\n\t\t\trotateX: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\n\t\t\t},\n\t\t\trotateY: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\n\t\t\t},\n\t\t\trotateZ: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\n\t\t\t},\n\t\t\trotateByAxis: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\n\t\t\t},\n\t\t\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\t\t\treturn this.applyToBufferAttribute( buffer );\n\t\n\t\t\t},\n\t\t\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\t\n\t\t\t},\n\t\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n\t\t\t\treturn this.makePerspective( left, right, top, bottom, near, far );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tPlane.prototype.isIntersectionLine = function ( line ) {\n\t\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\n\t\t};\n\t\n\t\tQuaternion.prototype.multiplyVector3 = function ( vector ) {\n\t\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\n\t\t};\n\t\n\t\tObject.assign( Ray.prototype, {\n\t\n\t\t\tisIntersectionBox: function ( box ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\t\treturn this.intersectsBox( box );\n\t\n\t\t\t},\n\t\t\tisIntersectionPlane: function ( plane ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\t\treturn this.intersectsPlane( plane );\n\t\n\t\t\t},\n\t\t\tisIntersectionSphere: function ( sphere ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Shape.prototype, {\n\t\n\t\t\textractAllPoints: function ( divisions ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\n\t\t\t\treturn this.extractPoints( divisions );\n\t\n\t\t\t},\n\t\t\textrude: function ( options ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\t\treturn new ExtrudeGeometry( this, options );\n\t\n\t\t\t},\n\t\t\tmakeGeometry: function ( options ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\t\treturn new ShapeGeometry( this, options );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Vector2.prototype, {\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\t\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\t\n\t\t\t},\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\t\t\treturn this.manhattanDistanceTo( v );\n\t\n\t\t\t},\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\t\t\treturn this.manhattanLength();\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Vector3.prototype, {\n\t\n\t\t\tsetEulerFromRotationMatrix: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\n\t\t\t},\n\t\t\tsetEulerFromQuaternion: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\n\t\t\t},\n\t\t\tgetPositionFromMatrix: function ( m ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\t\treturn this.setFromMatrixPosition( m );\n\t\n\t\t\t},\n\t\t\tgetScaleFromMatrix: function ( m ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\t\treturn this.setFromMatrixScale( m );\n\t\n\t\t\t},\n\t\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\n\t\t\t},\n\t\t\tapplyProjection: function ( m ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n\t\t\t\treturn this.applyMatrix4( m );\n\t\n\t\t\t},\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\t\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\t\n\t\t\t},\n\t\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\t\t\treturn this.manhattanDistanceTo( v );\n\t\n\t\t\t},\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\t\t\treturn this.manhattanLength();\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Vector4.prototype, {\n\t\n\t\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\t\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\t\n\t\t\t},\n\t\t\tlengthManhattan: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\t\t\treturn this.manhattanLength();\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( Geometry.prototype, {\n\t\n\t\t\tcomputeTangents: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\t\n\t\t\t},\n\t\t\tcomputeLineDistances: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( Object3D.prototype, {\n\t\n\t\t\tgetChildByName: function ( name ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\t\treturn this.getObjectByName( name );\n\t\n\t\t\t},\n\t\t\trenderDepth: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\n\t\t\t},\n\t\t\ttranslate: function ( distance, axis ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\t\treturn this.translateOnAxis( axis, distance );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( Object3D.prototype, {\n\t\n\t\t\teulerOrder: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\treturn this.rotation.order;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\t\tthis.rotation.order = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tuseQuaternion: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\n\t\t\t\t},\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( LOD.prototype, {\n\t\n\t\t\tobjects: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\t\treturn this.levels;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\t\n\t\t\t},\n\t\t\tset: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\t\t\treturn this.arcLengthDivisions;\n\t\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\t\t\tthis.arcLengthDivisions = value;\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\t\n\t\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\t\n\t\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\t\tthis.setFocalLength( focalLength );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Light.prototype, {\n\t\t\tonlyShadow: {\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFov: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\t\tthis.shadow.camera.fov = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraLeft: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\t\tthis.shadow.camera.left = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraRight: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\t\tthis.shadow.camera.right = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraTop: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\t\tthis.shadow.camera.top = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraBottom: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\t\tthis.shadow.camera.bottom = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraNear: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\t\tthis.shadow.camera.near = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraFar: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\t\tthis.shadow.camera.far = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowCameraVisible: {\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowBias: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\t\tthis.shadow.bias = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowDarkness: {\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapWidth: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\t\tthis.shadow.mapSize.width = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapHeight: {\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\t\tthis.shadow.mapSize.height = value;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( BufferAttribute.prototype, {\n\t\n\t\t\tlength: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n\t\t\t\t\treturn this.array.length;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.assign( BufferGeometry.prototype, {\n\t\n\t\t\taddIndex: function ( index ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\t\tthis.setIndex( index );\n\t\n\t\t\t},\n\t\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\n\t\t\t\tif ( indexOffset !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\n\t\t\t\t}\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\t\tthis.addGroup( start, count );\n\t\n\t\t\t},\n\t\t\tclearDrawCalls: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\t\tthis.clearGroups();\n\t\n\t\t\t},\n\t\t\tcomputeTangents: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\n\t\t\t},\n\t\t\tcomputeOffsets: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( BufferGeometry.prototype, {\n\t\n\t\t\tdrawcalls: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\toffsets: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\t\treturn this.groups;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Uniform.prototype, {\n\t\n\t\t\tdynamic: {\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tonUpdate: {\n\t\t\t\tvalue: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( Material.prototype, {\n\t\n\t\t\twrapAround: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\t\n\t\t\t\t},\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapRGB: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\n\t\t\t\t\treturn new Color();\n\t\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tshading: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\t\tthis.flatShading = ( value === FlatShading );\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\n\t\t\tmetal: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t},\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\n\t\t\tderivatives: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\treturn this.extensions.derivatives;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\t\tthis.extensions.derivatives = value;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.assign( WebGLRenderer.prototype, {\n\t\n\t\t\tgetCurrentRenderTarget: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\n\t\t\t\treturn this.getRenderTarget();\n\t\n\t\t\t},\n\t\n\t\t\tgetMaxAnisotropy: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\n\t\t\t\treturn this.capabilities.getMaxAnisotropy();\n\t\n\t\t\t},\n\t\n\t\t\tgetPrecision: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\n\t\t\t\treturn this.capabilities.precision;\n\t\n\t\t\t},\n\t\n\t\t\tresetGLState: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\n\t\t\t\treturn this.state.reset();\n\t\n\t\t\t},\n\t\n\t\t\tsupportsFloatTextures: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\n\t\t\t},\n\t\t\tsupportsHalfFloatTextures: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\t},\n\t\t\tsupportsStandardDerivatives: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\n\t\t\t},\n\t\t\tsupportsCompressedTextureS3TC: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\t},\n\t\t\tsupportsCompressedTexturePVRTC: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\t},\n\t\t\tsupportsBlendMinMax: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\t},\n\t\t\tsupportsVertexTextures: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n\t\t\t\treturn this.capabilities.vertexTextures;\n\t\n\t\t\t},\n\t\t\tsupportsInstancedArrays: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t},\n\t\t\tenableScissorTest: function ( boolean ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\t\tthis.setScissorTest( boolean );\n\t\n\t\t\t},\n\t\t\tinitMaterial: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\n\t\t\t},\n\t\t\taddPrePlugin: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\n\t\t\t},\n\t\t\taddPostPlugin: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\n\t\t\t},\n\t\t\tupdateShadowMap: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\n\t\t\t},\n\t\t\tsetFaceCulling: function () {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\n\t\t\tshadowMapEnabled: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.shadowMap.enabled;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\t\tthis.shadowMap.enabled = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapType: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.shadowMap.type;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\t\tthis.shadowMap.type = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tshadowMapCullFace: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( /* value */ ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\n\t\t\tcullFace: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( /* cullFace */ ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\trenderReverseSided: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t},\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\trenderSingleSided: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t},\n\t\t\t\tset: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\n\t\t\twrapS: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\treturn this.texture.wrapS;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\t\tthis.texture.wrapS = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\twrapT: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\treturn this.texture.wrapT;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\t\tthis.texture.wrapT = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tmagFilter: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\treturn this.texture.magFilter;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\t\tthis.texture.magFilter = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tminFilter: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\treturn this.texture.minFilter;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\t\tthis.texture.minFilter = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tanisotropy: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\treturn this.texture.anisotropy;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\t\tthis.texture.anisotropy = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\toffset: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\treturn this.texture.offset;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\t\tthis.texture.offset = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\trepeat: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\treturn this.texture.repeat;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\t\tthis.texture.repeat = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tformat: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\treturn this.texture.format;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\t\tthis.texture.format = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\treturn this.texture.type;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\t\tthis.texture.type = value;\n\t\n\t\t\t\t}\n\t\t\t},\n\t\t\tgenerateMipmaps: {\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\treturn this.texture.generateMipmaps;\n\t\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\t\tthis.texture.generateMipmaps = value;\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tObject.defineProperties( WebVRManager.prototype, {\n\t\n\t\t\tstanding: {\n\t\t\t\tset: function ( /* value */ ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\t//\n\t\n\t\tAudio.prototype.load = function ( file ) {\n\t\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\n\t\t\t\tscope.setBuffer( buffer );\n\t\n\t\t\t} );\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tAudioAnalyser.prototype.getData = function () {\n\t\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\n\t\n\t\t\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\n\t\t\treturn this.update( renderer, scene );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tvar GeometryUtils = {\n\t\n\t\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\t\t\tvar matrix;\n\t\n\t\t\t\tif ( geometry2.isMesh ) {\n\t\n\t\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\t\n\t\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\t\tgeometry2 = geometry2.geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\t\n\t\t\t},\n\t\n\t\t\tcenter: function ( geometry ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\t\treturn geometry.center();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tvar ImageUtils = {\n\t\n\t\t\tcrossOrigin: undefined,\n\t\n\t\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new TextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\t\n\t\t\t\tvar loader = new CubeTextureLoader();\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\t\n\t\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\t\treturn texture;\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTexture: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t},\n\t\n\t\t\tloadCompressedTextureCube: function () {\n\t\n\t\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction Projector() {\n\t\n\t\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\t\n\t\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\t\tvector.project( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\t\tvector.unproject( camera );\n\t\n\t\t\t};\n\t\n\t\t\tthis.pickingRay = function () {\n\t\n\t\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction CanvasRenderer() {\n\t\n\t\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\t\n\t\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tthis.clear = function () {};\n\t\t\tthis.render = function () {};\n\t\t\tthis.setClearColor = function () {};\n\t\t\tthis.setSize = function () {};\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar SceneUtils = {\n\t\n\t\t\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\t\n\t\t\t},\n\t\n\t\t\tdetach: function ( /* child, parent, scene */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\t\n\t\t\t},\n\t\n\t\t\tattach: function ( /* child, scene, parent */ ) {\n\t\n\t\t\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tfunction LensFlare() {\n\t\n\t\t\tconsole.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );\n\t\n\t\t}\n\t\n\t\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\t\texports.WebGLRenderTarget = WebGLRenderTarget;\n\t\texports.WebGLRenderer = WebGLRenderer;\n\t\texports.ShaderLib = ShaderLib;\n\t\texports.UniformsLib = UniformsLib;\n\t\texports.UniformsUtils = UniformsUtils;\n\t\texports.ShaderChunk = ShaderChunk;\n\t\texports.FogExp2 = FogExp2;\n\t\texports.Fog = Fog;\n\t\texports.Scene = Scene;\n\t\texports.Sprite = Sprite;\n\t\texports.LOD = LOD;\n\t\texports.SkinnedMesh = SkinnedMesh;\n\t\texports.Skeleton = Skeleton;\n\t\texports.Bone = Bone;\n\t\texports.Mesh = Mesh;\n\t\texports.LineSegments = LineSegments;\n\t\texports.LineLoop = LineLoop;\n\t\texports.Line = Line;\n\t\texports.Points = Points;\n\t\texports.Group = Group;\n\t\texports.VideoTexture = VideoTexture;\n\t\texports.DataTexture = DataTexture;\n\t\texports.CompressedTexture = CompressedTexture;\n\t\texports.CubeTexture = CubeTexture;\n\t\texports.CanvasTexture = CanvasTexture;\n\t\texports.DepthTexture = DepthTexture;\n\t\texports.Texture = Texture;\n\t\texports.CompressedTextureLoader = CompressedTextureLoader;\n\t\texports.DataTextureLoader = DataTextureLoader;\n\t\texports.CubeTextureLoader = CubeTextureLoader;\n\t\texports.TextureLoader = TextureLoader;\n\t\texports.ObjectLoader = ObjectLoader;\n\t\texports.MaterialLoader = MaterialLoader;\n\t\texports.BufferGeometryLoader = BufferGeometryLoader;\n\t\texports.DefaultLoadingManager = DefaultLoadingManager;\n\t\texports.LoadingManager = LoadingManager;\n\t\texports.JSONLoader = JSONLoader;\n\t\texports.ImageLoader = ImageLoader;\n\t\texports.ImageBitmapLoader = ImageBitmapLoader;\n\t\texports.FontLoader = FontLoader;\n\t\texports.FileLoader = FileLoader;\n\t\texports.Loader = Loader;\n\t\texports.LoaderUtils = LoaderUtils;\n\t\texports.Cache = Cache;\n\t\texports.AudioLoader = AudioLoader;\n\t\texports.SpotLightShadow = SpotLightShadow;\n\t\texports.SpotLight = SpotLight;\n\t\texports.PointLight = PointLight;\n\t\texports.RectAreaLight = RectAreaLight;\n\t\texports.HemisphereLight = HemisphereLight;\n\t\texports.DirectionalLightShadow = DirectionalLightShadow;\n\t\texports.DirectionalLight = DirectionalLight;\n\t\texports.AmbientLight = AmbientLight;\n\t\texports.LightShadow = LightShadow;\n\t\texports.Light = Light;\n\t\texports.StereoCamera = StereoCamera;\n\t\texports.PerspectiveCamera = PerspectiveCamera;\n\t\texports.OrthographicCamera = OrthographicCamera;\n\t\texports.CubeCamera = CubeCamera;\n\t\texports.ArrayCamera = ArrayCamera;\n\t\texports.Camera = Camera;\n\t\texports.AudioListener = AudioListener;\n\t\texports.PositionalAudio = PositionalAudio;\n\t\texports.AudioContext = AudioContext;\n\t\texports.AudioAnalyser = AudioAnalyser;\n\t\texports.Audio = Audio;\n\t\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\t\texports.StringKeyframeTrack = StringKeyframeTrack;\n\t\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\t\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\t\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\t\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\t\texports.PropertyMixer = PropertyMixer;\n\t\texports.PropertyBinding = PropertyBinding;\n\t\texports.KeyframeTrack = KeyframeTrack;\n\t\texports.AnimationUtils = AnimationUtils;\n\t\texports.AnimationObjectGroup = AnimationObjectGroup;\n\t\texports.AnimationMixer = AnimationMixer;\n\t\texports.AnimationClip = AnimationClip;\n\t\texports.Uniform = Uniform;\n\t\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\t\texports.BufferGeometry = BufferGeometry;\n\t\texports.Geometry = Geometry;\n\t\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\t\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\t\texports.InterleavedBuffer = InterleavedBuffer;\n\t\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\t\texports.Face3 = Face3;\n\t\texports.Object3D = Object3D;\n\t\texports.Raycaster = Raycaster;\n\t\texports.Layers = Layers;\n\t\texports.EventDispatcher = EventDispatcher;\n\t\texports.Clock = Clock;\n\t\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\t\texports.LinearInterpolant = LinearInterpolant;\n\t\texports.DiscreteInterpolant = DiscreteInterpolant;\n\t\texports.CubicInterpolant = CubicInterpolant;\n\t\texports.Interpolant = Interpolant;\n\t\texports.Triangle = Triangle;\n\t\texports.Math = _Math;\n\t\texports.Spherical = Spherical;\n\t\texports.Cylindrical = Cylindrical;\n\t\texports.Plane = Plane;\n\t\texports.Frustum = Frustum;\n\t\texports.Sphere = Sphere;\n\t\texports.Ray = Ray;\n\t\texports.Matrix4 = Matrix4;\n\t\texports.Matrix3 = Matrix3;\n\t\texports.Box3 = Box3;\n\t\texports.Box2 = Box2;\n\t\texports.Line3 = Line3;\n\t\texports.Euler = Euler;\n\t\texports.Vector4 = Vector4;\n\t\texports.Vector3 = Vector3;\n\t\texports.Vector2 = Vector2;\n\t\texports.Quaternion = Quaternion;\n\t\texports.Color = Color;\n\t\texports.ImmediateRenderObject = ImmediateRenderObject;\n\t\texports.VertexNormalsHelper = VertexNormalsHelper;\n\t\texports.SpotLightHelper = SpotLightHelper;\n\t\texports.SkeletonHelper = SkeletonHelper;\n\t\texports.PointLightHelper = PointLightHelper;\n\t\texports.RectAreaLightHelper = RectAreaLightHelper;\n\t\texports.HemisphereLightHelper = HemisphereLightHelper;\n\t\texports.GridHelper = GridHelper;\n\t\texports.PolarGridHelper = PolarGridHelper;\n\t\texports.FaceNormalsHelper = FaceNormalsHelper;\n\t\texports.DirectionalLightHelper = DirectionalLightHelper;\n\t\texports.CameraHelper = CameraHelper;\n\t\texports.BoxHelper = BoxHelper;\n\t\texports.Box3Helper = Box3Helper;\n\t\texports.PlaneHelper = PlaneHelper;\n\t\texports.ArrowHelper = ArrowHelper;\n\t\texports.AxesHelper = AxesHelper;\n\t\texports.Shape = Shape;\n\t\texports.Path = Path;\n\t\texports.ShapePath = ShapePath;\n\t\texports.Font = Font;\n\t\texports.CurvePath = CurvePath;\n\t\texports.Curve = Curve;\n\t\texports.ShapeUtils = ShapeUtils;\n\t\texports.WebGLUtils = WebGLUtils;\n\t\texports.WireframeGeometry = WireframeGeometry;\n\t\texports.ParametricGeometry = ParametricGeometry;\n\t\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\t\texports.TetrahedronGeometry = TetrahedronGeometry;\n\t\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\t\texports.OctahedronGeometry = OctahedronGeometry;\n\t\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\t\texports.IcosahedronGeometry = IcosahedronGeometry;\n\t\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\t\texports.DodecahedronGeometry = DodecahedronGeometry;\n\t\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\t\texports.PolyhedronGeometry = PolyhedronGeometry;\n\t\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\t\texports.TubeGeometry = TubeGeometry;\n\t\texports.TubeBufferGeometry = TubeBufferGeometry;\n\t\texports.TorusKnotGeometry = TorusKnotGeometry;\n\t\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\t\texports.TorusGeometry = TorusGeometry;\n\t\texports.TorusBufferGeometry = TorusBufferGeometry;\n\t\texports.TextGeometry = TextGeometry;\n\t\texports.TextBufferGeometry = TextBufferGeometry;\n\t\texports.SphereGeometry = SphereGeometry;\n\t\texports.SphereBufferGeometry = SphereBufferGeometry;\n\t\texports.RingGeometry = RingGeometry;\n\t\texports.RingBufferGeometry = RingBufferGeometry;\n\t\texports.PlaneGeometry = PlaneGeometry;\n\t\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\t\texports.LatheGeometry = LatheGeometry;\n\t\texports.LatheBufferGeometry = LatheBufferGeometry;\n\t\texports.ShapeGeometry = ShapeGeometry;\n\t\texports.ShapeBufferGeometry = ShapeBufferGeometry;\n\t\texports.ExtrudeGeometry = ExtrudeGeometry;\n\t\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\n\t\texports.EdgesGeometry = EdgesGeometry;\n\t\texports.ConeGeometry = ConeGeometry;\n\t\texports.ConeBufferGeometry = ConeBufferGeometry;\n\t\texports.CylinderGeometry = CylinderGeometry;\n\t\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\t\texports.CircleGeometry = CircleGeometry;\n\t\texports.CircleBufferGeometry = CircleBufferGeometry;\n\t\texports.BoxGeometry = BoxGeometry;\n\t\texports.BoxBufferGeometry = BoxBufferGeometry;\n\t\texports.ShadowMaterial = ShadowMaterial;\n\t\texports.SpriteMaterial = SpriteMaterial;\n\t\texports.RawShaderMaterial = RawShaderMaterial;\n\t\texports.ShaderMaterial = ShaderMaterial;\n\t\texports.PointsMaterial = PointsMaterial;\n\t\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\t\texports.MeshStandardMaterial = MeshStandardMaterial;\n\t\texports.MeshPhongMaterial = MeshPhongMaterial;\n\t\texports.MeshToonMaterial = MeshToonMaterial;\n\t\texports.MeshNormalMaterial = MeshNormalMaterial;\n\t\texports.MeshLambertMaterial = MeshLambertMaterial;\n\t\texports.MeshDepthMaterial = MeshDepthMaterial;\n\t\texports.MeshDistanceMaterial = MeshDistanceMaterial;\n\t\texports.MeshBasicMaterial = MeshBasicMaterial;\n\t\texports.LineDashedMaterial = LineDashedMaterial;\n\t\texports.LineBasicMaterial = LineBasicMaterial;\n\t\texports.Material = Material;\n\t\texports.Float64BufferAttribute = Float64BufferAttribute;\n\t\texports.Float32BufferAttribute = Float32BufferAttribute;\n\t\texports.Uint32BufferAttribute = Uint32BufferAttribute;\n\t\texports.Int32BufferAttribute = Int32BufferAttribute;\n\t\texports.Uint16BufferAttribute = Uint16BufferAttribute;\n\t\texports.Int16BufferAttribute = Int16BufferAttribute;\n\t\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n\t\texports.Uint8BufferAttribute = Uint8BufferAttribute;\n\t\texports.Int8BufferAttribute = Int8BufferAttribute;\n\t\texports.BufferAttribute = BufferAttribute;\n\t\texports.ArcCurve = ArcCurve;\n\t\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\t\texports.CubicBezierCurve = CubicBezierCurve;\n\t\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\t\texports.EllipseCurve = EllipseCurve;\n\t\texports.LineCurve = LineCurve;\n\t\texports.LineCurve3 = LineCurve3;\n\t\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\t\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\t\texports.SplineCurve = SplineCurve;\n\t\texports.REVISION = REVISION;\n\t\texports.MOUSE = MOUSE;\n\t\texports.CullFaceNone = CullFaceNone;\n\t\texports.CullFaceBack = CullFaceBack;\n\t\texports.CullFaceFront = CullFaceFront;\n\t\texports.CullFaceFrontBack = CullFaceFrontBack;\n\t\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\t\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\t\texports.BasicShadowMap = BasicShadowMap;\n\t\texports.PCFShadowMap = PCFShadowMap;\n\t\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\t\texports.FrontSide = FrontSide;\n\t\texports.BackSide = BackSide;\n\t\texports.DoubleSide = DoubleSide;\n\t\texports.FlatShading = FlatShading;\n\t\texports.SmoothShading = SmoothShading;\n\t\texports.NoColors = NoColors;\n\t\texports.FaceColors = FaceColors;\n\t\texports.VertexColors = VertexColors;\n\t\texports.NoBlending = NoBlending;\n\t\texports.NormalBlending = NormalBlending;\n\t\texports.AdditiveBlending = AdditiveBlending;\n\t\texports.SubtractiveBlending = SubtractiveBlending;\n\t\texports.MultiplyBlending = MultiplyBlending;\n\t\texports.CustomBlending = CustomBlending;\n\t\texports.AddEquation = AddEquation;\n\t\texports.SubtractEquation = SubtractEquation;\n\t\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\t\texports.MinEquation = MinEquation;\n\t\texports.MaxEquation = MaxEquation;\n\t\texports.ZeroFactor = ZeroFactor;\n\t\texports.OneFactor = OneFactor;\n\t\texports.SrcColorFactor = SrcColorFactor;\n\t\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\t\texports.SrcAlphaFactor = SrcAlphaFactor;\n\t\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\t\texports.DstAlphaFactor = DstAlphaFactor;\n\t\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\t\texports.DstColorFactor = DstColorFactor;\n\t\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\t\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\t\texports.NeverDepth = NeverDepth;\n\t\texports.AlwaysDepth = AlwaysDepth;\n\t\texports.LessDepth = LessDepth;\n\t\texports.LessEqualDepth = LessEqualDepth;\n\t\texports.EqualDepth = EqualDepth;\n\t\texports.GreaterEqualDepth = GreaterEqualDepth;\n\t\texports.GreaterDepth = GreaterDepth;\n\t\texports.NotEqualDepth = NotEqualDepth;\n\t\texports.MultiplyOperation = MultiplyOperation;\n\t\texports.MixOperation = MixOperation;\n\t\texports.AddOperation = AddOperation;\n\t\texports.NoToneMapping = NoToneMapping;\n\t\texports.LinearToneMapping = LinearToneMapping;\n\t\texports.ReinhardToneMapping = ReinhardToneMapping;\n\t\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\t\texports.CineonToneMapping = CineonToneMapping;\n\t\texports.UVMapping = UVMapping;\n\t\texports.CubeReflectionMapping = CubeReflectionMapping;\n\t\texports.CubeRefractionMapping = CubeRefractionMapping;\n\t\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\t\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\t\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\t\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\t\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\t\texports.RepeatWrapping = RepeatWrapping;\n\t\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\t\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\t\texports.NearestFilter = NearestFilter;\n\t\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\t\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\t\texports.LinearFilter = LinearFilter;\n\t\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\t\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\t\texports.UnsignedByteType = UnsignedByteType;\n\t\texports.ByteType = ByteType;\n\t\texports.ShortType = ShortType;\n\t\texports.UnsignedShortType = UnsignedShortType;\n\t\texports.IntType = IntType;\n\t\texports.UnsignedIntType = UnsignedIntType;\n\t\texports.FloatType = FloatType;\n\t\texports.HalfFloatType = HalfFloatType;\n\t\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\t\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\t\texports.UnsignedShort565Type = UnsignedShort565Type;\n\t\texports.UnsignedInt248Type = UnsignedInt248Type;\n\t\texports.AlphaFormat = AlphaFormat;\n\t\texports.RGBFormat = RGBFormat;\n\t\texports.RGBAFormat = RGBAFormat;\n\t\texports.LuminanceFormat = LuminanceFormat;\n\t\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\t\texports.RGBEFormat = RGBEFormat;\n\t\texports.DepthFormat = DepthFormat;\n\t\texports.DepthStencilFormat = DepthStencilFormat;\n\t\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\t\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\t\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\t\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\t\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\t\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\t\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\t\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\t\texports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;\n\t\texports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;\n\t\texports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;\n\t\texports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;\n\t\texports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;\n\t\texports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;\n\t\texports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;\n\t\texports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;\n\t\texports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;\n\t\texports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;\n\t\texports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;\n\t\texports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;\n\t\texports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;\n\t\texports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;\n\t\texports.LoopOnce = LoopOnce;\n\t\texports.LoopRepeat = LoopRepeat;\n\t\texports.LoopPingPong = LoopPingPong;\n\t\texports.InterpolateDiscrete = InterpolateDiscrete;\n\t\texports.InterpolateLinear = InterpolateLinear;\n\t\texports.InterpolateSmooth = InterpolateSmooth;\n\t\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\t\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\t\texports.WrapAroundEnding = WrapAroundEnding;\n\t\texports.TrianglesDrawMode = TrianglesDrawMode;\n\t\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\t\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\t\texports.LinearEncoding = LinearEncoding;\n\t\texports.sRGBEncoding = sRGBEncoding;\n\t\texports.GammaEncoding = GammaEncoding;\n\t\texports.RGBEEncoding = RGBEEncoding;\n\t\texports.LogLuvEncoding = LogLuvEncoding;\n\t\texports.RGBM7Encoding = RGBM7Encoding;\n\t\texports.RGBM16Encoding = RGBM16Encoding;\n\t\texports.RGBDEncoding = RGBDEncoding;\n\t\texports.BasicDepthPacking = BasicDepthPacking;\n\t\texports.RGBADepthPacking = RGBADepthPacking;\n\t\texports.CubeGeometry = BoxGeometry;\n\t\texports.Face4 = Face4;\n\t\texports.LineStrip = LineStrip;\n\t\texports.LinePieces = LinePieces;\n\t\texports.MeshFaceMaterial = MeshFaceMaterial;\n\t\texports.MultiMaterial = MultiMaterial;\n\t\texports.PointCloud = PointCloud;\n\t\texports.Particle = Particle;\n\t\texports.ParticleSystem = ParticleSystem;\n\t\texports.PointCloudMaterial = PointCloudMaterial;\n\t\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\t\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\t\texports.Vertex = Vertex;\n\t\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\t\texports.Int8Attribute = Int8Attribute;\n\t\texports.Uint8Attribute = Uint8Attribute;\n\t\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\t\texports.Int16Attribute = Int16Attribute;\n\t\texports.Uint16Attribute = Uint16Attribute;\n\t\texports.Int32Attribute = Int32Attribute;\n\t\texports.Uint32Attribute = Uint32Attribute;\n\t\texports.Float32Attribute = Float32Attribute;\n\t\texports.Float64Attribute = Float64Attribute;\n\t\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\t\texports.SplineCurve3 = SplineCurve3;\n\t\texports.Spline = Spline;\n\t\texports.AxisHelper = AxisHelper;\n\t\texports.BoundingBoxHelper = BoundingBoxHelper;\n\t\texports.EdgesHelper = EdgesHelper;\n\t\texports.WireframeHelper = WireframeHelper;\n\t\texports.XHRLoader = XHRLoader;\n\t\texports.BinaryTextureLoader = BinaryTextureLoader;\n\t\texports.GeometryUtils = GeometryUtils;\n\t\texports.ImageUtils = ImageUtils;\n\t\texports.Projector = Projector;\n\t\texports.CanvasRenderer = CanvasRenderer;\n\t\texports.SceneUtils = SceneUtils;\n\t\texports.LensFlare = LensFlare;\n\t\n\t\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n\n/***/ 110:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * Tween.js - Licensed under the MIT license\n\t * https://github.com/tweenjs/tween.js\n\t * ----------------------------------------------\n\t *\n\t * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n\t * Thank you all, you're awesome!\n\t */\n\t\n\tvar TWEEN = TWEEN || (function () {\n\t\n\t\tvar _tweens = [];\n\t\n\t\treturn {\n\t\n\t\t\tgetAll: function () {\n\t\n\t\t\t\treturn _tweens;\n\t\n\t\t\t},\n\t\n\t\t\tremoveAll: function () {\n\t\n\t\t\t\t_tweens = [];\n\t\n\t\t\t},\n\t\n\t\t\tadd: function (tween) {\n\t\n\t\t\t\t_tweens.push(tween);\n\t\n\t\t\t},\n\t\n\t\t\tremove: function (tween) {\n\t\n\t\t\t\tvar i = _tweens.indexOf(tween);\n\t\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\t_tweens.splice(i, 1);\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tupdate: function (time, preserve) {\n\t\n\t\t\t\tif (_tweens.length === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\n\t\t\t\tvar i = 0;\n\t\n\t\t\t\ttime = time !== undefined ? time : TWEEN.now();\n\t\n\t\t\t\twhile (i < _tweens.length) {\n\t\n\t\t\t\t\tif (_tweens[i].update(time) || preserve) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_tweens.splice(i, 1);\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\t};\n\t\n\t})();\n\t\n\t\n\t// Include a performance.now polyfill.\n\t// In node.js, use process.hrtime.\n\tif (typeof (window) === 'undefined' && typeof (process) !== 'undefined') {\n\t\tTWEEN.now = function () {\n\t\t\tvar time = process.hrtime();\n\t\n\t\t\t// Convert [seconds, nanoseconds] to milliseconds.\n\t\t\treturn time[0] * 1000 + time[1] / 1000000;\n\t\t};\n\t}\n\t// In a browser, use window.performance.now if it is available.\n\telse if (typeof (window) !== 'undefined' &&\n\t         window.performance !== undefined &&\n\t\t\t window.performance.now !== undefined) {\n\t\t// This must be bound, because directly assigning this function\n\t\t// leads to an invocation exception in Chrome.\n\t\tTWEEN.now = window.performance.now.bind(window.performance);\n\t}\n\t// Use Date.now if it is available.\n\telse if (Date.now !== undefined) {\n\t\tTWEEN.now = Date.now;\n\t}\n\t// Otherwise, use 'new Date().getTime()'.\n\telse {\n\t\tTWEEN.now = function () {\n\t\t\treturn new Date().getTime();\n\t\t};\n\t}\n\t\n\t\n\tTWEEN.Tween = function (object) {\n\t\n\t\tvar _object = object;\n\t\tvar _valuesStart = {};\n\t\tvar _valuesEnd = {};\n\t\tvar _valuesStartRepeat = {};\n\t\tvar _duration = 1000;\n\t\tvar _repeat = 0;\n\t\tvar _repeatDelayTime;\n\t\tvar _yoyo = false;\n\t\tvar _isPlaying = false;\n\t\tvar _reversed = false;\n\t\tvar _delayTime = 0;\n\t\tvar _startTime = null;\n\t\tvar _easingFunction = TWEEN.Easing.Linear.None;\n\t\tvar _interpolationFunction = TWEEN.Interpolation.Linear;\n\t\tvar _chainedTweens = [];\n\t\tvar _onStartCallback = null;\n\t\tvar _onStartCallbackFired = false;\n\t\tvar _onUpdateCallback = null;\n\t\tvar _onCompleteCallback = null;\n\t\tvar _onStopCallback = null;\n\t\n\t\tthis.to = function (properties, duration) {\n\t\n\t\t\t_valuesEnd = properties;\n\t\n\t\t\tif (duration !== undefined) {\n\t\t\t\t_duration = duration;\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.start = function (time) {\n\t\n\t\t\tTWEEN.add(this);\n\t\n\t\t\t_isPlaying = true;\n\t\n\t\t\t_onStartCallbackFired = false;\n\t\n\t\t\t_startTime = time !== undefined ? time : TWEEN.now();\n\t\t\t_startTime += _delayTime;\n\t\n\t\t\tfor (var property in _valuesEnd) {\n\t\n\t\t\t\t// Check if an Array was provided as property value\n\t\t\t\tif (_valuesEnd[property] instanceof Array) {\n\t\n\t\t\t\t\tif (_valuesEnd[property].length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\t\t_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// If `to()` specifies a property that doesn't exist in the source object,\n\t\t\t\t// we should not set that property in the object\n\t\t\t\tif (_object[property] === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\t// Save the starting value.\n\t\t\t\t_valuesStart[property] = _object[property];\n\t\n\t\t\t\tif ((_valuesStart[property] instanceof Array) === false) {\n\t\t\t\t\t_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t\t}\n\t\n\t\t\t\t_valuesStartRepeat[property] = _valuesStart[property] || 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.stop = function () {\n\t\n\t\t\tif (!_isPlaying) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\n\t\t\tTWEEN.remove(this);\n\t\t\t_isPlaying = false;\n\t\n\t\t\tif (_onStopCallback !== null) {\n\t\t\t\t_onStopCallback.call(_object, _object);\n\t\t\t}\n\t\n\t\t\tthis.stopChainedTweens();\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.end = function () {\n\t\n\t\t\tthis.update(_startTime + _duration);\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.stopChainedTweens = function () {\n\t\n\t\t\tfor (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t_chainedTweens[i].stop();\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.delay = function (amount) {\n\t\n\t\t\t_delayTime = amount;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.repeat = function (times) {\n\t\n\t\t\t_repeat = times;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.repeatDelay = function (amount) {\n\t\n\t\t\t_repeatDelayTime = amount;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.yoyo = function (yoyo) {\n\t\n\t\t\t_yoyo = yoyo;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\n\t\tthis.easing = function (easing) {\n\t\n\t\t\t_easingFunction = easing;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.interpolation = function (interpolation) {\n\t\n\t\t\t_interpolationFunction = interpolation;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.chain = function () {\n\t\n\t\t\t_chainedTweens = arguments;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.onStart = function (callback) {\n\t\n\t\t\t_onStartCallback = callback;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.onUpdate = function (callback) {\n\t\n\t\t\t_onUpdateCallback = callback;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.onComplete = function (callback) {\n\t\n\t\t\t_onCompleteCallback = callback;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.onStop = function (callback) {\n\t\n\t\t\t_onStopCallback = callback;\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t\tthis.update = function (time) {\n\t\n\t\t\tvar property;\n\t\t\tvar elapsed;\n\t\t\tvar value;\n\t\n\t\t\tif (time < _startTime) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\tif (_onStartCallbackFired === false) {\n\t\n\t\t\t\tif (_onStartCallback !== null) {\n\t\t\t\t\t_onStartCallback.call(_object, _object);\n\t\t\t\t}\n\t\n\t\t\t\t_onStartCallbackFired = true;\n\t\t\t}\n\t\n\t\t\telapsed = (time - _startTime) / _duration;\n\t\t\telapsed = elapsed > 1 ? 1 : elapsed;\n\t\n\t\t\tvalue = _easingFunction(elapsed);\n\t\n\t\t\tfor (property in _valuesEnd) {\n\t\n\t\t\t\t// Don't update properties that do not exist in the source object\n\t\t\t\tif (_valuesStart[property] === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tvar start = _valuesStart[property] || 0;\n\t\t\t\tvar end = _valuesEnd[property];\n\t\n\t\t\t\tif (end instanceof Array) {\n\t\n\t\t\t\t\t_object[property] = _interpolationFunction(end, value);\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\t\tif (typeof (end) === 'string') {\n\t\n\t\t\t\t\t\tif (end.charAt(0) === '+' || end.charAt(0) === '-') {\n\t\t\t\t\t\t\tend = start + parseFloat(end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend = parseFloat(end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Protect against non numeric properties.\n\t\t\t\t\tif (typeof (end) === 'number') {\n\t\t\t\t\t\t_object[property] = start + (end - start) * value;\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif (_onUpdateCallback !== null) {\n\t\t\t\t_onUpdateCallback.call(_object, value);\n\t\t\t}\n\t\n\t\t\tif (elapsed === 1) {\n\t\n\t\t\t\tif (_repeat > 0) {\n\t\n\t\t\t\t\tif (isFinite(_repeat)) {\n\t\t\t\t\t\t_repeat--;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\t\tfor (property in _valuesStartRepeat) {\n\t\n\t\t\t\t\t\tif (typeof (_valuesEnd[property]) === 'string') {\n\t\t\t\t\t\t\t_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (_yoyo) {\n\t\t\t\t\t\t\tvar tmp = _valuesStartRepeat[property];\n\t\n\t\t\t\t\t\t\t_valuesStartRepeat[property] = _valuesEnd[property];\n\t\t\t\t\t\t\t_valuesEnd[property] = tmp;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t_valuesStart[property] = _valuesStartRepeat[property];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (_yoyo) {\n\t\t\t\t\t\t_reversed = !_reversed;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (_repeatDelayTime !== undefined) {\n\t\t\t\t\t\t_startTime = time + _repeatDelayTime;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_startTime = time + _delayTime;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif (_onCompleteCallback !== null) {\n\t\n\t\t\t\t\t\t_onCompleteCallback.call(_object, _object);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t\t// Make the chained tweens start exactly at the time they should,\n\t\t\t\t\t\t// even if the `update()` method was called way past the duration of the tween\n\t\t\t\t\t\t_chainedTweens[i].start(_startTime + _duration);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t};\n\t\n\t};\n\t\n\t\n\tTWEEN.Easing = {\n\t\n\t\tLinear: {\n\t\n\t\t\tNone: function (k) {\n\t\n\t\t\t\treturn k;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tQuadratic: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn k * k;\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn k * (2 - k);\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn 0.5 * k * k;\n\t\t\t\t}\n\t\n\t\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tCubic: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn k * k * k;\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn --k * k * k + 1;\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t\t}\n\t\n\t\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tQuartic: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn k * k * k * k;\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn 1 - (--k * k * k * k);\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t\t}\n\t\n\t\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tQuintic: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn k * k * k * k * k;\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn --k * k * k * k * k + 1;\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t\t}\n\t\n\t\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tSinusoidal: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn Math.sin(k * Math.PI / 2);\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tExponential: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif (k === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\n\t\t\t\tif (k === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t\t}\n\t\n\t\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tCircular: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\treturn Math.sqrt(1 - (--k * k));\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t\t}\n\t\n\t\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tElastic: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\tif (k === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\n\t\t\t\tif (k === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\tif (k === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\n\t\t\t\tif (k === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif (k === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\n\t\t\t\tif (k === 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\n\t\t\t\tk *= 2;\n\t\n\t\t\t\tif (k < 1) {\n\t\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t\t}\n\t\n\t\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tBack: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\tvar s = 1.70158;\n\t\n\t\t\t\treturn k * k * ((s + 1) * k - s);\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\tvar s = 1.70158;\n\t\n\t\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tvar s = 1.70158 * 1.525;\n\t\n\t\t\t\tif ((k *= 2) < 1) {\n\t\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t\t}\n\t\n\t\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tBounce: {\n\t\n\t\t\tIn: function (k) {\n\t\n\t\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\t\n\t\t\t},\n\t\n\t\t\tOut: function (k) {\n\t\n\t\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\t\treturn 7.5625 * k * k;\n\t\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t\t} else {\n\t\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tInOut: function (k) {\n\t\n\t\t\t\tif (k < 0.5) {\n\t\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t\t}\n\t\n\t\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tTWEEN.Interpolation = {\n\t\n\t\tLinear: function (v, k) {\n\t\n\t\t\tvar m = v.length - 1;\n\t\t\tvar f = m * k;\n\t\t\tvar i = Math.floor(f);\n\t\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\t\n\t\t\tif (k < 0) {\n\t\t\t\treturn fn(v[0], v[1], f);\n\t\t\t}\n\t\n\t\t\tif (k > 1) {\n\t\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t\t}\n\t\n\t\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\t\n\t\t},\n\t\n\t\tBezier: function (v, k) {\n\t\n\t\t\tvar b = 0;\n\t\t\tvar n = v.length - 1;\n\t\t\tvar pw = Math.pow;\n\t\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\t\n\t\t\tfor (var i = 0; i <= n; i++) {\n\t\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t\t}\n\t\n\t\t\treturn b;\n\t\n\t\t},\n\t\n\t\tCatmullRom: function (v, k) {\n\t\n\t\t\tvar m = v.length - 1;\n\t\t\tvar f = m * k;\n\t\t\tvar i = Math.floor(f);\n\t\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\t\n\t\t\tif (v[0] === v[m]) {\n\t\n\t\t\t\tif (k < 0) {\n\t\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t\t}\n\t\n\t\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif (k < 0) {\n\t\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t\t}\n\t\n\t\t\t\tif (k > 1) {\n\t\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t\t}\n\t\n\t\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tUtils: {\n\t\n\t\t\tLinear: function (p0, p1, t) {\n\t\n\t\t\t\treturn (p1 - p0) * t + p0;\n\t\n\t\t\t},\n\t\n\t\t\tBernstein: function (n, i) {\n\t\n\t\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\t\n\t\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\t\n\t\t\t},\n\t\n\t\t\tFactorial: (function () {\n\t\n\t\t\t\tvar a = [1];\n\t\n\t\t\t\treturn function (n) {\n\t\n\t\t\t\t\tvar s = 1;\n\t\n\t\t\t\t\tif (a[n]) {\n\t\t\t\t\t\treturn a[n];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\t\ts *= i;\n\t\t\t\t\t}\n\t\n\t\t\t\t\ta[n] = s;\n\t\t\t\t\treturn s;\n\t\n\t\t\t\t};\n\t\n\t\t\t})(),\n\t\n\t\t\tCatmullRom: function (p0, p1, p2, p3, t) {\n\t\n\t\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t * t2;\n\t\n\t\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// UMD (Universal Module Definition)\n\t(function (root) {\n\t\n\t\tif (true) {\n\t\n\t\t\t// AMD\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\t\treturn TWEEN;\n\t\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t\t} else if (typeof module !== 'undefined' && typeof exports === 'object') {\n\t\n\t\t\t// Node.js\n\t\t\tmodule.exports = TWEEN;\n\t\n\t\t} else if (root !== undefined) {\n\t\n\t\t\t// Global variable\n\t\t\troot.TWEEN = TWEEN;\n\t\n\t\t}\n\t\n\t})(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/***/ }),\n\n/***/ 111:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }),\n\n/***/ 187:\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.initPosition = initPosition;\n\tfunction initPosition(isMobile, idx) {\n\t    var letterPosition;\n\t    if (isMobile) {\n\t        switch (idx) {\n\t            case 0:\n\t                return { x: -0.85, y: -2, z: 0, scale: 3 };\n\t            case 1:\n\t                return { x: 1.5, y: -2, z: 0, scale: 3 };\n\t            case 2:\n\t                return { x: 3.5, y: -2, z: 0, scale: 3 };\n\t            case 3:\n\t                return { x: 5, y: -2, z: 0, scale: 3 };\n\t            case 4:\n\t                return { x: -5.5, y: -2, z: 10, scale: 3 };\n\t            case 5:\n\t                return { x: -2.5, y: -2, z: 10, scale: 3 };\n\t            case 6:\n\t                return { x: 1, y: -2, z: 10, scale: 3 };\n\t            case 7:\n\t                return { x: 4, y: -2, z: 10, scale: 3 };\n\t            case 8:\n\t                return { x: 5.75, y: -2, z: 10, scale: 3 };\n\t            case 9:\n\t                return { x: 8, y: -2, z: 10, scale: 3 };\n\t            case 10:\n\t                return { x: 11, y: -2, z: 10, scale: 3 };\n\t            default:\n\t                return { x: 0, y: 0, z: 0, scale: 3 };\n\t        }\n\t    } else {\n\t        switch (idx) {\n\t            case 0:\n\t                return { x: -8.5, y: -2, z: 0, scale: 3 };\n\t            case 1:\n\t                return { x: -6.3, y: -2, z: 0, scale: 3 };\n\t            case 2:\n\t                return { x: -4.4, y: -2.1, z: 0, scale: 3 };\n\t            case 3:\n\t                return { x: -3, y: -2.1, z: 0, scale: 3 };\n\t            case 4:\n\t                return { x: -1, y: -2, z: 0, scale: 3 };\n\t            case 5:\n\t                return { x: 0.65, y: -2.1, z: 0, scale: 3 };\n\t            case 6:\n\t                return { x: 2.6, y: -2.1, z: 0, scale: 3 };\n\t            case 7:\n\t                return { x: 4.4, y: -2.1, z: 0, scale: 3 };\n\t            case 8:\n\t                return { x: 5.45, y: -2.1, z: 0, scale: 3 };\n\t            case 9:\n\t                return { x: 6.75, y: -2.1, z: 0, scale: 3 };\n\t            case 10:\n\t                return { x: 8.5, y: -2, z: 0, scale: 3 };\n\t            default:\n\t                return { x: 0, y: 0, z: 0, scale: 3 };\n\t        }\n\t    }\n\t}\n\n/***/ }),\n\n/***/ 188:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.initRotateTween = initRotateTween;\n\t\n\tvar _tween = __webpack_require__(110);\n\t\n\tvar _tween2 = _interopRequireDefault(_tween);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction initRotateTween(object) {\n\t  console.log(\"initializing rotate\", object);\n\t\n\t  var randomNumber1 = Math.floor(Math.random() * (6 - 2) + 2);\n\t  var randomNumber2 = Math.random() * (6 - 2) + 2;\n\t  var randomNumber3 = Math.random() * (6 - 2) + 2;\n\t  var randomNumber4 = Math.random() * (6 - 2) + 2;\n\t  var randomNumber5 = Math.random() * (6 - 2) + 2;\n\t  var randomNumber6 = Math.random() * (6 - 2) + 2;\n\t\n\t  var direction1 = generateDirection(randomNumber1);\n\t  var direction2 = generateOppositeDirection(direction1);\n\t  var direction3 = generateOppositeDirection(direction2);\n\t  var direction4 = generateOppositeDirection(direction3);\n\t  var direction5 = generateOppositeDirection(direction4);\n\t  var direction6 = generateOppositeDirection(direction5);\n\t\n\t  console.log(\"original rotation\", direction1, direction2);\n\t\n\t  var tween = new _tween2.default.Tween(object.rotation).to({ y: \"\" + direction1 + Math.PI / randomNumber1 }, 3500).easing(_tween2.default.Easing.Sinusoidal.Out);\n\t  var tween2 = new _tween2.default.Tween(object.rotation).to({ y: 0 }, 3500).easing(_tween2.default.Easing.Sinusoidal.In);\n\t  var tween3 = new _tween2.default.Tween(object.rotation).to({ y: \"\" + direction2 + Math.PI / randomNumber2 }, 3500).easing(_tween2.default.Easing.Sinusoidal.Out);\n\t  var tween4 = new _tween2.default.Tween(object.rotation).to({ y: 0 }, 3500).easing(_tween2.default.Easing.Sinusoidal.In);\n\t  var tween5 = new _tween2.default.Tween(object.rotation).to({ y: \"\" + direction3 + Math.PI / randomNumber3 }, 3500).easing(_tween2.default.Easing.Sinusoidal.Out);\n\t  var tween6 = new _tween2.default.Tween(object.rotation).to({ y: 0 }, 3500).easing(_tween2.default.Easing.Sinusoidal.In);\n\t  var tween7 = new _tween2.default.Tween(object.rotation).to({ y: \"\" + direction4 + Math.PI / randomNumber4 }, 3500).easing(_tween2.default.Easing.Sinusoidal.Out);\n\t  var tween8 = new _tween2.default.Tween(object.rotation).to({ y: 0 }, 3500).easing(_tween2.default.Easing.Sinusoidal.In);\n\t  var tween9 = new _tween2.default.Tween(object.rotation).to({ y: \"\" + direction5 + Math.PI / randomNumber5 }, 3500).easing(_tween2.default.Easing.Sinusoidal.Out);\n\t  var tween10 = new _tween2.default.Tween(object.rotation).to({ y: 0 }, 3500).easing(_tween2.default.Easing.Sinusoidal.In);\n\t  var tween11 = new _tween2.default.Tween(object.rotation).to({ y: \"\" + direction6 + Math.PI / randomNumber6 }, 3500).easing(_tween2.default.Easing.Sinusoidal.Out);\n\t  var tween12 = new _tween2.default.Tween(object.rotation).to({ y: 0 }, 3500).easing(_tween2.default.Easing.Sinusoidal.In);\n\t  tween.chain(tween2);\n\t  tween2.chain(tween3);\n\t  tween3.chain(tween4);\n\t  tween4.chain(tween5);\n\t  tween5.chain(tween6);\n\t  tween6.chain(tween7);\n\t  tween7.chain(tween8);\n\t  tween8.chain(tween9);\n\t  tween9.chain(tween10);\n\t  tween10.chain(tween11);\n\t  tween11.chain(tween12);\n\t  tween12.chain(tween);\n\t\n\t  tween.start();\n\t}\n\t\n\tfunction generateDirection(n) {\n\t  var direction = void 0;\n\t  n % 2 === 0 ? direction = \"-\" : direction = \"+\";\n\t  return direction;\n\t}\n\t\n\tfunction generateOppositeDirection(direction1) {\n\t  var direction = void 0;\n\t  direction1 === \"-\" ? direction = \"+\" : direction = \"-\";\n\t  return direction;\n\t}\n\n/***/ }),\n\n/***/ 189:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.initTitle = initTitle;\n\t\n\tvar _initTranslateTween = __webpack_require__(190);\n\t\n\tvar _initRotateTween = __webpack_require__(188);\n\t\n\tvar _initPosition = __webpack_require__(187);\n\t\n\tvar _three = __webpack_require__(178);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _threeObjLoader = __webpack_require__(413);\n\t\n\tvar OBJLoader = _interopRequireWildcard(_threeObjLoader);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tOBJLoader.default(THREE);\n\t\n\tfunction initTitle(threeLoader, objFile, titleColor, titleGroup, idx, isMobile) {\n\t  // let titleMaterial = new THREE.MeshPhongMaterial({color: `black`})\n\t  var titleMaterial = new THREE.MeshPhongMaterial({ color: '' + titleColor });\n\t\n\t  var titleLoader = new threeLoader.OBJLoader();\n\t  titleLoader.load('' + objFile, function (object) {\n\t\n\t    var objBbox = new THREE.Box3().setFromObject(object);\n\t    var offset = objBbox.getCenter();\n\t\n\t    // Geometry vertices centering to world axis\n\t    var bboxCenter = objBbox.getCenter().clone();\n\t    bboxCenter.multiplyScalar(-1);\n\t\n\t    object.traverse(function (child) {\n\t      if (child instanceof THREE.Mesh) {\n\t        child.geometry.translate(bboxCenter.x, bboxCenter.y, bboxCenter.z);\n\t        child.material = titleMaterial;\n\t        child.castShadow = true;\n\t      }\n\t    });\n\t\n\t    var letterPosition = (0, _initPosition.initPosition)(isMobile, idx);\n\t    var scale = letterPosition.scale;\n\t    object.scale.set(scale, scale, scale);\n\t\n\t    object.position.x = letterPosition.x - 1;\n\t    object.position.y = letterPosition.y;\n\t    object.position.z = letterPosition.z;\n\t\n\t    titleGroup.add(object);\n\t    (0, _initTranslateTween.initTranslateTween)(object);\n\t    (0, _initRotateTween.initRotateTween)(object);\n\t  }.bind(this));\n\t}\n\n/***/ }),\n\n/***/ 190:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.initTranslateTween = initTranslateTween;\n\t\n\tvar _tween = __webpack_require__(110);\n\t\n\tvar _tween2 = _interopRequireDefault(_tween);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction initTranslateTween(object) {\n\t  var randomNumber1 = generateRandomNumber();\n\t  var randomNumber2 = generateRandomNumber();\n\t  var randomNumber3 = generateRandomNumber();\n\t  var randomNumber4 = generateRandomNumber();\n\t  var randomNumber5 = generateRandomNumber();\n\t  var randomNumber6 = generateRandomNumber();\n\t\n\t  var originalPosition = object.position.y;\n\t\n\t  console.log(\"RANDOM NUMBER\", randomNumber1, randomNumber2);\n\t\n\t  var tween = new _tween2.default.Tween(object.position).to({ x: object.position.x, y: randomNumber1, z: object.position.z }, 1000).easing(_tween2.default.Easing.Quadratic.Out);\n\t\n\t  var returnTween = new _tween2.default.Tween(object.position).to({ y: originalPosition }, 2500).easing(_tween2.default.Easing.Bounce.Out);\n\t\n\t  var tween2 = new _tween2.default.Tween(object.position).to({ x: object.position.x, y: randomNumber2, z: object.position.z }, 1000).easing(_tween2.default.Easing.Quadratic.Out);\n\t\n\t  var returnTween2 = new _tween2.default.Tween(object.position).to({ y: originalPosition }, 2500).easing(_tween2.default.Easing.Bounce.Out);\n\t\n\t  var tween3 = new _tween2.default.Tween(object.position).to({ x: object.position.x, y: randomNumber3, z: object.position.z }, 1000).easing(_tween2.default.Easing.Quadratic.Out);\n\t\n\t  var returnTween3 = new _tween2.default.Tween(object.position).to({ y: originalPosition }, 2500).easing(_tween2.default.Easing.Bounce.Out);\n\t\n\t  var tween4 = new _tween2.default.Tween(object.position).to({ x: object.position.x, y: randomNumber4, z: object.position.z }, 1000).easing(_tween2.default.Easing.Quadratic.Out);\n\t\n\t  var returnTween4 = new _tween2.default.Tween(object.position).to({ y: originalPosition }, 2500).easing(_tween2.default.Easing.Bounce.Out);\n\t\n\t  var tween5 = new _tween2.default.Tween(object.position).to({ x: object.position.x, y: randomNumber5, z: object.position.z }, 1000).easing(_tween2.default.Easing.Quadratic.Out);\n\t\n\t  var returnTween5 = new _tween2.default.Tween(object.position).to({ y: originalPosition }, 2500).easing(_tween2.default.Easing.Bounce.Out);\n\t\n\t  var tween6 = new _tween2.default.Tween(object.position).to({ x: object.position.x, y: randomNumber6, z: object.position.z }, 1000).easing(_tween2.default.Easing.Quadratic.Out);\n\t\n\t  var returnTween6 = new _tween2.default.Tween(object.position).to({ y: originalPosition }, 2500).easing(_tween2.default.Easing.Bounce.Out);\n\t\n\t  tween.chain(returnTween);\n\t  returnTween.chain(tween2);\n\t  tween2.chain(returnTween2);\n\t  returnTween2.chain(tween3);\n\t  tween3.chain(returnTween3);\n\t  returnTween3.chain(tween4);\n\t  tween4.chain(returnTween4);\n\t  returnTween4.chain(tween5);\n\t  tween5.chain(returnTween5);\n\t  returnTween5.chain(tween6);\n\t  tween6.chain(returnTween6);\n\t  returnTween6.chain(tween);\n\t\n\t  tween.start();\n\t}\n\t\n\tfunction generateRandomNumber() {\n\t  var randomNumber = Math.abs(Math.random() * (4 - 1.5) + 1.5);\n\t  return randomNumber;\n\t}\n\n/***/ }),\n\n/***/ 191:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _gatsbyLink = __webpack_require__(139);\n\t\n\tvar _gatsbyLink2 = _interopRequireDefault(_gatsbyLink);\n\t\n\tvar _randomcolor = __webpack_require__(89);\n\t\n\tvar _randomcolor2 = _interopRequireDefault(_randomcolor);\n\t\n\tvar _initTitle = __webpack_require__(189);\n\t\n\tvar _three = __webpack_require__(178);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _tween = __webpack_require__(110);\n\t\n\tvar _tween2 = _interopRequireDefault(_tween);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar OrbitControls = __webpack_require__(414)(THREE);\n\t\n\tvar ThreeTitle = function (_Component) {\n\t  _inherits(ThreeTitle, _Component);\n\t\n\t  function ThreeTitle(props) {\n\t    _classCallCheck(this, ThreeTitle);\n\t\n\t    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\t\n\t    _this.onWindowResize = function () {\n\t      _this.camera.aspect = _this.mount.clientWidth / _this.mount.clientHeight;\n\t      _this.camera.updateProjectionMatrix();\n\t\n\t      _this.renderer.setSize(_this.mount.clientWidth, _this.mount.clientHeight);\n\t    };\n\t\n\t    _this.start = _this.start.bind(_this);\n\t    _this.stop = _this.stop.bind(_this);\n\t    _this.animate = _this.animate.bind(_this);\n\t    _this.THREE = THREE;\n\t    _this.addTitle = _this.addTitle.bind(_this);\n\t    return _this;\n\t  }\n\t\n\t  ThreeTitle.prototype.componentDidMount = function componentDidMount() {\n\t    window.addEventListener('resize', this.onWindowResize, false);\n\t\n\t    var width = this.mount.clientWidth;\n\t    var height = this.mount.clientHeight;\n\t\n\t    this.isMobile;\n\t    width <= 500 ? this.isMobile = true : this.isMobile = false;\n\t\n\t    //SCENE\n\t    this.scene = new THREE.Scene();\n\t\n\t    //RENDERER\n\t    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n\t    this.renderer.setClearColor(0x000000, 0);\n\t    this.renderer.setSize(width, height);\n\t    this.renderer.shadowMap.enabled = true;\n\t    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\t\n\t    this.mount.appendChild(this.renderer.domElement);\n\t\n\t    //CAMERA\n\t    this.camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);\n\t\n\t    //CONTROLS\n\t    this.controls = new OrbitControls(this.camera, this.mount);\n\t    this.controls.enableZoom = true;\n\t    this.controls.enablePan = false;\n\t    this.controls.maxPolarAngle = Math.PI / 2;\n\t    this.controls.maxDistance = 80;\n\t\n\t    //KEYLIGHT\n\t    this.keyLight = new THREE.AmbientLight(0xffffff, 0.5);\n\t    this.scene.add(this.keyLight);\n\t\n\t    //POINTLIGHT\n\t    this.pointLight = new THREE.PointLight(0xffffff, 1);\n\t\n\t    this.pointLight.castShadow = true;\n\t    this.scene.add(this.pointLight);\n\t\n\t    this.pointLight.shadow.camera.near = 0.5; // default\n\t    this.pointLight.shadow.camera.far = 500; // default\n\t\n\t    //ADD TITLE\n\t    this.titleGroup = new THREE.Group();\n\t    if (this.isMobile) {\n\t      this.objFiles = ['./models/title/1-1-C.obj', './models/title/1-2-O.obj', './models/title/1-3-L.obj', './models/title/1-4-E.obj'];\n\t    } else {\n\t      this.objFiles = ['./models/title/1-1-C.obj', './models/title/1-2-O.obj', './models/title/1-3-L.obj', './models/title/1-4-E.obj', './models/title/2-1-S.obj', './models/title/2-2-H.obj', './models/title/2-3-A.obj', './models/title/2-4-P.obj', './models/title/2-5-I.obj', './models/title/2-6-R.obj', './models/title/2-7-O.obj'];\n\t    }\n\t    this.titleColors = (0, _randomcolor2.default)({ luminosity: 'dark', count: 11 });\n\t\n\t    this.addTitle();\n\t\n\t    this.titleGroup.position.set(-2, -1, 0);\n\t    this.scene.add(this.titleGroup);\n\t\n\t    //ADD FLOOR\n\t    var floorColor = \"#fffd54\";\n\t    this.floorGroup = new THREE.Group();\n\t\n\t    this.floorGeometry = new THREE.PlaneBufferGeometry(200, 200, 32, 32);\n\t    this.floorMaterial = new THREE.MeshBasicMaterial({ color: '' + floorColor });\n\t    this.floor = new THREE.Mesh(this.floorGeometry, this.floorMaterial);\n\t    this.floor.rotation.x = -Math.PI / 2;\n\t    this.isMobile ? this.floor.position.y = -4.05 : this.floor.position.y = -4.05;\n\t    this.floorGroup.add(this.floor);\n\t\n\t    this.floor2Geometry = new THREE.PlaneBufferGeometry(200, 200, 32, 32);\n\t    this.floor2Material = new THREE.ShadowMaterial({ opacity: .2 });\n\t    this.floor2 = new THREE.Mesh(this.floor2Geometry, this.floor2Material);\n\t    this.floor2.rotation.x = -Math.PI / 2;\n\t    this.isMobile ? this.floor2.position.y = -4.05 : this.floor2.position.y = -4.05;\n\t    this.floor2.receiveShadow = true;\n\t    this.floorGroup.add(this.floor2);\n\t\n\t    this.scene.add(this.floorGroup);\n\t\n\t    //MOBILE\n\t    if (this.isMobile) {\n\t      console.log(this.camera);\n\t      this.camera.position.z = 18;\n\t      this.camera.position.x = 5;\n\t      this.camera.position.y = 2;\n\t      this.camera.lookAt(-0.87, -1, 0);\n\t      this.controls.target.set(-0.87, -1, 0);\n\t      // this.scene.fog = new THREE.Fog(0xfffd54, 55, 100);\n\t      this.pointLight.position.set(-3, 5, -5);\n\t      this.pointLight.shadow.mapSize.width = 512;\n\t      this.pointLight.shadow.mapSize.height = 512;\n\t    } else {\n\t      //DESKTOP\n\t      this.camera.position.z = 25;\n\t      this.camera.position.x = 1;\n\t      this.camera.position.y = 0;\n\t      // this.scene.fog = new THREE.Fog(0xfffd54, 18, 50);\n\t      this.camera.lookAt(-2.15, -2, 0);\n\t      this.controls.target.set(-2.15, -2, 0);\n\t      this.pointLight.position.set(0, 5, 5);\n\t      this.pointLight.shadow.mapSize.width = 512;\n\t      this.pointLight.shadow.mapSize.height = 512;\n\t    }\n\t    this.controls.update();\n\t\n\t    this.start();\n\t  };\n\t\n\t  ThreeTitle.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    this.stop();\n\t    this.mount.removeChild(this.renderer.domElement);\n\t    window.removeEventListener('resize', this.onWindowResize, false);\n\t  };\n\t\n\t  ThreeTitle.prototype.start = function start() {\n\t    if (!this.frameId) {\n\t      this.frameId = requestAnimationFrame(this.animate);\n\t    }\n\t  };\n\t\n\t  ThreeTitle.prototype.stop = function stop() {\n\t    cancelAnimationFrame(this.frameId);\n\t  };\n\t\n\t  ThreeTitle.prototype.animate = function animate() {\n\t    this.renderScene();\n\t    _tween2.default.update();\n\t    this.frameId = window.requestAnimationFrame(this.animate);\n\t  };\n\t\n\t  ThreeTitle.prototype.renderScene = function renderScene() {\n\t    this.renderer.render(this.scene, this.camera);\n\t  };\n\t\n\t  ThreeTitle.prototype.addTitle = function addTitle() {\n\t    for (var idx = 0; idx < this.objFiles.length; idx++) {\n\t      var objFile = this.objFiles[idx];\n\t      var titleColor = this.titleColors[idx];\n\t\n\t      (0, _initTitle.initTitle)(this.THREE, objFile, titleColor, this.titleGroup, idx, this.isMobile);\n\t    }\n\t  };\n\t\n\t  ThreeTitle.prototype.render = function render() {\n\t    var _this2 = this;\n\t\n\t    var color = (0, _randomcolor2.default)({ luminosity: 'light' });\n\t    return _react2.default.createElement('div', {\n\t      style: { height: '100vh', width: '100%' },\n\t      ref: function ref(mount) {\n\t        _this2.mount = mount;\n\t      }\n\t    });\n\t  };\n\t\n\t  return ThreeTitle;\n\t}(_react.Component);\n\t\n\texports.default = ThreeTitle;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 194:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _gatsbyLink = __webpack_require__(139);\n\t\n\tvar _gatsbyLink2 = _interopRequireDefault(_gatsbyLink);\n\t\n\tvar _threeTitle = __webpack_require__(191);\n\t\n\tvar _threeTitle2 = _interopRequireDefault(_threeTitle);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar IndexPage = function (_Component) {\n\t  _inherits(IndexPage, _Component);\n\t\n\t  function IndexPage() {\n\t    _classCallCheck(this, IndexPage);\n\t\n\t    return _possibleConstructorReturn(this, _Component.apply(this, arguments));\n\t  }\n\t\n\t  IndexPage.prototype.render = function render() {\n\t    return _react2.default.createElement(\n\t      'div',\n\t      { style: { width: '100%', height: '100%' } },\n\t      _react2.default.createElement(_threeTitle2.default, null)\n\t    );\n\t  };\n\t\n\t  return IndexPage;\n\t}(_react.Component);\n\t\n\texports.default = IndexPage;\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-index-js-0bae3f85d2bfecd3485f.js","/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n\n        var keys = getOwnPropertyNames(sourceComponent);\n\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try { // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n\n        return targetComponent;\n    }\n\n    return targetComponent;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/hoist-non-react-statics/index.js\n// module id = 144\n// module chunks = 35783957827783 231608221292675","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 41\n// module chunks = 35783957827783 231608221292675","// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        // Since we're generating multiple colors,\n        // incremement the seed. Otherwise we'd just\n        // generate the same color each time...\n        if (seed && options.seed) options.seed += 1;\n\n        colors.push(randomColor(options));\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue (options) {\n\n    var hueRange = getHueRange(options.hue),\n        hue = randomWithin(hueRange);\n\n    // Instead of storing red as two seperate ranges,\n    // we group them, using negative numbers\n    if (hue < 0) {hue = 360 + hue;}\n\n    return hue;\n\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n    }\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [19,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [47,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [63,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [179, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [258, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [283, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  return randomColor;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/randomcolor/randomColor.js\n// module id = 89\n// module chunks = 35783957827783 114276838955818","'use strict';\n\nfunction defaultOnError(err) {\n  throw new Error(err);\n}\n\nmodule.exports = function (THREE) {\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  THREE.OBJLoader = function (manager) {\n\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n    this.materials = null;\n\n    this.regexp = {\n      // v float float float\n      vertex_pattern: /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n      // vn float float float\n      normal_pattern: /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n      // vt float float\n      uv_pattern: /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n      // f vertex vertex vertex\n      face_vertex: /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/,\n      // f vertex/uv vertex/uv vertex/uv\n      face_vertex_uv: /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/,\n      // f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n      face_vertex_uv_normal: /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/,\n      // f vertex//normal vertex//normal vertex//normal\n      face_vertex_normal: /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/,\n      // o object_name | g group_name\n      object_pattern: /^[og]\\s*(.+)?/,\n      // s boolean\n      smoothing_pattern: /^s\\s+(\\d+|on|off)/,\n      // mtllib file_reference\n      material_library_pattern: /^mtllib /,\n      // usemtl material_name\n      material_use_pattern: /^usemtl /\n    };\n  };\n\n  THREE.OBJLoader.prototype = {\n\n    constructor: THREE.OBJLoader,\n\n    load: function load(url, onLoad, onProgress, onError) {\n\n      var scope = this;\n      this.onError = onError || defaultOnError;\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.load(url, function (text) {\n\n        onLoad(scope.parse(text));\n      }, onProgress, onError);\n    },\n\n    setPath: function setPath(value) {\n\n      this.path = value;\n    },\n\n    setMaterials: function setMaterials(materials) {\n\n      this.materials = materials;\n    },\n\n    _createParserState: function _createParserState() {\n\n      var state = {\n        objects: [],\n        object: {},\n\n        vertices: [],\n        normals: [],\n        uvs: [],\n\n        materialLibraries: [],\n\n        startObject: function startObject(name, fromDeclaration) {\n\n          // If the current object (initial from reset) is not from a g/o declaration in the parsed\n          // file. We need to use it for the first parsed g/o to keep things in sync.\n          if (this.object && this.object.fromDeclaration === false) {\n\n            this.object.name = name;\n            this.object.fromDeclaration = fromDeclaration !== false;\n            return;\n          }\n\n          var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n          if (this.object && typeof this.object._finalize === 'function') {\n\n            this.object._finalize(true);\n          }\n\n          this.object = {\n            name: name || '',\n            fromDeclaration: fromDeclaration !== false,\n\n            geometry: {\n              vertices: [],\n              normals: [],\n              uvs: []\n            },\n            materials: [],\n            smooth: true,\n\n            startMaterial: function startMaterial(name, libraries) {\n\n              var previous = this._finalize(false);\n\n              // New usemtl declaration overwrites an inherited material, except if faces were declared\n              // after the material, then it must be preserved for proper MultiMaterial continuation.\n              if (previous && (previous.inherited || previous.groupCount <= 0)) {\n\n                this.materials.splice(previous.index, 1);\n              }\n\n              var material = {\n                index: this.materials.length,\n                name: name || '',\n                mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n                smooth: previous !== undefined ? previous.smooth : this.smooth,\n                groupStart: previous !== undefined ? previous.groupEnd : 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false,\n\n                clone: function clone(index) {\n                  var cloned = {\n                    index: typeof index === 'number' ? index : this.index,\n                    name: this.name,\n                    mtllib: this.mtllib,\n                    smooth: this.smooth,\n                    groupStart: 0,\n                    groupEnd: -1,\n                    groupCount: -1,\n                    inherited: false\n                  };\n                  cloned.clone = this.clone.bind(cloned);\n                  return cloned;\n                }\n              };\n\n              this.materials.push(material);\n\n              return material;\n            },\n\n            currentMaterial: function currentMaterial() {\n\n              if (this.materials.length > 0) {\n                return this.materials[this.materials.length - 1];\n              }\n\n              return undefined;\n            },\n\n            _finalize: function _finalize(end) {\n\n              var lastMultiMaterial = this.currentMaterial();\n              if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\n                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n                lastMultiMaterial.inherited = false;\n              }\n\n              // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n              if (end && this.materials.length > 1) {\n\n                for (var mi = this.materials.length - 1; mi >= 0; mi--) {\n                  if (this.materials[mi].groupCount <= 0) {\n                    this.materials.splice(mi, 1);\n                  }\n                }\n              }\n\n              // Guarantee at least one empty material, this makes the creation later more straight forward.\n              if (end && this.materials.length === 0) {\n\n                this.materials.push({\n                  name: '',\n                  smooth: this.smooth\n                });\n              }\n\n              return lastMultiMaterial;\n            }\n          };\n\n          // Inherit previous objects material.\n          // Spec tells us that a declared material must be set to all objects until a new material is declared.\n          // If a usemtl declaration is encountered while this new object is being parsed, it will\n          // overwrite the inherited material. Exception being that there was already face declarations\n          // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n          if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n\n            var declared = previousMaterial.clone(0);\n            declared.inherited = true;\n            this.object.materials.push(declared);\n          }\n\n          this.objects.push(this.object);\n        },\n\n        finalize: function finalize() {\n\n          if (this.object && typeof this.object._finalize === 'function') {\n\n            this.object._finalize(true);\n          }\n        },\n\n        parseVertexIndex: function parseVertexIndex(value, len) {\n\n          var index = parseInt(value, 10);\n          return (index >= 0 ? index - 1 : index + len / 3) * 3;\n        },\n\n        parseNormalIndex: function parseNormalIndex(value, len) {\n\n          var index = parseInt(value, 10);\n          return (index >= 0 ? index - 1 : index + len / 3) * 3;\n        },\n\n        parseUVIndex: function parseUVIndex(value, len) {\n\n          var index = parseInt(value, 10);\n          return (index >= 0 ? index - 1 : index + len / 2) * 2;\n        },\n\n        addVertex: function addVertex(a, b, c) {\n\n          var src = this.vertices;\n          var dst = this.object.geometry.vertices;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[a + 2]);\n          dst.push(src[b + 0]);\n          dst.push(src[b + 1]);\n          dst.push(src[b + 2]);\n          dst.push(src[c + 0]);\n          dst.push(src[c + 1]);\n          dst.push(src[c + 2]);\n        },\n\n        addVertexLine: function addVertexLine(a) {\n\n          var src = this.vertices;\n          var dst = this.object.geometry.vertices;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[a + 2]);\n        },\n\n        addNormal: function addNormal(a, b, c) {\n\n          var src = this.normals;\n          var dst = this.object.geometry.normals;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[a + 2]);\n          dst.push(src[b + 0]);\n          dst.push(src[b + 1]);\n          dst.push(src[b + 2]);\n          dst.push(src[c + 0]);\n          dst.push(src[c + 1]);\n          dst.push(src[c + 2]);\n        },\n\n        addUV: function addUV(a, b, c) {\n\n          var src = this.uvs;\n          var dst = this.object.geometry.uvs;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[b + 0]);\n          dst.push(src[b + 1]);\n          dst.push(src[c + 0]);\n          dst.push(src[c + 1]);\n        },\n\n        addUVLine: function addUVLine(a) {\n\n          var src = this.uvs;\n          var dst = this.object.geometry.uvs;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n        },\n\n        addFace: function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {\n\n          var vLen = this.vertices.length;\n\n          var ia = this.parseVertexIndex(a, vLen);\n          var ib = this.parseVertexIndex(b, vLen);\n          var ic = this.parseVertexIndex(c, vLen);\n          var id;\n\n          if (d === undefined) {\n\n            this.addVertex(ia, ib, ic);\n          } else {\n\n            id = this.parseVertexIndex(d, vLen);\n\n            this.addVertex(ia, ib, id);\n            this.addVertex(ib, ic, id);\n          }\n\n          if (ua !== undefined) {\n\n            var uvLen = this.uvs.length;\n\n            ia = this.parseUVIndex(ua, uvLen);\n            ib = this.parseUVIndex(ub, uvLen);\n            ic = this.parseUVIndex(uc, uvLen);\n\n            if (d === undefined) {\n\n              this.addUV(ia, ib, ic);\n            } else {\n\n              id = this.parseUVIndex(ud, uvLen);\n\n              this.addUV(ia, ib, id);\n              this.addUV(ib, ic, id);\n            }\n          }\n\n          if (na !== undefined) {\n\n            // Normals are many times the same. If so, skip function call and parseInt.\n            var nLen = this.normals.length;\n            ia = this.parseNormalIndex(na, nLen);\n\n            ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n            ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n            if (d === undefined) {\n\n              this.addNormal(ia, ib, ic);\n            } else {\n\n              id = this.parseNormalIndex(nd, nLen);\n\n              this.addNormal(ia, ib, id);\n              this.addNormal(ib, ic, id);\n            }\n          }\n        },\n\n        addLineGeometry: function addLineGeometry(vertices, uvs) {\n\n          this.object.geometry.type = 'Line';\n\n          var vLen = this.vertices.length;\n          var uvLen = this.uvs.length;\n\n          for (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n            this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n          }\n\n          for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\n            this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n          }\n        }\n\n      };\n\n      state.startObject('', false);\n\n      return state;\n    },\n\n    parse: function parse(text, debug) {\n      if (typeof debug === 'undefined') {\n        debug = true;\n      }\n\n      if (debug) {\n        console.time('OBJLoader');\n      }\n\n      var state = this._createParserState();\n\n      if (text.indexOf('\\r\\n') !== -1) {\n\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      if (text.indexOf('\\\\\\n') !== -1) {\n\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n      }\n\n      var lines = text.split('\\n');\n      var line = '',\n          lineFirstChar = '',\n          lineSecondChar = '';\n      var lineLength = 0;\n      var result = [];\n\n      // Faster to just trim left side of the line. Use if available.\n      var trimLeft = typeof ''.trimLeft === 'function';\n\n      for (var i = 0, l = lines.length; i < l; i++) {\n\n        line = lines[i];\n\n        line = trimLeft ? line.trimLeft() : line.trim();\n\n        lineLength = line.length;\n\n        if (lineLength === 0) continue;\n\n        lineFirstChar = line.charAt(0);\n\n        // @todo invoke passed in handler if any\n        if (lineFirstChar === '#') continue;\n\n        if (lineFirstChar === 'v') {\n\n          lineSecondChar = line.charAt(1);\n\n          if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {\n\n            // 0                  1      2      3\n            // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n            state.vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n          } else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {\n\n            // 0                   1      2      3\n            // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n            state.normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n          } else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {\n\n            // 0               1      2\n            // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n            state.uvs.push(parseFloat(result[1]), parseFloat(result[2]));\n          } else {\n\n            this.onError(\"Unexpected vertex/normal/uv line: '\" + line + \"'\");\n          }\n        } else if (lineFirstChar === \"f\") {\n\n          if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {\n\n            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n            // 0                        1    2    3    4    5    6    7    8    9   10         11         12\n            // [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined]\n\n            state.addFace(result[1], result[4], result[7], result[10], result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);\n          } else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {\n\n            // f vertex/uv vertex/uv vertex/uv\n            // 0                  1    2    3    4    5    6   7          8\n            // [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n            state.addFace(result[1], result[3], result[5], result[7], result[2], result[4], result[6], result[8]);\n          } else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {\n\n            // f vertex//normal vertex//normal vertex//normal\n            // 0                     1    2    3    4    5    6   7          8\n            // [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n            state.addFace(result[1], result[3], result[5], result[7], undefined, undefined, undefined, undefined, result[2], result[4], result[6], result[8]);\n          } else if ((result = this.regexp.face_vertex.exec(line)) !== null) {\n\n            // f vertex vertex vertex\n            // 0            1    2    3   4\n            // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n            state.addFace(result[1], result[2], result[3], result[4]);\n          } else {\n\n            this.onError(\"Unexpected face line: '\" + line + \"'\");\n          }\n        } else if (lineFirstChar === \"l\") {\n\n          var lineParts = line.substring(1).trim().split(\" \");\n          var lineVertices = [],\n              lineUVs = [];\n\n          if (line.indexOf(\"/\") === -1) {\n\n            lineVertices = lineParts;\n          } else {\n\n            for (var li = 0, llen = lineParts.length; li < llen; li++) {\n\n              var parts = lineParts[li].split(\"/\");\n\n              if (parts[0] !== \"\") lineVertices.push(parts[0]);\n              if (parts[1] !== \"\") lineUVs.push(parts[1]);\n            }\n          }\n          state.addLineGeometry(lineVertices, lineUVs);\n        } else if ((result = this.regexp.object_pattern.exec(line)) !== null) {\n\n          // o object_name\n          // or\n          // g group_name\n\n          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n          // var name = result[ 0 ].substr( 1 ).trim();\n          var name = (\" \" + result[0].substr(1).trim()).substr(1);\n\n          state.startObject(name);\n        } else if (this.regexp.material_use_pattern.test(line)) {\n\n          // material\n\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        } else if (this.regexp.material_library_pattern.test(line)) {\n\n          // mtl file\n\n          state.materialLibraries.push(line.substring(7).trim());\n        } else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {\n\n          // smooth shading\n\n          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n          // but does not define a usemtl for each face set.\n          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n          // where explicit usemtl defines geometry groups.\n          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n          var value = result[1].trim().toLowerCase();\n          state.object.smooth = value === '1' || value === 'on';\n\n          var material = state.object.currentMaterial();\n          if (material) {\n\n            material.smooth = state.object.smooth;\n          }\n        } else {\n\n          // Handle null terminated files without exception\n          if (line === '\\0') continue;\n\n          this.onError(\"Unexpected line: '\" + line + \"'\");\n        }\n      }\n\n      state.finalize();\n\n      var container = new THREE.Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n\n      for (var i = 0, l = state.objects.length; i < l; i++) {\n\n        var object = state.objects[i];\n        var geometry = object.geometry;\n        var materials = object.materials;\n        var isLine = geometry.type === 'Line';\n\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0) continue;\n\n        var buffergeometry = new THREE.BufferGeometry();\n\n        buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));\n\n        if (geometry.normals.length > 0) {\n\n          buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));\n        } else {\n\n          buffergeometry.computeVertexNormals();\n        }\n\n        if (geometry.uvs.length > 0) {\n\n          buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));\n        }\n\n        // Create materials\n\n        var createdMaterials = [];\n\n        for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n          var sourceMaterial = materials[mi];\n          var material = undefined;\n\n          if (this.materials !== null) {\n\n            material = this.materials.create(sourceMaterial.name);\n\n            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n            if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\n              var materialLine = new THREE.LineBasicMaterial();\n              materialLine.copy(material);\n              material = materialLine;\n            }\n          }\n\n          if (!material) {\n\n            material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();\n            material.name = sourceMaterial.name;\n          }\n\n          material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;\n\n          createdMaterials.push(material);\n        }\n\n        // Create mesh\n\n        var mesh;\n\n        if (createdMaterials.length > 1) {\n\n          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n            var sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n          }\n\n          var multiMaterial = new THREE.MultiMaterial(createdMaterials);\n          mesh = !isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.LineSegments(buffergeometry, multiMaterial);\n        } else {\n\n          mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n        }\n\n        mesh.name = object.name;\n\n        container.add(mesh);\n      }\n\n      if (debug) {\n        console.timeEnd('OBJLoader');\n      }\n\n      return container;\n    }\n\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three-obj-loader/dist/index.js\n// module id = 413\n// module chunks = 35783957827783","module.exports = function( THREE ) {\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls( object, domElement ) {\n\n\t\tthis.object = object;\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function update () {\n\n\t\t\t\tvar position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function() {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tvar spherical = new THREE.Spherical();\n\t\tvar sphericalDelta = new THREE.Spherical();\n\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tvar panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tvar pan = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\treturn function pan ( deltaX, deltaY ) {\n\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\t//console.log( 'handleMouseDownPan' );\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\t//console.log( 'handleMouseMovePan' );\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( event ) {\n\n\t\t\t//console.log( 'handleMouseUp' );\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\t//console.log( 'handleMouseWheel' );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\t//console.log( 'handleKeyDown' );\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\t//console.log( 'handleTouchStartPan' );\n\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\t//console.log( 'handleTouchMovePan' );\n\n\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchEnd( event ) {\n\n\t\t\t//console.log( 'handleTouchEnd' );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleTouchStartDolly( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tcenter: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\t\treturn this.target;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three-orbit-controls/index.js\n// module id = 414\n// module chunks = 35783957827783","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.THREE = {})));\n}(this, (function (exports) { 'use strict';\n\n\t// Polyfills\n\n\tif ( Number.EPSILON === undefined ) {\n\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n\t}\n\n\tif ( Number.isInteger === undefined ) {\n\n\t\t// Missing in IE\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n\n\t\tNumber.isInteger = function ( value ) {\n\n\t\t\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\n\n\t\t};\n\n\t}\n\n\t//\n\n\tif ( Math.sign === undefined ) {\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\tMath.sign = function ( x ) {\n\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t\t};\n\n\t}\n\n\tif ( 'name' in Function.prototype === false ) {\n\n\t\t// Missing in IE\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( Object.assign === undefined ) {\n\n\t\t// Missing in IE\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t( function () {\n\n\t\t\tObject.assign = function ( target ) {\n\n\t\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t\t}\n\n\t\t\t\tvar output = Object( target );\n\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t};\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\n\tfunction EventDispatcher() {}\n\n\tObject.assign( EventDispatcher.prototype, {\n\n\t\taddEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t},\n\n\t\thasEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return false;\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t\t},\n\n\t\tremoveEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispatchEvent: function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar array = listenerArray.slice( 0 );\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tvar REVISION = '90';\n\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\tvar CullFaceNone = 0;\n\tvar CullFaceBack = 1;\n\tvar CullFaceFront = 2;\n\tvar CullFaceFrontBack = 3;\n\tvar FrontFaceDirectionCW = 0;\n\tvar FrontFaceDirectionCCW = 1;\n\tvar BasicShadowMap = 0;\n\tvar PCFShadowMap = 1;\n\tvar PCFSoftShadowMap = 2;\n\tvar FrontSide = 0;\n\tvar BackSide = 1;\n\tvar DoubleSide = 2;\n\tvar FlatShading = 1;\n\tvar SmoothShading = 2;\n\tvar NoColors = 0;\n\tvar FaceColors = 1;\n\tvar VertexColors = 2;\n\tvar NoBlending = 0;\n\tvar NormalBlending = 1;\n\tvar AdditiveBlending = 2;\n\tvar SubtractiveBlending = 3;\n\tvar MultiplyBlending = 4;\n\tvar CustomBlending = 5;\n\tvar AddEquation = 100;\n\tvar SubtractEquation = 101;\n\tvar ReverseSubtractEquation = 102;\n\tvar MinEquation = 103;\n\tvar MaxEquation = 104;\n\tvar ZeroFactor = 200;\n\tvar OneFactor = 201;\n\tvar SrcColorFactor = 202;\n\tvar OneMinusSrcColorFactor = 203;\n\tvar SrcAlphaFactor = 204;\n\tvar OneMinusSrcAlphaFactor = 205;\n\tvar DstAlphaFactor = 206;\n\tvar OneMinusDstAlphaFactor = 207;\n\tvar DstColorFactor = 208;\n\tvar OneMinusDstColorFactor = 209;\n\tvar SrcAlphaSaturateFactor = 210;\n\tvar NeverDepth = 0;\n\tvar AlwaysDepth = 1;\n\tvar LessDepth = 2;\n\tvar LessEqualDepth = 3;\n\tvar EqualDepth = 4;\n\tvar GreaterEqualDepth = 5;\n\tvar GreaterDepth = 6;\n\tvar NotEqualDepth = 7;\n\tvar MultiplyOperation = 0;\n\tvar MixOperation = 1;\n\tvar AddOperation = 2;\n\tvar NoToneMapping = 0;\n\tvar LinearToneMapping = 1;\n\tvar ReinhardToneMapping = 2;\n\tvar Uncharted2ToneMapping = 3;\n\tvar CineonToneMapping = 4;\n\tvar UVMapping = 300;\n\tvar CubeReflectionMapping = 301;\n\tvar CubeRefractionMapping = 302;\n\tvar EquirectangularReflectionMapping = 303;\n\tvar EquirectangularRefractionMapping = 304;\n\tvar SphericalReflectionMapping = 305;\n\tvar CubeUVReflectionMapping = 306;\n\tvar CubeUVRefractionMapping = 307;\n\tvar RepeatWrapping = 1000;\n\tvar ClampToEdgeWrapping = 1001;\n\tvar MirroredRepeatWrapping = 1002;\n\tvar NearestFilter = 1003;\n\tvar NearestMipMapNearestFilter = 1004;\n\tvar NearestMipMapLinearFilter = 1005;\n\tvar LinearFilter = 1006;\n\tvar LinearMipMapNearestFilter = 1007;\n\tvar LinearMipMapLinearFilter = 1008;\n\tvar UnsignedByteType = 1009;\n\tvar ByteType = 1010;\n\tvar ShortType = 1011;\n\tvar UnsignedShortType = 1012;\n\tvar IntType = 1013;\n\tvar UnsignedIntType = 1014;\n\tvar FloatType = 1015;\n\tvar HalfFloatType = 1016;\n\tvar UnsignedShort4444Type = 1017;\n\tvar UnsignedShort5551Type = 1018;\n\tvar UnsignedShort565Type = 1019;\n\tvar UnsignedInt248Type = 1020;\n\tvar AlphaFormat = 1021;\n\tvar RGBFormat = 1022;\n\tvar RGBAFormat = 1023;\n\tvar LuminanceFormat = 1024;\n\tvar LuminanceAlphaFormat = 1025;\n\tvar RGBEFormat = RGBAFormat;\n\tvar DepthFormat = 1026;\n\tvar DepthStencilFormat = 1027;\n\tvar RGB_S3TC_DXT1_Format = 33776;\n\tvar RGBA_S3TC_DXT1_Format = 33777;\n\tvar RGBA_S3TC_DXT3_Format = 33778;\n\tvar RGBA_S3TC_DXT5_Format = 33779;\n\tvar RGB_PVRTC_4BPPV1_Format = 35840;\n\tvar RGB_PVRTC_2BPPV1_Format = 35841;\n\tvar RGBA_PVRTC_4BPPV1_Format = 35842;\n\tvar RGBA_PVRTC_2BPPV1_Format = 35843;\n\tvar RGB_ETC1_Format = 36196;\n\tvar RGBA_ASTC_4x4_Format = 37808;\n\tvar RGBA_ASTC_5x4_Format = 37809;\n\tvar RGBA_ASTC_5x5_Format = 37810;\n\tvar RGBA_ASTC_6x5_Format = 37811;\n\tvar RGBA_ASTC_6x6_Format = 37812;\n\tvar RGBA_ASTC_8x5_Format = 37813;\n\tvar RGBA_ASTC_8x6_Format = 37814;\n\tvar RGBA_ASTC_8x8_Format = 37815;\n\tvar RGBA_ASTC_10x5_Format = 37816;\n\tvar RGBA_ASTC_10x6_Format = 37817;\n\tvar RGBA_ASTC_10x8_Format = 37818;\n\tvar RGBA_ASTC_10x10_Format = 37819;\n\tvar RGBA_ASTC_12x10_Format = 37820;\n\tvar RGBA_ASTC_12x12_Format = 37821;\n\tvar LoopOnce = 2200;\n\tvar LoopRepeat = 2201;\n\tvar LoopPingPong = 2202;\n\tvar InterpolateDiscrete = 2300;\n\tvar InterpolateLinear = 2301;\n\tvar InterpolateSmooth = 2302;\n\tvar ZeroCurvatureEnding = 2400;\n\tvar ZeroSlopeEnding = 2401;\n\tvar WrapAroundEnding = 2402;\n\tvar TrianglesDrawMode = 0;\n\tvar TriangleStripDrawMode = 1;\n\tvar TriangleFanDrawMode = 2;\n\tvar LinearEncoding = 3000;\n\tvar sRGBEncoding = 3001;\n\tvar GammaEncoding = 3007;\n\tvar RGBEEncoding = 3002;\n\tvar LogLuvEncoding = 3003;\n\tvar RGBM7Encoding = 3004;\n\tvar RGBM16Encoding = 3005;\n\tvar RGBDEncoding = 3006;\n\tvar BasicDepthPacking = 3200;\n\tvar RGBADepthPacking = 3201;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar _Math = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\t\tgenerateUUID: ( function () {\n\n\t\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\t\t\tvar lut = [];\n\n\t\t\tfor ( var i = 0; i < 256; i ++ ) {\n\n\t\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();\n\n\t\t\t}\n\n\t\t\treturn function generateUUID() {\n\n\t\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\n\t\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\n\t\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\n\t\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\n\t\t\t\treturn lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\n\t\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * _Math.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * _Math.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tceilPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tfloorPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tfunction Vector2( x, y ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\n\t}\n\n\tObject.defineProperties( Vector2.prototype, {\n\n\t\t\"width\": {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.x;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.x = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\t\"height\": {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.y;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.y = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Vector2.prototype, {\n\n\t\tisVector2: true,\n\n\t\tset: function ( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// assumes min < max, componentwise\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min = new Vector2();\n\t\t\tvar max = new Vector2();\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t},\n\n\t\tmanhattanLength: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() || 1 );\n\n\t\t},\n\n\t\tangle: function () {\n\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\t\treturn angle;\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t},\n\n\t\tmanhattanDistanceTo: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.normalize().multiplyScalar( length );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX( index );\n\t\t\tthis.y = attribute.getY( index );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateAround: function ( center, angle ) {\n\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Matrix4() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tObject.assign( Matrix4.prototype, {\n\n\t\tisMatrix4: true,\n\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyPosition: function ( m ) {\n\n\t\t\tvar te = this.elements, me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractRotation: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function extractRotation( m ) {\n\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeRotationFromEuler: function ( euler ) {\n\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = q._x, y = q._y, z = q._z, w = q._w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlookAt: function () {\n\n\t\t\tvar x = new Vector3();\n\t\t\tvar y = new Vector3();\n\t\t\tvar z = new Vector3();\n\n\t\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tz.subVectors( eye, target );\n\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t\t// eye and target are in the same position\n\n\t\t\t\t\tz.z = 1;\n\n\t\t\t\t}\n\n\t\t\t\tz.normalize();\n\t\t\t\tx.crossVectors( up, z );\n\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t\t// up and z are parallel\n\n\t\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t\t\tz.x += 0.0001;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz.z += 0.0001;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tz.normalize();\n\t\t\t\t\tx.crossVectors( up, z );\n\n\t\t\t\t}\n\n\t\t\t\tx.normalize();\n\t\t\t\ty.crossVectors( z, x );\n\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m, n ) {\n\n\t\t\tif ( n !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToBufferAttribute: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function applyToBufferAttribute( attribute ) {\n\n\t\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\t\tv1.z = attribute.getZ( i );\n\n\t\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn attribute;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPosition: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tscale: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetMaxScaleOnAxis: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t},\n\n\t\tmakeTranslation: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationX: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s, c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationY: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationZ: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts, c, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\t return this;\n\n\t\t},\n\n\t\tmakeScale: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeShear: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, y, z, 0,\n\t\t\t\tx, 1, z, 0,\n\t\t\t\tx, y, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompose: function ( position, quaternion, scale ) {\n\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdecompose: function () {\n\n\t\t\tvar vector = new Vector3();\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) sx = - sx;\n\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\n\t\t\t\t// scale the rotation part\n\t\t\t\tmatrix.copy( this );\n\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakePerspective: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tif ( far === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Quaternion( x, y, z, w ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tObject.assign( Quaternion, {\n\n\t\tslerp: function ( qa, qb, qm, t ) {\n\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t\t},\n\n\t\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tvar s = 1 - t,\n\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( Quaternion.prototype, {\n\n\t\tx: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._x;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t},\n\n\t\ty: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._y;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t},\n\n\t\tz: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._z;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t},\n\n\t\tw: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._w;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._w = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Quaternion.prototype, {\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t},\n\n\t\tcopy: function ( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromEuler: function ( euler, update ) {\n\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tvar cos = Math.cos;\n\t\t\tvar sin = Math.sin;\n\n\t\t\tvar c1 = cos( x / 2 );\n\t\t\tvar c2 = cos( y / 2 );\n\t\t\tvar c3 = cos( z / 2 );\n\n\t\t\tvar s1 = sin( x / 2 );\n\t\t\tvar s2 = sin( y / 2 );\n\t\t\tvar s3 = sin( z / 2 );\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t}\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromUnitVectors: function () {\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar r;\n\n\t\t\tvar EPS = 0.000001;\n\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\t\tif ( r < EPS ) {\n\n\t\t\t\t\tr = 0;\n\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t\t}\n\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\n\t\t\t\treturn this.normalize();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tinverse: function () {\n\n\t\t\t// quaternion is assumed to have unit length\n\n\t\t\treturn this.conjugate();\n\n\t\t},\n\n\t\tconjugate: function () {\n\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tvar l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( q, p ) {\n\n\t\t\tif ( p !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t},\n\n\t\tpremultiply: function ( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t},\n\n\t\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tslerp: function ( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector3( x, y, z ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\n\t}\n\n\tObject.assign( Vector3.prototype, {\n\n\t\tisVector3: true,\n\n\t\tset: function ( x, y, z ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyEuler: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function applyEuler( euler ) {\n\n\t\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyAxisAngle: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// calculate quat * vector\n\n\t\t\tvar ix = qw * x + qy * z - qz * y;\n\t\t\tvar iy = qw * y + qz * x - qx * z;\n\t\t\tvar iz = qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t\t// calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tproject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function project( camera ) {\n\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyMatrix4( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tunproject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function unproject( camera ) {\n\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyMatrix4( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttransformDirection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// assumes min < max, componentwise\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min = new Vector3();\n\t\t\tvar max = new Vector3();\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t},\n\n\t\t// TODO lengthSquared?\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t},\n\n\t\tmanhattanLength: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() || 1 );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.normalize().multiplyScalar( length );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tcross: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\n\t\t\t}\n\n\t\t\treturn this.crossVectors( this, v );\n\n\t\t},\n\n\t\tcrossVectors: function ( a, b ) {\n\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tprojectOnVector: function ( vector ) {\n\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t\t},\n\n\t\tprojectOnPlane: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\t\treturn this.sub( v1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\treflect: function () {\n\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function reflect( normal ) {\n\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tangleTo: function ( v ) {\n\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t},\n\n\t\tmanhattanDistanceTo: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t},\n\n\t\tsetFromSpherical: function ( s ) {\n\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCylindrical: function ( c ) {\n\n\t\t\tthis.x = c.radius * Math.sin( c.theta );\n\t\t\tthis.y = c.y;\n\t\t\tthis.z = c.radius * Math.cos( c.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixPosition: function ( m ) {\n\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 12 ];\n\t\t\tthis.y = e[ 13 ];\n\t\t\tthis.z = e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixScale: function ( m ) {\n\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX( index );\n\t\t\tthis.y = attribute.getY( index );\n\t\t\tthis.z = attribute.getZ( index );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\n\tfunction Matrix3() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tObject.assign( Matrix3.prototype, {\n\n\t\tisMatrix3: true,\n\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix4: function ( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToBufferAttribute: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function applyToBufferAttribute( attribute ) {\n\n\t\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\t\tv1.z = attribute.getZ( i );\n\n\t\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn attribute;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t},\n\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\t\tif ( matrix && matrix.isMatrix4 ) {\n\n\t\t\t\tconsole.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\n\n\t\t\t}\n\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar tmp, m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t\t},\n\n\t\ttransposeIntoArray: function ( r ) {\n\n\t\t\tvar m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\t\tvar c = Math.cos( rotation );\n\t\t\tvar s = Math.sin( rotation );\n\n\t\t\tthis.set(\n\t\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t\t0, 0, 1\n\t\t\t);\n\n\t\t},\n\n\t\tscale: function ( sx, sy ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotate: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta );\n\t\t\tvar s = Math.sin( theta );\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\n\t\t\tte[ 0 ] = c * a11 + s * a21;\n\t\t\tte[ 3 ] = c * a12 + s * a22;\n\t\t\tte[ 6 ] = c * a13 + s * a23;\n\n\t\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\t\tte[ 7 ] = - s * a13 + c * a23;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( tx, ty ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\n\tvar textureId = 0;\n\n\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\tTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: Texture,\n\n\t\tisTexture: true,\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\t\t\tthis.center.copy( source.center );\n\t\t\tthis.rotation = source.rotation;\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrix.copy( source.matrix );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tfunction getDataURL( image ) {\n\n\t\t\t\tvar canvas;\n\n\t\t\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\t\t\tcanvas = image;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\n\t\t\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\tmapping: this.mapping,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\t\trotation: this.rotation,\n\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\n\t\t\tif ( this.image !== undefined ) {\n\n\t\t\t\t// TODO: Move to THREE.Image\n\n\t\t\t\tvar image = this.image;\n\n\t\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject ) {\n\n\t\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t},\n\n\t\ttransformUv: function ( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping ) return;\n\n\t\t\tuv.applyMatrix3( this.matrix );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tObject.defineProperty( Texture.prototype, \"needsUpdate\", {\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector4( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tObject.assign( Vector4.prototype, {\n\n\t\tisVector4: true,\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( w ) {\n\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t// q is assumed to be normalized\n\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\t\tif ( s < 0.0001 ) {\n\n\t\t\t\tthis.x = 1;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = q.x / s;\n\t\t\t\tthis.y = q.y / s;\n\t\t\t\tthis.z = q.z / s;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\t\tte = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t\t}\n\n\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\tangle = Math.PI;\n\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.set( x, y, z, angle );\n\n\t\t\t\treturn this; // return 180 deg rotation\n\n\t\t\t}\n\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// assumes min < max, componentwise\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\tmax = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\t},\n\n\t\tmanhattanLength: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() || 1 );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.normalize().multiplyScalar( length );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX( index );\n\t\t\tthis.y = attribute.getY( index );\n\t\t\tthis.z = attribute.getZ( index );\n\t\t\tthis.w = attribute.getW( index );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tfunction WebGLRenderTarget( width, height, options ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: WebGLRenderTarget,\n\n\t\tisWebGLRenderTarget: true,\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\tthis.viewport.copy( source.viewport );\n\n\t\t\tthis.texture = source.texture.clone();\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\n\tfunction WebGLRenderTargetCube( width, height, options ) {\n\n\t\tWebGLRenderTarget.call( this, width, height, options );\n\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\n\t}\n\n\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n\tDataTexture.prototype = Object.create( Texture.prototype );\n\tDataTexture.prototype.constructor = DataTexture;\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tCubeTexture.prototype = Object.create( Texture.prototype );\n\tCubeTexture.prototype.constructor = CubeTexture;\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\t\tget: function () {\n\n\t\t\treturn this.image;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.image = value;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\n\tvar emptyTexture = new Texture();\n\tvar emptyCubeTexture = new CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tfunction UniformContainer() {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tvar arrayCacheF32 = [];\n\tvar arrayCacheI32 = [];\n\n\t// Float32Array caches used for uploading Matrix uniforms\n\n\tvar mat4array = new Float32Array( 16 );\n\tvar mat3array = new Float32Array( 9 );\n\n\t// Flattening for arrays of vectors and matrices\n\n\tfunction flatten( array, nBlocks, blockSize ) {\n\n\t\tvar firstElem = array[ 0 ];\n\n\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t// unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tvar n = nBlocks * blockSize,\n\t\t\tr = arrayCacheF32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Float32Array( n );\n\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t}\n\n\t\tif ( nBlocks !== 0 ) {\n\n\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n\t// Texture unit allocation\n\n\tfunction allocTexUnits( renderer, n ) {\n\n\t\tvar r = arrayCacheI32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Int32Array( n );\n\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\treturn r;\n\n\t}\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t// Single scalar\n\n\tfunction setValue1f( gl, v ) {\n\n\t\tgl.uniform1f( this.addr, v );\n\n\t}\n\n\tfunction setValue1i( gl, v ) {\n\n\t\tgl.uniform1i( this.addr, v );\n\n\t}\n\n\t// Single float vector (from flat array or THREE.VectorN)\n\n\tfunction setValue2fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) {\n\n\t\t\tgl.uniform2fv( this.addr, v );\n\n\t\t} else {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t}\n\n\t}\n\n\tfunction setValue3fv( gl, v ) {\n\n\t\tif ( v.x !== undefined ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t} else if ( v.r !== undefined ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t} else {\n\n\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t}\n\n\t}\n\n\tfunction setValue4fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) {\n\n\t\t\tgl.uniform4fv( this.addr, v );\n\n\t\t} else {\n\n\t\t\t gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t}\n\n\t}\n\n\t// Single matrix (from flat array or MatrixN)\n\n\tfunction setValue2fm( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue3fm( gl, v ) {\n\n\t\tif ( v.elements === undefined ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\t} else {\n\n\t\t\tmat3array.set( v.elements );\n\t\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\t}\n\n\t}\n\n\tfunction setValue4fm( gl, v ) {\n\n\t\tif ( v.elements === undefined ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\t} else {\n\n\t\t\tmat4array.set( v.elements );\n\t\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\t}\n\n\t}\n\n\t// Single texture (2D / Cube)\n\n\tfunction setValueT1( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t}\n\n\tfunction setValueT6( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t}\n\n\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\tfunction setValue2iv( gl, v ) {\n\n\t\tgl.uniform2iv( this.addr, v );\n\n\t}\n\n\tfunction setValue3iv( gl, v ) {\n\n\t\tgl.uniform3iv( this.addr, v );\n\n\t}\n\n\tfunction setValue4iv( gl, v ) {\n\n\t\tgl.uniform4iv( this.addr, v );\n\n\t}\n\n\t// Helper to pick the right setter for the singular case\n\n\tfunction getSingularSetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\n\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// Array of scalars\n\n\tfunction setValue1fv( gl, v ) {\n\n\t\tgl.uniform1fv( this.addr, v );\n\n\t}\n\tfunction setValue1iv( gl, v ) {\n\n\t\tgl.uniform1iv( this.addr, v );\n\n\t}\n\n\t// Array of vectors (flat or from THREE classes)\n\n\tfunction setValueV2a( gl, v ) {\n\n\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t}\n\n\tfunction setValueV3a( gl, v ) {\n\n\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t}\n\n\tfunction setValueV4a( gl, v ) {\n\n\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t}\n\n\t// Array of matrices (flat or from THREE clases)\n\n\tfunction setValueM2a( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t}\n\n\tfunction setValueM3a( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t}\n\n\tfunction setValueM4a( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t}\n\n\t// Array of textures (2D / Cube)\n\n\tfunction setValueT1a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\tfunction setValueT6a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\tfunction getPureArraySetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// --- Uniform Classes ---\n\n\tfunction SingleUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction StructuredUniform( id ) {\n\n\t\tthis.id = id;\n\n\t\tUniformContainer.call( this ); // mix-in\n\n\t}\n\n\tStructuredUniform.prototype.setValue = function ( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n\t// extracts\n\t// \t- the identifier (member name or array index)\n\t//  - followed by an optional right bracket (found when array index)\n\t//  - followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform( container, uniformObject ) {\n\n\t\tcontainer.seq.push( uniformObject );\n\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t}\n\n\tfunction parseUniform( activeInfo, addr, container ) {\n\n\t\tvar path = activeInfo.name,\n\t\t\tpathLength = path.length;\n\n\t\t// reset RegExp object, because of the early exit of a previous run\n\t\tRePathPart.lastIndex = 0;\n\n\t\tfor ( ; ; ) {\n\n\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\tid = match[ 1 ],\n\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\tvar map = container.map, next = map[ id ];\n\n\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Root Container\n\n\tfunction WebGLUniforms( gl, program, renderer ) {\n\n\t\tUniformContainer.call( this );\n\n\t\tthis.renderer = renderer;\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( var i = 0; i < n; ++ i ) {\n\n\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\tpath = info.name,\n\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function ( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\tfunction Color( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tObject.assign( Color.prototype, {\n\n\t\tisColor: true,\n\n\t\tr: 1, g: 1, b: 1,\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHex: function ( hex ) {\n\n\t\t\thex = Math.floor( hex );\n\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRGB: function ( r, g, b ) {\n\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHSL: function () {\n\n\t\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\t\tif ( s === 0 ) {\n\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetStyle: function ( style ) {\n\n\t\t\tfunction handleAlpha( string ) {\n\n\t\t\t\tif ( string === undefined ) return;\n\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar m;\n\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t\t// rgb / hsl\n\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t\t// hex color\n\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\n\t\t\t\tif ( size === 3 ) {\n\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( style && style.length > 0 ) {\n\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t\t},\n\n\t\tcopy: function ( color ) {\n\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertGammaToLinear: function () {\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertLinearToGamma: function () {\n\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetHex: function () {\n\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t\t},\n\n\t\tgetHexString: function () {\n\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t\t},\n\n\t\tgetHSL: function ( optionalTarget ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t},\n\n\t\tgetStyle: function () {\n\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t\t},\n\n\t\toffsetHSL: function ( h, s, l ) {\n\n\t\t\tvar hsl = this.getHSL();\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( color ) {\n\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddColors: function ( color1, color2 ) {\n\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( color ) {\n\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( color ) {\n\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerp: function ( color, alpha ) {\n\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( c ) {\n\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\treturn this.getHex();\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tvar UniformsLib = {\n\n\t\tcommon: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\n\t\t\tmap: { value: null },\n\t\t\tuvTransform: { value: new Matrix3() },\n\n\t\t\talphaMap: { value: null },\n\n\t\t},\n\n\t\tspecularmap: {\n\n\t\t\tspecularMap: { value: null },\n\n\t\t},\n\n\t\tenvmap: {\n\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\treflectivity: { value: 1.0 },\n\t\t\trefractionRatio: { value: 0.98 }\n\n\t\t},\n\n\t\taomap: {\n\n\t\t\taoMap: { value: null },\n\t\t\taoMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\tlightmap: {\n\n\t\t\tlightMap: { value: null },\n\t\t\tlightMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\temissivemap: {\n\n\t\t\temissiveMap: { value: null }\n\n\t\t},\n\n\t\tbumpmap: {\n\n\t\t\tbumpMap: { value: null },\n\t\t\tbumpScale: { value: 1 }\n\n\t\t},\n\n\t\tnormalmap: {\n\n\t\t\tnormalMap: { value: null },\n\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t\t},\n\n\t\tdisplacementmap: {\n\n\t\t\tdisplacementMap: { value: null },\n\t\t\tdisplacementScale: { value: 1 },\n\t\t\tdisplacementBias: { value: 0 }\n\n\t\t},\n\n\t\troughnessmap: {\n\n\t\t\troughnessMap: { value: null }\n\n\t\t},\n\n\t\tmetalnessmap: {\n\n\t\t\tmetalnessMap: { value: null }\n\n\t\t},\n\n\t\tgradientmap: {\n\n\t\t\tgradientMap: { value: null }\n\n\t\t},\n\n\t\tfog: {\n\n\t\t\tfogDensity: { value: 0.00025 },\n\t\t\tfogNear: { value: 1 },\n\t\t\tfogFar: { value: 2000 },\n\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t\t},\n\n\t\tlights: {\n\n\t\t\tambientLightColor: { value: [] },\n\n\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tcolor: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\t\tspotLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdirection: {},\n\t\t\t\tdistance: {},\n\t\t\t\tconeCos: {},\n\t\t\t\tpenumbraCos: {},\n\t\t\t\tdecay: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tspotShadowMap: { value: [] },\n\t\t\tspotShadowMatrix: { value: [] },\n\n\t\t\tpointLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdecay: {},\n\t\t\t\tdistance: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {},\n\t\t\t\tshadowCameraNear: {},\n\t\t\t\tshadowCameraFar: {}\n\t\t\t} },\n\n\t\t\tpointShadowMap: { value: [] },\n\t\t\tpointShadowMatrix: { value: [] },\n\n\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tskyColor: {},\n\t\t\t\tgroundColor: {}\n\t\t\t} },\n\n\t\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\t\trectAreaLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\twidth: {},\n\t\t\t\theight: {}\n\t\t\t} }\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\t\t\tsize: { value: 1.0 },\n\t\t\tscale: { value: 1.0 },\n\t\t\tmap: { value: null },\n\t\t\tuvTransform: { value: new Matrix3() }\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Uniform Utilities\n\t */\n\n\tvar UniformsUtils = {\n\n\t\tmerge: function ( uniforms ) {\n\n\t\t\tvar merged = {};\n\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn merged;\n\n\t\t},\n\n\t\tclone: function ( uniforms_src ) {\n\n\t\t\tvar uniforms_dst = {};\n\n\t\t\tfor ( var u in uniforms_src ) {\n\n\t\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uniforms_dst;\n\n\t\t}\n\n\t};\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n\tvar bsdfs = \"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t}\\n\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\\n\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\n\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n\tvar defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n\tvar fog_vertex = \"\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif\";\n\n\tvar fog_pars_vertex = \"#ifdef USE_FOG\\n  varying float fogDepth;\\n#endif\\n\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\";\n\n\tvar gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n\tvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\\n\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n\tvar project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n\tvar dithering_fragment = \"#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\\n\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\\n\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\n\";\n\n\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\\n\";\n\n\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\\n\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\\n\";\n\n\tvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\n\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\";\n\n\tvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar shadow_vert = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n\tvar ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_vertex: fog_vertex,\n\t\tfog_pars_vertex: fog_pars_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars: lights_pars,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_template: lights_template,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_fragment: normal_fragment,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\tdithering_fragment: dithering_fragment,\n\t\tdithering_pars_fragment: dithering_pars_fragment,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\n\tvar ShaderLib = {\n\n\t\tbasic: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.specularmap,\n\t\t\t\tUniformsLib.envmap,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.fog\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t\t},\n\n\t\tlambert: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.specularmap,\n\t\t\t\tUniformsLib.envmap,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\t\t\t\t{\n\t\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t\t},\n\n\t\tphong: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.specularmap,\n\t\t\t\tUniformsLib.envmap,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.gradientmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\t\t\t\t{\n\t\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\t\tspecular: { value: new Color( 0x111111 ) },\n\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t\t},\n\n\t\tstandard: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.envmap,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\t\t\t\t{\n\t\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\tmetalness: { value: 0.5 },\n\t\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.points,\n\t\t\t\tUniformsLib.fog\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\n\t\t},\n\n\t\tdashed: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tscale: { value: 1 },\n\t\t\t\t\tdashSize: { value: 1 },\n\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t\t},\n\n\t\tdepth: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t\t},\n\n\t\tnormal: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tcube: {\n\n\t\t\tuniforms: {\n\t\t\t\ttCube: { value: null },\n\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t\t},\n\n\t\tequirect: {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t\t},\n\n\t\tdistanceRGBA: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\t{\n\t\t\t\t\treferencePosition: { value: new Vector3() },\n\t\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t\t},\n\n\t\tshadow: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.lights,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tcolor: { value: new Color( 0x00000 ) },\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t},\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t\t}\n\n\t};\n\n\tShaderLib.physical = {\n\n\t\tuniforms: UniformsUtils.merge( [\n\t\t\tShaderLib.standard.uniforms,\n\t\t\t{\n\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\tCanvasTexture.prototype.constructor = CanvasTexture;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\n\t\tvar texture;\n\n\t\t// decompose matrixWorld\n\n\t\tvar spritePosition = new Vector3();\n\t\tvar spriteRotation = new Quaternion();\n\t\tvar spriteScale = new Vector3();\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0,\n\t\t\t\t  0.5, - 0.5, 1, 0,\n\t\t\t\t  0.5, 0.5, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\tvertexBuffer = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\tprogram = createProgram();\n\n\t\t\tattributes = {\n\t\t\t\tposition: gl.getAttribLocation( program, 'position' ),\n\t\t\t\tuv: gl.getAttribLocation( program, 'uv' )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\tuvOffset: gl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale: gl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\t\trotation: gl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tcenter: gl.getUniformLocation( program, 'center' ),\n\t\t\t\tscale: gl.getUniformLocation( program, 'scale' ),\n\n\t\t\t\tcolor: gl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap: gl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity: gl.getUniformLocation( program, 'opacity' ),\n\n\t\t\t\tmodelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\t\tfogType: gl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity: gl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear: gl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar: gl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor: gl.getUniformLocation( program, 'fogColor' ),\n\t\t\t\tfogDepth: gl.getUniformLocation( program, 'fogDepth' ),\n\n\t\t\t\talphaTest: gl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\t\ttexture = new CanvasTexture( canvas );\n\n\t\t}\n\n\t\tthis.render = function ( sprites, scene, camera ) {\n\n\t\t\tif ( sprites.length === 0 ) return;\n\n\t\t\t// setup gl\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tstate.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\n\t\t\tif ( fog ) {\n\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\t\tif ( fog.isFog ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\n\t\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\n\t\t\t}\n\n\n\t\t\t// update positions and sort\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tsprites.sort( painterSortStable );\n\n\t\t\t// render all sprites\n\n\t\t\tvar scale = [];\n\t\t\tvar center = [];\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\n\t\t\t\tif ( material.visible === false ) continue;\n\n\t\t\t\tsprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );\n\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\t\tcenter[ 0 ] = sprite.center.x - 0.5;\n\t\t\t\tcenter[ 1 ] = sprite.center.y - 0.5;\n\n\t\t\t\tvar fogType = 0;\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.center, center );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\t\t\t\tstate.buffers.depth.setTest( material.depthTest );\n\t\t\t\tstate.buffers.depth.setMask( material.depthWrite );\n\t\t\t\tstate.buffers.color.setMask( material.colorWrite );\n\n\t\t\t\ttextures.setTexture2D( material.map || texture, 0 );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\tsprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\n\t\t\tstate.reset();\n\n\t\t};\n\n\t\tfunction createProgram() {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t\t'precision ' + capabilities.precision + ' float;',\n\n\t\t\t\t'#define SHADER_NAME ' + 'SpriteMaterial',\n\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 center;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\t\t\t\t'varying float fogDepth;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'\tvec2 alignedPosition = ( position - center ) * scale;',\n\n\t\t\t\t'\tvec2 rotatedPosition;',\n\t\t\t\t'\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'\tvec4 mvPosition;',\n\n\t\t\t\t'\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'\tmvPosition.xy += rotatedPosition;',\n\n\t\t\t\t'\tgl_Position = projectionMatrix * mvPosition;',\n\n\t\t\t\t'\tfogDepth = - mvPosition.z;',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t\t'precision ' + capabilities.precision + ' float;',\n\n\t\t\t\t'#define SHADER_NAME ' + 'SpriteMaterial',\n\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\n\t\t\t\t'varying vec2 vUV;',\n\t\t\t\t'varying float fogDepth;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'\tif ( gl_FragColor.a < alphaTest ) discard;',\n\n\t\t\t\t'\tif ( fogType > 0 ) {',\n\n\t\t\t\t'\t\tfloat fogFactor = 0.0;',\n\n\t\t\t\t'\t\tif ( fogType == 1 ) {',\n\n\t\t\t\t'\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',\n\n\t\t\t\t'\t\t} else {',\n\n\t\t\t\t'\t\t\tconst float LOG2 = 1.442695;',\n\t\t\t\t'\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',\n\t\t\t\t'\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t'\t\t}',\n\n\t\t\t\t'\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',\n\n\t\t\t\t'\t}',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn b.id - a.id;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tvar materialId = 0;\n\n\tfunction Material() {\n\n\t\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.flatShading = false;\n\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\t\tthis.visible = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: Material,\n\n\t\tisMaterial: true,\n\n\t\tonBeforeCompile: function () {},\n\n\t\tsetValues: function ( values ) {\n\n\t\t\tif ( values === undefined ) return;\n\n\t\t\tfor ( var key in values ) {\n\n\t\t\t\tvar newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// for backward compatability if shading is set in the constructor\n\t\t\t\tif ( key === 'shading' ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\t\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\t\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\t\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\n\t\t\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\n\n\t\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t\t}\n\t\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t\t}\n\t\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t\t}\n\t\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\t}\n\n\t\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\n\t\t\t// rotation (SpriteMaterial)\n\t\t\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\t\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\t\tif ( this.morphTargets === true ) data.morphTargets = true;\n\t\t\tif ( this.skinning === true ) data.skinning = true;\n\n\t\t\tif ( this.visible === false ) data.visible = false;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\n\t\t\t// TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\n\t\t\tthis.colorWrite = source.colorWrite;\n\n\t\t\tthis.precision = source.precision;\n\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\t\tthis.dithering = source.dithering;\n\n\t\t\tthis.alphaTest = source.alphaTest;\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\t\tthis.overdraw = source.overdraw;\n\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\n\t\t\tif ( srcPlanes !== null ) {\n\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\n\t\t\tthis.shadowSide = source.shadowSide;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshDepthMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  referencePosition: <float>,\n\t *  nearDistance: <float>,\n\t *  farDistance: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>\n\t *\n\t * }\n\t */\n\n\tfunction MeshDistanceMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.referencePosition = new Vector3();\n\t\tthis.nearDistance = 1;\n\t\tthis.farDistance = 1000;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDistanceMaterial.prototype = Object.create( Material.prototype );\n\tMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\n\n\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\n\tMeshDistanceMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.referencePosition.copy( source.referencePosition );\n\t\tthis.nearDistance = source.nearDistance;\n\t\tthis.farDistance = source.farDistance;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n\t}\n\n\tObject.assign( Box3.prototype, {\n\n\t\tisBox3: true,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromArray: function ( array ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromBufferAttribute: function ( attribute ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\tvar x = attribute.getX( i );\n\t\t\t\tvar y = attribute.getY( i );\n\t\t\t\tvar z = attribute.getZ( i );\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\treturn this.expandByObject( object );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByObject: function () {\n\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\tvar scope, i, l;\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\tfunction traverse( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn function expandByObject( object ) {\n\n\t\t\t\tscope = this;\n\n\t\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\t\tobject.traverse( traverse );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t\t},\n\n\t\tintersectsSphere: ( function () {\n\n\t\t\tvar closestPoint = new Vector3();\n\n\t\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\tvar min, max;\n\n\t\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t\t} else {\n\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t\t}\n\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t\t},\n\n\t\tintersectsTriangle: ( function () {\n\n\t\t\t// triangle centered vertices\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\t// triangle edge vectors\n\t\t\tvar f0 = new Vector3();\n\t\t\tvar f1 = new Vector3();\n\t\t\tvar f2 = new Vector3();\n\n\t\t\tvar testAxis = new Vector3();\n\n\t\t\tvar center = new Vector3();\n\t\t\tvar extents = new Vector3();\n\n\t\t\tvar triangleNormal = new Vector3();\n\n\t\t\tfunction satForAxes( axes ) {\n\n\t\t\t\tvar i, j;\n\n\t\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t\t\t\ttestAxis.fromArray( axes, i );\n\t\t\t\t\t// project the aabb onto the seperating axis\n\t\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\n\t\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\t\t\t\tvar p0 = v0.dot( testAxis );\n\t\t\t\t\tvar p1 = v1.dot( testAxis );\n\t\t\t\t\tvar p2 = v2.dot( testAxis );\n\t\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\t\tif ( this.isEmpty() ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// compute box center and extents\n\t\t\t\tthis.getCenter( center );\n\t\t\t\textents.subVectors( this.max, center );\n\n\t\t\t\t// translate triangle to aabb origin\n\t\t\t\tv0.subVectors( triangle.a, center );\n\t\t\t\tv1.subVectors( triangle.b, center );\n\t\t\t\tv2.subVectors( triangle.c, center );\n\n\t\t\t\t// compute edge vectors for triangle\n\t\t\t\tf0.subVectors( v1, v0 );\n\t\t\t\tf1.subVectors( v2, v1 );\n\t\t\t\tf2.subVectors( v0, v2 );\n\n\t\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\t\t\tvar axes = [\n\t\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\n\t\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\n\t\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\n\t\t\t\t];\n\t\t\t\tif ( ! satForAxes( axes ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// test 3 face normals from the aabb\n\t\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\t\t\tif ( ! satForAxes( axes ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// finally testing the face normal of the triangle\n\t\t\t\t// use already existing triangle edge vectors here\n\t\t\t\ttriangleNormal.crossVectors( f0, f1 );\n\t\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\n\t\t\t\treturn satForAxes( axes );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetBoundingSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Sphere();\n\n\t\t\t\tthis.getCenter( result.center );\n\n\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar points = [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t];\n\n\t\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif ( this.isEmpty() ) return this;\n\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\t\tthis.setFromPoints( points );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Sphere( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n\t}\n\n\tObject.assign( Sphere.prototype, {\n\n\t\tset: function ( center, radius ) {\n\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function () {\n\n\t\t\tvar box = new Box3();\n\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\t\tvar center = this.center;\n\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t\t}\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( sphere ) {\n\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tempty: function () {\n\n\t\t\treturn ( this.radius <= 0 );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsSphere( this );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.copy( point );\n\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\t\tvar box = optionalTarget || new Box3();\n\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\n\t\t\treturn box;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.center.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( sphere ) {\n\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Plane( normal, constant ) {\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tObject.assign( Plane.prototype, {\n\n\t\tset: function ( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponents: function ( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCoplanarPoints: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t},\n\n\t\tdistanceToSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t},\n\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t\t},\n\n\t\tintersectLine: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tvar direction = line.delta( v1 );\n\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsLine: function ( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t},\n\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar m1 = new Matrix3();\n\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.constant -= offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tthis.planes = [\n\n\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t\t];\n\n\t}\n\n\tObject.assign( Frustum.prototype, {\n\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( frustum ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix: function ( m ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tintersectsObject: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsObject( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSprite: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsBox: function () {\n\n\t\t\tvar p1 = new Vector3(),\n\t\t\t\tp2 = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\tvar planes = this.planes;\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\n\n\t\tvar _frustum = new Frustum(),\n\t\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t\t_shadowMapSize = new Vector2(),\n\t\t\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\n\n\t\t\t_lookTarget = new Vector3(),\n\t\t\t_lightPositionWorld = new Vector3(),\n\n\t\t\t_MorphingFlag = 1,\n\t\t\t_SkinningFlag = 2,\n\n\t\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t\t_materialCache = {};\n\n\t\tvar shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\t\tvar cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tvar cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t\tvar cube2DViewPorts = [\n\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t];\n\n\t\t// init\n\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\t\tvar depthMaterial = new MeshDepthMaterial( {\n\n\t\t\t\tdepthPacking: RGBADepthPacking,\n\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning\n\n\t\t\t} );\n\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t\t//\n\n\t\t\tvar distanceMaterial = new MeshDistanceMaterial( {\n\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning\n\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tthis.enabled = false;\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.render = function ( lights, scene, camera ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\t\tif ( lights.length === 0 ) return;\n\n\t\t\t// TODO Clean up (needed in case of contextlost)\n\t\t\tvar _gl = _renderer.context;\n\t\t\tvar _state = _renderer.state;\n\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t\t_state.buffers.depth.setTest( true );\n\t\t\t_state.setScissorTest( false );\n\n\t\t\t// render depth map\n\n\t\t\tvar faceCount;\n\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\t\t\t\tvar isPointLight = light && light.isPointLight;\n\n\t\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\n\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.isSpotLightShadow ) {\n\n\t\t\t\t\tshadow.update( light );\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\tfaceCount = 6;\n\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\n\t\t\t\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaceCount = 1;\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t\t\t// compute shadow matrix\n\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t\trenderObject( scene, camera, shadowCamera, isPointLight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t};\n\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tvar result = null;\n\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t\t}\n\n\t\t\tif ( ! customMaterial ) {\n\n\t\t\t\tvar useMorphing = false;\n\n\t\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\t\tif ( geometry && geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t\t} else if ( geometry && geometry.isGeometry ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.isSkinnedMesh && material.skinning === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\n\n\t\t\t\t}\n\n\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\t\tvar variantIndex = 0;\n\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t\t} else {\n\n\t\t\t\tresult = customMaterial;\n\n\t\t\t}\n\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tresult.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif ( isPointLight && result.isMeshDistanceMaterial ) {\n\n\t\t\t\tresult.referencePosition.copy( lightPositionWorld );\n\t\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\t\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLAttributes( gl ) {\n\n\t\tvar buffers = {};\n\n\t\tfunction createBuffer( attribute, bufferType ) {\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\t\tvar buffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( bufferType, buffer );\n\t\t\tgl.bufferData( bufferType, array, usage );\n\n\t\t\tattribute.onUploadCallback();\n\n\t\t\tvar type = gl.FLOAT;\n\n\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\ttype = gl.FLOAT;\n\n\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\n\n\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\ttype = gl.SHORT;\n\n\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\ttype = gl.INT;\n\n\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\ttype = gl.BYTE;\n\n\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tbuffer: buffer,\n\t\t\t\ttype: type,\n\t\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar updateRange = attribute.updateRange;\n\n\t\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\t\tif ( attribute.dynamic === false ) {\n\n\t\t\t\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\n\n\t\t\t} else if ( updateRange.count === - 1 ) {\n\n\t\t\t\t// Not using update ranges\n\n\t\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t\t} else if ( updateRange.count === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction get( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\t\treturn buffers[ attribute.uuid ];\n\n\t\t}\n\n\t\tfunction remove( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\t\tvar data = buffers[ attribute.uuid ];\n\n\t\t\tif ( data ) {\n\n\t\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\t\tdelete buffers[ attribute.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction update( attribute, bufferType ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\t\tvar data = buffers[ attribute.uuid ];\n\n\t\t\tif ( data === undefined ) {\n\n\t\t\t\tbuffers[ attribute.uuid ] = createBuffer( attribute, bufferType );\n\n\t\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\t\tdata.version = attribute.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Euler( x, y, z, order ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || Euler.DefaultOrder;\n\n\t}\n\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n\tEuler.DefaultOrder = 'XYZ';\n\n\tObject.defineProperties( Euler.prototype, {\n\n\t\tx: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._x;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._x = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t},\n\n\t\ty: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._y;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._y = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t},\n\n\t\tz: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._z;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._z = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t},\n\n\t\torder: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this._order;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis._order = value;\n\t\t\t\tthis.onChangeCallback();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Euler.prototype, {\n\n\t\tisEuler: true,\n\n\t\tset: function ( x, y, z, order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t},\n\n\t\tcopy: function ( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\torder = order || this._order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromQuaternion: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromVector3: function ( v, order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t\t},\n\n\t\treorder: function () {\n\n\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\tvar q = new Quaternion();\n\n\t\t\treturn function reorder( newOrder ) {\n\n\t\t\t\tq.setFromEuler( this );\n\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t},\n\n\t\tfromArray: function ( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoVector3: function ( optionalResult ) {\n\n\t\t\tif ( optionalResult ) {\n\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t\t} else {\n\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t\t}\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Layers() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tObject.assign( Layers.prototype, {\n\n\t\tset: function ( channel ) {\n\n\t\t\tthis.mask = 1 << channel | 0;\n\n\t\t},\n\n\t\tenable: function ( channel ) {\n\n\t\t\tthis.mask |= 1 << channel | 0;\n\n\t\t},\n\n\t\ttoggle: function ( channel ) {\n\n\t\t\tthis.mask ^= 1 << channel | 0;\n\n\t\t},\n\n\t\tdisable: function ( channel ) {\n\n\t\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t\t},\n\n\t\ttest: function ( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\n\tvar object3DId = 0;\n\n\tfunction Object3D() {\n\n\t\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tvar position = new Vector3();\n\t\tvar rotation = new Euler();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.userData = {};\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\tObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: Object3D,\n\n\t\tisObject3D: true,\n\n\t\tonBeforeRender: function () {},\n\t\tonAfterRender: function () {},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tthis.quaternion.premultiply( q );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t},\n\n\t\tsetRotationFromEuler: function ( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t},\n\n\t\tsetRotationFromMatrix: function ( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t},\n\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t},\n\n\t\trotateOnAxis: function () {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateOnWorldAxis: function () {\n\n\t\t\t// rotate object on axis in world space\n\t\t\t// axis is assumed to be normalized\n\t\t\t// method assumes no rotated parent\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnWorldAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.premultiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateOnAxis: function () {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function translateX( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function translateY( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function translateZ( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlocalToWorld: function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t},\n\n\t\tworldToLocal: function () {\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function worldToLocal( vector ) {\n\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\t// This method does not support objects with rotated and/or translated parent(s)\n\n\t\t\tvar m1 = new Matrix4();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function lookAt( x, y, z ) {\n\n\t\t\t\tif ( x.isVector3 ) {\n\n\t\t\t\t\tvector.copy( x );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvector.set( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.isCamera ) {\n\n\t\t\t\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\t\t}\n\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tadd: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( ( object && object.isObject3D ) ) {\n\n\t\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\t\tthis.children.push( object );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tremove: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar index = this.children.indexOf( object );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tobject.parent = null;\n\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetObjectById: function ( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t},\n\n\t\tgetObjectByName: function ( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t},\n\n\t\tgetObjectByProperty: function ( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t},\n\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t\t},\n\n\t\tgetWorldQuaternion: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar scale = new Vector3();\n\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Quaternion();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldRotation: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Euler();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldScale: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\traycast: function () {},\n\n\t\ttraverse: function ( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseVisible: function ( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseAncestors: function ( callback ) {\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrix: function () {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// update children\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\t// meta is a string when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\t\tvar output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {},\n\t\t\t\t\tshapes: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tvar object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\n\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t//\n\n\t\t\tfunction serialize( library, element ) {\n\n\t\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\treturn element.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.geometry !== undefined ) {\n\n\t\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\t\tvar parameters = this.geometry.parameters;\n\n\t\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\t\tvar shapes = parameters.shapes;\n\n\t\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar shape = shapes[ i ];\n\n\t\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\t\tvar uuids = [];\n\n\t\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.material = uuids;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\t\t\t\tvar shapes = extractFromCache( meta.shapes );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function ( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t},\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tif ( recursive === undefined ) recursive = true;\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction Camera() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\t\tthis.projectionMatrix = new Matrix4();\n\n\t}\n\n\tCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Camera,\n\n\t\tisCamera: true,\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\n\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: OrthographicCamera,\n\n\t\tisOrthographicCamera: true,\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tif ( this.view === null ) {\n\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function () {\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tthis.view.enabled = false;\n\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\n\t\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = ( color && color.isColor ) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\t}\n\n\tObject.assign( Face3.prototype, {\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\n\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\n\tvar geometryId = 0; // Geometry uses even numbers as Id\n\n\tfunction Geometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: Geometry,\n\n\t\tisGeometry: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj = new Object3D();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfromBufferGeometry: function ( geometry ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\t\tscope.faces.push( face );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\tvar matrix = new Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tthis.applyMatrix( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = this.faces[ f ];\n\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\tvertices = new Array( this.vertices.length );\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new Vector3();\n\n\t\t\t}\n\n\t\t\tif ( areaWeighted ) {\n\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].normalize();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeFlatVertexNormals: function () {\n\n\t\t\tvar f, fl, face;\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeMorphNormals: function () {\n\n\t\t\tvar i, il, f, fl, face;\n\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\tvar tmpGeo = new Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\t// create on first access\n\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t\t// set vertices to morph target\n\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t\t// compute morph normals\n\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t// store morph normals\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore original normals\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar normalMatrix,\n\t\t\t\tvertexOffset = this.vertices.length,\n\t\t\t\tvertices1 = this.vertices,\n\t\t\t\tvertices2 = geometry.vertices,\n\t\t\t\tfaces1 = this.faces,\n\t\t\t\tfaces2 = geometry.faces,\n\t\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\t\tcolors1 = this.colors,\n\t\t\t\tcolors2 = geometry.colors;\n\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\t\tif ( matrix !== undefined ) {\n\n\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\t\tvertices1.push( vertexCopy );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\tfaces1.push( faceCopy );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\t\tif ( uv === undefined ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tuvs1.push( uvCopy );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmergeMesh: function ( mesh ) {\n\n\t\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t\t},\n\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\n\t\tmergeVertices: function () {\n\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = this.faces[ i ];\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Use unique set of vertices\n\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.vertices = [];\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsortFacesByMaterialIndex: function () {\n\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\n\t\t\t// tag faces\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tfaces[ i ]._id = i;\n\n\t\t\t}\n\n\t\t\t// sort faces\n\n\t\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t}\n\n\t\t\tfaces.sort( materialIndexSort );\n\n\t\t\t// sort uvs\n\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\t\tvar newUvs1, newUvs2;\n\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar id = faces[ i ]._id;\n\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t\t}\n\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Geometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\tvar faceType = 0;\n\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\n\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t\t}\n\n\t\t\tfunction getNormalIndex( normal ) {\n\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getColorIndex( color ) {\n\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getUvIndex( uv ) {\n\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tdata.data = {};\n\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t // Handle primitives\n\n\t\t\t var parameters = this.parameters;\n\n\t\t\t if ( parameters !== undefined ) {\n\n\t\t\t var values = [];\n\n\t\t\t for ( var key in parameters ) {\n\n\t\t\t values.push( parameters[ key ] );\n\n\t\t\t }\n\n\t\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t\t this.constructor.apply( geometry, values );\n\t\t\t return geometry;\n\n\t\t\t }\n\n\t\t\t return new this.constructor().copy( this );\n\t\t\t */\n\n\t\t\treturn new Geometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar i, il, j, jl, k, kl;\n\n\t\t\t// reset\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [[]];\n\t\t\tthis.morphTargets = [];\n\t\t\tthis.morphNormals = [];\n\t\t\tthis.skinWeights = [];\n\t\t\tthis.skinIndices = [];\n\t\t\tthis.lineDistances = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\n\t\t\t// name\n\n\t\t\tthis.name = source.name;\n\n\t\t\t// vertices\n\n\t\t\tvar vertices = source.vertices;\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tvar colors = source.colors;\n\n\t\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tvar faces = source.faces;\n\n\t\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// face vertex uvs\n\n\t\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphTargets = source.morphTargets;\n\n\t\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = {};\n\t\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t\t// vertices\n\n\t\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normals\n\n\t\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t\t// morph normals\n\n\t\t\tvar morphNormals = source.morphNormals;\n\n\t\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphNormal = {};\n\n\t\t\t\t// vertex normals\n\n\t\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\t\tvar destVertexNormal = {};\n\n\t\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// face normals\n\n\t\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t\t}\n\n\t\t\t// skin weights\n\n\t\t\tvar skinWeights = source.skinWeights;\n\n\t\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// skin indices\n\n\t\t\tvar skinIndices = source.skinIndices;\n\n\t\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// line distances\n\n\t\t\tvar lineDistances = source.lineDistances;\n\n\t\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t\t}\n\n\t\t\t// bounding box\n\n\t\t\tvar boundingBox = source.boundingBox;\n\n\t\t\tif ( boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t\t}\n\n\t\t\t// bounding sphere\n\n\t\t\tvar boundingSphere = source.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\t// update flags\n\n\t\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferAttribute( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.uuid = _Math.generateUUID();\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.onUploadCallback = function () {};\n\n\t\tthis.version = 0;\n\n\t}\n\n\tObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( BufferAttribute.prototype, {\n\n\t\tisBufferAttribute: true,\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyArray: function ( array ) {\n\n\t\t\tthis.array.set( array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyColorsArray: function ( colors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tvar color = colors[ i ];\n\n\t\t\t\tif ( color === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new Color();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyIndicesArray: function ( indices ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tvar index = indices[ i ];\n\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector2sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector3sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector4sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize ];\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonUpload: function ( callback ) {\n\n\t\t\tthis.onUploadCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction Int8BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n\tInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\n\n\tfunction Uint8BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n\tUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\n\n\tfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n\tUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\n\n\tfunction Int16BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n\tInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\n\n\tfunction Uint16BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n\tUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\n\n\tfunction Int32BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n\tInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\n\n\tfunction Uint32BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n\tUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\n\n\tfunction Float32BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n\tFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\n\n\tfunction Float64BufferAttribute( array, itemSize, normalized ) {\n\n\t\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\n\n\t}\n\n\tFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectGeometry() {\n\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( DirectGeometry.prototype, {\n\n\t\tcomputeGroups: function ( geometry ) {\n\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex = undefined;\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// materials\n\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( group !== undefined ) {\n\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\n\t\t\t}\n\n\t\t\tthis.groups = groups;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t\t// morphs\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\tvar morphTargetsPosition;\n\n\t\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t\t}\n\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\tvar morphTargetsNormal;\n\n\t\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// morphs\n\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t\t}\n\n\t\t\t\t// skins\n\n\t\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeGroups( geometry );\n\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction arrayMax( array ) {\n\n\t\tif ( array.length === 0 ) return - Infinity;\n\n\t\tvar max = array[ 0 ];\n\n\t\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\n\n\t\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t\t}\n\n\t\treturn max;\n\n\t}\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\n\tfunction BufferGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t}\n\n\tBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: BufferGeometry,\n\n\t\tisBufferGeometry: true,\n\n\t\tgetIndex: function () {\n\n\t\t\treturn this.index;\n\n\t\t},\n\n\t\tsetIndex: function ( index ) {\n\n\t\t\tif ( Array.isArray( index ) ) {\n\n\t\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tthis.index = index;\n\n\t\t\t}\n\n\t\t},\n\n\t\taddAttribute: function ( name, attribute ) {\n\n\t\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( name === 'index' ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.attributes[ name ] = attribute;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetAttribute: function ( name ) {\n\n\t\t\treturn this.attributes[ name ];\n\n\t\t},\n\n\t\tremoveAttribute: function ( name ) {\n\n\t\t\tdelete this.attributes[ name ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddGroup: function ( start, count, materialIndex ) {\n\n\t\t\tthis.groups.push( {\n\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t} );\n\n\t\t},\n\n\t\tclearGroups: function () {\n\n\t\t\tthis.groups = [];\n\n\t\t},\n\n\t\tsetDrawRange: function ( start, count ) {\n\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tmatrix.applyToBufferAttribute( position );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tvar normal = this.attributes.normal;\n\n\t\t\tif ( normal !== undefined ) {\n\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t\tnormalMatrix.applyToBufferAttribute( normal );\n\t\t\t\tnormal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj = new Object3D();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isMesh ) {\n\n\t\t\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tvar position = [];\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateFromObject: function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\t\tdirect = undefined;\n\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( direct === undefined ) {\n\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\tgeometry = direct;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t\t},\n\n\t\tfromDirectGeometry: function ( geometry ) {\n\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\t\tvar TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\t// morphs\n\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\n\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// skinning\n\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar box = new Box3();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tvar position = this.attributes.position;\n\n\t\t\t\tif ( position ) {\n\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tbox.setFromBufferAttribute( position );\n\t\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t\t\tvector.x = position.getX( i );\n\t\t\t\t\t\tvector.y = position.getY( i );\n\t\t\t\t\t\tvector.z = position.getZ( i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\t// backwards compatibility\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( attributes.position ) {\n\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\t// indexed elements\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmerge: function ( geometry, offset ) {\n\n\t\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalizeNormals: function () {\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function normalizeNormals() {\n\n\t\t\t\tvar normals = this.attributes.normal;\n\n\t\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t\t\tvector.x = normals.getX( i );\n\t\t\t\t\tvector.y = normals.getY( i );\n\t\t\t\t\tvector.z = normals.getZ( i );\n\n\t\t\t\t\tvector.normalize();\n\n\t\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoNonIndexed: function () {\n\n\t\t\tif ( this.index === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tdata.data = { attributes: {} };\n\n\t\t\tvar index = this.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t // Handle primitives\n\n\t\t\t var parameters = this.parameters;\n\n\t\t\t if ( parameters !== undefined ) {\n\n\t\t\t var values = [];\n\n\t\t\t for ( var key in parameters ) {\n\n\t\t\t values.push( parameters[ key ] );\n\n\t\t\t }\n\n\t\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t\t this.constructor.apply( geometry, values );\n\t\t\t return geometry;\n\n\t\t\t }\n\n\t\t\t return new this.constructor().copy( this );\n\t\t\t */\n\n\t\t\treturn new BufferGeometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar name, i, l;\n\n\t\t\t// reset\n\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\n\t\t\t// name\n\n\t\t\tthis.name = source.name;\n\n\t\t\t// index\n\n\t\t\tvar index = source.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.setIndex( index.clone() );\n\n\t\t\t}\n\n\t\t\t// attributes\n\n\t\t\tvar attributes = source.attributes;\n\n\t\t\tfor ( name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t\t}\n\n\t\t\t// morph attributes\n\n\t\t\tvar morphAttributes = source.morphAttributes;\n\n\t\t\tfor ( name in morphAttributes ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray.push( morphAttribute[ i ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tvar groups = source.groups;\n\n\t\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t\t// bounding box\n\n\t\t\tvar boundingBox = source.boundingBox;\n\n\t\t\tif ( boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t\t}\n\n\t\t\t// bounding sphere\n\n\t\t\tvar boundingSphere = source.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\t// draw range\n\n\t\t\tthis.drawRange.start = source.drawRange.start;\n\t\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// BoxGeometry\n\n\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\tBoxGeometry.prototype.constructor = BoxGeometry;\n\n\t// BoxBufferGeometry\n\n\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\twidth = width || 1;\n\t\theight = height || 1;\n\t\tdepth = depth || 1;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar numberOfVertices = 0;\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth = width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar ix, iy;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// PlaneGeometry\n\n\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n\t// PlaneBufferGeometry\n\n\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\twidth = width || 1;\n\t\theight = height || 1;\n\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\n\t\tvar ix, iy;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segment_height - height_half;\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\n\tfunction MeshBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction ShaderMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype = Object.create( Material.prototype );\n\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tShaderMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\n\t\tthis.defines = source.defines;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.skinning = source.skinning;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = source.extensions;\n\n\t\treturn this;\n\n\t};\n\n\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Ray( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n\t}\n\n\tObject.assign( Ray.prototype, {\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t\t},\n\n\t\tlookAt: function ( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trecast: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function recast( t ) {\n\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn result.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t},\n\n\t\tdistanceSqToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t\t// point behind the ray\n\n\t\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t\t}\n\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\t\treturn v1.distanceToSquared( point );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceSqToSegment: function () {\n\n\t\t\tvar segCenter = new Vector3();\n\t\t\tvar segDir = new Vector3();\n\t\t\tvar diff = new Vector3();\n\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\t\tif ( det > 0 ) {\n\n\t\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\n\t\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t\t}\n\n\t\t\t\treturn sqrDist;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t\t},\n\n\t\tdistanceToPlane: function ( plane ) {\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t : null;\n\n\t\t},\n\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\t\tvar t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, optionalTarget );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tintersectBox: function ( box, optionalTarget ) {\n\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tvar origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t\t},\n\n\t\tintersectsBox: ( function () {\n\n\t\t\tvar v = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectTriangle: function () {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new Vector3();\n\t\t\tvar edge1 = new Vector3();\n\t\t\tvar edge2 = new Vector3();\n\t\t\tvar normal = new Vector3();\n\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\n\t\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\n\t\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix4: function ( matrix4 ) {\n\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.transformDirection( matrix4 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Line3( start, end ) {\n\n\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n\t}\n\n\tObject.assign( Line3.prototype, {\n\n\t\tset: function ( start, end ) {\n\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( line ) {\n\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tdelta: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\n\t\t},\n\n\t\tdistanceSq: function () {\n\n\t\t\treturn this.start.distanceToSquared( this.end );\n\n\t\t},\n\n\t\tdistance: function () {\n\n\t\t\treturn this.start.distanceTo( this.end );\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tclosestPointToPointParameter: function () {\n\n\t\t\tvar startP = new Vector3();\n\t\t\tvar startEnd = new Vector3();\n\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\t\tif ( clampToLine ) {\n\n\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( line ) {\n\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Triangle( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tObject.assign( Triangle, {\n\n\t\tnormal: function () {\n\n\t\t\tvar v0 = new Vector3();\n\n\t\t\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tresult.subVectors( c, b );\n\t\t\t\tv0.subVectors( a, b );\n\t\t\t\tresult.cross( v0 );\n\n\t\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn result.set( 0, 0, 0 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\t// static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\t\tbarycoordFromPoint: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\t\t\tv0.subVectors( c, a );\n\t\t\t\tv1.subVectors( b, a );\n\t\t\t\tv2.subVectors( point, a );\n\n\t\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\t// collinear or singular triangle\n\t\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t\t\t}\n\n\t\t\t\tvar invDenom = 1 / denom;\n\t\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t\t// barycentric coordinates must always sum to 1\n\t\t\t\treturn result.set( 1 - u - v, v, u );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcontainsPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t\t\t};\n\n\t\t}()\n\n\t} );\n\n\tObject.assign( Triangle.prototype, {\n\n\t\tset: function ( a, b, c ) {\n\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( triangle ) {\n\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tarea: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function area() {\n\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmidpoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t\t},\n\n\t\tnormal: function ( optionalTarget ) {\n\n\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tplane: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Plane();\n\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t\t},\n\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsTriangle( this );\n\n\t\t},\n\n\t\tclosestPointToPoint: function () {\n\n\t\t\tvar plane = new Plane();\n\t\t\tvar edgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\tvar projectedPoint = new Vector3();\n\t\t\tvar closestPoint = new Vector3();\n\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\n\t\t\t\t// project the point onto the plane of the triangle\n\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t\t// check if the projection lies within the triangle\n\n\t\t\t\tif ( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t\t// if so, this is the closest point\n\n\t\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\t\tfor ( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\t\tif ( distance < minDistance ) {\n\n\t\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( triangle ) {\n\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\n\tfunction Mesh( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\tthis.drawMode = TrianglesDrawMode;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Mesh,\n\n\t\tisMesh: true,\n\n\t\tsetDrawMode: function ( value ) {\n\n\t\t\tthis.drawMode = value;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.drawMode = source.drawMode;\n\n\t\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateMorphTargets: function () {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar m, ml, name;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\t\t\tvar keys = Object.keys( morphAttributes );\n\n\t\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar morphTargets = geometry.morphTargets;\n\n\t\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tname = morphTargets[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\tvar vA = new Vector3();\n\t\t\tvar vB = new Vector3();\n\t\t\tvar vC = new Vector3();\n\n\t\t\tvar tempA = new Vector3();\n\t\t\tvar tempB = new Vector3();\n\t\t\tvar tempC = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tvar barycoord = new Vector3();\n\n\t\t\tvar intersectionPoint = new Vector3();\n\t\t\tvar intersectionPointWorld = new Vector3();\n\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\t\treturn uv1.clone();\n\n\t\t\t}\n\n\t\t\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\t\tvar intersect;\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersect === null ) return null;\n\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\n\n\t\t\t\tvA.fromBufferAttribute( position, a );\n\t\t\t\tvB.fromBufferAttribute( position, b );\n\t\t\t\tvC.fromBufferAttribute( position, c );\n\n\t\t\t\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uv ) {\n\n\t\t\t\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\t\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\t\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t\t}\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\tif ( material === undefined ) return;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\t// Check boundingBox before continuing\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t\t}\n\n\t\t\t\tvar intersection;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\t\tvar uv = geometry.attributes.uv;\n\t\t\t\t\tvar i, l;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\t// indexed buffer geometry\n\n\t\t\t\t\t\tfor ( i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\t\t\tfor ( i = 0, l = position.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\tb = i + 1;\n\t\t\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isMultiMaterial = Array.isArray( material );\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar uvs;\n\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\n\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tif ( uvs && uvs[ f ] ) {\n\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {\n\n\t\tvar clearColor = new Color( 0x000000 );\n\t\tvar clearAlpha = 0;\n\n\t\tvar planeCamera, planeMesh;\n\t\tvar boxMesh;\n\n\t\tfunction render( renderList, scene, camera, forceClear ) {\n\n\t\t\tvar background = scene.background;\n\n\t\t\tif ( background === null ) {\n\n\t\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t\t} else if ( background && background.isColor ) {\n\n\t\t\t\tsetClear( background, 1 );\n\t\t\t\tforceClear = true;\n\n\t\t\t}\n\n\t\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t\t}\n\n\t\t\tif ( background && background.isCubeTexture ) {\n\n\t\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\t\tnew BoxBufferGeometry( 1, 1, 1 ),\n\t\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\t\tuniforms: ShaderLib.cube.uniforms,\n\t\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\t\tdepthTest: true,\n\t\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\t\tfog: false\n\t\t\t\t\t\t} )\n\t\t\t\t\t);\n\n\t\t\t\t\tboxMesh.geometry.removeAttribute( 'normal' );\n\t\t\t\t\tboxMesh.geometry.removeAttribute( 'uv' );\n\n\t\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tgeometries.update( boxMesh.geometry );\n\n\t\t\t\t}\n\n\t\t\t\tboxMesh.material.uniforms.tCube.value = background;\n\n\t\t\t\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\n\n\t\t\t} else if ( background && background.isTexture ) {\n\n\t\t\t\tif ( planeCamera === undefined ) {\n\n\t\t\t\t\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n\t\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t\t\t\t);\n\n\t\t\t\t\tgeometries.update( planeMesh.geometry );\n\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.map = background;\n\n\t\t\t\t// TODO Push this to renderList\n\n\t\t\t\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setClear( color, alpha ) {\n\n\t\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tgetClearColor: function () {\n\n\t\t\t\treturn clearColor;\n\n\t\t\t},\n\t\t\tsetClearColor: function ( color, alpha ) {\n\n\t\t\t\tclearColor.set( color );\n\t\t\t\tclearAlpha = alpha !== undefined ? alpha : 1;\n\t\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t\t},\n\t\t\tgetClearAlpha: function () {\n\n\t\t\t\treturn clearAlpha;\n\n\t\t\t},\n\t\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t\t},\n\t\t\trender: render\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction painterSortStable( a, b ) {\n\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.program && b.program && a.program !== b.program ) {\n\n\t\t\treturn a.program.id - b.program.id;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable( a, b ) {\n\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction WebGLRenderList() {\n\n\t\tvar renderItems = [];\n\t\tvar renderItemsIndex = 0;\n\n\t\tvar opaque = [];\n\t\tvar transparent = [];\n\n\t\tfunction init() {\n\n\t\t\trenderItemsIndex = 0;\n\n\t\t\topaque.length = 0;\n\t\t\ttransparent.length = 0;\n\n\t\t}\n\n\t\tfunction push( object, geometry, material, z, group ) {\n\n\t\t\tvar renderItem = renderItems[ renderItemsIndex ];\n\n\t\t\tif ( renderItem === undefined ) {\n\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tprogram: material.program,\n\t\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\t\tz: z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\n\t\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t\t} else {\n\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.program = material.program;\n\t\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\t\trenderItem.z = z;\n\t\t\t\trenderItem.group = group;\n\n\t\t\t}\n\n\t\t\t( material.transparent === true ? transparent : opaque ).push( renderItem );\n\n\t\t\trenderItemsIndex ++;\n\n\t\t}\n\n\t\tfunction sort() {\n\n\t\t\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\n\t\t\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\treturn {\n\t\t\topaque: opaque,\n\t\t\ttransparent: transparent,\n\n\t\t\tinit: init,\n\t\t\tpush: push,\n\n\t\t\tsort: sort\n\t\t};\n\n\t}\n\n\tfunction WebGLRenderLists() {\n\n\t\tvar lists = {};\n\n\t\tfunction get( scene, camera ) {\n\n\t\t\tvar hash = scene.id + ',' + camera.id;\n\t\t\tvar list = lists[ hash ];\n\n\t\t\tif ( list === undefined ) {\n\n\t\t\t\t// console.log( 'THREE.WebGLRenderLists:', hash );\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tlists[ hash ] = list;\n\n\t\t\t}\n\n\t\t\treturn list;\n\n\t\t}\n\n\t\tfunction dispose() {\n\n\t\t\tlists = {};\n\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n\t}\n\n\tfunction WebGLMorphtargets( gl ) {\n\n\t\tvar influencesList = {};\n\t\tvar morphInfluences = new Float32Array( 8 );\n\n\t\tfunction update( object, geometry, material, program ) {\n\n\t\t\tvar objectInfluences = object.morphTargetInfluences;\n\n\t\t\tvar length = objectInfluences.length;\n\n\t\t\tvar influences = influencesList[ geometry.id ];\n\n\t\t\tif ( influences === undefined ) {\n\n\t\t\t\t// initialise list\n\n\t\t\t\tinfluences = [];\n\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t\t}\n\n\t\t\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\t\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\t\t// Remove current morphAttributes\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar influence = influences[ i ];\n\n\t\t\t\tif ( influence[ 1 ] !== 0 ) {\n\n\t\t\t\t\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Collect influences\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar influence = influences[ i ];\n\n\t\t\t\tinfluence[ 0 ] = i;\n\t\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tinfluences.sort( absNumericalSort );\n\n\t\t\t// Add morphAttributes\n\n\t\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\t\tvar influence = influences[ i ];\n\n\t\t\t\tif ( influence ) {\n\n\t\t\t\t\tvar index = influence[ 0 ];\n\t\t\t\t\tvar value = influence[ 1 ];\n\n\t\t\t\t\tif ( value ) {\n\n\t\t\t\t\t\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\t\t\t\t\t\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tvar type, bytesPerElement;\n\n\t\tfunction setIndex( value ) {\n\n\t\t\ttype = value.type;\n\t\t\tbytesPerElement = value.bytesPerElement;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\t\telse if ( mode === gl.POINTS ) infoRender.points += count;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\t\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.setMode = setMode;\n\t\tthis.setIndex = setIndex;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\t\t\telse if ( mode === gl.POINTS ) infoRender.points += count;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar position = geometry.attributes.position;\n\n\t\t\tif ( position.isInterleavedBufferAttribute ) {\n\n\t\t\t\tcount = position.data.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );\n\n\t\t\t}\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\t\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.setMode = setMode;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLGeometries( gl, attributes, infoMemory ) {\n\n\t\tvar geometries = {};\n\t\tvar wireframeAttributes = {};\n\n\t\tfunction onGeometryDispose( event ) {\n\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\t\tattributes.remove( buffergeometry.index );\n\n\t\t\t}\n\n\t\t\tfor ( var name in buffergeometry.attributes ) {\n\n\t\t\t\tattributes.remove( buffergeometry.attributes[ name ] );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tdelete geometries[ geometry.id ];\n\n\t\t\t// TODO Remove duplicate code\n\n\t\t\tvar attribute = wireframeAttributes[ geometry.id ];\n\n\t\t\tif ( attribute ) {\n\n\t\t\t\tattributes.remove( attribute );\n\t\t\t\tdelete wireframeAttributes[ geometry.id ];\n\n\t\t\t}\n\n\t\t\tattribute = wireframeAttributes[ buffergeometry.id ];\n\n\t\t\tif ( attribute ) {\n\n\t\t\t\tattributes.remove( attribute );\n\t\t\t\tdelete wireframeAttributes[ buffergeometry.id ];\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tinfoMemory.geometries --;\n\n\t\t}\n\n\t\tfunction get( object, geometry ) {\n\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry ) return buffergeometry;\n\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tbuffergeometry = geometry;\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t\t}\n\n\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t\t}\n\n\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\t\tinfoMemory.geometries ++;\n\n\t\t\treturn buffergeometry;\n\n\t\t}\n\n\t\tfunction update( geometry ) {\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\tfor ( var name in geometryAttributes ) {\n\n\t\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getWireframeAttribute( geometry ) {\n\n\t\t\tvar attribute = wireframeAttributes[ geometry.id ];\n\n\t\t\tif ( attribute ) return attribute;\n\n\t\t\tvar indices = [];\n\n\t\t\tvar geometryIndex = geometry.index;\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\t// console.time( 'wireframe' );\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\tvar array = geometryIndex.array;\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar array = geometryAttributes.position.array;\n\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'wireframe' );\n\n\t\t\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\n\t\t\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\twireframeAttributes[ geometry.id ] = attribute;\n\n\t\t\treturn attribute;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: get,\n\t\t\tupdate: update,\n\n\t\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLObjects( geometries, infoRender ) {\n\n\t\tvar updateList = {};\n\n\t\tfunction update( object ) {\n\n\t\t\tvar frame = infoRender.frame;\n\n\t\t\tvar geometry = object.geometry;\n\t\t\tvar buffergeometry = geometries.get( object, geometry );\n\n\t\t\t// Update once per frame\n\n\t\t\tif ( updateList[ buffergeometry.id ] !== frame ) {\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tbuffergeometry.updateFromObject( object );\n\n\t\t\t\t}\n\n\t\t\t\tgeometries.update( buffergeometry );\n\n\t\t\t\tupdateList[ buffergeometry.id ] = frame;\n\n\t\t\t}\n\n\t\t\treturn buffergeometry;\n\n\t\t}\n\n\t\tfunction dispose() {\n\n\t\t\tupdateList = {};\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\tfunction WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn [ 'Linear', '( value )' ];\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn [ 'sRGB', '( value )' ];\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn [ 'RGBE', '( value )' ];\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = 'Reinhard';\n\t\t\t\tbreak;\n\n\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = 'Uncharted2';\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction replaceClippingPlaneNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /^[ \\t]*#include +<([\\w\\d.]+)>/gm;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction WebGLProgram( renderer, extensions, code, material, shader, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = shader.vertexShader;\n\t\tvar fragmentShader = shader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( material.extensions, parameters, extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material.isRawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\t\tprefixVertex += '\\n';\n\n\t\t\t}\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\t\tprefixFragment += '\\n';\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + shader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + shader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\t\tvertexShader = unrollLoops( vertexShader );\n\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program ).trim();\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function () {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function () {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function () {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLPrograms( renderer, extensions, capabilities ) {\n\n\t\tvar programs = [];\n\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshToonMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points',\n\t\t\tShadowMaterial: 'shadow'\n\t\t};\n\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\", \"gradientMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"\n\t\t];\n\n\n\t\tfunction allocateBones( object ) {\n\n\t\t\tvar skeleton = object.skeleton;\n\t\t\tvar bones = skeleton.bones;\n\n\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\treturn 1024;\n\n\t\t\t} else {\n\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\t\tvar maxBones = Math.min( nVertexMatrices, bones.length );\n\n\t\t\t\tif ( maxBones < bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\t\tvar encoding;\n\n\t\t\tif ( ! map ) {\n\n\t\t\t\tencoding = LinearEncoding;\n\n\t\t\t} else if ( map.isTexture ) {\n\n\t\t\t\tencoding = map.encoding;\n\n\t\t\t} else if ( map.isWebGLRenderTarget ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\n\t\t\t}\n\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\t\tencoding = GammaEncoding;\n\n\t\t\t}\n\n\t\t\treturn encoding;\n\n\t\t}\n\n\t\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\n\t\t\tvar precision = capabilities.precision;\n\n\t\t\tif ( material.precision !== null ) {\n\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tvar parameters = {\n\n\t\t\t\tshaderID: shaderID,\n\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\t\tgradientMap: !! material.gradientMap,\n\n\t\t\t\tcombine: material.combine,\n\n\t\t\t\tvertexColors: material.vertexColors,\n\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: ( fog && fog.isFogExp2 ),\n\n\t\t\t\tflatShading: material.flatShading,\n\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\t\tskinning: material.skinning && maxBones > 0,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures,\n\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\t\tdithering: material.dithering,\n\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t\t};\n\n\t\t\treturn parameters;\n\n\t\t};\n\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\t\tvar array = [];\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tarray.push( parameters.shaderID );\n\n\t\t\t} else {\n\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\n\t\t\t}\n\n\t\t\tif ( material.defines !== undefined ) {\n\n\t\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\tarray.push( material.onBeforeCompile.toString() );\n\n\t\t\tarray.push( renderer.gammaOutput );\n\n\t\t\treturn array.join();\n\n\t\t};\n\n\t\tthis.acquireProgram = function ( material, shader, parameters, code ) {\n\n\t\t\tvar program;\n\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\t\tvar programInfo = programs[ p ];\n\n\t\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters );\n\t\t\t\tprograms.push( program );\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t};\n\n\t\tthis.releaseProgram = function ( program ) {\n\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory, infoRender ) {\n\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\tvar _videoTextures = {};\n\t\tvar _canvas;\n\n\t\t//\n\n\t\tfunction clampToMaxSize( image, maxSize ) {\n\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t\t}\n\n\t\tfunction makePowerOfTwo( image ) {\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t\t\t\t_canvas.width = _Math.floorPowerOfTwo( image.width );\n\t\t\t\t_canvas.height = _Math.floorPowerOfTwo( image.height );\n\n\t\t\t\tvar context = _canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, _canvas.width, _canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height, image );\n\n\t\t\t\treturn _canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n\t\t}\n\n\t\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\n\n\t\t\treturn texture.generateMipmaps && isPowerOfTwo &&\n\t\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t\t}\n\n\t\t// Fallback filters for non-power-of-2 textures\n\n\t\tfunction filterFallback( f ) {\n\n\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\t\treturn _gl.NEAREST;\n\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onTextureDispose( event ) {\n\n\t\t\tvar texture = event.target;\n\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\t\tdeallocateTexture( texture );\n\n\t\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t\tdelete _videoTextures[ texture.id ];\n\n\t\t\t}\n\n\t\t\tinfoMemory.textures --;\n\n\t\t}\n\n\t\tfunction onRenderTargetDispose( event ) {\n\n\t\t\tvar renderTarget = event.target;\n\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t\tinfoMemory.textures --;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction deallocateTexture( texture ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t\t} else {\n\n\t\t\t\t// 2D texture\n\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\t// remove all webgl properties\n\t\t\tproperties.remove( texture );\n\n\t\t}\n\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\tif ( ! renderTarget ) return;\n\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t\t}\n\n\t\t\tproperties.remove( renderTarget.texture );\n\t\t\tproperties.remove( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\n\n\t\tfunction setTexture2D( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tvar image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureCube( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image.length === 6 ) {\n\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t\tinfoMemory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\t\tvar isCompressed = ( texture && texture.isCompressedTexture );\n\t\t\t\t\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\t\t\tvar cubeImage = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\n\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension ) {\n\n\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\tinfoMemory.textures ++;\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\t\timage = makePowerOfTwo( image );\n\n\t\t\t}\n\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tif ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\n\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n\t\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n\t\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\t// Render targets\n\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else {\n\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t}\n\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t\t}\n\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\tinfoMemory.textures ++;\n\n\t\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\t// Setup framebuffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\t// Setup color buffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t// Setup depth and stencil buffers\n\n\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\t\tvar texture = renderTarget.texture;\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\n\n\t\t\t\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateVideoTexture( texture ) {\n\n\t\t\tvar id = texture.id;\n\t\t\tvar frame = infoRender.frame;\n\n\t\t\t// Check the last frame we updated the VideoTexture\n\n\t\t\tif ( _videoTextures[ id ] !== frame ) {\n\n\t\t\t\t_videoTextures[ id ] = frame;\n\t\t\t\ttexture.update();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n\t}\n\n\t/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\n\tfunction WebGLProperties() {\n\n\t\tvar properties = {};\n\n\t\tfunction get( object ) {\n\n\t\t\tvar uuid = object.uuid;\n\t\t\tvar map = properties[ uuid ];\n\n\t\t\tif ( map === undefined ) {\n\n\t\t\t\tmap = {};\n\t\t\t\tproperties[ uuid ] = map;\n\n\t\t\t}\n\n\t\t\treturn map;\n\n\t\t}\n\n\t\tfunction remove( object ) {\n\n\t\t\tdelete properties[ object.uuid ];\n\n\t\t}\n\n\t\tfunction update( object, key, value ) {\n\n\t\t\tvar uuid = object.uuid;\n\t\t\tvar map = properties[ uuid ];\n\n\t\t\tmap[ key ] = value;\n\n\t\t}\n\n\t\tfunction dispose() {\n\n\t\t\tproperties = {};\n\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLState( gl, extensions, utils ) {\n\n\t\tfunction ColorBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar color = new Vector4();\n\t\t\tvar currentColorMask = null;\n\t\t\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\t\treturn {\n\n\t\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentDepthMask = null;\n\t\t\tvar currentDepthFunc = null;\n\t\t\tvar currentDepthClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentStencilMask = null;\n\t\t\tvar currentStencilFunc = null;\n\t\t\tvar currentStencilRef = null;\n\t\t\tvar currentStencilFuncMask = null;\n\t\t\tvar currentStencilFail = null;\n\t\t\tvar currentStencilZFail = null;\n\t\t\tvar currentStencilZPass = null;\n\t\t\tvar currentStencilClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tvar colorBuffer = new ColorBuffer();\n\t\tvar depthBuffer = new DepthBuffer();\n\t\tvar stencilBuffer = new StencilBuffer();\n\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\t\tvar capabilities = {};\n\n\t\tvar compressedTextureFormats = null;\n\n\t\tvar currentProgram = null;\n\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\n\t\tvar currentLineWidth = null;\n\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\n\n\t\tvar lineWidthAvailable = false;\n\t\tvar version = 0;\n\t\tvar glVersion = gl.getParameter( gl.VERSION );\n\n\t\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\t   version = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\t   lineWidthAvailable = ( version >= 1.0 );\n\n\t\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\t   version = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\t   lineWidthAvailable = ( version >= 2.0 );\n\n\t\t}\n\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\n\t\tvar currentScissor = new Vector4();\n\t\tvar currentViewport = new Vector4();\n\n\t\tfunction createTexture( type, target, count ) {\n\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t\t// init\n\n\t\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\t\tdepthBuffer.setClear( 1 );\n\t\tstencilBuffer.setClear( 0 );\n\n\t\tenable( gl.DEPTH_TEST );\n\t\tdepthBuffer.setFunc( LessEqualDepth );\n\n\t\tsetFlipSided( false );\n\t\tsetCullFace( CullFaceBack );\n\t\tenable( gl.CULL_FACE );\n\n\t\tenable( gl.BLEND );\n\t\tsetBlending( NormalBlending );\n\n\t\t//\n\n\t\tfunction initAttributes() {\n\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tnewAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttribute( attribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getCompressedTextureFormats() {\n\n\t\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\t\tcompressedTextureFormats = [];\n\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {\n\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn compressedTextureFormats;\n\n\t\t}\n\n\t\tfunction useProgram( program ) {\n\n\t\t\tif ( currentProgram !== program ) {\n\n\t\t\t\tgl.useProgram( program );\n\n\t\t\t\tcurrentProgram = program;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\t\tif ( blending !== NoBlending ) {\n\n\t\t\t\tenable( gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.BLEND );\n\n\t\t\t}\n\n\t\t\tif ( blending !== CustomBlending ) {\n\n\t\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\n\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\n\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\n\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t} else {\n\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\n\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t\t}\n\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\t\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\n\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\t\tmaterial.side === DoubleSide\n\t\t\t\t? disable( gl.CULL_FACE )\n\t\t\t\t: enable( gl.CULL_FACE );\n\n\t\t\tvar flipSided = ( material.side === BackSide );\n\t\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\t\tsetFlipSided( flipSided );\n\n\t\t\tmaterial.transparent === true\n\t\t\t\t? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t: setBlending( NoBlending );\n\n\t\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\t\tdepthBuffer.setTest( material.depthTest );\n\t\t\tdepthBuffer.setMask( material.depthWrite );\n\t\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setFlipSided( flipSided ) {\n\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\t\tif ( flipSided ) {\n\n\t\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setCullFace( cullFace ) {\n\n\t\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\t\tenable( gl.CULL_FACE );\n\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\n\t\t}\n\n\t\tfunction setLineWidth( width ) {\n\n\t\t\tif ( width !== currentLineWidth ) {\n\n\t\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\t\tcurrentLineWidth = width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\t\tif ( polygonOffset ) {\n\n\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setScissorTest( scissorTest ) {\n\n\t\t\tif ( scissorTest ) {\n\n\t\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// texture\n\n\t\tfunction activeTexture( webglSlot ) {\n\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\tactiveTexture();\n\n\t\t\t}\n\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\t\tif ( boundTexture === undefined ) {\n\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t\t}\n\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction texImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction scissor( scissor ) {\n\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction viewport( viewport ) {\n\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction reset() {\n\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcapabilities = {};\n\n\t\t\tcompressedTextureFormats = null;\n\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\n\t\t\tcurrentProgram = null;\n\n\t\t\tcurrentBlending = null;\n\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\t\tuseProgram: useProgram,\n\n\t\t\tsetBlending: setBlending,\n\t\t\tsetMaterial: setMaterial,\n\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\t\tsetScissorTest: setScissorTest,\n\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\n\t\t\treset: reset\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\t\tvar maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t\t} else {\n\n\t\t\t\tmaxAnisotropy = 0;\n\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\n\t\t}\n\n\t\tfunction getMaxPrecision( precision ) {\n\n\t\t\tif ( precision === 'highp' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'highp';\n\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\n\t\t\t}\n\n\t\t\tif ( precision === 'mediump' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'mediump';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\n\t\t}\n\n\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tvar maxPrecision = getMaxPrecision( precision );\n\n\t\tif ( maxPrecision !== precision ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\tprecision = maxPrecision;\n\n\t\t}\n\n\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\t\treturn {\n\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\n\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: PerspectiveCamera,\n\n\t\tisPerspectiveCamera: true,\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\n\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t\t},\n\n\t\tgetEffectiveFOV: function () {\n\n\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t\t},\n\n\t\tgetFilmWidth: function () {\n\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t\t},\n\n\t\tgetFilmHeight: function () {\n\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t\t},\n\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tif ( this.view === null ) {\n\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function () {\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tthis.view.enabled = false;\n\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\n\t\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\n\t\t\t}\n\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\n\t\t\tdata.object.aspect = this.aspect;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ArrayCamera( array ) {\n\n\t\tPerspectiveCamera.call( this );\n\n\t\tthis.cameras = array || [];\n\n\t}\n\n\tArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\n\n\t\tconstructor: ArrayCamera,\n\n\t\tisArrayCamera: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebVRManager( renderer ) {\n\n\t\tvar scope = this;\n\n\t\tvar device = null;\n\t\tvar frameData = null;\n\n\t\tvar poseTarget = null;\n\n\t\tvar standingMatrix = new Matrix4();\n\t\tvar standingMatrixInverse = new Matrix4();\n\n\t\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\n\n\t\t\tframeData = new window.VRFrameData();\n\n\t\t}\n\n\t\tvar matrixWorldInverse = new Matrix4();\n\n\t\tvar cameraL = new PerspectiveCamera();\n\t\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\n\t\tcameraL.layers.enable( 1 );\n\n\t\tvar cameraR = new PerspectiveCamera();\n\t\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\n\t\tcameraR.layers.enable( 2 );\n\n\t\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\n\t\tcameraVR.layers.enable( 1 );\n\t\tcameraVR.layers.enable( 2 );\n\n\t\t//\n\n\t\tvar currentSize, currentPixelRatio;\n\n\t\tfunction onVRDisplayPresentChange() {\n\n\t\t\tif ( device !== null && device.isPresenting ) {\n\n\t\t\t\tvar eyeParameters = device.getEyeParameters( 'left' );\n\t\t\t\tvar renderWidth = eyeParameters.renderWidth;\n\t\t\t\tvar renderHeight = eyeParameters.renderHeight;\n\n\t\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\t\tcurrentSize = renderer.getSize();\n\n\t\t\t\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\n\n\t\t\t} else if ( scope.enabled ) {\n\n\t\t\t\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( typeof window !== 'undefined' ) {\n\n\t\t\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.enabled = false;\n\t\tthis.userHeight = 1.6;\n\n\t\tthis.getDevice = function () {\n\n\t\t\treturn device;\n\n\t\t};\n\n\t\tthis.setDevice = function ( value ) {\n\n\t\t\tif ( value !== undefined ) device = value;\n\n\t\t};\n\n\t\tthis.setPoseTarget = function ( object ) {\n\n\t\t\tif ( object !== undefined ) poseTarget = object;\n\n\t\t};\n\n\t\tthis.getCamera = function ( camera ) {\n\n\t\t\tif ( device === null ) return camera;\n\n\t\t\tdevice.depthNear = camera.near;\n\t\t\tdevice.depthFar = camera.far;\n\n\t\t\tdevice.getFrameData( frameData );\n\n\t\t\t//\n\n\t\t\tvar pose = frameData.pose;\n\t\t\tvar poseObject = poseTarget !== null ? poseTarget : camera;\n\n\t\t\tif ( pose.position !== null ) {\n\n\t\t\t\tposeObject.position.fromArray( pose.position );\n\n\t\t\t} else {\n\n\t\t\t\tposeObject.position.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( pose.orientation !== null ) {\n\n\t\t\t\tposeObject.quaternion.fromArray( pose.orientation );\n\n\t\t\t}\n\n\t\t\tvar stageParameters = device.stageParameters;\n\n\t\t\tif ( stageParameters ) {\n\n\t\t\t\tstandingMatrix.fromArray( stageParameters.sittingToStandingTransform );\n\n\t\t\t} else {\n\n\t\t\t\tstandingMatrix.makeTranslation( 0, scope.userHeight, 0 );\n\n\t\t\t}\n\n\t\t\tposeObject.position.applyMatrix4( standingMatrix );\n\t\t\tposeObject.updateMatrixWorld();\n\n\t\t\tif ( device.isPresenting === false ) return camera;\n\n\t\t\t//\n\n\t\t\tcameraL.near = camera.near;\n\t\t\tcameraR.near = camera.near;\n\n\t\t\tcameraL.far = camera.far;\n\t\t\tcameraR.far = camera.far;\n\n\t\t\tcameraVR.matrixWorld.copy( camera.matrixWorld );\n\t\t\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\n\n\t\t\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\n\t\t\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\n\n\t\t\t// TODO (mrdoob) Double check this code\n\n\t\t\tstandingMatrixInverse.getInverse( standingMatrix );\n\n\t\t\tcameraL.matrixWorldInverse.multiply( standingMatrixInverse );\n\t\t\tcameraR.matrixWorldInverse.multiply( standingMatrixInverse );\n\n\t\t\tvar parent = poseObject.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\n\t\t\t\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\n\t\t\t\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t// envMap and Mirror needs camera.matrixWorld\n\n\t\t\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\n\t\t\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\n\n\t\t\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\n\t\t\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\n\n\t\t\t// HACK (mrdoob)\n\t\t\t// https://github.com/w3c/webvr/issues/203\n\n\t\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t//\n\n\t\t\tvar layers = device.getLayers();\n\n\t\t\tif ( layers.length ) {\n\n\t\t\t\tvar layer = layers[ 0 ];\n\n\t\t\t\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\n\n\t\t\t\t\tcameraL.bounds.fromArray( layer.leftBounds );\n\n\t\t\t\t}\n\n\t\t\t\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\n\n\t\t\t\t\tcameraR.bounds.fromArray( layer.rightBounds );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn cameraVR;\n\n\t\t};\n\n\t\tthis.getStandingMatrix = function () {\n\n\t\t\treturn standingMatrix;\n\n\t\t};\n\n\t\tthis.submitFrame = function () {\n\n\t\t\tif ( device && device.isPresenting ) device.submitFrame();\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\tif ( typeof window !== 'undefined' ) {\n\n\t\t\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLExtensions( gl ) {\n\n\t\tvar extensions = {};\n\n\t\treturn {\n\n\t\t\tget: function ( name ) {\n\n\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\t\treturn extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tvar extension;\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\textensions[ name ] = extension;\n\n\t\t\t\treturn extension;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction WebGLClipping() {\n\n\t\tvar scope = this,\n\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\n\t\t\tplane = new Plane(),\n\t\t\tviewNormalMatrix = new Matrix3(),\n\n\t\t\tuniform = { value: null, needsUpdate: false };\n\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\n\t\t\treturn enabled;\n\n\t\t};\n\n\t\tthis.beginShadows = function () {\n\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\n\t\t};\n\n\t\tthis.endShadows = function () {\n\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\n\t\t};\n\n\t\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t\t// there's no local clipping\n\n\t\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t\t// there's no global clipping\n\n\t\t\t\t\tprojectPlanes( null );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresetGlobalState();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\n\t\t\tif ( uniform.value !== globalState ) {\n\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\n\t\t}\n\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\n\t\t\tif ( nPlanes !== 0 ) {\n\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author thespite / http://www.twitter.com/thespite\n\t */\n\n\tfunction WebGLUtils( gl, extensions ) {\n\n\t\tfunction convert( p ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( p === RepeatWrapping ) return gl.REPEAT;\n\t\t\tif ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;\n\n\t\t\tif ( p === NearestFilter ) return gl.NEAREST;\n\t\t\tif ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;\n\n\t\t\tif ( p === LinearFilter ) return gl.LINEAR;\n\t\t\tif ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;\n\n\t\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;\n\n\t\t\tif ( p === ByteType ) return gl.BYTE;\n\t\t\tif ( p === ShortType ) return gl.SHORT;\n\t\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\t\tif ( p === IntType ) return gl.INT;\n\t\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\t\tif ( p === HalfFloatType ) {\n\n\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t\t}\n\n\t\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t\tif ( p === AddEquation ) return gl.FUNC_ADD;\n\t\t\tif ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;\n\t\t\tif ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;\n\n\t\t\tif ( p === ZeroFactor ) return gl.ZERO;\n\t\t\tif ( p === OneFactor ) return gl.ONE;\n\t\t\tif ( p === SrcColorFactor ) return gl.SRC_COLOR;\n\t\t\tif ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;\n\t\t\tif ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === DstAlphaFactor ) return gl.DST_ALPHA;\n\t\t\tif ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;\n\n\t\t\tif ( p === DstColorFactor ) return gl.DST_COLOR;\n\t\t\tif ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;\n\n\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t}\n\n\t\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\treturn p;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\treturn { convert: convert };\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction UniformsCache() {\n\n\t\tvar lights = {};\n\n\t\treturn {\n\n\t\t\tget: function ( light ) {\n\n\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\t\treturn lights[ light.id ];\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms;\n\n\t\t\t\tswitch ( light.type ) {\n\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\t\treturn uniforms;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tvar count = 0;\n\n\tfunction WebGLLights() {\n\n\t\tvar cache = new UniformsCache();\n\n\t\tvar state = {\n\n\t\t\tid: count ++,\n\n\t\t\thash: '',\n\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\trectArea: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: []\n\n\t\t};\n\n\t\tvar vector3 = new Vector3();\n\t\tvar matrix4 = new Matrix4();\n\t\tvar matrix42 = new Matrix4();\n\n\t\tfunction setup( lights, shadows, camera ) {\n\n\t\t\tvar r = 0, g = 0, b = 0;\n\n\t\t\tvar directionalLength = 0;\n\t\t\tvar pointLength = 0;\n\t\t\tvar spotLength = 0;\n\t\t\tvar rectAreaLength = 0;\n\t\t\tvar hemiLength = 0;\n\n\t\t\tvar viewMatrix = camera.matrixWorldInverse;\n\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tvar color = light.color;\n\t\t\t\tvar intensity = light.intensity;\n\t\t\t\tvar distance = light.distance;\n\n\t\t\t\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\n\t\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\t\tdirectionalLength ++;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\t\tspotLength ++;\n\n\t\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t\t// (a) intensity is the total visible light emitted\n\t\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\n\t\t\t\t\t// (b) intensity is the brightness of the light\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\t\tmatrix42.identity();\n\t\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\t\t// TODO (abelnation): RectAreaLight distance?\n\t\t\t\t\t// uniforms.distance = distance;\n\n\t\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\t\trectAreaLength ++;\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tuniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\t\tuniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\t\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\t\tpointLength ++;\n\n\t\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\t\themiLength ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.ambient[ 0 ] = r;\n\t\t\tstate.ambient[ 1 ] = g;\n\t\t\tstate.ambient[ 2 ] = b;\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.hash = state.id + ',' + directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\tstate: state\n\t\t};\n\n\t}\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction WebGLRenderState() {\n\n\t\tvar lights = new WebGLLights();\n\n\t\tvar lightsArray = [];\n\t\tvar shadowsArray = [];\n\t\tvar spritesArray = [];\n\n\t\tfunction init() {\n\n\t\t\tlightsArray.length = 0;\n\t\t\tshadowsArray.length = 0;\n\t\t\tspritesArray.length = 0;\n\n\t\t}\n\n\t\tfunction pushLight( light ) {\n\n\t\t\tlightsArray.push( light );\n\n\t\t}\n\n\t\tfunction pushShadow( shadowLight ) {\n\n\t\t\tshadowsArray.push( shadowLight );\n\n\t\t}\n\n\t\tfunction pushSprite( shadowLight ) {\n\n\t\t\tspritesArray.push( shadowLight );\n\n\t\t}\n\n\t\tfunction setupLights( camera ) {\n\n\t\t\tlights.setup( lightsArray, shadowsArray, camera );\n\n\t\t}\n\n\t\tvar state = {\n\t\t\tlightsArray: lightsArray,\n\t\t\tshadowsArray: shadowsArray,\n\t\t\tspritesArray: spritesArray,\n\n\t\t\tlights: lights\n\t\t};\n\n\t\treturn {\n\t\t\tinit: init,\n\t\t\tstate: state,\n\t\t\tsetupLights: setupLights,\n\n\t\t\tpushLight: pushLight,\n\t\t\tpushShadow: pushShadow,\n\t\t\tpushSprite: pushSprite\n\t\t};\n\n\t}\n\n\tfunction WebGLRenderStates() {\n\n\t\tvar renderStates = {};\n\n\t\tfunction get( scene, camera ) {\n\n\t\t\tvar hash = scene.id + ',' + camera.id;\n\n\t\t\tvar renderState = renderStates[ hash ];\n\n\t\t\tif ( renderState === undefined ) {\n\n\t\t\t\trenderState = new WebGLRenderState();\n\t\t\t\trenderStates[ hash ] = renderState;\n\n\t\t\t}\n\n\t\t\treturn renderState;\n\n\t\t}\n\n\t\tfunction dispose() {\n\n\t\t\trenderStates = {};\n\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\n\t}\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\n\tfunction WebGLRenderer( parameters ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\t\tparameters = parameters || {};\n\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\n\n\t\tvar currentRenderList = null;\n\t\tvar currentRenderState = null;\n\n\t\t// public properties\n\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\n\t\t// physical lights\n\n\t\tthis.physicallyCorrectLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\n\t\t// morphs\n\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\n\t\t// internal properties\n\n\t\tvar _this = this,\n\n\t\t\t_isContextLost = false,\n\n\t\t\t// internal state cache\n\n\t\t\t_currentRenderTarget = null,\n\t\t\t_currentFramebuffer = null,\n\t\t\t_currentMaterialId = - 1,\n\t\t\t_currentGeometryProgram = '',\n\n\t\t\t_currentCamera = null,\n\t\t\t_currentArrayCamera = null,\n\n\t\t\t_currentViewport = new Vector4(),\n\t\t\t_currentScissor = new Vector4(),\n\t\t\t_currentScissorTest = null,\n\n\t\t\t//\n\n\t\t\t_usedTextureUnits = 0,\n\n\t\t\t//\n\n\t\t\t_width = _canvas.width,\n\t\t\t_height = _canvas.height,\n\n\t\t\t_pixelRatio = 1,\n\n\t\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t\t_scissorTest = false,\n\n\t\t\t// frustum\n\n\t\t\t_frustum = new Frustum(),\n\n\t\t\t// clipping\n\n\t\t\t_clipping = new WebGLClipping(),\n\t\t\t_clippingEnabled = false,\n\t\t\t_localClippingEnabled = false,\n\n\t\t\t// camera matrices cache\n\n\t\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t\t_vector3 = new Vector3(),\n\n\t\t\t// info\n\n\t\t\t_infoMemory = {\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\t\t\t},\n\n\t\t\t_infoRender = {\n\n\t\t\t\tframe: 0,\n\t\t\t\tcalls: 0,\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0,\n\t\t\t\tpoints: 0\n\n\t\t\t};\n\n\t\tthis.info = {\n\n\t\t\trender: _infoRender,\n\t\t\tmemory: _infoMemory,\n\t\t\tprograms: null,\n\t\t\tautoReset: true,\n\t\t\treset: resetInfo\n\n\t\t};\n\n\t\tfunction resetInfo() {\n\n\t\t\t_infoRender.frame ++;\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\n\t\t}\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\t// initialize\n\n\t\tvar _gl;\n\n\t\ttry {\n\n\t\t\tvar contextAttributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\t\tpowerPreference: _powerPreference\n\t\t\t};\n\n\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\n\t\t}\n\n\t\tvar extensions, capabilities, state;\n\t\tvar properties, textures, attributes, geometries, objects;\n\t\tvar programCache, renderLists, renderStates;\n\n\t\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\t\tvar spriteRenderer;\n\n\t\tvar utils;\n\n\t\tfunction initGLContext() {\n\n\t\t\textensions = new WebGLExtensions( _gl );\n\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\textensions.get( 'OES_texture_float' );\n\t\t\textensions.get( 'OES_texture_float_linear' );\n\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\textensions.get( 'OES_element_index_uint' );\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tutils = new WebGLUtils( _gl, extensions );\n\n\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\t\tstate = new WebGLState( _gl, extensions, utils );\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory, _infoRender );\n\t\t\tattributes = new WebGLAttributes( _gl );\n\t\t\tgeometries = new WebGLGeometries( _gl, attributes, _infoMemory );\n\t\t\tobjects = new WebGLObjects( geometries, _infoRender );\n\t\t\tmorphtargets = new WebGLMorphtargets( _gl );\n\t\t\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\n\t\t\trenderLists = new WebGLRenderLists();\n\t\t\trenderStates = new WebGLRenderStates();\n\n\t\t\tbackground = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );\n\n\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t\t\tspriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );\n\n\t\t\t_this.info.programs = programCache.programs;\n\n\t\t\t_this.context = _gl;\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.state = state;\n\n\t\t}\n\n\t\tinitGLContext();\n\n\t\t// vr\n\n\t\tvar vr = new WebVRManager( _this );\n\n\t\tthis.vr = vr;\n\n\t\t// shadow map\n\n\t\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\n\n\t\tthis.shadowMap = shadowMap;\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.loseContext();\n\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\n\t\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.restoreContext();\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _width, _height, false );\n\n\t\t};\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\tvar device = vr.getDevice();\n\n\t\t\tif ( device && device.isPresenting ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\n\t\t\tif ( updateStyle !== false ) {\n\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width * _pixelRatio,\n\t\t\t\theight: _height * _pixelRatio\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_pixelRatio = pixelRatio;\n\n\t\t\t_canvas.width = width * pixelRatio;\n\t\t\t_canvas.height = height * pixelRatio;\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getCurrentViewport = function () {\n\n\t\t\treturn _currentViewport;\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\t_viewport.set( x, _height - y - height, width, height );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\t_scissor.set( x, _height - y - height, width, height );\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function () {\n\n\t\t\treturn background.getClearColor();\n\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\n\t\t\tbackground.setClearColor.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn background.getClearAlpha();\n\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\n\t\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\tvar bits = 0;\n\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\n\t\t};\n\n\t\t//\n\n\t\tthis.dispose = function () {\n\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tobjects.dispose();\n\n\t\t\tvr.dispose();\n\n\t\t\tstopAnimation();\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t\t_isContextLost = true;\n\n\t\t}\n\n\t\tfunction onContextRestore( /* event */ ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t\t_isContextLost = false;\n\n\t\t\tinitGLContext();\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tvar material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\tproperties.remove( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReference( material ) {\n\n\t\t\tvar programInfo = properties.get( material ).program;\n\n\t\t\tmaterial.program = undefined;\n\n\t\t\tif ( programInfo !== undefined ) {\n\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tfunction renderObjectImmediate( object, program, material ) {\n\n\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar buffers = properties.get( object );\n\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tif ( object.hasPositions ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( programAttributes.position );\n\t\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasNormals ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t\t! material.isMeshStandardMaterial &&\n\t\t\t\t\t! material.isMeshNormalMaterial &&\n\t\t\t\t\tmaterial.flatShading === true ) {\n\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( programAttributes.normal );\n\n\t\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( programAttributes.uv );\n\n\t\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( programAttributes.color );\n\n\t\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\t\tobject.count = 0;\n\n\t\t};\n\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\t\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );\n\n\t\t\tvar updateBuffers = false;\n\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tmorphtargets.update( object, geometry, material, program );\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\t\tvar rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\t\t\tvar renderer = bufferRenderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattribute = attributes.get( index );\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( attribute );\n\n\t\t\t}\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar dataCount = Infinity;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdataCount = index.count;\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\tdataCount = position.count;\n\n\t\t\t}\n\n\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t\tif ( drawCount === 0 ) return;\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t}\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor ( var name in programAttributes ) {\n\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\n\t\t\t\t\t\tvar attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\t\tvar buffer = attribute.buffer;\n\t\t\t\t\t\tvar type = attribute.type;\n\t\t\t\t\t\tvar bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t}\n\n\t\t// Compile\n\n\t\tthis.compile = function ( scene, camera ) {\n\n\t\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\t\tcurrentRenderState.init();\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tcurrentRenderState.setupLights( camera );\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tif ( object.material ) {\n\n\t\t\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < object.material.length; i ++ ) {\n\n\t\t\t\t\t\t\tinitMaterial( object.material[ i ], scene.fog, object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinitMaterial( object.material, scene.fog, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tvar isAnimating = false;\n\t\tvar onAnimationFrame = null;\n\n\t\tfunction startAnimation() {\n\n\t\t\tif ( isAnimating ) return;\n\n\t\t\trequestAnimationLoopFrame();\n\n\t\t\tisAnimating = true;\n\n\t\t}\n\n\t\tfunction stopAnimation() {\n\n\t\t\tisAnimating = false;\n\n\t\t}\n\n\t\tfunction requestAnimationLoopFrame() {\n\n\t\t\tvar device = vr.getDevice();\n\n\t\t\tif ( device && device.isPresenting ) {\n\n\t\t\t\tdevice.requestAnimationFrame( animationLoop );\n\n\t\t\t} else {\n\n\t\t\t\twindow.requestAnimationFrame( animationLoop );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction animationLoop( time ) {\n\n\t\t\tif ( isAnimating === false ) return;\n\n\t\t\tonAnimationFrame( time );\n\n\t\t\trequestAnimationLoopFrame();\n\n\t\t}\n\n\t\tthis.animate = function ( callback ) {\n\n\t\t\tonAnimationFrame = callback;\n\t\t\tonAnimationFrame !== null ? startAnimation() : stopAnimation();\n\n\t\t};\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\t\tif ( ! ( camera && camera.isCamera ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( _isContextLost ) return;\n\n\t\t\t// reset caching for this frame\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tif ( vr.enabled ) {\n\n\t\t\t\tcamera = vr.getCamera( camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\t\tcurrentRenderState.init();\n\n\t\t\tscene.onBeforeRender( _this, scene, camera, renderTarget );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\t\tcurrentRenderList = renderLists.get( scene, camera );\n\t\t\tcurrentRenderList.init();\n\n\t\t\tprojectObject( scene, camera, _this.sortObjects );\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\tcurrentRenderList.sort();\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\t\tcurrentRenderState.setupLights( camera );\n\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t\t//\n\n\t\t\tif ( this.info.autoReset ) this.info.reset();\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\trenderTarget = null;\n\n\t\t\t}\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t\t//\n\n\t\t\tbackground.render( currentRenderList, scene, camera, forceClear );\n\n\t\t\t// render scene\n\n\t\t\tvar opaqueObjects = currentRenderList.opaque;\n\t\t\tvar transparentObjects = currentRenderList.transparent;\n\n\t\t\tif ( scene.overrideMaterial ) {\n\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t\t} else {\n\n\t\t\t\t// opaque pass (front-to-back order)\n\n\t\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\n\n\t\t\t\t// transparent pass (back-to-front order)\n\n\t\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\n\n\t\t\t}\n\n\t\t\t// custom renderers\n\n\t\t\tvar spritesArray = currentRenderState.state.spritesArray;\n\n\t\t\tspriteRenderer.render( spritesArray, scene, camera );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t}\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\tstate.setPolygonOffset( false );\n\n\t\t\tscene.onAfterRender( _this, scene, camera );\n\n\t\t\tif ( vr.enabled ) {\n\n\t\t\t\tvr.submitFrame();\n\n\t\t\t}\n\n\t\t\t// _gl.finish();\n\n\t\t\tcurrentRenderList = null;\n\t\t\tcurrentRenderState = null;\n\n\t\t};\n\n\t\t/*\n\t\t// TODO Duplicated code (Frustum)\n\n\t\tvar _sphere = new Sphere();\n\n\t\tfunction isObjectViewable( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSpriteViewable( sprite ) {\n\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSphereViewable( sphere ) {\n\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\t\tif ( numPlanes === 0 ) return true;\n\n\t\t\tvar planes = _this.clippingPlanes,\n\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\n\t\t\tdo {\n\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t\t} while ( ++ i !== numPlanes );\n\n\t\t\treturn true;\n\n\t\t}\n\t\t*/\n\n\t\tfunction projectObject( object, camera, sortObjects ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushSprite( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, sortObjects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\n\t\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\t\t_currentArrayCamera = camera;\n\n\t\t\t\t\tvar cameras = camera.cameras;\n\n\t\t\t\t\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar camera2 = cameras[ j ];\n\n\t\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\t\tvar bounds = camera2.bounds;\n\n\t\t\t\t\t\t\tvar x = bounds.x * _width;\n\t\t\t\t\t\t\tvar y = bounds.y * _height;\n\t\t\t\t\t\t\tvar width = bounds.z * _width;\n\t\t\t\t\t\t\tvar height = bounds.w * _height;\n\n\t\t\t\t\t\t\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\n\n\t\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_currentArrayCamera = null;\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\t\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\trenderObjectImmediate( object, program, material );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\n\t\t}\n\n\t\tfunction initMaterial( material, fog, object ) {\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tvar lights = currentRenderState.state.lights;\n\t\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t} else if ( program.code !== code ) {\n\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\t} else if ( materialProperties.lightsHash !== lights.state.hash ) {\n\n\t\t\t\tproperties.update( material, 'lightsHash', lights.state.hash );\n\t\t\t\tprogramChange = false;\n\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\n\t\t\t}\n\n\t\t\tif ( programChange ) {\n\n\t\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.onBeforeCompile( materialProperties.shader );\n\n\t\t\t\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\n\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\n\t\t\t}\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\t\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\t\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar uniforms = materialProperties.shader.uniforms;\n\n\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t\t! material.isRawShaderMaterial ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t\t}\n\n\t\t\tmaterialProperties.fog = fog;\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = lights.state.hash;\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t\t}\n\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t}\n\n\t\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t\t_usedTextureUnits = 0;\n\n\t\t\tvar materialProperties = properties.get( material );\n\t\t\tvar lights = currentRenderState.state.lights;\n\n\t\t\tif ( _clippingEnabled ) {\n\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate === false ) {\n\n\t\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\n\t\t\t\t\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate ) {\n\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.shader.uniforms;\n\n\t\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Avoid unneeded uniform updates per ArrayCamera's sub-camera\n\n\t\t\t\tif ( _currentCamera !== ( _currentArrayCamera || camera ) ) {\n\n\t\t\t\t\t_currentCamera = ( _currentArrayCamera || camera );\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\t\tmaterial.skinning ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\n\t\t\tif ( material.skinning ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tvar bones = skeleton.bones;\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\t\tif ( skeleton.boneTexture === undefined ) {\n\n\t\t\t\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\t\t\t\t\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\t\t\t\tsize = _Math.ceilPowerOfTwo( size );\n\t\t\t\t\t\t\tsize = Math.max( size, 4 );\n\n\t\t\t\t\t\t\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\t\t\t\t\t\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\n\n\t\t\t\t\t\t\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\t\t\t\t\t\tboneTexture.needsUpdate = true;\n\n\t\t\t\t\t\t\tskeleton.boneMatrices = boneMatrices;\n\t\t\t\t\t\t\tskeleton.boneTexture = boneTexture;\n\t\t\t\t\t\t\tskeleton.boneTextureSize = size;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\n\n\t\t\t\tif ( material.lights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t\tif ( material.isMeshToonMaterial ) {\n\n\t\t\t\t\t\trefreshUniformsToon( m_uniforms, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDepth( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDistance( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\t\trefreshUniformsNormal( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\t\t\tm_uniforms.color.value = material.color;\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t\t}\n\n\t\t\t\t// RectAreaLight Texture\n\t\t\t\t// TODO (mrdoob): Find a nicer implementation\n\n\t\t\t\tif ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;\n\t\t\t\tif ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;\n\n\t\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t\t}\n\n\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// Uniforms (refresh uniforms objects)\n\n\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tif ( material.color ) {\n\n\t\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t\t}\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t}\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuniforms.map.value = material.map;\n\n\t\t\t}\n\n\t\t\tif ( material.alphaMap ) {\n\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t}\n\n\t\t\tif ( material.specularMap ) {\n\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t}\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\n\t\t\tvar uvScaleMap;\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t} else if ( material.roughnessMap ) {\n\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t\t} else if ( material.metalnessMap ) {\n\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\t\t\t\tvar rotation = uvScaleMap.rotation;\n\t\t\t\t\tvar center = uvScaleMap.center;\n\n\t\t\t\t\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\n\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t}\n\n\t\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\n\t\t}\n\n\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _height * 0.5;\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tif ( material.map.matrixAutoUpdate === true ) {\n\n\t\t\t\t\tvar offset = material.map.offset;\n\t\t\t\t\tvar repeat = material.map.repeat;\n\t\t\t\t\tvar rotation = material.map.rotation;\n\t\t\t\t\tvar center = material.map.center;\n\n\t\t\t\t\tmaterial.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\n\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\t\tuniforms.fogColor.value = fog.color;\n\n\t\t\tif ( fog.isFog ) {\n\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t\tif ( material.gradientMap ) {\n\n\t\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif ( material.roughnessMap ) {\n\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.metalnessMap ) {\n\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t}\n\n\t\tfunction refreshUniformsDepth( uniforms, material ) {\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tuniforms.referencePosition.value.copy( material.referencePosition );\n\t\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\t\tuniforms.farDistance.value = material.farDistance;\n\n\t\t}\n\n\t\tfunction refreshUniformsNormal( uniforms, material ) {\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\t// Textures\n\n\t\tfunction allocTextureUnit() {\n\n\t\t\tvar textureUnit = _usedTextureUnits;\n\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t\t}\n\n\t\t\t_usedTextureUnits += 1;\n\n\t\t\treturn textureUnit;\n\n\t\t}\n\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function () {\n\n\t\t\tvar warned = false;\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTexture = ( function () {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTexture( texture, slot ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTextureCube = ( function () {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t}\n\n\t\t\tvar framebuffer = null;\n\t\t\tvar isCube = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\t\t\t\tisCube = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t} else {\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t}\n\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport );\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tvar restore = false;\n\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\trestore = true;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t\t! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t\t! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function ( position, texture, level ) {\n\n\t\t\tvar width = texture.image.width;\n\t\t\tvar height = texture.image.height;\n\t\t\tvar internalFormat = utils.convert( texture.format );\n\n\t\t\tthis.setTexture2D( texture, 0 );\n\n\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, internalFormat, position.x, position.y, width, height, 0 );\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction FogExp2( color, density ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tFogExp2.prototype.clone = function () {\n\n\t\treturn new FogExp2( this.color.getHex(), this.density );\n\n\t};\n\n\tFogExp2.prototype.toJSON = function ( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Fog( color, near, far ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tFog.prototype.clone = function () {\n\n\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\n\t};\n\n\tFog.prototype.toJSON = function ( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Scene() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t}\n\n\tScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Scene,\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\n\tfunction SpriteMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\tSpriteMaterial.prototype.isSpriteMaterial = true;\n\n\tSpriteMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\n\t\tthis.rotation = source.rotation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Sprite( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Sprite';\n\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Sprite,\n\n\t\tisSprite: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar intersectPoint = new Vector3();\n\t\t\tvar worldPosition = new Vector3();\n\t\t\tvar worldScale = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tworldPosition.setFromMatrixPosition( this.matrixWorld );\n\t\t\t\traycaster.ray.closestPointToPoint( worldPosition, intersectPoint );\n\n\t\t\t\tworldScale.setFromMatrixScale( this.matrixWorld );\n\t\t\t\tvar guessSizeSq = worldScale.x * worldScale.y / 4;\n\n\t\t\t\tif ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\t\treturn this;\n\n\t\t}\n\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LOD() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LOD,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\t\tvar levels = source.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddLevel: function ( object, distance ) {\n\n\t\t\tif ( distance === undefined ) distance = 0;\n\n\t\t\tdistance = Math.abs( distance );\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\t\tthis.add( object );\n\n\t\t},\n\n\t\tgetObjectForDistance: function ( distance ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tupdate: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar levels = this.levels;\n\n\t\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.levels = [];\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Skeleton( bones, boneInverses ) {\n\n\t\t// copy the bone array\n\n\t\tbones = bones || [];\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\n\n\t\t// use the supplied bone inverses or calculate the inverses\n\n\t\tif ( boneInverses === undefined ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Skeleton.prototype, {\n\n\t\tcalculateInverses: function () {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tvar inverse = new Matrix4();\n\n\t\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\t\tinverse.getInverse( this.bones[ i ].matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tvar bone, i, il;\n\n\t\t\t// recover the bind-time world matrices\n\n\t\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tbone = this.bones[ i ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// compute the local matrices, positions, rotations and scales\n\n\t\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tbone = this.bones[ i ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: ( function () {\n\n\t\t\tvar offsetMatrix = new Matrix4();\n\t\t\tvar identityMatrix = new Matrix4();\n\n\t\t\treturn function update() {\n\n\t\t\t\tvar bones = this.bones;\n\t\t\t\tvar boneInverses = this.boneInverses;\n\t\t\t\tvar boneMatrices = this.boneMatrices;\n\t\t\t\tvar boneTexture = this.boneTexture;\n\n\t\t\t\t// flatten bone matrices to array\n\n\t\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\t\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\n\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t\t\toffsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( boneTexture !== undefined ) {\n\n\t\t\t\t\tboneTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclone: function () {\n\n\t\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t\t},\n\n\t\tgetBoneByName: function ( name ) {\n\n\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tvar bone = this.bones[ i ];\n\n\t\t\t\tif ( bone.name === name ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Bone() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Bone,\n\n\t\tisBone: true\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkinnedMesh( geometry, material ) {\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = 'attached';\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tvar bones = this.initBones();\n\t\tvar skeleton = new Skeleton( bones );\n\n\t\tthis.bind( skeleton, this.matrixWorld );\n\n\t\tthis.normalizeSkinWeights();\n\n\t}\n\n\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\t\tconstructor: SkinnedMesh,\n\n\t\tisSkinnedMesh: true,\n\n\t\tinitBones: function () {\n\n\t\t\tvar bones = [], bone, gbone;\n\t\t\tvar i, il;\n\n\t\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\t\t\t// first, create array of 'Bone' objects from geometry data\n\n\t\t\t\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tgbone = this.geometry.bones[ i ];\n\n\t\t\t\t\t// create new 'Bone' object\n\n\t\t\t\t\tbone = new Bone();\n\t\t\t\t\tbones.push( bone );\n\n\t\t\t\t\t// apply values\n\n\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t\t}\n\n\t\t\t\t// second, create bone hierarchy\n\n\t\t\t\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tgbone = this.geometry.bones[ i ];\n\n\t\t\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\n\n\t\t\t\t\t\t// subsequent bones in the hierarchy\n\n\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// topmost bone, immediate child of the skinned mesh\n\n\t\t\t\t\t\tthis.add( bones[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// now the bones are part of the scene graph and children of the skinned mesh.\n\t\t\t// let's update the corresponding matrices\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn bones;\n\n\t\t},\n\n\t\tbind: function ( skeleton, bindMatrix ) {\n\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif ( bindMatrix === undefined ) {\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tthis.skeleton.pose();\n\n\t\t},\n\n\t\tnormalizeSkinWeights: function () {\n\n\t\t\tvar scale, i;\n\n\t\t\tif ( this.geometry && this.geometry.isGeometry ) {\n\n\t\t\t\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\t\tscale = 1.0 / sw.manhattanLength();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\n\n\t\t\t\tvar vec = new Vector4();\n\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\t\tfor ( i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\t\tscale = 1.0 / vec.manhattanLength();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\n\tfunction LineBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tLineBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Line( geometry, material, mode ) {\n\n\t\tif ( mode === 1 ) {\n\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new LineSegments( geometry, material );\n\n\t\t}\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Line,\n\n\t\tisLine: true,\n\n\t\tcomputeLineDistances: ( function () {\n\n\t\t\tvar start = new Vector3();\n\t\t\tvar end = new Vector3();\n\n\t\t\treturn function computeLineDistances() {\n\n\t\t\t\tvar geometry = this.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t// we assume non-indexed geometry\n\n\t\t\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\t\tvar lineDistances = [ 0 ];\n\n\t\t\t\t\t\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\t\t\tlineDistances[ i ] += start.distanceTo( end );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new THREE.Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\t\t\tlineDistances[ 0 ] = 0;\n\n\t\t\t\t\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar vStart = new Vector3();\n\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\tvar interRay = new Vector3();\n\t\t\t\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LineSegments( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineSegments,\n\n\t\tisLineSegments: true,\n\n\t\tcomputeLineDistances: ( function () {\n\n\t\t\tvar start = new Vector3();\n\t\t\tvar end = new Vector3();\n\n\t\t\treturn function computeLineDistances() {\n\n\t\t\t\tvar geometry = this.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t// we assume non-indexed geometry\n\n\t\t\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\t\tvar lineDistances = [];\n\n\t\t\t\t\t\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new THREE.Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tstart.copy( vertices[ i ] );\n\t\t\t\t\t\tend.copy( vertices[ i + 1 ] );\n\n\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}() )\n\n\t} );\n\n\t/**\n\t * @author mgreter / http://github.com/mgreter\n\t */\n\n\tfunction LineLoop( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n\tLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineLoop,\n\n\t\tisLineLoop: true,\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\n\tfunction PointsMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tPointsMaterial.prototype = Object.create( Material.prototype );\n\tPointsMaterial.prototype.constructor = PointsMaterial;\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tPointsMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Points( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Points,\n\n\t\tisPoints: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\t\t\tsphere.radius += threshold;\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new Vector3();\n\n\t\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Group() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Group';\n\n\t}\n\n\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Group,\n\n\t\tisGroup: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\n\n\t\tconstructor: VideoTexture,\n\n\t\tisVideoTexture: true,\n\n\t\tupdate: function () {\n\n\t\t\tvar video = this.image;\n\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\tCompressedTexture.prototype.constructor = CompressedTexture;\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\n\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\tDepthTexture.prototype = Object.create( Texture.prototype );\n\tDepthTexture.prototype.constructor = DepthTexture;\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction WireframeGeometry( geometry ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\n\t\t// helper variables\n\n\t\tvar i, j, l, o, ol;\n\t\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\n\t\tvar key, keys = [ 'a', 'b', 'c' ];\n\t\tvar vertex;\n\n\t\t// different logic for Geometry and BufferGeometry\n\n\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( key in edges ) {\n\n\t\t\t\te = edges[ key ];\n\n\t\t\t\tvertex = geometry.vertices[ e.index1 ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex = geometry.vertices[ e.index2 ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else if ( geometry && geometry.isBufferGeometry ) {\n\n\t\t\tvar position, indices, groups;\n\t\t\tvar group, start, count;\n\t\t\tvar index1, index2;\n\n\t\t\tvertex = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tposition = geometry.attributes.position;\n\t\t\t\tindices = geometry.index;\n\t\t\t\tgroups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\t\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tgroup = groups[ o ];\n\n\t\t\t\t\tstart = group.start;\n\t\t\t\t\tcount = group.count;\n\n\t\t\t\t\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tedge1 = indices.getX( i + j );\n\t\t\t\t\t\t\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// generate vertices\n\n\t\t\t\tfor ( key in edges ) {\n\n\t\t\t\t\te = edges[ key ];\n\n\t\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tposition = geometry.attributes.position;\n\n\t\t\t\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tindex1 = 3 * i + j;\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\t// ParametricGeometry\n\n\tfunction ParametricGeometry( func, slices, stacks ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\n\t// ParametricBufferGeometry\n\n\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ParametricBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tvar EPS = 0.00001;\n\n\t\tvar normal = new Vector3();\n\n\t\tvar p0 = new Vector3(), p1 = new Vector3();\n\t\tvar pu = new Vector3(), pv = new Vector3();\n\n\t\tvar i, j;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tvar sliceCount = slices + 1;\n\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\t\tvar v = i / stacks;\n\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tvar u = j / slices;\n\n\t\t\t\t// vertex\n\n\t\t\t\tp0 = func( u, v, p0 );\n\t\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t\t// normal\n\n\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\t\tp1 = func( u - EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp1 = func( u + EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\t\tp1 = func( u, v - EPS, p1 );\n\t\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp1 = func( u, v + EPS, p1 );\n\t\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\t\tvar a = i * sliceCount + j;\n\t\t\t\tvar b = i * sliceCount + j + 1;\n\t\t\t\tvar c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\tvar d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// PolyhedronGeometry\n\n\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n\t// PolyhedronBufferGeometry\n\n\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tvar vertexBuffer = [];\n\t\tvar uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tappplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tvar cols = Math.pow( 2, detail );\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tvar v = [];\n\n\t\t\tvar i, j;\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tvar rows = cols - i;\n\n\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction appplyRadius( radius ) {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tvar stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\tvar centroid = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tvar azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// TetrahedronGeometry\n\n\tfunction TetrahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n\t// TetrahedronBufferGeometry\n\n\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// OctahedronGeometry\n\n\tfunction OctahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n\t// OctahedronBufferGeometry\n\n\tfunction OctahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// IcosahedronGeometry\n\n\tfunction IcosahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n\t// IcosahedronBufferGeometry\n\n\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tvar vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t 0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\t t, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t 1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t 3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t 4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// DodecahedronGeometry\n\n\tfunction DodecahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n\t// DodecahedronBufferGeometry\n\n\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\n\t\tvar vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, 1/, )\n\t\t\t 0, - r, - t, 0, - r, t,\n\t\t\t 0, r, - t, 0, r, t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\t r, - t, 0, r, t, 0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tvar indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t */\n\n\t// TubeGeometry\n\n\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = bufferGeometry.tangents;\n\t\tthis.normals = bufferGeometry.normals;\n\t\tthis.binormals = bufferGeometry.binormals;\n\n\t\t// create geometry\n\n\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\tTubeGeometry.prototype.constructor = TubeGeometry;\n\n\t// TubeBufferGeometry\n\n\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar P = new Vector3();\n\n\t\tvar i, j;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\t\tvar indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tvar N = frames.normals[ i ];\n\t\t\tvar B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tvar sin = Math.sin( v );\n\t\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * based on http://www.blackpawn.com/texts/pqtorus/\n\t */\n\n\t// TorusKnotGeometry\n\n\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n\t// TorusKnotBufferGeometry\n\n\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 1;\n\t\ttube = tube || 0.4;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar i, j;\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar P1 = new Vector3();\n\t\tvar P2 = new Vector3();\n\n\t\tvar B = new Vector3();\n\t\tvar T = new Vector3();\n\t\tvar N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// TorusGeometry\n\n\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusGeometry.prototype.constructor = TorusGeometry;\n\n\t// TorusBufferGeometry\n\n\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradius = radius || 1;\n\t\ttube = tube || 0.4;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar center = new Vector3();\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * Port from https://github.com/mapbox/earcut (v2.1.2)\n\t */\n\n\tvar Earcut = {\n\n\t\ttriangulate: function ( data, holeIndices, dim ) {\n\n\t\t\tdim = dim || 2;\n\n\t\t\tvar hasHoles = holeIndices && holeIndices.length,\n\t\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\n\t\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\n\t\t\t\ttriangles = [];\n\n\t\t\tif ( ! outerNode ) return triangles;\n\n\t\t\tvar minX, minY, maxX, maxY, x, y, invSize;\n\n\t\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n\t\t\tif ( data.length > 80 * dim ) {\n\n\t\t\t\tminX = maxX = data[ 0 ];\n\t\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\t\tx = data[ i ];\n\t\t\t\t\ty = data[ i + 1 ];\n\t\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t\t}\n\n\t\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\t\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\n\t\t\t}\n\n\t\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\n\n\t\t\treturn triangles;\n\n\t\t}\n\n\t};\n\n\t// create a circular doubly linked list from polygon points in the specified winding order\n\n\tfunction linkedList( data, start, end, dim, clockwise ) {\n\n\t\tvar i, last;\n\n\t\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t\t} else {\n\n\t\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t\t}\n\n\t\tif ( last && equals( last, last.next ) ) {\n\n\t\t\tremoveNode( last );\n\t\t\tlast = last.next;\n\n\t\t}\n\n\t\treturn last;\n\n\t}\n\n\t// eliminate colinear or duplicate points\n\n\tfunction filterPoints( start, end ) {\n\n\t\tif ( ! start ) return start;\n\t\tif ( ! end ) end = start;\n\n\t\tvar p = start, again;\n\n\t\tdo {\n\n\t\t\tagain = false;\n\n\t\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\t\tremoveNode( p );\n\t\t\t\tp = end = p.prev;\n\t\t\t\tif ( p === p.next ) break;\n\t\t\t\tagain = true;\n\n\t\t\t} else {\n\n\t\t\t\tp = p.next;\n\n\t\t\t}\n\n\t\t} while ( again || p !== end );\n\n\t\treturn end;\n\n\t}\n\n\t// main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\tfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\t\tif ( ! ear ) return;\n\n\t\t// interlink polygon nodes in z-order\n\n\t\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\t\tvar stop = ear, prev, next;\n\n\t\t// iterate through ears, slicing them one by one\n\n\t\twhile ( ear.prev !== ear.next ) {\n\n\t\t\tprev = ear.prev;\n\t\t\tnext = ear.next;\n\n\t\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t\t// cut off the triangle\n\t\t\t\ttriangles.push( prev.i / dim );\n\t\t\t\ttriangles.push( ear.i / dim );\n\t\t\t\ttriangles.push( next.i / dim );\n\n\t\t\t\tremoveNode( ear );\n\n\t\t\t\t// skipping the next vertice leads to less sliver triangles\n\t\t\t\tear = next.next;\n\t\t\t\tstop = next.next;\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tear = next;\n\n\t\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\n\t\t\tif ( ear === stop ) {\n\n\t\t\t\t// try filtering points and slicing again\n\n\t\t\t\tif ( ! pass ) {\n\n\t\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\n\t\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// check whether a polygon node forms a valid ear with adjacent nodes\n\n\tfunction isEar( ear ) {\n\n\t\tvar a = ear.prev,\n\t\t\tb = ear,\n\t\t\tc = ear.next;\n\n\t\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t\t// now make sure we don't have other points inside the potential ear\n\t\tvar p = ear.next.next;\n\n\t\twhile ( p !== ear.prev ) {\n\n\t\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\t\tvar a = ear.prev,\n\t\t\tb = ear,\n\t\t\tc = ear.next;\n\n\t\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t\t// triangle bbox; min & max are calculated like this for speed\n\n\t\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\n\t\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\n\t\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\n\t\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\n\n\t\t// z-order range for the current triangle bbox;\n\n\t\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\n\t\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\n\n\t\t// first look for points inside the triangle in increasing z-order\n\n\t\tvar p = ear.nextZ;\n\n\t\twhile ( p && p.z <= maxZ ) {\n\n\t\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\t\tp = p.nextZ;\n\n\t\t}\n\n\t\t// then look for points in decreasing z-order\n\n\t\tp = ear.prevZ;\n\n\t\twhile ( p && p.z >= minZ ) {\n\n\t\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\n\t\t\tp = p.prevZ;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t// go through all polygon nodes and cure small local self-intersections\n\n\tfunction cureLocalIntersections( start, triangles, dim ) {\n\n\t\tvar p = start;\n\n\t\tdo {\n\n\t\t\tvar a = p.prev, b = p.next.next;\n\n\t\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\t\ttriangles.push( a.i / dim );\n\t\t\t\ttriangles.push( p.i / dim );\n\t\t\t\ttriangles.push( b.i / dim );\n\n\t\t\t\t// remove two nodes involved\n\n\t\t\t\tremoveNode( p );\n\t\t\t\tremoveNode( p.next );\n\n\t\t\t\tp = start = b;\n\n\t\t\t}\n\n\t\t\tp = p.next;\n\n\t\t} while ( p !== start );\n\n\t\treturn p;\n\n\t}\n\n\t// try splitting polygon into two and triangulate them independently\n\n\tfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t\t// look for a valid diagonal that divides the polygon into two\n\n\t\tvar a = start;\n\n\t\tdo {\n\n\t\t\tvar b = a.next.next;\n\n\t\t\twhile ( b !== a.prev ) {\n\n\t\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t\t// split the polygon in two by the diagonal\n\n\t\t\t\t\tvar c = splitPolygon( a, b );\n\n\t\t\t\t\t// filter colinear points around the cuts\n\n\t\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t\t// run earcut on each half\n\n\t\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\n\t\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tb = b.next;\n\n\t\t\t}\n\n\t\t\ta = a.next;\n\n\t\t} while ( a !== start );\n\n\t}\n\n\t// link every hole into the outer loop, producing a single-ring polygon without holes\n\n\tfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\t\tvar queue = [], i, len, start, end, list;\n\n\t\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\t\tstart = holeIndices[ i ] * dim;\n\t\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\t\tlist = linkedList( data, start, end, dim, false );\n\t\t\tif ( list === list.next ) list.steiner = true;\n\t\t\tqueue.push( getLeftmost( list ) );\n\n\t\t}\n\n\t\tqueue.sort( compareX );\n\n\t\t// process holes from left to right\n\n\t\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\t\teliminateHole( queue[ i ], outerNode );\n\t\t\touterNode = filterPoints( outerNode, outerNode.next );\n\n\t\t}\n\n\t\treturn outerNode;\n\n\t}\n\n\tfunction compareX( a, b ) {\n\n\t\treturn a.x - b.x;\n\n\t}\n\n\t// find a bridge between vertices that connects hole with an outer ring and and link it\n\n\tfunction eliminateHole( hole, outerNode ) {\n\n\t\touterNode = findHoleBridge( hole, outerNode );\n\n\t\tif ( outerNode ) {\n\n\t\t\tvar b = splitPolygon( outerNode, hole );\n\n\t\t\tfilterPoints( b, b.next );\n\n\t\t}\n\n\t}\n\n\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\tfunction findHoleBridge( hole, outerNode ) {\n\n\t\tvar p = outerNode,\n\t\t\thx = hole.x,\n\t\t\thy = hole.y,\n\t\t\tqx = - Infinity,\n\t\t\tm;\n\n\t\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t\t// segment's endpoint with lesser x will be potential connection point\n\n\t\tdo {\n\n\t\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\n\t\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\t\tqx = x;\n\n\t\t\t\t\tif ( x === hx ) {\n\n\t\t\t\t\t\tif ( hy === p.y ) return p;\n\t\t\t\t\t\tif ( hy === p.next.y ) return p.next;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tp = p.next;\n\n\t\t} while ( p !== outerNode );\n\n\t\tif ( ! m ) return null;\n\n\t\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\n\n\t\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t\t// if there are no points found, we have a valid connection;\n\t\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\t\tvar stop = m,\n\t\t\tmx = m.x,\n\t\t\tmy = m.y,\n\t\t\ttanMin = Infinity,\n\t\t\ttan;\n\n\t\tp = m.next;\n\n\t\twhile ( p !== stop ) {\n\n\t\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\n\n\t\t\t\t\tm = p;\n\t\t\t\t\ttanMin = tan;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t\treturn m;\n\n\t}\n\n\t// interlink polygon nodes in z-order\n\n\tfunction indexCurve( start, minX, minY, invSize ) {\n\n\t\tvar p = start;\n\n\t\tdo {\n\n\t\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\t\tp.prevZ = p.prev;\n\t\t\tp.nextZ = p.next;\n\t\t\tp = p.next;\n\n\t\t} while ( p !== start );\n\n\t\tp.prevZ.nextZ = null;\n\t\tp.prevZ = null;\n\n\t\tsortLinked( p );\n\n\t}\n\n\t// Simon Tatham's linked list merge sort algorithm\n\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\tfunction sortLinked( list ) {\n\n\t\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n\n\t\tdo {\n\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnumMerges = 0;\n\n\t\t\twhile ( p ) {\n\n\t\t\t\tnumMerges ++;\n\t\t\t\tq = p;\n\t\t\t\tpSize = 0;\n\n\t\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\t\tpSize ++;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tif ( ! q ) break;\n\n\t\t\t\t}\n\n\t\t\t\tqSize = inSize;\n\n\t\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\tpSize --;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\tqSize --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\t\telse list = e;\n\n\t\t\t\t\te.prevZ = tail;\n\t\t\t\t\ttail = e;\n\n\t\t\t\t}\n\n\t\t\t\tp = q;\n\n\t\t\t}\n\n\t\t\ttail.nextZ = null;\n\t\t\tinSize *= 2;\n\n\t\t} while ( numMerges > 1 );\n\n\t\treturn list;\n\n\t}\n\n\t// z-order of a point given coords and inverse of the longer side of data bbox\n\n\tfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t\t// coords are transformed into non-negative 15-bit integer range\n\n\t\tx = 32767 * ( x - minX ) * invSize;\n\t\ty = 32767 * ( y - minY ) * invSize;\n\n\t\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\t\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\t\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\t\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\t\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\t\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\t\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\t\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\t\treturn x | ( y << 1 );\n\n\t}\n\n\t// find the leftmost node of a polygon ring\n\n\tfunction getLeftmost( start ) {\n\n\t\tvar p = start, leftmost = start;\n\n\t\tdo {\n\n\t\t\tif ( p.x < leftmost.x ) leftmost = p;\n\t\t\tp = p.next;\n\n\t\t} while ( p !== start );\n\n\t\treturn leftmost;\n\n\t}\n\n\t// check if a point lies within a convex triangle\n\n\tfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\t\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\n\t\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\n\t\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\n\n\t}\n\n\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\tfunction isValidDiagonal( a, b ) {\n\n\t\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\n\t\t\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\n\n\t}\n\n\t// signed area of a triangle\n\n\tfunction area( p, q, r ) {\n\n\t\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n\t}\n\n\t// check if two points are equal\n\n\tfunction equals( p1, p2 ) {\n\n\t\treturn p1.x === p2.x && p1.y === p2.y;\n\n\t}\n\n\t// check if two segments intersect\n\n\tfunction intersects( p1, q1, p2, q2 ) {\n\n\t\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\n\t\t\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\n\n\t\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\n\t\t\t\t\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\n\n\t}\n\n\t// check if a polygon diagonal intersects any polygon segments\n\n\tfunction intersectsPolygon( a, b ) {\n\n\t\tvar p = a;\n\n\t\tdo {\n\n\t\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\t\t\t\t\tintersects( p, p.next, a, b ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tp = p.next;\n\n\t\t} while ( p !== a );\n\n\t\treturn false;\n\n\t}\n\n\t// check if a polygon diagonal is locally inside the polygon\n\n\tfunction locallyInside( a, b ) {\n\n\t\treturn area( a.prev, a, a.next ) < 0 ?\n\t\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n\t}\n\n\t// check if the middle point of a polygon diagonal is inside the polygon\n\n\tfunction middleInside( a, b ) {\n\n\t\tvar p = a,\n\t\t\tinside = false,\n\t\t\tpx = ( a.x + b.x ) / 2,\n\t\t\tpy = ( a.y + b.y ) / 2;\n\n\t\tdo {\n\n\t\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\n\n\t\t\t\tinside = ! inside;\n\n\t\t\t}\n\n\t\t\tp = p.next;\n\n\t\t} while ( p !== a );\n\n\t\treturn inside;\n\n\t}\n\n\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\tfunction splitPolygon( a, b ) {\n\n\t\tvar a2 = new Node( a.i, a.x, a.y ),\n\t\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\t\tan = a.next,\n\t\t\tbp = b.prev;\n\n\t\ta.next = b;\n\t\tb.prev = a;\n\n\t\ta2.next = an;\n\t\tan.prev = a2;\n\n\t\tb2.next = a2;\n\t\ta2.prev = b2;\n\n\t\tbp.next = b2;\n\t\tb2.prev = bp;\n\n\t\treturn b2;\n\n\t}\n\n\t// create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\tfunction insertNode( i, x, y, last ) {\n\n\t\tvar p = new Node( i, x, y );\n\n\t\tif ( ! last ) {\n\n\t\t\tp.prev = p;\n\t\t\tp.next = p;\n\n\t\t} else {\n\n\t\t\tp.next = last.next;\n\t\t\tp.prev = last;\n\t\t\tlast.next.prev = p;\n\t\t\tlast.next = p;\n\n\t\t}\n\n\t\treturn p;\n\n\t}\n\n\tfunction removeNode( p ) {\n\n\t\tp.next.prev = p.prev;\n\t\tp.prev.next = p.next;\n\n\t\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\t\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n\t}\n\n\tfunction Node( i, x, y ) {\n\n\t\t// vertice index in coordinates array\n\t\tthis.i = i;\n\n\t\t// vertex coordinates\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\t// previous and next vertice nodes in a polygon ring\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\n\t\t// z-order curve value\n\t\tthis.z = null;\n\n\t\t// previous and next nodes in z-order\n\t\tthis.prevZ = null;\n\t\tthis.nextZ = null;\n\n\t\t// indicates whether this is a steiner point\n\t\tthis.steiner = false;\n\n\t}\n\n\tfunction signedArea( data, start, end, dim ) {\n\n\t\tvar sum = 0;\n\n\t\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\n\n\t\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\t\tj = i;\n\n\t\t}\n\n\t\treturn sum;\n\n\t}\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar ShapeUtils = {\n\n\t\t// calculate area of the contour polygon\n\n\t\tarea: function ( contour ) {\n\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\n\t\t},\n\n\t\tisClockWise: function ( pts ) {\n\n\t\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t\t},\n\n\t\ttriangulateShape: function ( contour, holes ) {\n\n\t\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\t\tvar holeIndices = []; // array of hole indices\n\t\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\t\tremoveDupEndPts( contour );\n\t\t\taddContour( vertices, contour );\n\n\t\t\t//\n\n\t\t\tvar holeIndex = contour.length;\n\n\t\t\tholes.forEach( removeDupEndPts );\n\n\t\t\tfor ( var i = 0; i < holes.length; i ++ ) {\n\n\t\t\t\tholeIndices.push( holeIndex );\n\t\t\t\tholeIndex += holes[ i ].length;\n\t\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t\t}\n\n\t\t\treturn faces;\n\n\t\t}\n\n\t};\n\n\tfunction removeDupEndPts( points ) {\n\n\t\tvar l = points.length;\n\n\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.pop();\n\n\t\t}\n\n\t}\n\n\tfunction addContour( vertices, contour ) {\n\n\t\tfor ( var i = 0; i < contour.length; i ++ ) {\n\n\t\t\tvertices.push( contour[ i ].x );\n\t\t\tvertices.push( contour[ i ].y );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  UVGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t */\n\n\t// ExtrudeGeometry\n\n\tfunction ExtrudeGeometry( shapes, options ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\t// ExtrudeBufferGeometry\n\n\tfunction ExtrudeBufferGeometry( shapes, options ) {\n\n\t\tif ( typeof ( shapes ) === \"undefined\" ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeBufferGeometry';\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\n\t\t//this.computeVertexNormals();\n\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n\t}\n\n\tExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\n\tExtrudeBufferGeometry.prototype.getArrays = function () {\n\n\t\tvar positionAttribute = this.getAttribute( \"position\" );\n\t\tvar verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];\n\n\t\tvar uvAttribute = this.getAttribute( \"uv\" );\n\t\tvar uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];\n\n\t\tvar IndexAttribute = this.index;\n\t\tvar indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];\n\n\t\treturn {\n\t\t\tposition: verticesArray,\n\t\t\tuv: uvArray,\n\t\t\tindex: indicesArray\n\t\t};\n\n\t};\n\n\tExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tvar sl = shapes.length;\n\t\toptions.arrays = this.getArrays();\n\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\n\t\t}\n\n\t\tthis.setIndex( options.arrays.index );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );\n\n\t};\n\n\tExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tvar arrays = options.arrays ? options.arrays : this.getArrays();\n\t\tvar verticesArray = arrays.position;\n\t\tvar indicesArray = arrays.index;\n\t\tvar uvArray = arrays.uv;\n\n\t\tvar placeholder = [];\n\n\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x,\n\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false; // assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [],\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y, amount + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, amount + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );\n\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0,\n\t\t\t\t\tsl = steps + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tplaceholder.push( x );\n\t\t\tplaceholder.push( y );\n\t\t\tplaceholder.push( z );\n\n\t\t}\n\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( d );\n\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\t\t\taddVertex( d );\n\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t}\n\n\t\tfunction addVertex( index ) {\n\n\t\t\tindicesArray.push( verticesArray.length / 3 );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t}\n\n\n\t\tfunction addUV( vector2 ) {\n\n\t\t\tuvArray.push( vector2.x );\n\t\t\tuvArray.push( vector2.y );\n\n\t\t}\n\n\t\tif ( ! options.arrays ) {\n\n\t\t\tthis.setIndex( indicesArray );\n\t\t\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.WorldUVGenerator = {\n\n\t\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\t\tvar a_x = vertices[ indexA * 3 ];\n\t\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\t\tvar b_x = vertices[ indexB * 3 ];\n\t\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\t\tvar c_x = vertices[ indexC * 3 ];\n\t\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, a_y ),\n\t\t\t\tnew Vector2( b_x, b_y ),\n\t\t\t\tnew Vector2( c_x, c_y )\n\t\t\t];\n\n\t\t},\n\n\t\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\t\tvar a_x = vertices[ indexA * 3 ];\n\t\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\t\tvar a_z = vertices[ indexA * 3 + 2 ];\n\t\t\tvar b_x = vertices[ indexB * 3 ];\n\t\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\t\tvar b_z = vertices[ indexB * 3 + 2 ];\n\t\t\tvar c_x = vertices[ indexC * 3 ];\n\t\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\t\t\tvar c_z = vertices[ indexC * 3 + 2 ];\n\t\t\tvar d_x = vertices[ indexD * 3 ];\n\t\t\tvar d_y = vertices[ indexD * 3 + 1 ];\n\t\t\tvar d_z = vertices[ indexD * 3 + 2 ];\n\n\t\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\n\t// TextGeometry\n\n\tfunction TextGeometry( text, parameters ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TextGeometry';\n\n\t\tthis.parameters = {\n\t\t\ttext: text,\n\t\t\tparameters: parameters\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTextGeometry.prototype = Object.create( Geometry.prototype );\n\tTextGeometry.prototype.constructor = TextGeometry;\n\n\t// TextBufferGeometry\n\n\tfunction TextBufferGeometry( text, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tvar font = parameters.font;\n\n\t\tif ( ! ( font && font.isFont ) ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new Geometry();\n\n\t\t}\n\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tExtrudeBufferGeometry.call( this, shapes, parameters );\n\n\t\tthis.type = 'TextBufferGeometry';\n\n\t}\n\n\tTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\n\tTextBufferGeometry.prototype.constructor = TextBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// SphereGeometry\n\n\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\tSphereGeometry.prototype.constructor = SphereGeometry;\n\n\t// SphereBufferGeometry\n\n\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 1;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\n\t\tvar ix, iy;\n\n\t\tvar index = 0;\n\t\tvar grid = [];\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tvar verticesRow = [];\n\n\t\t\tvar v = iy / heightSegments;\n\n\t\t\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tvar u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tvar a = grid[ iy ][ ix + 1 ];\n\t\t\t\tvar b = grid[ iy ][ ix ];\n\t\t\t\tvar c = grid[ iy + 1 ][ ix ];\n\t\t\t\tvar d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n\t/**\n\t * @author Kaleb Murphy\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// RingGeometry\n\n\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\tRingGeometry.prototype.constructor = RingGeometry;\n\n\t// RingBufferGeometry\n\n\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 0.5;\n\t\touterRadius = outerRadius || 1;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// some helper variables\n\n\t\tvar segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// LatheGeometry\n\n\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\tLatheGeometry.prototype.constructor = LatheGeometry;\n\n\t// LatheBufferGeometry\n\n\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar base;\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar i, j;\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tbase = j + i * points.length;\n\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif ( phiLength === Math.PI * 2 ) {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new Vector3();\n\t\t\tvar n2 = new Vector3();\n\t\t\tvar n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\n\t\t\tbase = segments * points.length * 3;\n\n\t\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// ShapeGeometry\n\n\tfunction ShapeGeometry( shapes, curveSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tif ( typeof curveSegments === 'object' ) {\n\n\t\t\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\n\n\t\t\tcurveSegments = curveSegments.curveSegments;\n\n\t\t}\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\tShapeGeometry.prototype.toJSON = function () {\n\n\t\tvar data = Geometry.prototype.toJSON.call( this );\n\n\t\tvar shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t};\n\n\t// ShapeBufferGeometry\n\n\tfunction ShapeBufferGeometry( shapes, curveSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ShapeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\tcurveSegments = curveSegments || 12;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar groupStart = 0;\n\t\tvar groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tvar i, l, shapeHole;\n\n\t\t\tvar indexOffset = vertices.length / 3;\n\t\t\tvar points = shape.extractPoints( curveSegments );\n\n\t\t\tvar shapeVertices = points.shape;\n\t\t\tvar shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t\t// also check if holes are in the opposite direction\n\n\t\t\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\t\tshapeHole = shapeHoles[ i ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tshapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tvar vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// incides\n\n\t\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar a = face[ 0 ] + indexOffset;\n\t\t\t\tvar b = face[ 1 ] + indexOffset;\n\t\t\t\tvar c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\n\tShapeBufferGeometry.prototype.toJSON = function () {\n\n\t\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tvar shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t};\n\n\t//\n\n\tfunction toJSON( shapes, data ) {\n\n\t\tdata.shapes = [];\n\n\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\tvar shape = shapes[ i ];\n\n\t\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.shapes.push( shapes.uuid );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\n\t\t// helper variables\n\n\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\t\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\n\t\tvar key, keys = [ 'a', 'b', 'c' ];\n\n\t\t// prepare source geometry\n\n\t\tvar geometry2;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry2 = new Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry2 = geometry.clone();\n\n\t\t}\n\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\n\t\tvar sourceVertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\n\t\t// now create a data structure where each entry represents an edge with its adjoining faces\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 );\n\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tedges[ key ].face2 = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices\n\n\t\tfor ( key in edges ) {\n\n\t\t\tvar e = edges[ key ];\n\n\t\t\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\n\t\t\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\t\tvar vertex = sourceVertices[ e.index1 ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex = sourceVertices[ e.index2 ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t// CylinderGeometry\n\n\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n\t// CylinderBufferGeometry\n\n\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tvar scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n\t\theight = height || 1;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar index = 0;\n\t\tvar indexArray = [];\n\t\tvar halfHeight = height / 2;\n\t\tvar groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tvar x, y;\n\t\t\tvar normal = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tvar indexRow = [];\n\n\t\t\t\tvar v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tvar a = indexArray[ y ][ x ];\n\t\t\t\t\tvar b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\t\tvar uv = new Vector2();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\n\t\t\tcenterIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\t// ConeGeometry\n\n\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\tConeGeometry.prototype.constructor = ConeGeometry;\n\n\t// ConeBufferGeometry\n\n\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author hughes\n\t */\n\n\t// CircleGeometry\n\n\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\tCircleGeometry.prototype.constructor = CircleGeometry;\n\n\t// CircleBufferGeometry\n\n\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar i, s;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\n\n\tvar Geometries = Object.freeze({\n\t\tWireframeGeometry: WireframeGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tTextBufferGeometry: TextBufferGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingBufferGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tShapeBufferGeometry: ShapeBufferGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\tBoxGeometry: BoxGeometry,\n\t\tBoxBufferGeometry: BoxBufferGeometry\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  color: <THREE.Color>,\n\t *  opacity: <float>\n\t * }\n\t */\n\n\tfunction ShadowMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.opacity = 1.0;\n\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tShadowMaterial.prototype = Object.create( Material.prototype );\n\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction RawShaderMaterial( parameters ) {\n\n\t\tShaderMaterial.call( this, parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshStandardMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\n\tfunction MeshPhysicalMaterial( parameters ) {\n\n\t\tMeshStandardMaterial.call( this );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshPhongMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author takahirox / http://github.com/takahirox\n\t *\n\t * parameters = {\n\t *  gradientMap: new THREE.Texture( <Image> )\n\t * }\n\t */\n\n\tfunction MeshToonMaterial( parameters ) {\n\n\t\tMeshPhongMaterial.call( this );\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.gradientMap = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\n\tMeshToonMaterial.prototype.constructor = MeshToonMaterial;\n\n\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n\tMeshToonMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshPhongMaterial.prototype.copy.call( this, source );\n\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshNormalMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshLambertMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\n\tfunction LineDashedMaterial( parameters ) {\n\n\t\tLineBasicMaterial.call( this );\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\n\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tLineDashedMaterial.prototype.copy = function ( source ) {\n\n\t\tLineBasicMaterial.prototype.copy.call( this, source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Materials = Object.freeze({\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshToonMaterial: MeshToonMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshDistanceMaterial: MeshDistanceMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar Cache = {\n\n\t\tenabled: false,\n\n\t\tfiles: {},\n\n\t\tadd: function ( key, file ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[ key ] = file;\n\n\t\t},\n\n\t\tget: function ( key ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[ key ];\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete this.files[ key ];\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.files = {};\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar isLoading = false;\n\t\tvar itemsLoaded = 0;\n\t\tvar itemsTotal = 0;\n\t\tvar urlModifier = undefined;\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\t\t\treturn this;\n\n\t\t};\n\n\t}\n\n\tvar DefaultLoadingManager = new LoadingManager();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar loading = {};\n\n\tfunction FileLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FileLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\turl = this.manager.resolveURL( url );\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\t// Check if request is duplicate\n\n\t\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\t\tloading[ url ].push( {\n\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\n\t\t\t\t} );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Check for data: URI\n\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\tif ( dataUriRegexResult ) {\n\n\t\t\t\tvar mimeType = dataUriRegexResult[ 1 ];\n\t\t\t\tvar isBase64 = !! dataUriRegexResult[ 2 ];\n\t\t\t\tvar data = dataUriRegexResult[ 3 ];\n\n\t\t\t\tdata = window.decodeURIComponent( data );\n\n\t\t\t\tif ( isBase64 ) data = window.atob( data );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar response;\n\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\t\tvar view = new Uint8Array( data.length );\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tresponse = view.buffer;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\twindow.setTimeout( function () {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, 0 );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\twindow.setTimeout( function () {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}, 0 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Initialise array for duplicate requests\n\n\t\t\t\tloading[ url ] = [];\n\n\t\t\t\tloading[ url ].push( {\n\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\n\t\t\t\t} );\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\t\trequest.open( 'GET', url, true );\n\n\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\tvar response = this.response;\n\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\t\tdelete loading[ url ];\n\n\t\t\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\t\tdelete loading[ url ];\n\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n\t\t\t\tfor ( var header in this.requestHeader ) {\n\n\t\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\n\t\t\t\t}\n\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn request;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResponseType: function ( value ) {\n\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetMimeType: function ( value ) {\n\n\t\t\tthis.mimeType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRequestHeader: function ( value ) {\n\n\t\t\tthis.requestHeader = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\n\tfunction CompressedTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( CompressedTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar images = [];\n\n\t\t\tvar texture = new CompressedTexture();\n\t\t\ttexture.image = images;\n\n\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\tvar loaded = 0;\n\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\t\tloadTexture( i );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\n\tfunction DataTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( DataTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new DataTexture();\n\n\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\t\ttexture.image = texData.image;\n\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\t\ttexture.format = texData.format;\n\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\t\ttexture.type = texData.type;\n\n\t\t\t\t}\n\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}, onProgress, onError );\n\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ImageLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( ImageLoader.prototype, {\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\turl = this.manager.resolveURL( url );\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\t\timage.addEventListener( 'load', function () {\n\n\t\t\t\tCache.add( url, this );\n\n\t\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\t/*\n\t\t\timage.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tif ( onProgress ) onProgress( event );\n\n\t\t\t}, false );\n\t\t\t*/\n\n\t\t\timage.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}, false );\n\n\t\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\timage.src = url;\n\n\t\t\treturn image;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( CubeTextureLoader.prototype, {\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new CubeTexture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, undefined, onError );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction TextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( TextureLoader.prototype, {\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new Texture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\ttexture.image = image;\n\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of curve methods:\n\t * .getPoint( t, optionalTarget ), .getTangent( t )\n\t * .getPointAt( u, optionalTarget ), .getTangentAt( u )\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following curves inherit from THREE.Curve:\n\t *\n\t * -- 2D curves --\n\t * THREE.ArcCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.EllipseCurve\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.SplineCurve\n\t *\n\t * -- 3D curves --\n\t * THREE.CatmullRomCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath.\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\n\tfunction Curve() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\tObject.assign( Curve.prototype, {\n\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\t\tgetPoint: function ( /* t, optionalTarget */ ) {\n\n\t\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\t\tgetPointAt: function ( u, optionalTarget ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t, optionalTarget );\n\n\t\t},\n\n\t\t// Get sequence of points using getPoint( t )\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get sequence of points using getPointAt( u )\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get total curve arc length\n\n\t\tgetLength: function () {\n\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\n\t\t},\n\n\t\t// Get list of cumulative segment lengths\n\n\t\tgetLengths: function ( divisions ) {\n\n\t\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\n\t\t\tif ( this.cacheArcLengths &&\n\t\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t\t! this.needsUpdate ) {\n\n\t\t\t\treturn this.cacheArcLengths;\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\n\t\t\tcache.push( 0 );\n\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t\t},\n\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\tgetUtoTmapping: function ( u, distance ) {\n\n\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\tvar i = 0, il = arcLengths.length;\n\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\tif ( distance ) {\n\n\t\t\t\ttargetArcLength = distance;\n\n\t\t\t} else {\n\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t\t}\n\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\tvar low = 0, high = il - 1, comparison;\n\n\t\t\twhile ( low <= high ) {\n\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\t\tlow = i + 1;\n\n\t\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\t\thigh = i - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// DONE\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\t\treturn i / ( il - 1 );\n\n\t\t\t}\n\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t\t// add that fractional amount to t\n\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\t\treturn t;\n\n\t\t},\n\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\t\tgetTangent: function ( t ) {\n\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\n\t\t\t// Capping in case of danger\n\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\n\t\t},\n\n\t\tgetTangentAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\n\t\t},\n\n\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\tvar normal = new Vector3();\n\n\t\t\tvar tangents = [];\n\t\t\tvar normals = [];\n\t\t\tvar binormals = [];\n\n\t\t\tvar vec = new Vector3();\n\t\t\tvar mat = new Matrix4();\n\n\t\t\tvar i, u, theta;\n\n\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\t\tu = i / segments;\n\n\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\ttangents[ i ].normalize();\n\n\t\t\t}\n\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\tvar min = Number.MAX_VALUE;\n\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\t\tif ( tx <= min ) {\n\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( ty <= min ) {\n\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t\t}\n\n\t\t\tif ( tz <= min ) {\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t\t}\n\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\tif ( closed === true ) {\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\t\ttheta = - theta;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Curve',\n\t\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\t\tdata.type = this.type;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tfromJSON: function ( json ) {\n\n\t\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX || 0;\n\t\tthis.aY = aY || 0;\n\n\t\tthis.xRadius = xRadius || 1;\n\t\tthis.yRadius = yRadius || 1;\n\n\t\tthis.aStartAngle = aStartAngle || 0;\n\t\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\n\n\t\tthis.aClockwise = aClockwise || false;\n\n\t\tthis.aRotation = aRotation || 0;\n\n\t}\n\n\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector2();\n\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t};\n\n\tEllipseCurve.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t};\n\n\n\tEllipseCurve.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t};\n\n\tEllipseCurve.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t};\n\n\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\tArcCurve.prototype.constructor = ArcCurve;\n\n\tArcCurve.prototype.isArcCurve = true;\n\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tfunction init( x0, x1, t0, t1 ) {\n\n\t\t\tc0 = x0;\n\t\t\tc1 = t0;\n\t\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t\t},\n\n\t\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\n\t\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t\t},\n\n\t\t\tcalc: function ( t ) {\n\n\t\t\t\tvar t2 = t * t;\n\t\t\t\tvar t3 = t2 * t;\n\t\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tvar tmp = new Vector3();\n\tvar px = new CubicPoly();\n\tvar py = new CubicPoly();\n\tvar pz = new CubicPoly();\n\n\tfunction CatmullRomCurve3( points, closed, curveType, tension ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points || [];\n\t\tthis.closed = closed || false;\n\t\tthis.curveType = curveType || 'centripetal';\n\t\tthis.tension = tension || 0.5;\n\n\t}\n\n\tCatmullRomCurve3.prototype = Object.create( Curve.prototype );\n\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\n\n\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n\tCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector3();\n\n\t\tvar points = this.points;\n\t\tvar l = points.length;\n\n\t\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tvar intPoint = Math.floor( p );\n\t\tvar weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tp1 = points[ intPoint % l ];\n\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t};\n\n\tCatmullRomCurve3.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tvar point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t};\n\n\tCatmullRomCurve3.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.points = [];\n\n\t\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tvar point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t};\n\n\tCatmullRomCurve3.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tvar point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Bezier Curves formulas obtained from\n\t * http://en.wikipedia.org/wiki/Bzier_curve\n\t */\n\n\tfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n\t//\n\n\tfunction QuadraticBezierP0( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * p;\n\n\t}\n\n\tfunction QuadraticBezierP1( t, p ) {\n\n\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t}\n\n\tfunction QuadraticBezierP2( t, p ) {\n\n\t\treturn t * t * p;\n\n\t}\n\n\tfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\t\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\t\tQuadraticBezierP2( t, p2 );\n\n\t}\n\n\t//\n\n\tfunction CubicBezierP0( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * k * p;\n\n\t}\n\n\tfunction CubicBezierP1( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\n\t}\n\n\tfunction CubicBezierP2( t, p ) {\n\n\t\treturn 3 * ( 1 - t ) * t * t * p;\n\n\t}\n\n\tfunction CubicBezierP3( t, p ) {\n\n\t\treturn t * t * t * p;\n\n\t}\n\n\tfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\t\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\t\tCubicBezierP3( t, p3 );\n\n\t}\n\n\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0 || new Vector2();\n\t\tthis.v1 = v1 || new Vector2();\n\t\tthis.v2 = v2 || new Vector2();\n\t\tthis.v3 = v3 || new Vector2();\n\n\t}\n\n\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\n\tCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector2();\n\n\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t};\n\n\tCubicBezierCurve.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t};\n\n\tCubicBezierCurve.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t};\n\n\tCubicBezierCurve.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t};\n\n\tfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0 || new Vector3();\n\t\tthis.v1 = v1 || new Vector3();\n\t\tthis.v2 = v2 || new Vector3();\n\t\tthis.v3 = v3 || new Vector3();\n\n\t}\n\n\tCubicBezierCurve3.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\n\n\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\n\tCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector3();\n\n\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t};\n\n\tCubicBezierCurve3.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t};\n\n\tCubicBezierCurve3.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t};\n\n\tCubicBezierCurve3.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t};\n\n\tfunction LineCurve( v1, v2 ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1 || new Vector2();\n\t\tthis.v2 = v2 || new Vector2();\n\n\t}\n\n\tLineCurve.prototype = Object.create( Curve.prototype );\n\tLineCurve.prototype.constructor = LineCurve;\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector2();\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t};\n\n\tLineCurve.prototype.getTangent = function ( /* t */ ) {\n\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\t\treturn tangent.normalize();\n\n\t};\n\n\tLineCurve.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tLineCurve.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t};\n\n\tLineCurve.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tfunction LineCurve3( v1, v2 ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1 || new Vector3();\n\t\tthis.v2 = v2 || new Vector3();\n\n\t}\n\n\tLineCurve3.prototype = Object.create( Curve.prototype );\n\tLineCurve3.prototype.constructor = LineCurve3;\n\n\tLineCurve3.prototype.isLineCurve3 = true;\n\n\tLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector3();\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t};\n\n\tLineCurve3.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tLineCurve3.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t};\n\n\tLineCurve3.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0 || new Vector2();\n\t\tthis.v1 = v1 || new Vector2();\n\t\tthis.v2 = v2 || new Vector2();\n\n\t}\n\n\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\n\tQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector2();\n\n\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t};\n\n\tQuadraticBezierCurve.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tQuadraticBezierCurve.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t};\n\n\tQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tfunction QuadraticBezierCurve3( v0, v1, v2 ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0 || new Vector3();\n\t\tthis.v1 = v1 || new Vector3();\n\t\tthis.v2 = v2 || new Vector3();\n\n\t}\n\n\tQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\n\n\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\n\tQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector3();\n\n\t\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t};\n\n\tQuadraticBezierCurve3.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tQuadraticBezierCurve3.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t};\n\n\tQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t};\n\n\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points || [];\n\n\t}\n\n\tSplineCurve.prototype = Object.create( Curve.prototype );\n\tSplineCurve.prototype.constructor = SplineCurve;\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\t\tvar point = optionalTarget || new Vector2();\n\n\t\tvar points = this.points;\n\t\tvar p = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( p );\n\t\tvar weight = p - intPoint;\n\n\t\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar p1 = points[ intPoint ];\n\t\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t};\n\n\tSplineCurve.prototype.copy = function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tvar point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tSplineCurve.prototype.toJSON = function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.points = [];\n\n\t\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tvar point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t};\n\n\tSplineCurve.prototype.fromJSON = function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tvar point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Curves = Object.freeze({\n\t\tArcCurve: ArcCurve,\n\t\tCatmullRomCurve3: CatmullRomCurve3,\n\t\tCubicBezierCurve: CubicBezierCurve,\n\t\tCubicBezierCurve3: CubicBezierCurve3,\n\t\tEllipseCurve: EllipseCurve,\n\t\tLineCurve: LineCurve,\n\t\tLineCurve3: LineCurve3,\n\t\tQuadraticBezierCurve: QuadraticBezierCurve,\n\t\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\t\tSplineCurve: SplineCurve\n\t});\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\n\tfunction CurvePath() {\n\n\t\tCurve.call( this );\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\t\tconstructor: CurvePath,\n\n\t\tadd: function ( curve ) {\n\n\t\t\tthis.curves.push( curve );\n\n\t\t},\n\n\t\tclosePath: function () {\n\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\n\t\t\t// To think about boundaries points.\n\n\t\t\twhile ( i < curveLengths.length ) {\n\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t\t},\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tgetLength: function () {\n\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\n\t\t},\n\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getCurveLengths();\n\n\t\t},\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\tgetCurveLengths: function () {\n\n\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\t\treturn this.cacheLengths;\n\n\t\t\t}\n\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\t\t\tvar lengths = [], sums = 0;\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\n\t\t\treturn lengths;\n\n\t\t},\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( divisions === undefined ) divisions = 40;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tdivisions = divisions || 12;\n\n\t\t\tvar points = [], last;\n\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t\t: ( curve && curve.isLineCurve ) ? 1\n\t\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t\t: divisions;\n\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCurve.prototype.copy.call( this, source );\n\n\t\t\tthis.curves = [];\n\n\t\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\t\tvar curve = source.curves[ i ];\n\n\t\t\t\tthis.curves.push( curve.clone() );\n\n\t\t\t}\n\n\t\t\tthis.autoClose = source.autoClose;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\t\tdata.autoClose = this.autoClose;\n\t\t\tdata.curves = [];\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tvar curve = this.curves[ i ];\n\t\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tfromJSON: function ( json ) {\n\n\t\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\t\tthis.autoClose = json.autoClose;\n\t\t\tthis.curves = [];\n\n\t\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\t\tvar curve = json.curves[ i ];\n\t\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t **/\n\n\tfunction Path( points ) {\n\n\t\tCurvePath.call( this );\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\t\tconstructor: Path,\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\t\tvar curve = new SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\t},\n\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t},\n\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCurvePath.prototype.copy.call( this, source );\n\n\t\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = CurvePath.prototype.toJSON.call( this );\n\n\t\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tfromJSON: function ( json ) {\n\n\t\t\tCurvePath.prototype.fromJSON.call( this, json );\n\n\t\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\n\tfunction Shape( points ) {\n\n\t\tPath.call( this, points );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tShape.prototype = Object.assign( Object.create( Path.prototype ), {\n\n\t\tconstructor: Shape,\n\n\t\tgetPointsHoles: function ( divisions ) {\n\n\t\t\tvar holesPts = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t\t}\n\n\t\t\treturn holesPts;\n\n\t\t},\n\n\t\t// get points of shape and holes (keypoints based on segments parameter)\n\n\t\textractPoints: function ( divisions ) {\n\n\t\t\treturn {\n\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t\t};\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tPath.prototype.copy.call( this, source );\n\n\t\t\tthis.holes = [];\n\n\t\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\t\tvar hole = source.holes[ i ];\n\n\t\t\t\tthis.holes.push( hole.clone() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = Path.prototype.toJSON.call( this );\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.holes = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tvar hole = this.holes[ i ];\n\t\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tfromJSON: function ( json ) {\n\n\t\t\tPath.prototype.fromJSON.call( this, json );\n\n\t\t\tthis.uuid = json.uuid;\n\t\t\tthis.holes = [];\n\n\t\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\t\tvar hole = json.holes[ i ];\n\t\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Light( color, intensity ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\t\tthis.receiveShadow = undefined;\n\n\t}\n\n\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Light,\n\n\t\tisLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\t\tLight.call( this, skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.castShadow = undefined;\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: HemisphereLight,\n\n\t\tisHemisphereLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.groundColor.copy( source.groundColor );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LightShadow( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.matrix = new Matrix4();\n\n\t}\n\n\tObject.assign( LightShadow.prototype, {\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.camera = source.camera.clone();\n\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\n\t\t\tthis.mapSize.copy( source.mapSize );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar object = {};\n\n\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\tdelete object.camera.matrix;\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SpotLightShadow() {\n\n\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t}\n\n\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: SpotLightShadow,\n\n\t\tisSpotLightShadow: true,\n\n\t\tupdate: function ( light ) {\n\n\t\t\tvar camera = this.camera;\n\n\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || camera.far;\n\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: SpotLight,\n\n\t\tisSpotLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\n\tfunction PointLight( color, intensity, distance, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t}\n\n\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: PointLight,\n\n\t\tisPointLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectionalLightShadow( ) {\n\n\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: DirectionalLightShadow\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DirectionalLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: DirectionalLight,\n\n\t\tisDirectionalLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AmbientLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t\tthis.castShadow = undefined;\n\n\t}\n\n\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: AmbientLight,\n\n\t\tisAmbientLight: true\n\n\t} );\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\tfunction RectAreaLight( color, intensity, width, height ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = ( width !== undefined ) ? width : 10;\n\t\tthis.height = ( height !== undefined ) ? height : 10;\n\n\t}\n\n\tRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: RectAreaLight,\n\n\t\tisRectAreaLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Light.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.width = this.width;\n\t\t\tdata.object.height = this.height;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n\t}\n\n\tStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\t\tconstructor: StringKeyframeTrack,\n\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction BooleanKeyframeTrack( name, times, values ) {\n\n\t\tKeyframeTrack.call( this, name, times, values );\n\n\t}\n\n\tBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\t\tconstructor: BooleanKeyframeTrack,\n\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\n\t} );\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\n\tfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t}\n\n\tObject.assign( Interpolant.prototype, {\n\n\t\tevaluate: function ( t ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\n\t\t\t\tt1 = pp[ i1 ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\tvalidate_interval: {\n\n\t\t\t\tseek: {\n\n\t\t\t\t\tvar right;\n\n\t\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t//-\n\t\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t\t} // linear scan\n\n\t\t\t\t\t// binary search\n\n\t\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t\t// check boundary cases, again\n\n\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // seek\n\n\t\t\t\tthis._cachedIndex = i1;\n\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t\t} // validate_interval\n\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t\t},\n\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\n\t\t// --- Protected interface\n\n\t\tDefaultSettings_: {},\n\n\t\tgetSettings_: function () {\n\n\t\t\treturn this.settings || this.DefaultSettings_;\n\n\t\t},\n\n\t\tcopySampleValue_: function ( index ) {\n\n\t\t\t// copies a sample value to the result buffer\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// Template methods for derived classes:\n\n\t\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\n\t\t\tthrow new Error( 'call to abstract method' );\n\t\t\t// implementations shall return this.resultBuffer\n\n\t\t},\n\n\t\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\n\t\t\t// empty\n\n\t\t}\n\n\t} );\n\n\t//!\\ DECLARE ALIAS AFTER assign prototype !\n\tObject.assign( Interpolant.prototype, {\n\n\t\t//( 0, t, t0 ), returns this.resultBuffer\n\t\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\n\t\t//( N-1, tN-1, t ), returns this.resultBuffer\n\t\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\n\t} );\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: QuaternionLinearInterpolant,\n\n\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset = i1 * stride,\n\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\t\tconstructor: QuaternionKeyframeTrack,\n\n\t\tValueTypeName: 'quaternion',\n\n\t\t// ValueBufferType is inherited\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n\t}\n\n\tColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\t\tconstructor: ColorKeyframeTrack,\n\n\t\tValueTypeName: 'color'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n\t}\n\n\tNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\t\tconstructor: NumberKeyframeTrack,\n\n\t\tValueTypeName: 'number'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t}\n\n\tCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: CubicInterpolant,\n\n\t\tDefaultSettings_: {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t},\n\n\t\tintervalChanged_: function ( i1, t0, t1 ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\n\t\t\tif ( tPrev === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tNext === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\n\t\t},\n\n\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\n\t\t\t// evaluate polynomials\n\n\t\t\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\t\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\t\tvar sN = wN * ppp - wN * pp;\n\n\t\t\t// combine data linearly\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: LinearInterpolant,\n\n\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: DiscreteInterpolant,\n\n\t\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\n\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tvar AnimationUtils = {\n\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function ( array, from, to ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t\t}\n\n\t\t\treturn array.slice( from, to );\n\n\t\t},\n\n\t\t// converts an array to a specific type\n\t\tconvertArray: function ( array, type, forceClone ) {\n\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\t\treturn new type( array ); // create typed array\n\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t\t},\n\n\t\tisTypedArray: function ( object ) {\n\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\n\t\t},\n\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function ( times ) {\n\n\t\t\tfunction compareTime( i, j ) {\n\n\t\t\t\treturn times[ i ] - times[ j ];\n\n\t\t\t}\n\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\t\tresult.sort( compareTime );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function ( values, stride, order ) {\n\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t}\n\n\t\t\tif ( key === undefined ) return; // no data\n\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t\t// ...assume THREE.Math-ish\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise push as-is\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t\tthis.validate();\n\t\tthis.optimize();\n\n\t}\n\n\t// Static methods:\n\n\tObject.assign( KeyframeTrack, {\n\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\t\tparse: function ( json ) {\n\n\t\t\tif ( json.type === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t\t\t}\n\n\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\t\tif ( json.times === undefined ) {\n\n\t\t\t\tvar times = [], values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\n\t\t\t}\n\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\t\treturn trackType.parse( json );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume a constructor compatible with the base\n\t\t\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( track ) {\n\n\t\t\tvar trackType = track.constructor;\n\n\t\t\tvar json;\n\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\t\tjson = trackType.toJSON( track );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t\t};\n\n\t\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\t_getTrackTypeForValueTypeName: function ( typeName ) {\n\n\t\t\tswitch ( typeName.toLowerCase() ) {\n\n\t\t\t\tcase 'scalar':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'float':\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'integer':\n\n\t\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\t\tcase 'vector':\n\t\t\t\tcase 'vector2':\n\t\t\t\tcase 'vector3':\n\t\t\t\tcase 'vector4':\n\n\t\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\t\tcase 'color':\n\n\t\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\t\tcase 'quaternion':\n\n\t\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'boolean':\n\n\t\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\t\tcase 'string':\n\n\t\t\t\t\treturn StringKeyframeTrack;\n\n\t\t\t}\n\n\t\t\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n\t\t}\n\n\t} );\n\n\tObject.assign( KeyframeTrack.prototype, {\n\n\t\tconstructor: KeyframeTrack,\n\n\t\tTimeBufferType: Float32Array,\n\n\t\tValueBufferType: Float32Array,\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodDiscrete: function ( result ) {\n\n\t\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: function ( result ) {\n\n\t\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tsetInterpolation: function ( interpolation ) {\n\n\t\t\tvar factoryMethod;\n\n\t\t\tswitch ( interpolation ) {\n\n\t\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( factoryMethod === undefined ) {\n\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\n\t\t},\n\n\t\tgetInterpolation: function () {\n\n\t\t\tswitch ( this.createInterpolant ) {\n\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\t\treturn InterpolateSmooth;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetValueSize: function () {\n\n\t\t\treturn this.values.length / this.times.length;\n\n\t\t},\n\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function ( timeOffset ) {\n\n\t\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function ( timeScale ) {\n\n\t\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function ( startTime, endTime ) {\n\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t\t++ from;\n\n\t\t\t}\n\n\t\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t\t-- to;\n\n\t\t\t}\n\n\t\t\t++ to; // inclusive -> exclusive bound\n\n\t\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\n\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function () {\n\n\t\t\tvar valid = true;\n\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\n\t\t\t\tnKeys = times.length;\n\n\t\t\tif ( nKeys === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar prevTime = null;\n\n\t\t\tfor ( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\t\tvar currTime = times[ i ];\n\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\n\t\t\t}\n\n\t\t\tif ( values !== undefined ) {\n\n\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn valid;\n\n\t\t},\n\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function () {\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\n\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\t\twriteIndex = 1,\n\t\t\t\tlastIndex = times.length - 1;\n\n\t\t\tfor ( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\t\tvar keep = false;\n\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tkeep = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// in-place compaction\n\n\t\t\t\tif ( keep ) {\n\n\t\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t++ writeIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flush last keyframe (compaction looks ahead)\n\n\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t\tif ( writeIndex !== times.length ) {\n\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n\t}\n\n\tVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\t\tconstructor: VectorKeyframeTrack,\n\n\t\tValueTypeName: 'vector'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tfunction AnimationClip( name, duration, tracks ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t\tthis.optimize();\n\n\t}\n\n\tObject.assign( AnimationClip, {\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t\t},\n\n\t\ttoJSON: function ( clip ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\n\t\t\tvar json = {\n\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push(\n\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, - 1, tracks );\n\n\t\t},\n\n\t\tfindByName: function ( objectOrClipArray, name ) {\n\n\t\t\tvar clipArray = objectOrClipArray;\n\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\t\treturn clipArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n\t\t\tvar animationToMorphTargets = {};\n\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar clips = [];\n\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t\t}\n\n\t\t\treturn clips;\n\n\t\t},\n\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function ( animation, bones ) {\n\n\t\t\tif ( ! animation ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || - 1;\n\t\t\tvar fps = animation.fps || 30;\n\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t\t// process morph targets\n\t\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\t\tvar animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tracks.length === 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( AnimationClip.prototype, {\n\n\t\tresetDuration: function () {\n\n\t\t\tvar tracks = this.tracks, duration = 0;\n\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\t\tvar track = this.tracks[ i ];\n\n\t\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\n\t\t},\n\n\t\ttrim: function () {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\toptimize: function () {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].optimize();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MaterialLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.textures = {};\n\n\t}\n\n\tObject.assign( MaterialLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new FileLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTextures: function ( value ) {\n\n\t\t\tthis.textures = value;\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar textures = this.textures;\n\n\t\t\tfunction getTexture( name ) {\n\n\t\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn textures[ name ];\n\n\t\t\t}\n\n\t\t\tvar material = new Materials[ json.type ]();\n\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\n\t\t\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\t\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\t\t// Deprecated\n\n\t\t\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\n\n\t\t\t// for PointsMaterial\n\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t\t// maps\n\n\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\t\tvar normalScale = json.normalScale;\n\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t\t}\n\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometryLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( BufferGeometryLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new FileLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\tvar index = json.data.index;\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tvar attributes = json.data.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t\t}\n\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif ( groups !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\t\tvar center = new Vector3();\n\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\tvar TYPED_ARRAYS = {\n\t\tInt8Array: Int8Array,\n\t\tUint8Array: Uint8Array,\n\t\t// Workaround for IE11 pre KB2929437. See #11440\n\t\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\n\t\tInt16Array: Int16Array,\n\t\tUint16Array: Uint16Array,\n\t\tInt32Array: Int32Array,\n\t\tUint32Array: Uint32Array,\n\t\tFloat32Array: Float32Array,\n\t\tFloat64Array: Float64Array\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Loader() {\n\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\n\t}\n\n\tLoader.Handlers = {\n\n\t\thandlers: [],\n\n\t\tadd: function ( regex, loader ) {\n\n\t\t\tthis.handlers.push( regex, loader );\n\n\t\t},\n\n\t\tget: function ( file ) {\n\n\t\t\tvar handlers = this.handlers;\n\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\tObject.assign( Loader.prototype, {\n\n\t\tcrossOrigin: undefined,\n\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tcreateMaterial: ( function () {\n\n\t\t\tvar BlendingMode = {\n\t\t\t\tNoBlending: NoBlending,\n\t\t\t\tNormalBlending: NormalBlending,\n\t\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\t\tCustomBlending: CustomBlending\n\t\t\t};\n\n\t\t\tvar color = new Color();\n\t\t\tvar textureLoader = new TextureLoader();\n\t\t\tvar materialLoader = new MaterialLoader();\n\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\t\tvar texture;\n\n\t\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\t\treturn uuid;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\t\treturn materialLoader.parse( json );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t */\n\n\tvar LoaderUtils = {\n\n\t\tdecodeText: function ( array ) {\n\n\t\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\t\treturn new TextDecoder().decode( array );\n\n\t\t\t}\n\n\t\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\t\tvar s = '';\n\n\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t// Implicitly assumes little-endian.\n\t\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t\t}\n\n\t\t\t// Merges multi-byte utf-8 characters.\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t},\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tvar parts = url.split( '/' );\n\n\t\t\tif ( parts.length === 1 ) return './';\n\n\t\t\tparts.pop();\n\n\t\t\treturn parts.join( '/' ) + '/';\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction JSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\tObject.assign( JSONLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\n\n\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: ( function () {\n\n\t\t\tfunction parseModel( json, geometry ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\t\toffset, zLength,\n\n\t\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\t\ttype,\n\t\t\t\t\tisQuad,\n\t\t\t\t\thasMaterial,\n\t\t\t\t\thasFaceVertexUv,\n\t\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\t\tfaces = json.faces,\n\t\t\t\t\tvertices = json.vertices,\n\t\t\t\t\tnormals = json.normals,\n\t\t\t\t\tcolors = json.colors,\n\n\t\t\t\t\tscale = json.scale,\n\n\t\t\t\t\tnUvLayers = 0;\n\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\t\t\t\t\tisQuad = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin( json, geometry ) {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x = json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a = json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( json, geometry ) {\n\n\t\t\t\tvar scale = json.scale;\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations( json, geometry ) {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\treturn function parse( json, texturePath ) {\n\n\t\t\t\tif ( json.data !== undefined ) {\n\n\t\t\t\t\t// Geometry 4.0 spec\n\t\t\t\t\tjson = json.data;\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.scale !== undefined ) {\n\n\t\t\t\t\tjson.scale = 1.0 / json.scale;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tjson.scale = 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new Geometry();\n\n\t\t\t\tparseModel( json, geometry );\n\t\t\t\tparseSkin( json, geometry );\n\t\t\t\tparseMorphing( json, geometry );\n\t\t\t\tparseAnimations( json, geometry );\n\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\t\treturn { geometry: geometry };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ObjectLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\n\t}\n\n\tObject.assign( ObjectLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( this.texturePath === '' ) {\n\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new FileLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = null;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tscope.parse( json, onLoad );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tparse: function ( json, onLoad ) {\n\n\t\t\tvar shapes = this.parseShape( json.shapes );\n\t\t\tvar geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t} );\n\n\t\t\tvar textures = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\t\tif ( json.animations ) {\n\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t\t}\n\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t},\n\n\t\tparseShape: function ( json ) {\n\n\t\t\tvar shapes = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t},\n\n\t\tparseGeometries: function ( json, shapes ) {\n\n\t\t\tvar geometries = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.vertices,\n\t\t\t\t\t\t\t\tdata.indices,\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.details\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\t\tcase 'ShapeBufferGeometry':\n\n\t\t\t\t\t\t\tvar geometryShapes = [];\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = data.shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ i ] ];\n\n\t\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\t\tdata.curveSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data, this.texturePath ).geometry;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometries;\n\n\t\t},\n\n\t\tparseMaterials: function ( json, textures ) {\n\n\t\t\tvar materials = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.type === 'MultiMaterial' ) {\n\n\t\t\t\t\t\t// Deprecated\n\n\t\t\t\t\t\tvar array = [];\n\n\t\t\t\t\t\tfor ( var j = 0; j < data.materials.length; j ++ ) {\n\n\t\t\t\t\t\t\tarray.push( loader.parse( data.materials[ j ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[ data.uuid ] = array;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseAnimations: function ( json ) {\n\n\t\t\tvar animations = [];\n\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\t\tanimations.push( clip );\n\n\t\t\t}\n\n\t\t\treturn animations;\n\n\t\t},\n\n\t\tparseImages: function ( json, onLoad ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\n\t\t\tfunction loadImage( url ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\treturn loader.load( url, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, undefined, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\tparseTextures: function ( json, images ) {\n\n\t\t\tfunction parseConstant( value, type ) {\n\n\t\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\t\treturn type[ value ];\n\n\t\t\t}\n\n\t\t\tvar textures = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textures;\n\n\t\t},\n\n\t\tparseObject: function ( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar uuid = name[ i ];\n\n\t\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\n\t\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineLoop':\n\n\t\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineSegments':\n\n\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tobject.matrix.fromArray( data.matrix );\n\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.shadow ) {\n\n\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t\t}\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tvar children = data.children;\n\n\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\tvar TEXTURE_MAPPING = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\n\tvar TEXTURE_WRAPPING = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\n\tvar TEXTURE_FILTER = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t};\n\n\t/**\n\t * @author thespite / http://clicktorelease.com/\n\t */\n\n\tfunction ImageBitmapLoader( manager ) {\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\t\tthis.options = undefined;\n\n\t}\n\n\tImageBitmapLoader.prototype = {\n\n\t\tconstructor: ImageBitmapLoader,\n\n\t\tsetOptions: function setOptions( options ) {\n\n\t\t\tthis.options = options;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tload: function load( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\tfetch( url ).then( function ( res ) {\n\n\t\t\t\treturn res.blob();\n\n\t\t\t} ).then( function ( blob ) {\n\n\t\t\t\treturn createImageBitmap( blob, scope.options );\n\n\t\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\t\tCache.add( url, imageBitmap );\n\n\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} ).catch( function ( e ) {\n\n\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t} );\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( /* value */ ) {\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\t **/\n\n\tfunction ShapePath() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tObject.assign( ShapePath.prototype, {\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push( this.currentPath );\n\t\t\tthis.currentPath.moveTo( x, y );\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tthis.currentPath.lineTo( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts ) {\n\n\t\t\tthis.currentPath.splineThru( pts );\n\n\t\t},\n\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\t\tvar shapes = [];\n\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\t\tvar edgeLowPt = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn\tinside;\n\n\t\t\t}\n\n\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\t\tif ( subPaths.length === 1 ) {\n\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\t\tif ( solid ) {\n\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t\t//console.log('cw', i);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t\t//console.log('ccw', i);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tif ( newShapes.length > 1 ) {\n\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmpHoles;\n\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Font( data ) {\n\n\t\tthis.type = 'Font';\n\n\t\tthis.data = data;\n\n\t}\n\n\tObject.assign( Font.prototype, {\n\n\t\tisFont: true,\n\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\t\tvar shapes = [];\n\t\t\tvar paths = createPaths( text, size, divisions, this.data );\n\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\tfunction createPaths( text, size, divisions, data ) {\n\n\t\tvar chars = String( text ).split( '' );\n\t\tvar scale = size / data.resolution;\n\t\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\t\tvar paths = [];\n\n\t\tvar offsetX = 0, offsetY = 0;\n\n\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\tvar char = chars[ i ];\n\n\t\t\tif ( char === '\\n' ) {\n\n\t\t\t\toffsetX = 0;\n\t\t\t\toffsetY -= line_height;\n\n\t\t\t} else {\n\n\t\t\t\tvar ret = createPath( char, divisions, scale, offsetX, offsetY, data );\n\t\t\t\toffsetX += ret.offsetX;\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn paths;\n\n\t}\n\n\tfunction createPath( char, divisions, scale, offsetX, offsetY, data ) {\n\n\t\tvar glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\t\tif ( ! glyph ) return;\n\n\t\tvar path = new ShapePath();\n\n\t\tvar x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\t\tif ( glyph.o ) {\n\n\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn { offsetX: glyph.ha * scale, path: path };\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction FontLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FontLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar font = scope.parse( json );\n\n\t\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\treturn new Font( json );\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar context;\n\n\tvar AudioContext = {\n\n\t\tgetContext: function () {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction AudioLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( AudioLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar context = AudioContext.getContext();\n\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction StereoCamera() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t}\n\n\tObject.assign( StereoCamera.prototype, {\n\n\t\tupdate: ( function () {\n\n\t\t\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\n\n\t\t\tvar eyeRight = new Matrix4();\n\t\t\tvar eyeLeft = new Matrix4();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tinstance = this;\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\teyeSep = this.eyeSep / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t\t// translate xOffset\n\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t\t// for left eye\n\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t\t// for right eye\n\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CubeCamera( near, far, cubeResolution ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tvar fov = 90, aspect = 1;\n\n\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\tthis.renderTarget.texture.name = \"CubeCamera\";\n\n\t\tthis.update = function ( renderer, scene ) {\n\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t\tthis.clear = function ( renderer, color, depth, stencil ) {\n\n\t\t\tvar renderTarget = this.renderTarget;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTarget.activeCubeFace = i;\n\t\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t}\n\n\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\tCubeCamera.prototype.constructor = CubeCamera;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioListener() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t}\n\n\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: AudioListener,\n\n\t\tgetInput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tremoveFilter: function ( ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.filter;\n\n\t\t},\n\n\t\tsetFilter: function ( value ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t\t} else {\n\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\n\t\t},\n\n\t\tgetMasterVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetMasterVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3();\n\n\t\t\tvar orientation = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t\tif ( listener.positionX ) {\n\n\t\t\t\t\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\n\t\t\t\t\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\n\t\t\t\t\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\n\t\t\t\t\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\n\t\t\t\t\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\n\t\t\t\t\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\n\t\t\t\t\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\n\t\t\t\t\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\n\t\t\t\t\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction Audio( listener ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.loop = false;\n\t\tthis.startTime = 0;\n\t\tthis.offset = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis.filters = [];\n\n\t}\n\n\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Audio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tsetNodeSource: function ( audioNode ) {\n\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetBuffer: function ( audioBuffer ) {\n\n\t\t\tthis.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\n\t\t\tif ( this.autoplay ) this.play();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tplay: function () {\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar source = this.context.createBufferSource();\n\n\t\t\tsource.buffer = this.buffer;\n\t\t\tsource.loop = this.loop;\n\t\t\tsource.onended = this.onEnded.bind( this );\n\t\t\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tsource.start( this.startTime, this.offset );\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\tthis.source = source;\n\n\t\t\treturn this.connect();\n\n\t\t},\n\n\t\tpause: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\n\t\t\t\tthis.isPlaying = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.offset = 0;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdisconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilters: function () {\n\n\t\t\treturn this.filters;\n\n\t\t},\n\n\t\tsetFilters: function ( value ) {\n\n\t\t\tif ( ! value ) value = [];\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\n\t\t\t} else {\n\n\t\t\t\tthis.filters = value;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.getFilters()[ 0 ];\n\n\t\t},\n\n\t\tsetFilter: function ( filter ) {\n\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t\t},\n\n\t\tsetPlaybackRate: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetPlaybackRate: function () {\n\n\t\t\treturn this.playbackRate;\n\n\t\t},\n\n\t\tonEnded: function () {\n\n\t\t\tthis.isPlaying = false;\n\n\t\t},\n\n\t\tgetLoop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn this.loop;\n\n\t\t},\n\n\t\tsetLoop: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.loop = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.loop = this.loop;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PositionalAudio( listener ) {\n\n\t\tAudio.call( this, listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\t\tconstructor: PositionalAudio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.panner;\n\n\t\t},\n\n\t\tgetRefDistance: function () {\n\n\t\t\treturn this.panner.refDistance;\n\n\t\t},\n\n\t\tsetRefDistance: function ( value ) {\n\n\t\t\tthis.panner.refDistance = value;\n\n\t\t},\n\n\t\tgetRolloffFactor: function () {\n\n\t\t\treturn this.panner.rolloffFactor;\n\n\t\t},\n\n\t\tsetRolloffFactor: function ( value ) {\n\n\t\t\tthis.panner.rolloffFactor = value;\n\n\t\t},\n\n\t\tgetDistanceModel: function () {\n\n\t\t\treturn this.panner.distanceModel;\n\n\t\t},\n\n\t\tsetDistanceModel: function ( value ) {\n\n\t\t\tthis.panner.distanceModel = value;\n\n\t\t},\n\n\t\tgetMaxDistance: function () {\n\n\t\t\treturn this.panner.maxDistance;\n\n\t\t},\n\n\t\tsetMaxDistance: function ( value ) {\n\n\t\t\tthis.panner.maxDistance = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioAnalyser( audio, fftSize ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\tObject.assign( AudioAnalyser.prototype, {\n\n\t\tgetFrequencyData: function () {\n\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\t\treturn this.data;\n\n\t\t},\n\n\t\tgetAverageFrequency: function () {\n\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tvalue += data[ i ];\n\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tbufferType = Array;\n\t\t\t\tmixFunction = this._select;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\n\t\t}\n\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\n\t\tthis._mixBufferRegion = mixFunction;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\tObject.assign( PropertyMixer.prototype, {\n\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function ( accuIndex, weight ) {\n\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\t\tif ( currentWeight === 0 ) {\n\n\t\t\t\t// accuN := incoming * weight\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\n\t\t\t} else {\n\n\t\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\n\t\t},\n\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function ( accuIndex ) {\n\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tweight = this.cumulativeWeight,\n\n\t\t\t\tbinding = this.binding;\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t\tif ( weight < 1 ) {\n\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t\t}\n\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function () {\n\n\t\t\tvar binding = this.binding;\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toriginalValueOffset = stride * 3;\n\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t},\n\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function () {\n\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t\t},\n\n\n\t\t// mix functions\n\n\t\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tif ( t >= 0.5 ) {\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t\t},\n\n\t\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tvar s = 1 - t;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tvar j = dstOffset + i;\n\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\t// Characters [].:/ are reserved for track binding syntax.\n\tvar RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\n\tfunction Composite( targetGroup, path, optionalParsedPath ) {\n\n\t\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tObject.assign( Composite.prototype, {\n\n\t\tgetValue: function ( array, offset ) {\n\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t\t},\n\n\t\tsetValue: function ( array, offset ) {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbind: function () {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].bind();\n\n\t\t\t}\n\n\t\t},\n\n\t\tunbind: function () {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].unbind();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\n\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t}\n\n\tObject.assign( PropertyBinding, {\n\n\t\tComposite: Composite,\n\n\t\tcreate: function ( root, path, parsedPath ) {\n\n\t\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t\t} else {\n\n\t\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Replaces spaces with underscores and removes unsupported characters from\n\t\t * node names, to ensure compatibility with parseTrackName().\n\t\t *\n\t\t * @param  {string} name Node name to be sanitized.\n\t\t * @return {string}\n\t\t */\n\t\tsanitizeNodeName: ( function () {\n\n\t\t\tvar reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );\n\n\t\t\treturn function sanitizeNodeName( name ) {\n\n\t\t\t\treturn name.replace( /\\s/g, '_' ).replace( reservedRe, '' );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tparseTrackName: function () {\n\n\t\t\t// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t\t\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t\t\t// instead, we exclude reserved characters and match everything else.\n\t\t\tvar wordChar = '[^' + RESERVED_CHARS_RE + ']';\n\t\t\tvar wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n\t\t\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t\t\t// be matched to parse the rest of the track name.\n\t\t\tvar directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar );\n\n\t\t\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\t\t\tvar nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );\n\n\t\t\t// Object on target node, and accessor. May not contain reserved\n\t\t\t// characters. Accessor may contain any character except closing bracket.\n\t\t\tvar objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar );\n\n\t\t\t// Property and accessor. May not contain reserved characters. Accessor may\n\t\t\t// contain any non-bracket characters.\n\t\t\tvar propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar );\n\n\t\t\tvar trackRe = new RegExp( ''\n\t\t\t\t+ '^'\n\t\t\t\t+ directoryRe\n\t\t\t\t+ nodeRe\n\t\t\t\t+ objectRe\n\t\t\t\t+ propertyRe\n\t\t\t\t+ '$'\n\t\t\t);\n\n\t\t\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\n\t\t\treturn function parseTrackName( trackName ) {\n\n\t\t\t\tvar matches = trackRe.exec( trackName );\n\n\t\t\t\tif ( ! matches ) {\n\n\t\t\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t\t\t}\n\n\t\t\t\tvar results = {\n\t\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\t\tnodeName: matches[ 2 ],\n\t\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\t\t\tpropertyIndex: matches[ 6 ]\n\t\t\t\t};\n\n\t\t\t\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\t\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\t\t\tvar objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t\t\t// Object names must be checked against a whitelist. Otherwise, there\n\t\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t\t// include '.' characters).\n\t\t\t\t\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\t\t\tresults.objectName = objectName;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t\t\t}\n\n\t\t\t\treturn results;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfindNode: function ( root, nodeName ) {\n\n\t\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\t\treturn root;\n\n\t\t\t}\n\n\t\t\t// search into skeleton bones.\n\t\t\tif ( root.skeleton ) {\n\n\t\t\t\tvar bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// search into node subtree.\n\t\t\tif ( root.children ) {\n\n\t\t\t\tvar searchNodeSubtree = function ( children ) {\n\n\t\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t};\n\n\t\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\t\tif ( subTreeNode ) {\n\n\t\t\t\t\treturn subTreeNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function () {},\n\t\t_setValue_unavailable: function () {},\n\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\n\t\tGetterByBindingType: [\n\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\t\tvar source = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t\t}\n\n\t\t],\n\n\t\tSetterByBindingTypeAndVersioning: [\n\n\t\t\t[\n\t\t\t\t// Direct\n\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// EntireArray\n\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// ArrayElement\n\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// HasToFromArray\n\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t]\n\n\t\t],\n\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\n\t\t},\n\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\n\t\t},\n\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function () {\n\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\t\tthis.node = targetObject;\n\n\t\t\t}\n\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( objectName ) {\n\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\n\t\t\t\t\tcase 'materials':\n\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\t\tif ( nodeProperty === undefined ) {\n\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t}\n\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\n\t\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else {\n\n\t\t\t\tthis.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t\t},\n\n\t\tunbind: function () {\n\n\t\t\tthis.node = null;\n\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\n\t\t}\n\n\t} );\n\n\t//!\\ DECLARE ALIAS AFTER assign prototype !\n\tObject.assign( PropertyBinding.prototype, {\n\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n\t} );\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction AnimationObjectGroup() {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tObject.assign( AnimationObjectGroup.prototype, {\n\n\t\tisAnimationObjectGroup: true,\n\n\t\tadd: function () {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length,\n\t\t\t\tknownObject = undefined;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index === undefined ) {\n\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\tremove: function () {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// remove & forget\n\t\tuncache: function () {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\t\tsubscribe_: function ( path, parsedPath ) {\n\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\t\tindex = bindings.length;\n\n\t\t\tindicesByPath[ path ] = index;\n\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\n\t\t\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = objects[ i ];\n\t\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\n\t\t},\n\n\t\tunsubscribe_: function ( path ) {\n\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\n\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tvar interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\t\tthis.paused = false;\t\t\t\t// true -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// false -> zero effective weight\n\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n\t}\n\n\tObject.assign( AnimationAction.prototype, {\n\n\t\t// State & Scheduling\n\n\t\tplay: function () {\n\n\t\t\tthis._mixer._activateAction( this );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis._mixer._deactivateAction( this );\n\n\t\t\treturn this.reset();\n\n\t\t},\n\n\t\treset: function () {\n\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = - 1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\n\t\t},\n\n\t\tisRunning: function () {\n\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\t// return true when play has been called\n\t\tisScheduled: function () {\n\n\t\t\treturn this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\tstartAt: function ( time ) {\n\n\t\t\tthis._startTime = time;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetLoop: function ( mode, repetitions ) {\n\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Weight\n\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function ( weight ) {\n\n\t\t\tthis.weight = weight;\n\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\t\treturn this.stopFading();\n\n\t\t},\n\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function () {\n\n\t\t\treturn this._effectiveWeight;\n\n\t\t},\n\n\t\tfadeIn: function ( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t\t},\n\n\t\tfadeOut: function ( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t\t},\n\n\t\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\n\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\n\t\t\tif ( warp ) {\n\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\n\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t\t},\n\n\t\tstopFading: function () {\n\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\t\tif ( weightInterpolant !== null ) {\n\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Time Scale Control\n\n\t\t// set the time scale stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function ( timeScale ) {\n\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function () {\n\n\t\t\treturn this._effectiveTimeScale;\n\n\t\t},\n\n\t\tsetDuration: function ( duration ) {\n\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\tsyncWith: function ( action ) {\n\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\thalt: function ( duration ) {\n\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t\t},\n\n\t\twarp: function ( startTimeScale, endTimeScale, duration ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstopWarping: function () {\n\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Object Accessors\n\n\t\tgetMixer: function () {\n\n\t\t\treturn this._mixer;\n\n\t\t},\n\n\t\tgetClip: function () {\n\n\t\t\treturn this._clip;\n\n\t\t},\n\n\t\tgetRoot: function () {\n\n\t\t\treturn this._localRoot || this._mixer._root;\n\n\t\t},\n\n\t\t// Interna\n\n\t\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t\t// called by the mixer\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\t\tthis._updateWeight( time );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar startTime = this._startTime;\n\n\t\t\tif ( startTime !== null ) {\n\n\t\t\t\t// check for scheduled start of action\n\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t\t}\n\n\t\t\t\t// start\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t\t// apply time scale and advance time\n\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\t\t\tvar weight = this._updateWeight( time );\n\n\t\t\tif ( weight > 0 ) {\n\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_updateWeight: function ( time ) {\n\n\t\t\tvar weight = 0;\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\n\t\t},\n\n\t\t_updateTimeScale: function ( time ) {\n\n\t\t\tvar timeScale = 0;\n\n\t\t\tif ( ! this.paused ) {\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\n\t\t},\n\n\t\t_updateTime: function ( deltaTime ) {\n\n\t\t\tvar time = this.time + deltaTime;\n\n\t\t\tif ( deltaTime === 0 ) return time;\n\n\t\t\tvar duration = this._clip.duration,\n\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\n\t\t\tif ( loop === LoopOnce ) {\n\n\t\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t\t// just started\n\n\t\t\t\t\tthis._loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\n\t\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\t\ttime = duration;\n\n\t\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\t\ttime = 0;\n\n\t\t\t\t\t} else break handle_stop;\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t\t// just started\n\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t\t// wrap around\n\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif ( pending < 0 ) {\n\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// keep running\n\n\t\t\t\t\t\tif ( pending === 0 ) {\n\n\t\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\n\t\t},\n\n\t\t_setEndings: function ( atStart, atEnd, pingPong ) {\n\n\t\t\tvar settings = this._interpolantSettings;\n\n\t\t\tif ( pingPong ) {\n\n\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\n\t\t\t} else {\n\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\t\tif ( atStart ) {\n\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t\tif ( atEnd ) {\n\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_scheduleFading: function ( duration, weightNow, weightThen ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction AnimationMixer( root ) {\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\tAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\t\tconstructor: AnimationMixer,\n\n\t\t_bindAction: function ( action, prototypeAction ) {\n\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingsByName === undefined ) {\n\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t}\n\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t\t}\n\n\t\t},\n\n\t\t_activateAction: function ( action ) {\n\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t_deactivateAction: function ( action ) {\n\n\t\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Memory manager\n\n\t\t_initMemoryManager: function () {\n\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t// }\n\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\n\t\t\tvar scope = this;\n\n\t\t\tthis.stats = {\n\n\t\t\t\tactions: {\n\t\t\t\t\tget total() {\n\n\t\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t\t},\n\t\t\t\t\tget inUse() {\n\n\t\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() {\n\n\t\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t\t},\n\t\t\t\t\tget inUse() {\n\n\t\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() {\n\n\t\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t\t},\n\t\t\t\t\tget inUse() {\n\n\t\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Memory management for AnimationAction objects\n\n\t\t_isActiveAction: function ( action ) {\n\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\n\t\t},\n\n\t\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip === undefined ) {\n\n\t\t\t\tactionsForClip = {\n\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\n\t\t\t\t};\n\n\t\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t\t} else {\n\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t\t},\n\n\t\t_removeInactiveAction: function ( action ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\n\t\t\taction._cacheIndex = null;\n\n\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\n\t\t\taction._byClipCacheIndex = null;\n\n\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\t\tdelete actionByRoot[ rootUuid ];\n\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t},\n\n\t\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendAction: function ( action ) {\n\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t\t},\n\n\t\t_takeBackAction: function ( action ) {\n\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t\t},\n\n\t\t// Memory management for PropertyMixer objects\n\n\t\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( bindingByName === undefined ) {\n\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t\t}\n\n\t\t\tbindingByName[ trackName ] = binding;\n\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\n\t\t},\n\n\t\t_removeInactiveBinding: function ( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\n\t\t\tdelete bindingByName[ trackName ];\n\n\t\t\tremove_empty_map: {\n\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\n\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendBinding: function ( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t\t},\n\n\t\t_takeBackBinding: function ( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t\t},\n\n\n\t\t// Memory management of Interpolants for weight and time scale\n\n\t\t_lendControlInterpolant: function () {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\t\tif ( interpolant === undefined ) {\n\n\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t\t}\n\n\t\t\treturn interpolant;\n\n\t\t},\n\n\t\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t\t},\n\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function ( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\t\treturn existingAction;\n\n\t\t\t\t}\n\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t\t}\n\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\t\treturn newAction;\n\n\t\t},\n\n\t\t// get an existing action\n\t\texistingAction: function ( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function () {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tactions[ i ].reset();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].useCount = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// advance the time and update apply the animation\n\t\tupdate: function ( deltaTime ) {\n\n\t\t\tdeltaTime *= this.timeScale;\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t\t// run active actions\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tvar action = actions[ i ];\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t\t// update scene graph\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// return this mixer's root target object\n\t\tgetRoot: function () {\n\n\t\t\treturn this._root;\n\n\t\t},\n\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function ( clip ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function ( root ) {\n\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( action !== undefined ) {\n\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingByName !== undefined ) {\n\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\t\tif ( action !== null ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Uniform( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\tUniform.prototype.clone = function () {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferGeometry() {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\n\t}\n\n\tInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\n\n\t\tconstructor: InstancedBufferGeometry,\n\n\t\tisInstancedBufferGeometry: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tBufferGeometry.prototype.copy.call( this, source );\n\n\t\t\tthis.maxInstancedCount = source.maxInstancedCount;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\tObject.defineProperties( InterleavedBufferAttribute.prototype, {\n\n\t\tcount: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.data.count;\n\n\t\t\t}\n\n\t\t},\n\n\t\tarray: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.data.array;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tObject.assign( InterleavedBufferAttribute.prototype, {\n\n\t\tisInterleavedBufferAttribute: true,\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBuffer( array, stride ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.onUploadCallback = function () {};\n\n\t\tthis.version = 0;\n\n\t}\n\n\tObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( InterleavedBuffer.prototype, {\n\n\t\tisInterleavedBuffer: true,\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tonUpload: function ( callback ) {\n\n\t\t\tthis.onUploadCallback = callback;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\t\tInterleavedBuffer.call( this, array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\n\n\t\tconstructor: InstancedInterleavedBuffer,\n\n\t\tisInstancedInterleavedBuffer: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n\t\tBufferAttribute.call( this, array, itemSize );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\n\n\t\tconstructor: InstancedBufferAttribute,\n\n\t\tisInstancedBufferAttribute: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\n\tfunction Raycaster( origin, direction, near, far ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Raycaster.prototype, {\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Clock( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tObject.assign( Clock.prototype, {\n\n\t\tstart: function () {\n\n\t\t\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\t\t\tthis.autoStart = false;\n\n\t\t},\n\n\t\tgetElapsedTime: function () {\n\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\n\t\t},\n\n\t\tgetDelta: function () {\n\n\t\t\tvar diff = 0;\n\n\t\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\t\tthis.start();\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tif ( this.running ) {\n\n\t\t\t\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\n\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\n\t\t\t\tthis.elapsedTime += diff;\n\n\t\t\t}\n\n\t\t\treturn diff;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\n\tfunction Spherical( radius, phi, theta ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\t\treturn this;\n\n\t}\n\n\tObject.assign( Spherical.prototype, {\n\n\t\tset: function ( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function () {\n\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function ( vec3 ) {\n\n\t\t\tthis.radius = vec3.length();\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n\t *\n\t */\n\n\tfunction Cylindrical( radius, theta, y ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tObject.assign( Cylindrical.prototype, {\n\n\t\tset: function ( radius, theta, y ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.theta = theta;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.theta = other.theta;\n\t\t\tthis.y = other.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function ( vec3 ) {\n\n\t\t\tthis.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z );\n\t\t\tthis.y = vec3.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Box2( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n\t}\n\n\tObject.assign( Box2.prototype, {\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 4 splitting planes to rule out intersections\n\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction ImmediateRenderObject( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.material = material;\n\t\tthis.render = function ( /* renderCallback */ ) {};\n\n\t}\n\n\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\n\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n\tVertexNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\t\tvar faces = objGeometry.faces;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction SpotLightHelper( light, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\n\tSpotLightHelper.prototype.dispose = function () {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t};\n\n\tSpotLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar vector2 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tthis.light.updateMatrixWorld();\n\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\t\tif ( this.color !== undefined ) {\n\n\t\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t\t} else {\n\n\t\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction getBoneList( object ) {\n\n\t\tvar boneList = [];\n\n\t\tif ( object && object.isBone ) {\n\n\t\t\tboneList.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t\t}\n\n\t\treturn boneList;\n\n\t}\n\n\tfunction SkeletonHelper( object ) {\n\n\t\tvar bones = getBoneList( object );\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar vertices = [];\n\t\tvar colors = [];\n\n\t\tvar color1 = new Color( 0, 0, 1 );\n\t\tvar color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( var i = 0; i < bones.length; i ++ ) {\n\n\t\t\tvar bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\n\tSkeletonHelper.prototype.updateMatrixWorld = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\tvar boneMatrix = new Matrix4();\n\t\tvar matrixWorldInv = new Matrix4();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tvar bones = this.bones;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\tmatrixWorldInv.getInverse( this.root.matrixWorld );\n\n\t\t\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\t\tvar bone = bones[ i ];\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\t\tposition.setXYZ( j, vector.x, vector.y, vector.z );\n\n\t\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\t\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\n\n\t\t\t\t\tj += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PointLightHelper( light, sphereSize, color ) {\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.color = color;\n\n\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n\t}\n\n\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\tPointLightHelper.prototype.constructor = PointLightHelper;\n\n\tPointLightHelper.prototype.dispose = function () {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t};\n\n\tPointLightHelper.prototype.update = function () {\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t};\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t * @author Mugen87 / http://github.com/Mugen87\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction RectAreaLightHelper( light, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\n\n\t\tthis.line = new Line( geometry, material );\n\t\tthis.add( this.line );\n\n\n\t\tthis.update();\n\n\t}\n\n\tRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\n\tRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\n\n\tRectAreaLightHelper.prototype.dispose = function () {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t};\n\n\tRectAreaLightHelper.prototype.update = function () {\n\n\t\t// calculate new dimensions of the helper\n\n\t\tvar hx = this.light.width * 0.5;\n\t\tvar hy = this.light.height * 0.5;\n\n\t\tvar position = this.line.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\t// update vertices\n\n\t\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\n\t\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\n\t\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\n\t\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\n\t\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\n\n\t\tposition.needsUpdate = true;\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.line.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.line.material.color.copy( this.light.color );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction HemisphereLightHelper( light, size, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tvar geometry = new OctahedronBufferGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\n\n\t\tvar position = geometry.getAttribute( 'position' );\n\t\tvar colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n\tHemisphereLightHelper.prototype.dispose = function () {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t};\n\n\tHemisphereLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\tvar color1 = new Color();\n\t\tvar color2 = new Color();\n\n\t\treturn function update() {\n\n\t\t\tvar mesh = this.children[ 0 ];\n\n\t\t\tif ( this.color !== undefined ) {\n\n\t\t\t\tthis.material.color.set( this.color );\n\n\t\t\t} else {\n\n\t\t\t\tvar colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t\tcolor1.copy( this.light.color );\n\t\t\t\tcolor2.copy( this.light.groundColor );\n\n\t\t\t\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\t\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\n\n\t\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tcolors.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction GridHelper( size, divisions, color1, color2 ) {\n\n\t\tsize = size || 10;\n\t\tdivisions = divisions || 10;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar center = divisions / 2;\n\t\tvar step = size / divisions;\n\t\tvar halfSize = size / 2;\n\n\t\tvar vertices = [], colors = [];\n\n\t\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tvar color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\tGridHelper.prototype.constructor = GridHelper;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / http://github.com/Mugen87\n\t * @author Hectate / http://www.github.com/Hectate\n\t */\n\n\tfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\n\n\t\tradius = radius || 10;\n\t\tradials = radials || 16;\n\t\tcircles = circles || 8;\n\t\tdivisions = divisions || 64;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar vertices = [];\n\t\tvar colors = [];\n\n\t\tvar x, z;\n\t\tvar v, i, j, r, color;\n\n\t\t// create the radials\n\n\t\tfor ( i = 0; i <= radials; i ++ ) {\n\n\t\t\tv = ( i / radials ) * ( Math.PI * 2 );\n\n\t\t\tx = Math.sin( v ) * radius;\n\t\t\tz = Math.cos( v ) * radius;\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tvertices.push( x, 0, z );\n\n\t\t\tcolor = ( i & 1 ) ? color1 : color2;\n\n\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t}\n\n\t\t// create the circles\n\n\t\tfor ( i = 0; i <= circles; i ++ ) {\n\n\t\t\tcolor = ( i & 1 ) ? color1 : color2;\n\n\t\t\tr = radius - ( radius / circles * i );\n\n\t\t\tfor ( j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tv = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tPolarGridHelper.prototype = Object.create( LineSegments.prototype );\n\tPolarGridHelper.prototype.constructor = PolarGridHelper;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\t\tnNormals = objGeometry.faces.length;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\n\t}\n\n\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n\tFaceNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction DirectionalLightHelper( light, size, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n\tDirectionalLightHelper.prototype.dispose = function () {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t};\n\n\tDirectionalLightHelper.prototype.update = function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar v3 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\n\t\t\tthis.lightPlane.lookAt( v3 );\n\n\t\t\tif ( this.color !== undefined ) {\n\n\t\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t\t} else {\n\n\t\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t\t}\n\n\t\t\tthis.targetLine.lookAt( v3 );\n\t\t\tthis.targetLine.scale.z = v3.length();\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\tfunction CameraHelper( camera ) {\n\n\t\tvar geometry = new BufferGeometry();\n\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\t\tvar vertices = [];\n\t\tvar colors = [];\n\n\t\tvar pointMap = {};\n\n\t\t// colors\n\n\t\tvar colorFrustum = new Color( 0xffaa00 );\n\t\tvar colorCone = new Color( 0xff0000 );\n\t\tvar colorUp = new Color( 0x00aaff );\n\t\tvar colorTarget = new Color( 0xffffff );\n\t\tvar colorCross = new Color( 0x333333 );\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2', colorFrustum );\n\t\taddLine( 'n2', 'n4', colorFrustum );\n\t\taddLine( 'n4', 'n3', colorFrustum );\n\t\taddLine( 'n3', 'n1', colorFrustum );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2', colorFrustum );\n\t\taddLine( 'f2', 'f4', colorFrustum );\n\t\taddLine( 'f4', 'f3', colorFrustum );\n\t\taddLine( 'f3', 'f1', colorFrustum );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1', colorFrustum );\n\t\taddLine( 'n2', 'f2', colorFrustum );\n\t\taddLine( 'n3', 'f3', colorFrustum );\n\t\taddLine( 'n4', 'f4', colorFrustum );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1', colorCone );\n\t\taddLine( 'p', 'n2', colorCone );\n\t\taddLine( 'p', 'n3', colorCone );\n\t\taddLine( 'p', 'n4', colorCone );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2', colorUp );\n\t\taddLine( 'u2', 'u3', colorUp );\n\t\taddLine( 'u3', 'u1', colorUp );\n\n\t\t// target\n\n\t\taddLine( 'c', 't', colorTarget );\n\t\taddLine( 'p', 'c', colorCross );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2', colorCross );\n\t\taddLine( 'cn3', 'cn4', colorCross );\n\n\t\taddLine( 'cf1', 'cf2', colorCross );\n\t\taddLine( 'cf3', 'cf4', colorCross );\n\n\t\tfunction addLine( a, b, color ) {\n\n\t\t\taddPoint( a, color );\n\t\t\taddPoint( b, color );\n\n\t\t}\n\n\t\tfunction addPoint( id, color ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\tCameraHelper.prototype.constructor = CameraHelper;\n\n\tCameraHelper.prototype.update = function () {\n\n\t\tvar geometry, pointMap;\n\n\t\tvar vector = new Vector3();\n\t\tvar camera = new Camera();\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\t\tvar points = pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\t\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function update() {\n\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\n\t\t\tvar w = 1, h = 1;\n\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t\t// center / target\n\n\t\t\tsetPoint( 'c', 0, 0, - 1 );\n\t\t\tsetPoint( 't', 0, 0, 1 );\n\n\t\t\t// near\n\n\t\t\tsetPoint( 'n1', - w, - h, - 1 );\n\t\t\tsetPoint( 'n2', w, - h, - 1 );\n\t\t\tsetPoint( 'n3', - w, h, - 1 );\n\t\t\tsetPoint( 'n4', w, h, - 1 );\n\n\t\t\t// far\n\n\t\t\tsetPoint( 'f1', - w, - h, 1 );\n\t\t\tsetPoint( 'f2', w, - h, 1 );\n\t\t\tsetPoint( 'f3', - w, h, 1 );\n\t\t\tsetPoint( 'f4', w, h, 1 );\n\n\t\t\t// up\n\n\t\t\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( 'u3', 0, h * 2, - 1 );\n\n\t\t\t// cross\n\n\t\t\tsetPoint( 'cf1', - w, 0, 1 );\n\t\t\tsetPoint( 'cf2', w, 0, 1 );\n\t\t\tsetPoint( 'cf3', 0, - h, 1 );\n\t\t\tsetPoint( 'cf4', 0, h, 1 );\n\n\t\t\tsetPoint( 'cn1', - w, 0, - 1 );\n\t\t\tsetPoint( 'cn2', w, 0, - 1 );\n\t\t\tsetPoint( 'cn3', 0, - h, - 1 );\n\t\t\tsetPoint( 'cn4', 0, h, - 1 );\n\n\t\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / http://github.com/Mugen87\n\t */\n\n\tfunction BoxHelper( object, color ) {\n\n\t\tthis.object = object;\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\tBoxHelper.prototype.constructor = BoxHelper;\n\n\tBoxHelper.prototype.update = ( function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function update( object ) {\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t\t}\n\n\t\t\tif ( this.object !== undefined ) {\n\n\t\t\t\tbox.setFromObject( this.object );\n\n\t\t\t}\n\n\t\t\tif ( box.isEmpty() ) return;\n\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\n\t\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t};\n\n\t} )();\n\n\tBoxHelper.prototype.setFromObject = function ( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3Helper( box, hex ) {\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.box = box;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tBox3Helper.prototype = Object.create( LineSegments.prototype );\n\tBox3Helper.prototype.constructor = Box3Helper;\n\n\tBox3Helper.prototype.updateMatrixWorld = function ( force ) {\n\n\t\tvar box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction PlaneHelper( plane, size, hex ) {\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = ( size === undefined ) ? 1 : size;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\t//\n\n\t\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\n\n\t\tvar geometry2 = new BufferGeometry();\n\t\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\n\n\t}\n\n\tPlaneHelper.prototype = Object.create( Line.prototype );\n\tPlaneHelper.prototype.constructor = PlaneHelper;\n\n\tPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\n\n\t\tvar scale = - this.plane.constant;\n\n\t\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\n\tvar lineGeometry;\n\tvar coneGeometry;\n\n\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tObject3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tif ( lineGeometry === undefined ) {\n\n\t\t\tlineGeometry = new BufferGeometry();\n\t\t\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\tArrowHelper.prototype.constructor = ArrowHelper;\n\n\tArrowHelper.prototype.setDirection = ( function () {\n\n\t\tvar axis = new Vector3();\n\t\tvar radians;\n\n\t\treturn function setDirection( dir ) {\n\n\t\t\t// dir is assumed to be normalized\n\n\t\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\t\tradians = Math.acos( dir.y );\n\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t};\n\n\tArrowHelper.prototype.setColor = function ( color ) {\n\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\n\t};\n\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AxesHelper( size ) {\n\n\t\tsize = size || 1;\n\n\t\tvar vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tvar colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tAxesHelper.prototype = Object.create( LineSegments.prototype );\n\tAxesHelper.prototype.constructor = AxesHelper;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Face4( a, b, c, d, normal, color, materialIndex ) {\n\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\n\t}\n\n\tvar LineStrip = 0;\n\n\tvar LinePieces = 1;\n\n\tfunction MeshFaceMaterial( materials ) {\n\n\t\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\n\t\treturn materials;\n\n\t}\n\n\tfunction MultiMaterial( materials ) {\n\n\t\tif ( materials === undefined ) materials = [];\n\n\t\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\n\t\tmaterials.isMultiMaterial = true;\n\t\tmaterials.materials = materials;\n\t\tmaterials.clone = function () {\n\n\t\t\treturn materials.slice();\n\n\t\t};\n\t\treturn materials;\n\n\t}\n\n\tfunction PointCloud( geometry, material ) {\n\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\n\t}\n\n\tfunction Particle( material ) {\n\n\t\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n\t\treturn new Sprite( material );\n\n\t}\n\n\tfunction ParticleSystem( geometry, material ) {\n\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\n\t}\n\n\tfunction PointCloudMaterial( parameters ) {\n\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\n\t}\n\n\tfunction ParticleBasicMaterial( parameters ) {\n\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\n\t}\n\n\tfunction ParticleSystemMaterial( parameters ) {\n\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\n\t}\n\n\tfunction Vertex( x, y, z ) {\n\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new Vector3( x, y, z );\n\n\t}\n\n\t//\n\n\tfunction DynamicBufferAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n\t}\n\n\tfunction Int8Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n\t\treturn new Int8BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Uint8Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n\t\treturn new Uint8BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n\t\treturn new Uint8ClampedBufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Int16Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n\t\treturn new Int16BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Uint16Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n\t\treturn new Uint16BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Int32Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n\t\treturn new Int32BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Uint32Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n\t\treturn new Uint32BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Float32Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n\t\treturn new Float32BufferAttribute( array, itemSize );\n\n\t}\n\n\tfunction Float64Attribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n\t\treturn new Float64BufferAttribute( array, itemSize );\n\n\t}\n\n\t//\n\n\tCurve.create = function ( construct, getPoint ) {\n\n\t\tconsole.log( 'THREE.Curve.create() has been deprecated' );\n\n\t\tconstruct.prototype = Object.create( Curve.prototype );\n\t\tconstruct.prototype.constructor = construct;\n\t\tconstruct.prototype.getPoint = getPoint;\n\n\t\treturn construct;\n\n\t};\n\n\t//\n\n\tObject.assign( CurvePath.prototype, {\n\n\t\tcreatePointsGeometry: function ( divisions ) {\n\n\t\t\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t\t// generate geometry from path points (for Line or Points objects)\n\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\t\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t\t// generate geometry from equidistant sampling along the path\n\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateGeometry: function ( points ) {\n\n\t\t\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t\tvar geometry = new Geometry();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.assign( Path.prototype, {\n\n\t\tfromPoints: function ( points ) {\n\n\t\t\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction ClosedSplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\n\t}\n\n\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t//\n\n\tfunction SplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\n\t}\n\n\tSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t//\n\n\tfunction Spline( points ) {\n\n\t\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\n\t}\n\n\tSpline.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\tObject.assign( Spline.prototype, {\n\n\t\tinitFromArray: function ( /* a */ ) {\n\n\t\t\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\n\n\t\t},\n\t\tgetControlPointsArray: function ( /* optionalTarget */ ) {\n\n\t\t\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\n\n\t\t},\n\t\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\n\n\t\t\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction AxisHelper( size ) {\n\n\t\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\n\t\treturn new AxesHelper( size );\n\n\t}\n\n\tfunction BoundingBoxHelper( object, color ) {\n\n\t\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n\t\treturn new BoxHelper( object, color );\n\n\t}\n\n\tfunction EdgesHelper( object, hex ) {\n\n\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n\t}\n\n\tGridHelper.prototype.setColors = function () {\n\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\n\t\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\n\n\t};\n\n\tfunction WireframeHelper( object, hex ) {\n\n\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n\t}\n\n\t//\n\n\tObject.assign( Loader.prototype, {\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\n\t\t\treturn LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t} );\n\n\tfunction XHRLoader( manager ) {\n\n\t\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n\t\treturn new FileLoader( manager );\n\n\t}\n\n\tfunction BinaryTextureLoader( manager ) {\n\n\t\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n\t\treturn new DataTextureLoader( manager );\n\n\t}\n\n\t//\n\n\tObject.assign( Box2.prototype, {\n\n\t\tcenter: function ( optionalTarget ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\n\t\t},\n\t\tempty: function () {\n\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\n\t\t}\n\t} );\n\n\tObject.assign( Box3.prototype, {\n\n\t\tcenter: function ( optionalTarget ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\n\t\t},\n\t\tempty: function () {\n\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\n\t\t}\n\t} );\n\n\tLine3.prototype.center = function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\treturn this.getCenter( optionalTarget );\n\n\t};\n\n\tObject.assign( _Math, {\n\n\t\trandom16: function () {\n\n\t\t\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\n\t\t},\n\n\t\tnearestPowerOfTwo: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\n\t\t\treturn _Math.floorPowerOfTwo( value );\n\n\t\t},\n\n\t\tnextPowerOfTwo: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\n\t\t\treturn _Math.ceilPowerOfTwo( value );\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Matrix3.prototype, {\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\n\t\t},\n\t\tmultiplyVector3Array: function ( /* a */ ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\n\n\t\t},\n\t\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\t\treturn this.applyToBufferAttribute( buffer );\n\n\t\t},\n\t\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Matrix4.prototype, {\n\n\t\textractPosition: function ( m ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\n\t\t},\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\t\tgetPosition: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function getPosition() {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t\t};\n\n\t\t}(),\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\n\t\t},\n\t\tmultiplyToArray: function () {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\n\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\n\t\t},\n\t\tmultiplyVector3Array: function ( /* a */ ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\n\n\t\t},\n\t\trotateAxis: function ( v ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\n\t\t},\n\t\ttranslate: function () {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\n\t\t},\n\t\trotateX: function () {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\n\t\t},\n\t\trotateY: function () {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\n\t\t},\n\t\trotateZ: function () {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\n\t\t},\n\t\trotateByAxis: function () {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\n\t\t},\n\t\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\t\treturn this.applyToBufferAttribute( buffer );\n\n\t\t},\n\t\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\n\t\t},\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n\t\t\treturn this.makePerspective( left, right, top, bottom, near, far );\n\n\t\t}\n\n\t} );\n\n\tPlane.prototype.isIntersectionLine = function ( line ) {\n\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\n\t};\n\n\tQuaternion.prototype.multiplyVector3 = function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\n\t};\n\n\tObject.assign( Ray.prototype, {\n\n\t\tisIntersectionBox: function ( box ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Shape.prototype, {\n\n\t\textractAllPoints: function ( divisions ) {\n\n\t\t\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\n\t\t\treturn this.extractPoints( divisions );\n\n\t\t},\n\t\textrude: function ( options ) {\n\n\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\treturn new ExtrudeGeometry( this, options );\n\n\t\t},\n\t\tmakeGeometry: function ( options ) {\n\n\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\treturn new ShapeGeometry( this, options );\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Vector2.prototype, {\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t\t},\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\t\treturn this.manhattanDistanceTo( v );\n\n\t\t},\n\t\tlengthManhattan: function () {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\t\treturn this.manhattanLength();\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Vector3.prototype, {\n\n\t\tsetEulerFromRotationMatrix: function () {\n\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\n\t\t},\n\t\tapplyProjection: function ( m ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n\t\t\treturn this.applyMatrix4( m );\n\n\t\t},\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t\t},\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\t\treturn this.manhattanDistanceTo( v );\n\n\t\t},\n\t\tlengthManhattan: function () {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\t\treturn this.manhattanLength();\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Vector4.prototype, {\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t\t},\n\t\tlengthManhattan: function () {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\t\treturn this.manhattanLength();\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.assign( Geometry.prototype, {\n\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t\t},\n\t\tcomputeLineDistances: function () {\n\n\t\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Object3D.prototype, {\n\n\t\tgetChildByName: function ( name ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\n\t\t},\n\t\trenderDepth: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( Object3D.prototype, {\n\n\t\teulerOrder: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t\t},\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( LOD.prototype, {\n\n\t\tobjects: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\tObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\n\t\t}\n\n\t} );\n\n\tObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\t\treturn this.arcLengthDivisions;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\t\tthis.arcLengthDivisions = value;\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\n\t};\n\n\t//\n\n\tObject.defineProperties( Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( BufferAttribute.prototype, {\n\n\t\tlength: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n\t\t\t\treturn this.array.length;\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\tObject.assign( BufferGeometry.prototype, {\n\n\t\taddIndex: function ( index ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\n\t\t\tif ( indexOffset !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\n\t\t},\n\t\tclearDrawCalls: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\n\t\t},\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\n\t\t},\n\t\tcomputeOffsets: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( BufferGeometry.prototype, {\n\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.defineProperties( Uniform.prototype, {\n\n\t\tdynamic: {\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\n\t\t\t}\n\t\t},\n\t\tonUpdate: {\n\t\t\tvalue: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.defineProperties( Material.prototype, {\n\n\t\twrapAround: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t\t},\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\n\t\t\t\treturn new Color();\n\n\t\t\t}\n\t\t},\n\n\t\tshading: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\tthis.flatShading = ( value === FlatShading );\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\n\t\tmetal: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\n\t\t\t},\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( ShaderMaterial.prototype, {\n\n\t\tderivatives: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.assign( WebGLRenderer.prototype, {\n\n\t\tgetCurrentRenderTarget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\n\t\t\treturn this.getRenderTarget();\n\n\t\t},\n\n\t\tgetMaxAnisotropy: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\n\t\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t\t},\n\n\t\tgetPrecision: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\n\t\t\treturn this.capabilities.precision;\n\n\t\t},\n\n\t\tresetGLState: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\n\t\t\treturn this.state.reset();\n\n\t\t},\n\n\t\tsupportsFloatTextures: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n\t\t\treturn this.capabilities.vertexTextures;\n\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\n\t\t},\n\t\tinitMaterial: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\n\t\t},\n\t\taddPrePlugin: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\n\t\t},\n\t\taddPostPlugin: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\n\t\t},\n\t\tupdateShadowMap: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\n\t\t},\n\t\tsetFaceCulling: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\n\n\t\t}\n\n\t} );\n\n\tObject.defineProperties( WebGLRenderer.prototype, {\n\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\n\t\t\t\treturn this.shadowMap.enabled;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\n\t\t\t\treturn this.shadowMap.type;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\t\treturn undefined;\n\n\t\t\t},\n\t\t\tset: function ( /* value */ ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLShadowMap.prototype, {\n\n\t\tcullFace: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\t\treturn undefined;\n\n\t\t\t},\n\t\t\tset: function ( /* cullFace */ ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t\t}\n\t\t},\n\t\trenderReverseSided: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\t\t\treturn undefined;\n\n\t\t\t},\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t\t}\n\t\t},\n\t\trenderSingleSided: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\t\t\treturn undefined;\n\n\t\t\t},\n\t\t\tset: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\n\t\twrapS: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebVRManager.prototype, {\n\n\t\tstanding: {\n\t\t\tset: function ( /* value */ ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\t//\n\n\tAudio.prototype.load = function ( file ) {\n\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\n\t\t\tscope.setBuffer( buffer );\n\n\t\t} );\n\t\treturn this;\n\n\t};\n\n\tAudioAnalyser.prototype.getData = function () {\n\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\n\t};\n\n\t//\n\n\tCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\n\n\t\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\n\t\treturn this.update( renderer, scene );\n\n\t};\n\n\t//\n\n\tvar GeometryUtils = {\n\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\t\tvar matrix;\n\n\t\t\tif ( geometry2.isMesh ) {\n\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t\t}\n\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t\t},\n\n\t\tcenter: function ( geometry ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\n\t\t}\n\n\t};\n\n\tvar ImageUtils = {\n\n\t\tcrossOrigin: undefined,\n\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\t\tvar loader = new TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\t\tvar loader = new CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadCompressedTexture: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t},\n\n\t\tloadCompressedTextureCube: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Projector() {\n\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\t\tthis.projectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\n\t\t};\n\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\n\t\t};\n\n\t\tthis.pickingRay = function () {\n\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t\t};\n\n\t}\n\n\t//\n\n\tfunction CanvasRenderer() {\n\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\n\t}\n\n\t//\n\n\tvar SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\n\n\t\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t\t},\n\n\t\tdetach: function ( /* child, parent, scene */ ) {\n\n\t\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t\t},\n\n\t\tattach: function ( /* child, scene, parent */ ) {\n\n\t\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction LensFlare() {\n\n\t\tconsole.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );\n\n\t}\n\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.ShaderLib = ShaderLib;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.FogExp2 = FogExp2;\n\texports.Fog = Fog;\n\texports.Scene = Scene;\n\texports.Sprite = Sprite;\n\texports.LOD = LOD;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.Skeleton = Skeleton;\n\texports.Bone = Bone;\n\texports.Mesh = Mesh;\n\texports.LineSegments = LineSegments;\n\texports.LineLoop = LineLoop;\n\texports.Line = Line;\n\texports.Points = Points;\n\texports.Group = Group;\n\texports.VideoTexture = VideoTexture;\n\texports.DataTexture = DataTexture;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CubeTexture = CubeTexture;\n\texports.CanvasTexture = CanvasTexture;\n\texports.DepthTexture = DepthTexture;\n\texports.Texture = Texture;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.MaterialLoader = MaterialLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.LoadingManager = LoadingManager;\n\texports.JSONLoader = JSONLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.ImageBitmapLoader = ImageBitmapLoader;\n\texports.FontLoader = FontLoader;\n\texports.FileLoader = FileLoader;\n\texports.Loader = Loader;\n\texports.LoaderUtils = LoaderUtils;\n\texports.Cache = Cache;\n\texports.AudioLoader = AudioLoader;\n\texports.SpotLightShadow = SpotLightShadow;\n\texports.SpotLight = SpotLight;\n\texports.PointLight = PointLight;\n\texports.RectAreaLight = RectAreaLight;\n\texports.HemisphereLight = HemisphereLight;\n\texports.DirectionalLightShadow = DirectionalLightShadow;\n\texports.DirectionalLight = DirectionalLight;\n\texports.AmbientLight = AmbientLight;\n\texports.LightShadow = LightShadow;\n\texports.Light = Light;\n\texports.StereoCamera = StereoCamera;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.CubeCamera = CubeCamera;\n\texports.ArrayCamera = ArrayCamera;\n\texports.Camera = Camera;\n\texports.AudioListener = AudioListener;\n\texports.PositionalAudio = PositionalAudio;\n\texports.AudioContext = AudioContext;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.Audio = Audio;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.PropertyMixer = PropertyMixer;\n\texports.PropertyBinding = PropertyBinding;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.AnimationUtils = AnimationUtils;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationClip = AnimationClip;\n\texports.Uniform = Uniform;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.BufferGeometry = BufferGeometry;\n\texports.Geometry = Geometry;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.Face3 = Face3;\n\texports.Object3D = Object3D;\n\texports.Raycaster = Raycaster;\n\texports.Layers = Layers;\n\texports.EventDispatcher = EventDispatcher;\n\texports.Clock = Clock;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.Interpolant = Interpolant;\n\texports.Triangle = Triangle;\n\texports.Math = _Math;\n\texports.Spherical = Spherical;\n\texports.Cylindrical = Cylindrical;\n\texports.Plane = Plane;\n\texports.Frustum = Frustum;\n\texports.Sphere = Sphere;\n\texports.Ray = Ray;\n\texports.Matrix4 = Matrix4;\n\texports.Matrix3 = Matrix3;\n\texports.Box3 = Box3;\n\texports.Box2 = Box2;\n\texports.Line3 = Line3;\n\texports.Euler = Euler;\n\texports.Vector4 = Vector4;\n\texports.Vector3 = Vector3;\n\texports.Vector2 = Vector2;\n\texports.Quaternion = Quaternion;\n\texports.Color = Color;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.VertexNormalsHelper = VertexNormalsHelper;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.PointLightHelper = PointLightHelper;\n\texports.RectAreaLightHelper = RectAreaLightHelper;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.GridHelper = GridHelper;\n\texports.PolarGridHelper = PolarGridHelper;\n\texports.FaceNormalsHelper = FaceNormalsHelper;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.CameraHelper = CameraHelper;\n\texports.BoxHelper = BoxHelper;\n\texports.Box3Helper = Box3Helper;\n\texports.PlaneHelper = PlaneHelper;\n\texports.ArrowHelper = ArrowHelper;\n\texports.AxesHelper = AxesHelper;\n\texports.Shape = Shape;\n\texports.Path = Path;\n\texports.ShapePath = ShapePath;\n\texports.Font = Font;\n\texports.CurvePath = CurvePath;\n\texports.Curve = Curve;\n\texports.ShapeUtils = ShapeUtils;\n\texports.WebGLUtils = WebGLUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.TubeBufferGeometry = TubeBufferGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusBufferGeometry = TorusBufferGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.TextBufferGeometry = TextBufferGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.SphereBufferGeometry = SphereBufferGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.RingBufferGeometry = RingBufferGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.LatheBufferGeometry = LatheBufferGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ShapeBufferGeometry = ShapeBufferGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.ConeBufferGeometry = ConeBufferGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.CircleBufferGeometry = CircleBufferGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.BoxBufferGeometry = BoxBufferGeometry;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.PointsMaterial = PointsMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshToonMaterial = MeshToonMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshDistanceMaterial = MeshDistanceMaterial;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.Material = Material;\n\texports.Float64BufferAttribute = Float64BufferAttribute;\n\texports.Float32BufferAttribute = Float32BufferAttribute;\n\texports.Uint32BufferAttribute = Uint32BufferAttribute;\n\texports.Int32BufferAttribute = Int32BufferAttribute;\n\texports.Uint16BufferAttribute = Uint16BufferAttribute;\n\texports.Int16BufferAttribute = Int16BufferAttribute;\n\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n\texports.Uint8BufferAttribute = Uint8BufferAttribute;\n\texports.Int8BufferAttribute = Int8BufferAttribute;\n\texports.BufferAttribute = BufferAttribute;\n\texports.ArcCurve = ArcCurve;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.EllipseCurve = EllipseCurve;\n\texports.LineCurve = LineCurve;\n\texports.LineCurve3 = LineCurve3;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.SplineCurve = SplineCurve;\n\texports.REVISION = REVISION;\n\texports.MOUSE = MOUSE;\n\texports.CullFaceNone = CullFaceNone;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.FrontSide = FrontSide;\n\texports.BackSide = BackSide;\n\texports.DoubleSide = DoubleSide;\n\texports.FlatShading = FlatShading;\n\texports.SmoothShading = SmoothShading;\n\texports.NoColors = NoColors;\n\texports.FaceColors = FaceColors;\n\texports.VertexColors = VertexColors;\n\texports.NoBlending = NoBlending;\n\texports.NormalBlending = NormalBlending;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.CustomBlending = CustomBlending;\n\texports.AddEquation = AddEquation;\n\texports.SubtractEquation = SubtractEquation;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.MinEquation = MinEquation;\n\texports.MaxEquation = MaxEquation;\n\texports.ZeroFactor = ZeroFactor;\n\texports.OneFactor = OneFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.NeverDepth = NeverDepth;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.EqualDepth = EqualDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterDepth = GreaterDepth;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.MixOperation = MixOperation;\n\texports.AddOperation = AddOperation;\n\texports.NoToneMapping = NoToneMapping;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.UVMapping = UVMapping;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.ByteType = ByteType;\n\texports.ShortType = ShortType;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.IntType = IntType;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.FloatType = FloatType;\n\texports.HalfFloatType = HalfFloatType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.AlphaFormat = AlphaFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBAFormat = RGBAFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.RGBEFormat = RGBEFormat;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;\n\texports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;\n\texports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;\n\texports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;\n\texports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;\n\texports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;\n\texports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;\n\texports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;\n\texports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;\n\texports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;\n\texports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;\n\texports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;\n\texports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;\n\texports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LoopPingPong = LoopPingPong;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.LinearEncoding = LinearEncoding;\n\texports.sRGBEncoding = sRGBEncoding;\n\texports.GammaEncoding = GammaEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.CubeGeometry = BoxGeometry;\n\texports.Face4 = Face4;\n\texports.LineStrip = LineStrip;\n\texports.LinePieces = LinePieces;\n\texports.MeshFaceMaterial = MeshFaceMaterial;\n\texports.MultiMaterial = MultiMaterial;\n\texports.PointCloud = PointCloud;\n\texports.Particle = Particle;\n\texports.ParticleSystem = ParticleSystem;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Vertex = Vertex;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\texports.SplineCurve3 = SplineCurve3;\n\texports.Spline = Spline;\n\texports.AxisHelper = AxisHelper;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.EdgesHelper = EdgesHelper;\n\texports.WireframeHelper = WireframeHelper;\n\texports.XHRLoader = XHRLoader;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.GeometryUtils = GeometryUtils;\n\texports.ImageUtils = ImageUtils;\n\texports.Projector = Projector;\n\texports.CanvasRenderer = CanvasRenderer;\n\texports.SceneUtils = SceneUtils;\n\texports.LensFlare = LensFlare;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three/build/three.js\n// module id = 178\n// module chunks = 35783957827783","/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\n\nvar TWEEN = TWEEN || (function () {\n\n\tvar _tweens = [];\n\n\treturn {\n\n\t\tgetAll: function () {\n\n\t\t\treturn _tweens;\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\t_tweens = [];\n\n\t\t},\n\n\t\tadd: function (tween) {\n\n\t\t\t_tweens.push(tween);\n\n\t\t},\n\n\t\tremove: function (tween) {\n\n\t\t\tvar i = _tweens.indexOf(tween);\n\n\t\t\tif (i !== -1) {\n\t\t\t\t_tweens.splice(i, 1);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function (time, preserve) {\n\n\t\t\tif (_tweens.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i = 0;\n\n\t\t\ttime = time !== undefined ? time : TWEEN.now();\n\n\t\t\twhile (i < _tweens.length) {\n\n\t\t\t\tif (_tweens[i].update(time) || preserve) {\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\t_tweens.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\t};\n\n})();\n\n\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\nif (typeof (window) === 'undefined' && typeof (process) !== 'undefined') {\n\tTWEEN.now = function () {\n\t\tvar time = process.hrtime();\n\n\t\t// Convert [seconds, nanoseconds] to milliseconds.\n\t\treturn time[0] * 1000 + time[1] / 1000000;\n\t};\n}\n// In a browser, use window.performance.now if it is available.\nelse if (typeof (window) !== 'undefined' &&\n         window.performance !== undefined &&\n\t\t window.performance.now !== undefined) {\n\t// This must be bound, because directly assigning this function\n\t// leads to an invocation exception in Chrome.\n\tTWEEN.now = window.performance.now.bind(window.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n\tTWEEN.now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n\tTWEEN.now = function () {\n\t\treturn new Date().getTime();\n\t};\n}\n\n\nTWEEN.Tween = function (object) {\n\n\tvar _object = object;\n\tvar _valuesStart = {};\n\tvar _valuesEnd = {};\n\tvar _valuesStartRepeat = {};\n\tvar _duration = 1000;\n\tvar _repeat = 0;\n\tvar _repeatDelayTime;\n\tvar _yoyo = false;\n\tvar _isPlaying = false;\n\tvar _reversed = false;\n\tvar _delayTime = 0;\n\tvar _startTime = null;\n\tvar _easingFunction = TWEEN.Easing.Linear.None;\n\tvar _interpolationFunction = TWEEN.Interpolation.Linear;\n\tvar _chainedTweens = [];\n\tvar _onStartCallback = null;\n\tvar _onStartCallbackFired = false;\n\tvar _onUpdateCallback = null;\n\tvar _onCompleteCallback = null;\n\tvar _onStopCallback = null;\n\n\tthis.to = function (properties, duration) {\n\n\t\t_valuesEnd = properties;\n\n\t\tif (duration !== undefined) {\n\t\t\t_duration = duration;\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tthis.start = function (time) {\n\n\t\tTWEEN.add(this);\n\n\t\t_isPlaying = true;\n\n\t\t_onStartCallbackFired = false;\n\n\t\t_startTime = time !== undefined ? time : TWEEN.now();\n\t\t_startTime += _delayTime;\n\n\t\tfor (var property in _valuesEnd) {\n\n\t\t\t// Check if an Array was provided as property value\n\t\t\tif (_valuesEnd[property] instanceof Array) {\n\n\t\t\t\tif (_valuesEnd[property].length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\t_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);\n\n\t\t\t}\n\n\t\t\t// If `to()` specifies a property that doesn't exist in the source object,\n\t\t\t// we should not set that property in the object\n\t\t\tif (_object[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save the starting value.\n\t\t\t_valuesStart[property] = _object[property];\n\n\t\t\tif ((_valuesStart[property] instanceof Array) === false) {\n\t\t\t\t_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t}\n\n\t\t\t_valuesStartRepeat[property] = _valuesStart[property] || 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tthis.stop = function () {\n\n\t\tif (!_isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tTWEEN.remove(this);\n\t\t_isPlaying = false;\n\n\t\tif (_onStopCallback !== null) {\n\t\t\t_onStopCallback.call(_object, _object);\n\t\t}\n\n\t\tthis.stopChainedTweens();\n\t\treturn this;\n\n\t};\n\n\tthis.end = function () {\n\n\t\tthis.update(_startTime + _duration);\n\t\treturn this;\n\n\t};\n\n\tthis.stopChainedTweens = function () {\n\n\t\tfor (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t_chainedTweens[i].stop();\n\t\t}\n\n\t};\n\n\tthis.delay = function (amount) {\n\n\t\t_delayTime = amount;\n\t\treturn this;\n\n\t};\n\n\tthis.repeat = function (times) {\n\n\t\t_repeat = times;\n\t\treturn this;\n\n\t};\n\n\tthis.repeatDelay = function (amount) {\n\n\t\t_repeatDelayTime = amount;\n\t\treturn this;\n\n\t};\n\n\tthis.yoyo = function (yoyo) {\n\n\t\t_yoyo = yoyo;\n\t\treturn this;\n\n\t};\n\n\n\tthis.easing = function (easing) {\n\n\t\t_easingFunction = easing;\n\t\treturn this;\n\n\t};\n\n\tthis.interpolation = function (interpolation) {\n\n\t\t_interpolationFunction = interpolation;\n\t\treturn this;\n\n\t};\n\n\tthis.chain = function () {\n\n\t\t_chainedTweens = arguments;\n\t\treturn this;\n\n\t};\n\n\tthis.onStart = function (callback) {\n\n\t\t_onStartCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.onUpdate = function (callback) {\n\n\t\t_onUpdateCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.onComplete = function (callback) {\n\n\t\t_onCompleteCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.onStop = function (callback) {\n\n\t\t_onStopCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.update = function (time) {\n\n\t\tvar property;\n\t\tvar elapsed;\n\t\tvar value;\n\n\t\tif (time < _startTime) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (_onStartCallbackFired === false) {\n\n\t\t\tif (_onStartCallback !== null) {\n\t\t\t\t_onStartCallback.call(_object, _object);\n\t\t\t}\n\n\t\t\t_onStartCallbackFired = true;\n\t\t}\n\n\t\telapsed = (time - _startTime) / _duration;\n\t\telapsed = elapsed > 1 ? 1 : elapsed;\n\n\t\tvalue = _easingFunction(elapsed);\n\n\t\tfor (property in _valuesEnd) {\n\n\t\t\t// Don't update properties that do not exist in the source object\n\t\t\tif (_valuesStart[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar start = _valuesStart[property] || 0;\n\t\t\tvar end = _valuesEnd[property];\n\n\t\t\tif (end instanceof Array) {\n\n\t\t\t\t_object[property] = _interpolationFunction(end, value);\n\n\t\t\t} else {\n\n\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\tif (typeof (end) === 'string') {\n\n\t\t\t\t\tif (end.charAt(0) === '+' || end.charAt(0) === '-') {\n\t\t\t\t\t\tend = start + parseFloat(end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend = parseFloat(end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Protect against non numeric properties.\n\t\t\t\tif (typeof (end) === 'number') {\n\t\t\t\t\t_object[property] = start + (end - start) * value;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (_onUpdateCallback !== null) {\n\t\t\t_onUpdateCallback.call(_object, value);\n\t\t}\n\n\t\tif (elapsed === 1) {\n\n\t\t\tif (_repeat > 0) {\n\n\t\t\t\tif (isFinite(_repeat)) {\n\t\t\t\t\t_repeat--;\n\t\t\t\t}\n\n\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\tfor (property in _valuesStartRepeat) {\n\n\t\t\t\t\tif (typeof (_valuesEnd[property]) === 'string') {\n\t\t\t\t\t\t_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_yoyo) {\n\t\t\t\t\t\tvar tmp = _valuesStartRepeat[property];\n\n\t\t\t\t\t\t_valuesStartRepeat[property] = _valuesEnd[property];\n\t\t\t\t\t\t_valuesEnd[property] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\t_valuesStart[property] = _valuesStartRepeat[property];\n\n\t\t\t\t}\n\n\t\t\t\tif (_yoyo) {\n\t\t\t\t\t_reversed = !_reversed;\n\t\t\t\t}\n\n\t\t\t\tif (_repeatDelayTime !== undefined) {\n\t\t\t\t\t_startTime = time + _repeatDelayTime;\n\t\t\t\t} else {\n\t\t\t\t\t_startTime = time + _delayTime;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (_onCompleteCallback !== null) {\n\n\t\t\t\t\t_onCompleteCallback.call(_object, _object);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t// Make the chained tweens start exactly at the time they should,\n\t\t\t\t\t// even if the `update()` method was called way past the duration of the tween\n\t\t\t\t\t_chainedTweens[i].start(_startTime + _duration);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n};\n\n\nTWEEN.Easing = {\n\n\tLinear: {\n\n\t\tNone: function (k) {\n\n\t\t\treturn k;\n\n\t\t}\n\n\t},\n\n\tQuadratic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\n\t\t}\n\n\t},\n\n\tCubic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tQuartic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn 1 - (--k * k * k * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t}\n\n\t},\n\n\tQuintic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tSinusoidal: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t}\n\n\t},\n\n\tExponential: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\n\t\t}\n\n\t},\n\n\tCircular: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t}\n\n\t},\n\n\tElastic: {\n\n\t\tIn: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tk *= 2;\n\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n\t\t}\n\n\t},\n\n\tBack: {\n\n\t\tIn: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t}\n\n\t},\n\n\tBounce: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t}\n\n\t}\n\n};\n\nTWEEN.Interpolation = {\n\n\tLinear: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\n\t\tif (k < 0) {\n\t\t\treturn fn(v[0], v[1], f);\n\t\t}\n\n\t\tif (k > 1) {\n\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t}\n\n\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n\t},\n\n\tBezier: function (v, k) {\n\n\t\tvar b = 0;\n\t\tvar n = v.length - 1;\n\t\tvar pw = Math.pow;\n\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\n\t\tfor (var i = 0; i <= n; i++) {\n\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t}\n\n\t\treturn b;\n\n\t},\n\n\tCatmullRom: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n\t\tif (v[0] === v[m]) {\n\n\t\t\tif (k < 0) {\n\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t}\n\n\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n\t\t} else {\n\n\t\t\tif (k < 0) {\n\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t}\n\n\t\t\tif (k > 1) {\n\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t}\n\n\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\n\t\t}\n\n\t},\n\n\tUtils: {\n\n\t\tLinear: function (p0, p1, t) {\n\n\t\t\treturn (p1 - p0) * t + p0;\n\n\t\t},\n\n\t\tBernstein: function (n, i) {\n\n\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\n\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\n\t\t},\n\n\t\tFactorial: (function () {\n\n\t\t\tvar a = [1];\n\n\t\t\treturn function (n) {\n\n\t\t\t\tvar s = 1;\n\n\t\t\t\tif (a[n]) {\n\t\t\t\t\treturn a[n];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\ts *= i;\n\t\t\t\t}\n\n\t\t\t\ta[n] = s;\n\t\t\t\treturn s;\n\n\t\t\t};\n\n\t\t})(),\n\n\t\tCatmullRom: function (p0, p1, p2, p3, t) {\n\n\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\n\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n};\n\n// UMD (Universal Module Definition)\n(function (root) {\n\n\tif (typeof define === 'function' && define.amd) {\n\n\t\t// AMD\n\t\tdefine([], function () {\n\t\t\treturn TWEEN;\n\t\t});\n\n\t} else if (typeof module !== 'undefined' && typeof exports === 'object') {\n\n\t\t// Node.js\n\t\tmodule.exports = TWEEN;\n\n\t} else if (root !== undefined) {\n\n\t\t// Global variable\n\t\troot.TWEEN = TWEEN;\n\n\t}\n\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tween.js/src/Tween.js\n// module id = 110\n// module chunks = 35783957827783","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 111\n// module chunks = 35783957827783 114276838955818","export function initPosition(isMobile, idx){\n  var letterPosition\n  if(isMobile){\n    switch(idx) {\n    case 0:\n        return {x: -0.85, y: -2, z: 0, scale: 3}\n    case 1:\n        return {x: 1.5, y: -2, z: 0, scale: 3}\n    case 2:\n        return {x: 3.5, y: -2, z: 0, scale: 3}\n    case 3:\n        return {x: 5, y: -2, z: 0, scale: 3}\n    case 4:\n        return {x: -5.5, y: -2, z: 10, scale: 3}\n    case 5:\n        return {x: -2.5, y: -2, z: 10, scale: 3}\n    case 6:\n        return {x: 1, y: -2, z: 10, scale: 3}\n    case 7:\n        return {x: 4, y: -2, z: 10, scale: 3}\n    case 8:\n        return {x: 5.75, y: -2, z: 10, scale: 3}\n    case 9:\n        return {x: 8, y: -2, z: 10, scale: 3}\n    case 10:\n        return {x: 11, y: -2, z: 10, scale: 3}\n    default:\n        return {x: 0, y: 0, z: 0, scale: 3}\n    }\n  } else {\n    switch(idx) {\n    case 0:\n        return {x: -8.5, y: -2, z: 0, scale: 3}\n    case 1:\n        return {x: -6.3, y: -2, z: 0, scale: 3}\n    case 2:\n        return {x: -4.4, y: -2.1, z: 0, scale: 3}\n    case 3:\n        return {x: -3, y: -2.1, z: 0, scale: 3}\n    case 4:\n        return {x: -1, y: -2, z: 0, scale: 3}\n    case 5:\n        return {x: 0.65, y: -2.1, z: 0, scale: 3}\n    case 6:\n        return {x: 2.6, y: -2.1, z: 0, scale: 3}\n    case 7:\n        return {x: 4.4, y: -2.1, z: 0, scale: 3}\n    case 8:\n        return {x: 5.45, y: -2.1, z: 0, scale: 3}\n    case 9:\n        return {x: 6.75, y: -2.1, z: 0, scale: 3}\n    case 10:\n        return {x: 8.5, y: -2, z: 0, scale: 3}\n    default:\n        return {x: 0, y: 0, z: 0, scale: 3}\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/three/initPosition.js","import TWEEN from 'tween.js'\n\nexport function initRotateTween(object){\n  console.log(\"initializing rotate\", object)\n\n  let randomNumber1 = Math.floor((Math.random() * (6 - (2)) + (2)))\n  let randomNumber2 = (Math.random() * (6 - (2)) + (2))\n  let randomNumber3 = (Math.random() * (6 - (2)) + (2))\n  let randomNumber4 = (Math.random() * (6 - (2)) + (2))\n  let randomNumber5 = (Math.random() * (6 - (2)) + (2))\n  let randomNumber6 = (Math.random() * (6 - (2)) + (2))\n\n  let direction1 = generateDirection(randomNumber1)\n  let direction2 = generateOppositeDirection(direction1)\n  let direction3 = generateOppositeDirection(direction2)\n  let direction4 = generateOppositeDirection(direction3)\n  let direction5 = generateOppositeDirection(direction4)\n  let direction6 = generateOppositeDirection(direction5)\n\n  console.log(\"original rotation\", direction1, direction2)\n\n  let tween = new TWEEN.Tween(object.rotation)\n    .to({y: `${direction1}` + Math.PI/randomNumber1}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.Out)\n  let tween2 = new TWEEN.Tween(object.rotation)\n    .to({y: 0}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.In)\n  let tween3 = new TWEEN.Tween(object.rotation)\n    .to({y: `${direction2}` + Math.PI/randomNumber2}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.Out)\n  let tween4 = new TWEEN.Tween(object.rotation)\n    .to({y: 0}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.In)\n  let tween5 = new TWEEN.Tween(object.rotation)\n    .to({y: `${direction3}` + Math.PI/randomNumber3}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.Out)\n  let tween6 = new TWEEN.Tween(object.rotation)\n    .to({y: 0}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.In)\n  let tween7 = new TWEEN.Tween(object.rotation)\n    .to({y: `${direction4}` + Math.PI/randomNumber4}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.Out)\n  let tween8 = new TWEEN.Tween(object.rotation)\n    .to({y: 0}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.In)\n  let tween9 = new TWEEN.Tween(object.rotation)\n    .to({y: `${direction5}` + Math.PI/randomNumber5}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.Out)\n  let tween10 = new TWEEN.Tween(object.rotation)\n    .to({y: 0}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.In)\n  let tween11 = new TWEEN.Tween(object.rotation)\n    .to({y: `${direction6}` + Math.PI/randomNumber6}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.Out)\n  let tween12 = new TWEEN.Tween(object.rotation)\n    .to({y: 0}, 3500)\n    .easing(TWEEN.Easing.Sinusoidal.In)\n  tween.chain(tween2)\n  tween2.chain(tween3)\n  tween3.chain(tween4)\n  tween4.chain(tween5)\n  tween5.chain(tween6)\n  tween6.chain(tween7)\n  tween7.chain(tween8)\n  tween8.chain(tween9)\n  tween9.chain(tween10)\n  tween10.chain(tween11)\n  tween11.chain(tween12)\n  tween12.chain(tween)\n\n  tween.start()\n}\n\nfunction generateDirection(n) {\n  let direction\n  n % 2 === 0 ? direction = \"-\" : direction = \"+\"\n  return direction\n}\n\nfunction generateOppositeDirection(direction1){\n  let direction\n  direction1 === \"-\" ? direction = \"+\" : direction = \"-\"\n  return direction\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/three/initRotateTween.js","import {initTranslateTween} from './initTranslateTween.js'\nimport {initRotateTween} from './initRotateTween.js'\nimport {initPosition} from './initPosition.js'\nimport * as THREE from 'three';\nimport * as OBJLoader from 'three-obj-loader';\nOBJLoader.default(THREE)\n\nexport function initTitle(threeLoader, objFile, titleColor, titleGroup, idx, isMobile){\n  // let titleMaterial = new THREE.MeshPhongMaterial({color: `black`})\n  let titleMaterial = new THREE.MeshPhongMaterial({color: `${titleColor}`})\n\n  let titleLoader = new threeLoader.OBJLoader()\n  titleLoader.load(`${objFile}`, function(object){\n\n    var objBbox = new THREE.Box3().setFromObject(object);\n    let offset = objBbox.getCenter();\n\n    // Geometry vertices centering to world axis\n    var bboxCenter = objBbox.getCenter().clone();\n    bboxCenter.multiplyScalar(-1);\n\n    object.traverse(function(child){\n      if(child instanceof THREE.Mesh){\n        child.geometry.translate(bboxCenter.x, bboxCenter.y, bboxCenter.z);\n        child.material = titleMaterial\n        child.castShadow = true\n      }\n    })\n\n    var letterPosition = initPosition(isMobile, idx)\n    var scale = letterPosition.scale\n    object.scale.set(scale, scale, scale)\n\n\n\n    object.position.x = (letterPosition.x - 1)\n    object.position.y = (letterPosition.y)\n    object.position.z = (letterPosition.z)\n\n    titleGroup.add(object)\n    initTranslateTween(object)\n    initRotateTween(object)\n  }.bind(this))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/three/initTitle.js","import TWEEN from 'tween.js'\n\nexport function initTranslateTween(object){\n  let randomNumber1 = generateRandomNumber()\n  let randomNumber2 = generateRandomNumber()\n  let randomNumber3 = generateRandomNumber()\n  let randomNumber4 = generateRandomNumber()\n  let randomNumber5 = generateRandomNumber()\n  let randomNumber6 = generateRandomNumber()\n\n  let originalPosition = object.position.y\n\n  console.log(\"RANDOM NUMBER\", randomNumber1, randomNumber2)\n\n  let tween = new TWEEN.Tween(object.position)\n    .to({ x: object.position.x, y: randomNumber1, z: object.position.z }, 1000)\n    .easing(TWEEN.Easing.Quadratic.Out)\n\n  let returnTween = new TWEEN.Tween(object.position)\n    .to({ y: originalPosition}, 2500)\n    .easing(TWEEN.Easing.Bounce.Out)\n\n  let tween2 = new TWEEN.Tween(object.position)\n    .to({ x: object.position.x, y: randomNumber2, z: object.position.z }, 1000)\n    .easing(TWEEN.Easing.Quadratic.Out)\n\n  let returnTween2 = new TWEEN.Tween(object.position)\n    .to({ y: originalPosition}, 2500)\n    .easing(TWEEN.Easing.Bounce.Out)\n\n  let tween3 = new TWEEN.Tween(object.position)\n    .to({ x: object.position.x, y: randomNumber3, z: object.position.z }, 1000)\n    .easing(TWEEN.Easing.Quadratic.Out)\n\n  let returnTween3 = new TWEEN.Tween(object.position)\n    .to({ y: originalPosition}, 2500)\n    .easing(TWEEN.Easing.Bounce.Out)\n\n  let tween4 = new TWEEN.Tween(object.position)\n    .to({ x: object.position.x, y: randomNumber4, z: object.position.z }, 1000)\n    .easing(TWEEN.Easing.Quadratic.Out)\n\n  let returnTween4 = new TWEEN.Tween(object.position)\n    .to({ y: originalPosition}, 2500)\n    .easing(TWEEN.Easing.Bounce.Out)\n\n  let tween5 = new TWEEN.Tween(object.position)\n    .to({ x: object.position.x, y: randomNumber5, z: object.position.z }, 1000)\n    .easing(TWEEN.Easing.Quadratic.Out)\n\n  let returnTween5 = new TWEEN.Tween(object.position)\n      .to({ y: originalPosition}, 2500)\n      .easing(TWEEN.Easing.Bounce.Out)\n\n  let tween6 = new TWEEN.Tween(object.position)\n    .to({ x: object.position.x, y: randomNumber6, z: object.position.z }, 1000)\n    .easing(TWEEN.Easing.Quadratic.Out)\n\n  let returnTween6 = new TWEEN.Tween(object.position)\n    .to({ y: originalPosition}, 2500)\n    .easing(TWEEN.Easing.Bounce.Out)\n\n  tween.chain(returnTween)\n  returnTween.chain(tween2)\n  tween2.chain(returnTween2)\n  returnTween2.chain(tween3)\n  tween3.chain(returnTween3)\n  returnTween3.chain(tween4)\n  tween4.chain(returnTween4)\n  returnTween4.chain(tween5)\n  tween5.chain(returnTween5)\n  returnTween5.chain(tween6)\n  tween6.chain(returnTween6)\n  returnTween6.chain(tween)\n\n\n  tween.start()\n\n}\n\nfunction generateRandomNumber(){\n  let randomNumber = Math.abs((Math.random() * (4 - (1.5)) + (1.5)))\n  return randomNumber\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/three/initTranslateTween.js","import React, { Component } from 'react';\nimport Link from 'gatsby-link';\nimport randomColor from 'randomcolor'\nimport {initTitle} from './initTitle.js'\nimport * as THREE from 'three';\nimport TWEEN from 'tween.js'\nvar OrbitControls = require('three-orbit-controls')(THREE)\n\nclass ThreeTitle extends Component{\n  constructor(props) {\n   super(props)\n\n   this.start = this.start.bind(this)\n   this.stop = this.stop.bind(this)\n   this.animate = this.animate.bind(this)\n   this.THREE = THREE\n   this.addTitle = this.addTitle.bind(this)\n }\n\n  componentDidMount(){\n    window.addEventListener( 'resize', this.onWindowResize, false );\n\n    const width = this.mount.clientWidth\n    const height = this.mount.clientHeight\n\n    this.isMobile\n    width <=500 ? this.isMobile = true : this.isMobile = false\n\n    //SCENE\n    this.scene = new THREE.Scene()\n\n\n    //RENDERER\n    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })\n    this.renderer.setClearColor(0x000000, 0)\n    this.renderer.setSize(width, height)\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    this.mount.appendChild(this.renderer.domElement)\n\n    //CAMERA\n    this.camera = new THREE.PerspectiveCamera(\n      35,\n      width / height,\n      0.1,\n      1000\n    )\n\n    //CONTROLS\n    this.controls = new OrbitControls(this.camera, this.mount)\n    this.controls.enableZoom = true;\n    this.controls.enablePan = false;\n    this.controls.maxPolarAngle = Math.PI/2\n    this.controls.maxDistance = 80\n\n    //KEYLIGHT\n    this.keyLight = new THREE.AmbientLight(0xffffff, 0.5)\n    this.scene.add(this.keyLight);\n\n    //POINTLIGHT\n    this.pointLight = new THREE.PointLight( 0xffffff, 1 )\n\n    this.pointLight.castShadow = true\n    this.scene.add(this.pointLight)\n\n    this.pointLight.shadow.camera.near = 0.5;       // default\n    this.pointLight.shadow.camera.far = 500      // default\n\n    //ADD TITLE\n    this.titleGroup = new THREE.Group()\n    if(this.isMobile){\n      this.objFiles = ['./models/title/1-1-C.obj', './models/title/1-2-O.obj', './models/title/1-3-L.obj', './models/title/1-4-E.obj']\n    } else {\n      this.objFiles = ['./models/title/1-1-C.obj', './models/title/1-2-O.obj', './models/title/1-3-L.obj', './models/title/1-4-E.obj', './models/title/2-1-S.obj', './models/title/2-2-H.obj', './models/title/2-3-A.obj', './models/title/2-4-P.obj', './models/title/2-5-I.obj', './models/title/2-6-R.obj', './models/title/2-7-O.obj' ]\n    }\n    this.titleColors = randomColor({luminosity: 'dark', count: 11})\n\n    this.addTitle()\n\n    this.titleGroup.position.set(-2, -1, 0)\n    this.scene.add(this.titleGroup)\n\n    //ADD FLOOR\n    const floorColor = \"#fffd54\"\n    this.floorGroup = new THREE.Group()\n\n    this.floorGeometry = new THREE.PlaneBufferGeometry(200, 200, 32, 32)\n    this.floorMaterial = new THREE.MeshBasicMaterial({color: `${floorColor}`})\n    this.floor = new THREE.Mesh(this.floorGeometry, this.floorMaterial)\n    this.floor.rotation.x = - Math.PI / 2\n    this.isMobile ? this.floor.position.y = -4.05 : this.floor.position.y = -4.05\n    this.floorGroup.add(this.floor)\n\n    this.floor2Geometry = new THREE.PlaneBufferGeometry(200, 200, 32, 32)\n    this.floor2Material = new THREE.ShadowMaterial({opacity:.2})\n    this.floor2 = new THREE.Mesh(this.floor2Geometry, this.floor2Material)\n    this.floor2.rotation.x = - Math.PI / 2\n    this.isMobile ? this.floor2.position.y = -4.05 : this.floor2.position.y = -4.05\n    this.floor2.receiveShadow = true\n    this.floorGroup.add(this.floor2)\n\n    this.scene.add(this.floorGroup)\n\n    //MOBILE\n    if(this.isMobile){\n      console.log(this.camera)\n      this.camera.position.z = 18\n      this.camera.position.x = 5\n      this.camera.position.y = 2\n      this.camera.lookAt(-0.87, -1, 0)\n      this.controls.target.set(-0.87, -1, 0)\n      // this.scene.fog = new THREE.Fog(0xfffd54, 55, 100);\n      this.pointLight.position.set(-3, 5, -5 )\n      this.pointLight.shadow.mapSize.width = 512;\n      this.pointLight.shadow.mapSize.height = 512;\n    } else {\n      //DESKTOP\n      this.camera.position.z = 25\n      this.camera.position.x = 1\n      this.camera.position.y = 0\n      // this.scene.fog = new THREE.Fog(0xfffd54, 18, 50);\n      this.camera.lookAt(-2.15, -2, 0)\n      this.controls.target.set(-2.15, -2, 0)\n      this.pointLight.position.set( 0, 5, 5 )\n      this.pointLight.shadow.mapSize.width = 512;\n      this.pointLight.shadow.mapSize.height = 512;\n    }\n    this.controls.update()\n\n    this.start()\n  }\n\n\n  componentWillUnmount() {\n    this.stop()\n    this.mount.removeChild(this.renderer.domElement)\n    window.removeEventListener('resize', this.onWindowResize, false)\n  }\n\n  start() {\n    if (!this.frameId) {\n      this.frameId = requestAnimationFrame(this.animate)\n    }\n  }\n\n  stop() {\n    cancelAnimationFrame(this.frameId)\n  }\n\n  animate() {\n    this.renderScene()\n    TWEEN.update()\n    this.frameId = window.requestAnimationFrame(this.animate)\n  }\n\n  renderScene() {\n    this.renderer.render(this.scene, this.camera)\n  }\n\n  addTitle(){\n    for(let idx = 0; idx < this.objFiles.length; idx++){\n      let objFile = this.objFiles[idx]\n      let titleColor = this.titleColors[idx]\n\n      initTitle(this.THREE, objFile, titleColor, this.titleGroup, idx, this.isMobile )\n    }\n  }\n\n  onWindowResize = () => {\n    this.camera.aspect = this.mount.clientWidth / this.mount.clientHeight;\n    this.camera.updateProjectionMatrix();\n\n   this.renderer.setSize( this.mount.clientWidth, this.mount.clientHeight );\n  }\n\n  render(){\n    const color = randomColor({luminosity: 'light'})\n    return(\n      <div\n         style={{ height: `100vh`, width: `100%`}}\n         ref={(mount) => { this.mount = mount }}\n        />\n    )\n  }\n}\n\nexport default ThreeTitle\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/three/threeTitle.js","import React, { Component } from 'react'\nimport Link from 'gatsby-link'\nimport ThreeTitle from '../components/three/threeTitle.js'\n\n\nclass IndexPage extends Component {\n\n  render(){\n    return(\n      <div style={{width: '100%', height: '100%'}}>\n        <ThreeTitle />\n      </div>\n    )\n  }\n}\n\nexport default IndexPage\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/index.js"],"sourceRoot":""}